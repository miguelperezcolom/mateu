{"version":3,"file":"getFormatParse-7ea0c25b.js","sources":["../../src/UNSAFE_IntlDateTime/CalendarUtils.ts","../../src/UNSAFE_IntlDateTime/ISODateTimezoneOffset.ts","../../src/UNSAFE_IntlDateTime/NativeDateTimeConstants.ts","../../src/UNSAFE_IntlDateTime/dateTimeUtils.ts","../../src/UNSAFE_IntlDateTime/NativeParserImpl.ts","../../src/UNSAFE_IntlDateTime/formatParse.ts","../../src/UNSAFE_IntlDateTime/getFormatParse.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n// This class fills in the localeElements by using the data from Intl.DateTimeFormat.\n// This data is used for parsing.\n\ntype WidthOptions = 'short' | 'narrow' | 'long';\nexport type CalendarWidthNames = 'abbreviated' | 'narrow' | 'wide';\n\ntype WeekdayNames = 'sun' | 'mon' | 'tue' | 'wed' | 'thu' | 'fri' | 'sat';\n\ntype MonthType = {\n  '1': string;\n  '2': string;\n  '3': string;\n  '4': string;\n  '5': string;\n  '6': string;\n  '7': string;\n  '8': string;\n  '9': string;\n  '10': string;\n  '11': string;\n  '12': string;\n};\n\ntype DayType = {\n  sun: string;\n  mon: string;\n  tue: string;\n  wed: string;\n  thu: string;\n  fri: string;\n  sat: string;\n};\ntype DayPeriodType = {\n  am: string;\n  pm: string;\n};\ntype ErasWidthType = {\n  '0': string;\n  '1': string;\n};\ntype MonthWidthType = {\n  abbreviated: MonthType;\n  narrow: MonthType;\n  wide: MonthType;\n};\ntype DayWidthType = {\n  abbreviated: DayType;\n  narrow: DayType;\n  wide: DayType;\n};\ntype MonthsNodeType = {\n  format: MonthWidthType;\n  'stand-alone': MonthWidthType;\n};\ntype DaysNodeType = {\n  format: DayWidthType;\n  'stand-alone': DayWidthType;\n};\n\ntype DayPeriodFormatWidthType = {\n  wide: DayPeriodType;\n};\ntype DayPeriodsNodeType = {\n  format: DayPeriodFormatWidthType;\n};\ntype ErasType = {\n  eraNarrow: ErasWidthType;\n  eraAbbr: ErasWidthType;\n  eraName: ErasWidthType;\n};\nexport type CalendarNodeType = {\n  months: MonthsNodeType;\n  days: DaysNodeType;\n  dayPeriods: DayPeriodsNodeType;\n  eras: ErasType;\n  locale: string;\n};\n\ntype EraDesc = Array<{ era: string; start: string }>;\n\nexport class CalendarUtils {\n  // calendars[locale][calendarname]\n  public static calendars: Record<string, Record<string, CalendarNodeType>> | undefined;\n\n  private static readonly _monthNamesFormatMap = {\n    short: 'abbreviated',\n    narrow: 'narrow',\n    long: 'wide'\n  } as const;\n  private static readonly _weekdaysFormatMap = {\n    1: 'sun',\n    2: 'mon',\n    3: 'tue',\n    4: 'wed',\n    5: 'thu',\n    6: 'fri',\n    7: 'sat'\n  } as const;\n\n  // The following locales have month name like '1<literal>' (where literal is the lang's character for 'month')\n  // if we pass in the options\n  // month:'long' or month:'short' the corresponding pattern in CLDR is 'M<literal>'\n  // which is month numeric followed by the <literal>. As a result formatToParts\n  // will return {type: month, value:1} followed by {type: literal, value:<literal>}.\n  // These locales have same names for stand-alone and format month names.\n  // As a work around we will get the format month names for these\n  // locales using the stand-alone option instead of formatToParts.\n  // For example: in ja-JP locale we have:\n  // \"months\": {\n  //   \"format\": {\n  //       \"abbreviated\": {\n  //           \"1\": \"1\\u6708\",\n  //  }\n  // but the corresponding pattern is \"yMMMd\": \"y\\u5e74M\\u6708d\\u65e5\"\n  // so formatToParts will return\n  // {type: month, value:1} followed by {type: literal, value:'\\u6708d'}\n  // As a result we get '1' as month name in the calendar data instead of '1\\u6708'\n\n  private static exceptionLocales = [\n    'ja',\n    'ja-JP',\n    'zh',\n    'zh-Hans',\n    'zh-Hans-CN',\n    'zh-Hans-HK',\n    'zh-Hans-MO',\n    'zh-Hans-SG',\n    'zh-Hant',\n    'zh-Hant-HK',\n    'zh-Hant-MO',\n    'zh-Hant-TW'\n  ];\n  // Uses the Intl.DateTimeFormat formatToParts to get the day periods.\n  // Returns this object\n  // \"dayPeriods\": {\n  //  \"format\": {\n  //    \"wide\": {\n  //      \"am\": \"AM\",\n  //      \"pm\": \"PM\"\n  //    }}}\n  private static _getDayPeriods(locale: string, calendar: string) {\n    const date = new Date(2019, 0, 1, 0, 0, 0);\n\n    function getDayPeriodsFromFormatToParts(formatter: Intl.DateTimeFormat) {\n      const formatParts = formatter.formatToParts(date);\n      const eraPart = formatParts.find((value) => value.type === 'dayPeriod');\n      // TODO Era is failing for chinese calendar. Need to fix it\n      if (eraPart) {\n        return eraPart.value;\n      }\n      return '';\n    }\n    const options: {\n      hour: Intl.DateTimeFormatOptions['hour'];\n      hour12: Intl.DateTimeFormatOptions['hour12'];\n    } = { hour: 'numeric', hour12: true };\n    const formatterLocale = CalendarUtils.getFormatterLocale(locale, calendar);\n    const formatter = new Intl.DateTimeFormat(formatterLocale, options);\n    const amValue = getDayPeriodsFromFormatToParts(formatter);\n    date.setHours(20);\n    const pmValue = getDayPeriodsFromFormatToParts(formatter);\n    return { format: { wide: { am: amValue, pm: pmValue } } };\n  }\n\n  private static getFormatterLocale(locale: string, calendar: string) {\n    return locale + '-u-ca-' + calendar;\n  }\n\n  // Example of an eras from localeElements is this, but this fn gets all the data, not just eraAbbr.\n  // \"eras\": {\n  //   \"eraAbbr\": {\n  //     \"0\": \"BC\",\n  //     \"1\": \"AD\"\n  //   }\n  // },\n  private static _getEras(locale: string, calendar: string) {\n    const eras: EraDesc = [{ era: '0', start: '2000-02-11T00:00:00' }];\n    const cal: ErasType = {\n      eraNarrow: { '0': '', '1': '' },\n      eraAbbr: { '0': '', '1': '' },\n      eraName: { '0': '', '1': '' }\n    };\n\n    function getEraFromFormatToParts(formatter: Intl.DateTimeFormat, date: Date) {\n      const formatParts = formatter.formatToParts(date);\n      const eraPart = formatParts.find((value) => value.type === 'era');\n      if (eraPart) {\n        return eraPart.value;\n      }\n      return '';\n    }\n\n    const eraLenArray: Array<NonNullable<Intl.DateTimeFormatOptions['era']>> = [\n      'narrow',\n      'short',\n      'long'\n    ];\n    const formatterLocale = CalendarUtils.getFormatterLocale(locale, calendar);\n    // get the erra name for narrow, short, long.\n    // e.g., A, AD, Anno Domini\n    // this is used to map the era option value from Intl.DateTimeFormat to\n    // what we want to short in our CalendarNode\n    const eraMap = {\n      narrow: 'eraNarrow',\n      short: 'eraAbbr',\n      long: 'eraName'\n    };\n\n    for (let i = 0; i < eras.length; i++) {\n      const date = new Date(eras[i].start);\n      for (let j = 0; j < eraLenArray.length; j++) {\n        const eraLenName = eraLenArray[j];\n        const options: {\n          year: Intl.DateTimeFormatOptions['year'];\n          month: Intl.DateTimeFormatOptions['month'];\n          day: Intl.DateTimeFormatOptions['day'];\n          era: Intl.DateTimeFormatOptions['era'];\n        } = { year: 'numeric', month: 'numeric', day: 'numeric', era: eraLenName };\n        const formatter = new Intl.DateTimeFormat(formatterLocale, options);\n        const eraForLength = getEraFromFormatToParts(formatter, date);\n        const eraNameForNode = eraMap[eraLenName] as keyof ErasType;\n        const eraObj = { '0': eraForLength, '1': eraForLength };\n        cal[eraNameForNode] = eraObj;\n      }\n    }\n    return cal;\n  }\n\n  private static _fillMonthAndDays(\n    locale: string,\n    calendar: string,\n    widthVal: CalendarWidthNames,\n    options: Intl.DateTimeFormatOptions,\n    isStandAlone: boolean\n  ) {\n    // These date are used to fill in the months and weekdays.\n    // Each date is a different day of week and month. Like, the first is sun in January, the second is mon in Feb, etc.\n    // If you know that a specific date, such as January 5, 2020, falls on a Sunday in Los Angeles, you can safely assume that it's also a Sunday in China.\n    // This assumption is based on the consistency of the seven-day week cycle used worldwide\n    // and the fact that days of the week are determined by the Earth's rotation.\n    const dates: Array<Array<number>> = [\n      [2020, 0, 5],\n      [2020, 1, 3],\n      [2020, 2, 3],\n      [2020, 3, 1],\n      [2020, 4, 7],\n      [2020, 5, 5],\n      [2020, 6, 4],\n      [2020, 7, 1],\n      [2020, 8, 1],\n      [2020, 9, 1],\n      [2020, 10, 1],\n      [2020, 11, 1]\n    ];\n\n    function getMonthFromFormatToParts(formatParts: Intl.DateTimeFormatPart[]) {\n      const monthPart = formatParts.find((value) => value.type === 'month');\n      if (monthPart) {\n        return monthPart.value;\n      }\n      return null;\n    }\n\n    function getWeekdayFromFormatToParts(formatParts: Intl.DateTimeFormatPart[]) {\n      const weekdayPart = formatParts.find((value) => value.type === 'weekday');\n      if (weekdayPart) {\n        return weekdayPart.value;\n      }\n      return null;\n    }\n\n    const formatterLocale = CalendarUtils.getFormatterLocale(locale, calendar);\n    const formatter = new Intl.DateTimeFormat(formatterLocale, options);\n\n    type MonthFormatType = {\n      abbreviated?: Partial<MonthType>;\n      narrow?: Partial<MonthType>;\n      wide?: Partial<MonthType>;\n    };\n    type DayFormatType = {\n      abbreviated?: Partial<DayType>;\n      narrow?: Partial<DayType>;\n      wide?: Partial<DayType>;\n    };\n    const calMonthFormat: MonthFormatType = {};\n    const calDayFormat: DayFormatType = {};\n\n    // It loops from 0 to 12, dates is for each month. [0] is the year, [1] is the month, [2] is the day\n    // create a new date with year, month, day. each date[j] is a different month of the year, and it also has a different weekday.\n    for (let j = 0; j < dates.length; j++) {\n      const index = j + 1; // 1 to 12\n      const dayIndexVal: WeekdayNames =\n        CalendarUtils._weekdaysFormatMap[index as keyof typeof CalendarUtils._weekdaysFormatMap];\n      const date = new Date(dates[j][0], dates[j][1], dates[j][2]);\n      const formatParts = formatter.formatToParts(date);\n      let month;\n      let weekday;\n      // for stand-alone (e.g., {month: 'short'}), there is only one entry, so we can just get the\n      // value of format. No need for formatToParts to pull out just the month piece.\n      // Note that for ja format gives you the month kanji character too and formatToParts month is only the number. The kanji character is in the literal.\n      if (isStandAlone) {\n        month = formatter.format(date);\n        weekday = formatter.format(date);\n      } else {\n        month = getMonthFromFormatToParts(formatParts);\n        weekday = getWeekdayFromFormatToParts(formatParts);\n      }\n      // store the month and weekday in the obj; only fill in weekday if (index <= 7)\n      if (calMonthFormat[widthVal] === undefined) {\n        calMonthFormat[widthVal] = {};\n      }\n      // @ts-ignore\n      calMonthFormat[widthVal][index] = month;\n      if (index <= 7) {\n        if (calDayFormat[widthVal] === undefined) {\n          calDayFormat[widthVal] = {};\n        }\n        // @ts-ignore\n        calDayFormat[widthVal][dayIndexVal] = weekday;\n      }\n    }\n    return {\n      monthFormat: calMonthFormat, // This will be an object like {'abbreviated': Partial<MonthType}\n      dayFormat: calDayFormat\n    };\n  }\n\n  private static _getFormatMonthAndDays(locale: string, calendar: string) {\n    const calMonths = [];\n    const calDays = [];\n    // Intl.DateTimeFormat's month can take: \"numeric\" (e.g., 3)\"2-digit\" (e.g., 03)\"long\" (e.g., March)\"short\" (e.g., Mar) \"narrow\" (e.g., M).\n    const types: Array<WidthOptions> = ['short', 'narrow', 'long'];\n    for (let i = 0; i < types.length; i++) {\n      const options: Intl.DateTimeFormatOptions = {\n        month: types[i],\n        weekday: types[i],\n        year: 'numeric',\n        day: 'numeric'\n      };\n      // types get mapped to short: 'abbreviated', narrow: 'narrow', long: 'wide'\n      const widthVal = CalendarUtils._monthNamesFormatMap[types[i]]; // get alternate names for 'narrow', 'short', 'long'\n      const monthDayObjForWidth = CalendarUtils._fillMonthAndDays(\n        locale,\n        calendar,\n        widthVal,\n        options,\n        false\n      );\n\n      calMonths[i] = monthDayObjForWidth.monthFormat;\n      calDays[i] = monthDayObjForWidth.dayFormat;\n    }\n\n    const myMonthObj = Object.assign({}, ...calMonths);\n    const myDayObj = Object.assign({}, ...calDays);\n\n    const myMonthFormatObj: Partial<MonthsNodeType> = {};\n    myMonthFormatObj.format = myMonthObj;\n    const myDayFormatObj: Partial<DaysNodeType> = {};\n    myDayFormatObj.format = myDayObj;\n\n    myMonthFormatObj['stand-alone'] = myMonthFormatObj.format;\n    myDayFormatObj['stand-alone'] = myDayFormatObj.format;\n\n    return {\n      monthsNode: myMonthFormatObj as MonthsNodeType,\n      daysNode: myDayFormatObj as DaysNodeType\n    };\n  }\n\n  private static _getStandAloneDays(locale: string, calendar: string) {\n    const calDays = [];\n    // Intl.DateTimeFormat's weekday can take: \"long\" (e.g., Monday)\"short\" (e.g., Mon) \"narrow\" (e.g., M).\n    // stand-alone weekday is displayed when the options conatin only one attribute weekday: options = {weekday:'long'}\n    const types: Array<WidthOptions> = ['short', 'narrow', 'long'];\n    for (let i = 0; i < types.length; i++) {\n      const options: Intl.DateTimeFormatOptions = {\n        weekday: types[i]\n      };\n      // types get mapped to short: 'abbreviated', narrow: 'narrow', long: 'wide'\n      const widthVal = CalendarUtils._monthNamesFormatMap[types[i]]; // get alternate names for 'narrow', 'short', 'long'\n      const dayObjForWidth = CalendarUtils._fillMonthAndDays(\n        locale,\n        calendar,\n        widthVal,\n        options,\n        true\n      );\n      calDays[i] = dayObjForWidth.dayFormat;\n    }\n    const myDayObj = Object.assign({}, ...calDays);\n    const myDayStandAloneObj = { 'stand-alone': {} };\n    myDayStandAloneObj['stand-alone'] = myDayObj;\n    return {\n      daysNode: myDayStandAloneObj as DaysNodeType\n    };\n  }\n\n  private static _getStandAloneMonths(locale: string, calendar: string) {\n    const calMonths = [];\n    // Intl.DateTimeFormat's month can take: \"numeric\" (e.g., 3)\"2-digit\" (e.g., 03)\"long\" (e.g., March)\"short\" (e.g., Mar) \"narrow\" (e.g., M).\n    // stand-alone month is displayed when the options conatin only one attribute month: options = {month:'long'}\n    const types: Array<WidthOptions> = ['short', 'narrow', 'long'];\n    for (let i = 0; i < types.length; i++) {\n      const options = {\n        month: types[i]\n      };\n      // types get mapped to short: 'abbreviated', narrow: 'narrow', long: 'wide'\n      const widthVal = CalendarUtils._monthNamesFormatMap[types[i]]; // get alternate names for 'narrow', 'short', 'long'\n      const monthObjForWidth = CalendarUtils._fillMonthAndDays(\n        locale,\n        calendar,\n        widthVal,\n        options,\n        true\n      );\n      calMonths[i] = monthObjForWidth.monthFormat;\n    }\n    const myMonthObj = Object.assign({}, ...calMonths);\n    const myMonthStandAloneObj = { 'stand-alone': {} };\n    myMonthStandAloneObj['stand-alone'] = myMonthObj;\n    return {\n      monthsNode: myMonthStandAloneObj as MonthsNodeType\n    };\n  }\n  /**\n   * Fills in CalendarUtils.calendars[locale][calendar] public static object.\n   * @param locale locale name\n   * @param calendar calendar name\n   */\n  public static getCalendar(locale: string, calendar: string): CalendarNodeType {\n    CalendarUtils.calendars = CalendarUtils.calendars ?? {};\n    CalendarUtils.calendars[locale] = CalendarUtils.calendars[locale] ?? {};\n\n    if (CalendarUtils.calendars[locale][calendar] === undefined) {\n      const dayPeriodsObj = CalendarUtils._getDayPeriods(locale, calendar);\n      const erasObj = CalendarUtils._getEras(locale, calendar);\n      let monthFormat;\n      let dayFormat;\n      const standAloneMonths = CalendarUtils._getStandAloneMonths(locale, calendar);\n      const standAloneDays = CalendarUtils._getStandAloneDays(locale, calendar);\n      const useStandAlone = CalendarUtils.exceptionLocales.includes(locale);\n      // TODO this might only be needed for gregorian calendar. Need to check when\n      // we support other calendars\n      if (useStandAlone) {\n        monthFormat = standAloneMonths.monthsNode['stand-alone'];\n        dayFormat = standAloneDays.daysNode['stand-alone'];\n      } else {\n        const monthsDaysNodeObj = CalendarUtils._getFormatMonthAndDays(locale, calendar);\n        monthFormat = monthsDaysNodeObj.monthsNode.format;\n        dayFormat = monthsDaysNodeObj.daysNode.format;\n      }\n      const monthsNodes: MonthsNodeType = {\n        format: monthFormat,\n        'stand-alone': standAloneMonths.monthsNode['stand-alone']\n      };\n      const daysNodes: DaysNodeType = {\n        format: dayFormat,\n        'stand-alone': standAloneDays.daysNode['stand-alone']\n      };\n      CalendarUtils.calendars[locale][calendar] = {\n        dayPeriods: dayPeriodsObj,\n        months: monthsNodes,\n        days: daysNodes,\n        eras: erasObj,\n        locale: locale\n      };\n    }\n    return CalendarUtils.calendars[locale][calendar];\n  }\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport type DateDef = {\n  year: number;\n  month: number; // 1-based!\n  date: number;\n  hours: number;\n  minutes: number;\n};\n// cache the converters\nconst formatterCache: Map<string, Intl.DateTimeFormat> = new Map();\n\n/**\n * Calculates the time zone offset (in minutes) between UTC and a specified time zone\n * for a given date, accounting for Daylight Saving Time (DST) transitions.\n * @param date - An object representing the date and time, e.g., date.year.\n * @param timeZone  - The IANA time zone name (e.g., \"America/Los_Angeles\")\n * @returns {number} The offset in minutes between UTC and the specified time zone,\n * accounting for potential Daylight Saving Time (DST) adjustments.\n */\nexport function getISODateOffset(date: DateDef, timeZone: string): number {\n  // Special handling of first of the year with year < 100, e.g., 0001-01-01.\n  if (date.year < 100 && date.month === 1 && date.date === 1) {\n    // Increment date by 1 and run again so that we are not on a January 1 date, and instead on January 2 date. This\n    // prevents the roll-back to the previous day staying on the same year bug for year < 100.\n    // Instead we calculate the offset based on the day year-month-day+1 so that _applyTimezoneToDate doesn't encounter the issue\n    // where when you are on January 1, you should get December 31 of the previous year, but for year < 100, you do not get the previous year\n    // you get December 31 of the same year. The automatic rollback is not working for year < 100.\n    // E.g., 0099-01-01 is the limit, subtract a date and you are getting the same year, like 0099-12-31. The expected is 0098-12-31.\n    // So to calculate the offset, we use 0099-01-02 instead. Changing the day by one will not affect the offset for year < 100.\n    // If we do not do this, then _getOffset gives a bogus offset, which then causes an Invalid Time error. This helps fix issues found in\n    // JET-60050 OJ-INPUT-DATE COMPONENT UNABLE TO PARSE MIN-DATE AND MAX-DATE ATTRIBUTES FOR DATES < 100.\n    const newDate = {\n      year: date.year,\n      month: date.month,\n      date: date.date + 1,\n      hours: date.hours,\n      minutes: date.minutes\n    };\n    return getISODateOffset(newDate, timeZone);\n  }\n\n  // Get the timezone-adjusted representation of the date parameter interpreted as UTC\n  const d = new Date(Date.UTC(date.year, date.month - 1, date.date, date.hours, date.minutes));\n  if (date.year < 100) {\n    d.setFullYear(date.year);\n  }\n  const utcDateAtTimezone = _applyTimezoneToDate(d, timeZone);\n  // get the offset of the target timezone (subject to a possible DTS change adjustment)\n  const offset = _getOffset(date, utcDateAtTimezone);\n  let adjustment = 0;\n  d.setTime(d.getTime() - offset * 60000);\n\n  // check whether the offset is correct\n  if (!(date.year < 100)) {\n    // no need to check for dst before year 100. Plus we have issues with year < 100 so don't do unnecessary work.\n    if (!_compareDates(_applyTimezoneToDate(d, timeZone), date)) {\n      // try to accommodate 'fall back'/move 1 hour west\n      adjustment = -60;\n      d.setTime(d.getTime() + 60 * 60000);\n      if (!_compareDates(_applyTimezoneToDate(d, timeZone), date)) {\n        // spring forward/move 1 hour east\n        // This case should always produce a match unless we are hitting the missing hour during the 'spring forward'\n        // JS Date() favors the DST in this case, so we will remain at the 'spring forward' offset even if _compareDates()\n        // would have returned false\n        adjustment = 60;\n        d.setTime(d.getTime() - 120 * 60000);\n      }\n    }\n  }\n\n  const result = offset + adjustment;\n\n  return result;\n}\n\nfunction _applyTimezoneToDate(d: Date, timeZone: string): DateDef {\n  const cnv = _getConverter(timeZone);\n  const formattedUTC = cnv.format(d);\n  const [localDate, localTime] = formattedUTC.split(',');\n  const [month, date, year] = localDate.split('/');\n  const [hours, minutes] = localTime.trim().split(':');\n  return {\n    year: parseInt(year),\n    month: parseInt(month),\n    date: parseInt(date),\n    hours: parseInt(hours),\n    minutes: parseInt(minutes)\n  };\n}\n\nfunction _getOffset(original: DateDef, asUTC: DateDef): number {\n  let originalMins = original.hours * 60 + original.minutes;\n  let utcMinutes = asUTC.hours * 60 + asUTC.minutes;\n  // any shift in year, month or day indicates the following day\n  let delta = original.year - asUTC.year;\n  if (delta == 0) {\n    delta = original.month - asUTC.month;\n    if (delta === 0) {\n      delta = original.date - asUTC.date;\n    }\n  }\n  if (delta > 0) {\n    originalMins += 24 * 60;\n  } else if (delta < 0) {\n    utcMinutes += 24 * 60;\n  }\n  return utcMinutes - originalMins;\n}\n\nfunction _compareDates(date1: DateDef, date2: DateDef) {\n  return (\n    date1.year === date2.year &&\n    date1.month === date2.month &&\n    date1.hours === date2.hours &&\n    date1.minutes === date2.minutes\n  );\n}\n\nfunction _getConverter(timezone: string) {\n  let formatter = formatterCache.get(timezone);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat('en-US', {\n      year: 'numeric',\n      month: 'numeric',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: 'numeric',\n      second: 'numeric',\n      hourCycle: 'h23',\n      timeZone: timezone\n    });\n    formatterCache.set(timezone, formatter);\n  }\n  return formatter;\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport class NativeDateTimeConstants {\n  public static readonly _YEAR_AND_DATE_REGEXP = /(\\d{1,4})\\D+?(\\d{1,4})/g;\n  public static readonly _YMD_REGEXP = /(\\d{1,4})\\D+?(\\d{1,4})\\D+?(\\d{1,4})/g;\n  public static readonly _TIME_REGEXP =\n    /(\\d{1,2})(?:\\D(\\d{1,2}))?(?:\\D(\\d{1,2}))?(?:\\D(\\d{1,3}))?/g;\n  public static readonly _TIME_FORMAT_REGEXP = /h|H|K|k/g;\n\n  public static readonly _YEAR_REGEXP = /y{1,4}/;\n  public static readonly _MONTH_REGEXP = /M{1,5}/;\n  public static readonly _DAY_REGEXP = /d{1,2}/;\n  public static readonly _WEEK_DAY_REGEXP = /E{1,5}/;\n  public static readonly _HOUR_REGEXP = /h{1,2}|k{1,2}/i;\n  public static readonly _MINUTE_REGEXP = /m{1,2}/;\n  public static readonly _SECOND_REGEXP = /s{1,2}/;\n  public static readonly _FRACTIONAL_SECOND_REGEXP = /S{1,3}/;\n  public static readonly _AMPM_REGEXP = /a{1,2}/;\n  public static readonly _WORD_REGEXP = '(\\\\D+?\\\\s*)';\n\n  // This eslint disable require to make eacs happy\n  // eslint-disable-next-line no-useless-escape\n  public static readonly _ESCAPE_REGEXP = /([\\^$.*+?|\\[\\](){}])/g;\n\n  public static readonly _TOKEN_REGEXP =\n    /ccccc|cccc|ccc|cc|c|EEEEE|EEEE|EEE|EE|E|dd|d|MMMMM|MMMM|MMM|MM|M|LLLLL|LLLL|LLL|LL|L|yyyy|yy|y|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|aa|a|SSS|SS|S|zzzz|zzz|zz|z|v|ZZZ|ZZ|Z|XXX|XX|X|VV|GGGGG|GGGG|GGG|GG|G/g;\n  public static readonly _ZULU = 'zulu';\n  public static readonly _LOCAL = 'local';\n  public static readonly _AUTO = 'auto';\n  public static readonly _INVARIANT = 'invariant';\n  public static readonly _OFFSET = 'offset';\n  public static readonly _ALNUM_REGEXP = '(\\\\D+|\\\\d\\\\d?\\\\D|\\\\d\\\\d?|\\\\D+\\\\d\\\\d?)';\n  public static readonly _NON_DIGIT_REGEXP = '(\\\\D+|\\\\D+\\\\d\\\\d?)';\n  public static readonly _NON_DIGIT_OPT_REGEXP = '(\\\\D*)';\n  public static readonly _STR_REGEXP = '(.+?)';\n  public static readonly _TWO_DIGITS_REGEXP = '(\\\\d\\\\d?)';\n  public static readonly _THREE_DIGITS_REGEXP = '(\\\\d{1,3})';\n  public static readonly _FOUR_DIGITS_REGEXP = '(\\\\d{1,4})';\n  public static readonly _SLASH_REGEXP = '(\\\\/)';\n\n  public static readonly _PROPERTIES_MAP = {\n    MMM: {\n      token: 'months',\n      style: 'format',\n      mLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'month',\n      value: 'short',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    MMMM: {\n      token: 'months',\n      style: 'format',\n      mLen: 'wide',\n      matchIndex: 0,\n      key: 'month',\n      value: 'long',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    MMMMM: {\n      token: 'months',\n      style: 'format',\n      mLen: 'narrow',\n      matchIndex: 0,\n      key: 'month',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    LLL: {\n      token: 'months',\n      style: 'stand-alone',\n      mLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'month',\n      value: 'short',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    LLLL: {\n      token: 'months',\n      style: 'stand-alone',\n      mLen: 'wide',\n      matchIndex: 1,\n      key: 'month',\n      value: 'long',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    LLLLL: {\n      token: 'months',\n      style: 'stand-alone',\n      mLen: 'narrow',\n      matchIndex: 1,\n      key: 'month',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._ALNUM_REGEXP\n    },\n    E: {\n      token: 'days',\n      style: 'format',\n      dLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EEE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'abbreviated',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EEEE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'wide',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'long',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    EEEEE: {\n      token: 'days',\n      style: 'format',\n      dLen: 'narrow',\n      matchIndex: 0,\n      key: 'weekday',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    c: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    cc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    ccc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'abbreviated',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'short',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    cccc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'wide',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'long',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    ccccc: {\n      token: 'days',\n      style: 'stand-alone',\n      dLen: 'narrow',\n      matchIndex: 1,\n      key: 'weekday',\n      value: 'narrow',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    h: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 11,\n      start2: 1,\n      end2: 12,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    hh: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 11,\n      start2: 1,\n      end2: 12,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    K: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 12,\n      start2: 0,\n      end2: 12,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    KK: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 12,\n      start2: 0,\n      end2: 12,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    H: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 23,\n      start2: 0,\n      end2: 23,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    HH: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 23,\n      start2: 0,\n      end2: 23,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    k: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 24,\n      start2: 0,\n      end2: 24,\n      key: 'hour',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    kk: {\n      token: 'time',\n      timePart: 'hour',\n      start1: 0,\n      end1: 24,\n      start2: 0,\n      end2: 24,\n      key: 'hour',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    m: {\n      token: 'time',\n      timePart: 'minute',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'minute',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    mm: {\n      token: 'time',\n      timePart: 'minute',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'minute',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    s: {\n      token: 'time',\n      timePart: 'second',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'second',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    ss: {\n      token: 'time',\n      timePart: 'second',\n      start1: 0,\n      end1: 59,\n      start2: 0,\n      end2: 59,\n      key: 'second',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    S: {\n      token: 'time',\n      timePart: 'millisec',\n      start1: 0,\n      end1: 999,\n      start2: 0,\n      end2: 999,\n      key: 'millisecond',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._THREE_DIGITS_REGEXP\n    },\n    SS: {\n      token: 'time',\n      timePart: 'millisec',\n      start1: 0,\n      end1: 999,\n      start2: 0,\n      end2: 999,\n      key: 'millisecond',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._THREE_DIGITS_REGEXP\n    },\n    SSS: {\n      token: 'time',\n      timePart: 'millisec',\n      start1: 0,\n      end1: 999,\n      start2: 0,\n      end2: 999,\n      key: 'millisecond',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._THREE_DIGITS_REGEXP\n    },\n    d: {\n      token: 'dayOfMonth',\n      key: 'day',\n      value: 'numeric',\n      getPartIdx: 2,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    dd: {\n      token: 'dayOfMonth',\n      key: 'day',\n      value: '2-digit',\n      getPartIdx: 2,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    M: {\n      token: 'monthIndex',\n      key: 'month',\n      value: 'numeric',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    MM: {\n      token: 'monthIndex',\n      key: 'month',\n      value: '2-digit',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    L: {\n      token: 'monthIndex',\n      key: 'month',\n      value: 'numeric',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    LL: {\n      token: 'monthIndex',\n      key: 'month',\n      value: '2-digit',\n      getPartIdx: 1,\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    y: {\n      token: 'year',\n      key: 'year',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._FOUR_DIGITS_REGEXP\n    },\n    yy: {\n      token: 'year',\n      key: 'year',\n      value: '2-digit',\n      regExp: NativeDateTimeConstants._TWO_DIGITS_REGEXP\n    },\n    yyyy: {\n      token: 'year',\n      key: 'year',\n      value: 'numeric',\n      regExp: NativeDateTimeConstants._FOUR_DIGITS_REGEXP\n    },\n    a: {\n      token: 'ampm',\n      key: 'dayPeriod',\n      value: undefined,\n      regExp: NativeDateTimeConstants._WORD_REGEXP\n    },\n    z: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    v: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    zz: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    zzz: {\n      token: 'tzAbbrev',\n      key: 'timeZoneName',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    zzzz: {\n      token: 'tzFull',\n      key: 'timeZoneName',\n      value: 'long',\n      regExp: NativeDateTimeConstants._STR_REGEXP\n    },\n    Z: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    ZZ: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    ZZZ: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    X: {\n      token: 'tzh',\n      key: 'tzh',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    XX: {\n      token: 'tzhm',\n      key: 'tzhm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    XXX: {\n      token: 'tzhsepm',\n      key: 'tzhsepm',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    VV: {\n      token: 'tzid',\n      key: 'tzid',\n      value: 'short',\n      regExp: NativeDateTimeConstants._STR_REGEXP,\n      type: 'tzOffset'\n    },\n    G: {\n      token: 'era',\n      key: 'era',\n      value: 'eraAbbr',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraAbbr',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GGG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraAbbr',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GGGG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraName',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    GGGGG: {\n      token: 'era',\n      key: 'era',\n      value: 'eraNarrow',\n      regExp: NativeDateTimeConstants._NON_DIGIT_REGEXP\n    },\n    '/': {\n      token: 'slash',\n      regExp: NativeDateTimeConstants._SLASH_REGEXP\n    }\n  };\n\n  public static readonly FRACTIONAL_SECOND_MAP = {\n    a: {\n      key: 'dayPeriod',\n      token: 'dayPeriod',\n      value: 'narrow'\n    },\n    SSS: {\n      key: 'fractionalSecondDigits',\n      token: 'fractionalSecond',\n      value: 3\n    },\n    SS: {\n      key: 'fractionalSecondDigits',\n      token: 'fractionalSecond',\n      value: 2\n    },\n    S: {\n      key: 'fractionalSecondDigits',\n      token: 'fractionalSecond',\n      value: 1\n    }\n  };\n  // Map between tokens length and options\n  public static readonly _tokenMap = {\n    era: { short: 'GGG', long: 'GGGG', narrow: 'GGGGG' },\n    month: { short: 'MMM', long: 'MMMM', narrow: 'MMMMM', numeric: 'M', '2-digit': 'MM' },\n    weekday: { short: 'EEE', long: 'EEEE', narrow: 'EEEEE' },\n    year: { numeric: 'y', '2-digit': 'yy' },\n    day: { numeric: 'd', '2-digit': 'dd' },\n    hour: { numeric: 'h', '2-digit': 'hh' },\n    minute: { numeric: 'm', '2-digit': 'mm' },\n    second: { numeric: 's', '2-digit': 'ss' },\n    fractionalSecond: { 1: 'S', 2: 'SS', 3: 'SSS' },\n    timeZoneName: { short: 'z', long: 'zzzz' }\n  };\n  // Map between tokens and timeStyle and dateStyle\n  // Always set year to y, hour to h, minute to m, and second to s\n  // We need to get the pattern from the options. It is only needed by parse,\n  // prase does not care of the difference between h an hh, y and yy because\n  // they are all numeric. so 2021/09/01 is equivalent to 21/9/1 because the\n  // pattern is (\\d)+/(\\d)+/(\\(d)+ matches both of inputs\n  public static readonly _dateTimeFormats = {\n    dateStyle: {\n      full: { year: 'y', month_s: 'MM', month_m: 'MMMM', weekday: 'EEEE', day: 'd' },\n      long: { year: 'y', month_s: 'MM', month_m: 'MMMM', day: 'd' },\n      medium: { year: 'y', month_s: 'MM', month_m: 'MMM', day: 'd' },\n      short: { year: 'y', month_s: 'M', month_m: 'MMM', day: 'd' }\n    },\n    timeStyle: {\n      full: { hour: 'h', minute: 'mm', second: 'ss', timeZoneName: 'zzzz' },\n      long: { hour: 'h', minute: 'mm', second: 'ss', timeZoneName: 'z' },\n      medium: { hour: 'h', minute: 'mm', second: 'ss' },\n      short: { hour: 'h', minute: 'mm' }\n    }\n  };\n  // letters a-z and A-Z are reserved for date-time tokens in the pattern\n  // they need to be surrounded by single quote if they are not a token.\n  // for example at should appear as 'at' in the pattern\n  public static readonly _ALPHA_REGEXP = /([a-zA-Z]+)/;\n  public static readonly _HOUR12_REGEXP = /h/g;\n  public static readonly _hourCycleMap = {\n    h12: 'h',\n    h23: 'H',\n    h11: 'K',\n    h24: 'k'\n  };\n  // zh-TW locales have different symbols for pm depending on the time.\n  // The following entries are noon, after noon, and evening\n  public static readonly _zh_tw_locales = ['zh-TW', 'zh-Hant', 'zh-Hant-TW'];\n  public static readonly _zh_tw_pm_symbols = ['\\u4e2d\\u5348', '\\u4e0b\\u5348', '\\u665a\\u4e0a'];\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { NativeDateTimeResolvedOptions } from './NativeDateTimeOptions';\n\n/**\n * Date time utilities.\n */\n\nconst regexTrim = /^\\s+|\\s+$|\\u200f|\\u200e/g;\nconst regexTrimNumber = /\\s+|\\u200f|\\u200e/g;\nconst regexTrimRightZeros = /0+$/g;\nconst zeros = ['0', '00', '000'];\n\n// ISO 8601 string accepted values:\n// -date only: YYYY or YYYY-MM or YYYY-MM-dd\n// -time only without timezone: Thh:mm or Thh:mm:ss or Thh:mm:ss.SSS\n// -time only with timezone: any of the time values above followed by any of the following:\n// Z or +/-hh:mm or +/-hhmm or +/-hh\n// -date time: any of the date values followed by any of the time values\n// NOTE: These regexps do not validate the number range of each segment.\nexport const _ISO_DATE_REGEXP =\n  /^[+-]?\\d{4}(?:-\\d{2}(?:-\\d{2})?)?(?:T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d+)?)?(Z|[+-]\\d{2}(?::?\\d{2})?)?)?$|^T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d+)?)?(Z|[+-]\\d{2}(?::?\\d{2})?)?$/;\n\nconst _ISO_DATE_ONLY_REGEXP = /^[+-]?\\d{4}-\\d{2}-\\d{2}$/;\n\nconst _ISO_TIME_ONLY_REGEXP = /^T\\d{2}:\\d{2}(?::\\d{2}(?:\\.\\d+)?)?$/;\n\n/**\n * Returns true if the value represents a date-only ISO string.\n *\n * @param {string} value\n * @returns true if the string represents a date-only ISO string\n */\nexport function isDateOnlyIsoString(value?: string | null) {\n  // If value is undefined/null, returns true.\n  // If value is empty or blank string, returns false.\n  // Otherwise checks value against the regexp.\n  const isValid =\n    value === undefined || value === null\n      ? true\n      : value.trim().length > 0\n      ? _ISO_DATE_ONLY_REGEXP.test(value.trim())\n      : false;\n  return isValid;\n}\n\n/**\n * Determines whether a given string is a valid ISO 8601 time-only format (`TXX:XX[:XX[.XXX]]`).\n * Ensures the format is correct and that the hour, minute, second and millisecond are within valid ranges.\n * @param {string | null | undefined} value - The input string to validate.\n * @returns true if the input is null or undefined, or if the input string is a valid ISO 8601 time-only string and all segments are valid ranges.\n * Returns false otherwise.\n */\nexport function isTimeOnlyIsoString(value?: string | null) {\n  if (value === undefined || value === null) {\n    return true;\n  }\n  if (value.trim().length === 0) {\n    return false;\n  }\n  // Note: We could use Intl.DateTimeFormat to test the iso string, but this should be more efficient unless we use a cached version.\n  const isoStrRegExpText = _ISO_TIME_ONLY_REGEXP.test(value);\n  if (!isoStrRegExpText) {\n    return false;\n  }\n  // Test the range of the parts.\n  try {\n    // If this returns without throwing then the value's hour, minute, second, millisecond parts are in range.\n    IsoStrParts(value);\n  } catch (_) {\n    return false;\n  }\n  return true;\n}\n\nexport function startsWith(value: string, pattern: string) {\n  return value.indexOf(pattern) === 0;\n}\n\nexport function trim(value: string) {\n  return (value + '').replace(regexTrim, '');\n}\n\nexport function trimRightZeros(value: string) {\n  return (value + '').replace(regexTrimRightZeros, '');\n}\n\nexport function trimNumber(value: string) {\n  const s = (value + '').replace(regexTrimNumber, '');\n  return s;\n}\n\nexport function toUpper(value: string) {\n  // \"he-IL\" has non-breaking space in weekday names.\n  return value.split('\\u00A0').join(' ').toUpperCase();\n}\n\nexport function padZeros(num: number, c: number) {\n  let s = num + '';\n  let isNegative = false;\n  if (num < 0) {\n    s = s.substr(1);\n    isNegative = true;\n  }\n  if (c > 1 && s.length < c) {\n    s = zeros[c - 2] + s;\n    s = s.substr(s.length - c, c);\n  }\n  if (isNegative) {\n    s = '-' + s;\n  }\n  return s;\n}\n\nexport function zeroPad(str: string, count: number, left: boolean) {\n  let result = '' + str;\n\n  for (let l = result.length; l < count; l += 1) {\n    result = left ? '0' + result : result + '0';\n  }\n  return result;\n}\n\nfunction _throwInvalidISOStringRange(\n  isoStr: string,\n  name: string,\n  displayValue: string | number,\n  displayLow: number,\n  displayHigh: number\n) {\n  const msg =\n    'The string ' +\n    isoStr +\n    ' is not a valid ISO 8601 string: ' +\n    displayValue +\n    ' is out of range.  Enter a value between ' +\n    displayLow +\n    ' and ' +\n    displayHigh +\n    ' for ' +\n    name;\n\n  const errorInfo = {\n    cause: {\n      code: 'isoStringOutOfRange',\n      parameterMap: {\n        isoStr: isoStr,\n        value: displayValue,\n        minValue: displayLow,\n        maxValue: displayHigh,\n        propertyName: name\n      }\n    }\n  };\n\n  const rangeError = new (RangeError as any)(msg, errorInfo);\n  throw rangeError;\n}\n\nfunction _throwInvalidISOStringSyntax(str: string) {\n  const msg = 'The string ' + str + ' is not a valid ISO 8601 string syntax.';\n  const errorInfo = {\n    cause: {\n      code: 'invalidISOString',\n      parameterMap: {\n        isoStr: str\n      }\n    }\n  };\n  const e = new (Error as any)(msg, errorInfo);\n  throw e;\n}\n\n/**\n * <p>Returns a local ISO string provided a Date object.\n * This method can be used to convert a moment in time or a local ISO string into\n * a local ISO string. It can also be used to convert any Date object into local ISO\n * string.</p>\n * Examples below are where the local (user's system) time zone is UTC-06:00<br>\n * dateToLocalIso(new Date('2021-06-04T00:00:00-04:00')); -->'2021-06-03T22:00:00'<br>\n * dateToLocalIso(new Date('2021-06-04T02:30:00Z')); -->'2021-06-03T20:30:00'<br>\n * In this example the input ISO string is local, the output is the same:<br>\n * dateToLocalIso(new Date('2021-06-04T02:30:00')); -->'2021-06-04T02:30:00'<br>\n * In this example we just want to convert a Date object:<br>\n * dateToLocalIso(new Date());<br>\n */\nexport function dateToLocalIso(_date: Date | number) {\n  let date = _date;\n  if (typeof date === 'number') {\n    date = new Date(date);\n  }\n  let isoStr =\n    padZeros(date.getFullYear(), 4) +\n    '-' +\n    padZeros(date.getMonth() + 1, 2) +\n    '-' +\n    padZeros(date.getDate(), 2) +\n    'T' +\n    padZeros(date.getHours(), 2) +\n    ':' +\n    padZeros(date.getMinutes(), 2) +\n    ':' +\n    padZeros(date.getSeconds(), 2);\n  if (date.getMilliseconds() > 0) {\n    isoStr += '.' + trimRightZeros(padZeros(date.getMilliseconds(), 3));\n  }\n  return isoStr;\n}\n\nexport function isLeapYear(y: number) {\n  if (y % 400 === 0) {\n    return true;\n  } else if (y % 100 === 0) {\n    return false;\n  } else if (y % 4 === 0) {\n    return true;\n  }\n  return false;\n}\n\n// Get days in month depending on month and leap year\nexport function getDaysInMonth(y: number, m: number) {\n  switch (m) {\n    case 0:\n    case 2:\n    case 4:\n    case 6:\n    case 7:\n    case 9:\n    case 11:\n      return 31;\n    case 1:\n      if (isLeapYear(y)) {\n        return 29;\n      }\n      return 28;\n    default:\n      return 30;\n  }\n}\n\nexport function IsoStrParts(isoString: string) {\n  const tst = _ISO_DATE_REGEXP.test(isoString);\n  if (tst === false) {\n    _throwInvalidISOStringSyntax(isoString);\n  }\n  const splitted = isoString.split('T');\n  const tIndex = isoString.indexOf('T');\n  const today = new Date();\n  let i;\n  let isBC = false;\n  const datetime = [today.getFullYear(), today.getMonth() + 1, today.getDate(), 0, 0, 0, 0];\n\n  if (splitted[0] !== '') {\n    // contains date portion\n    // test if date is BC, year is negative\n    if (startsWith(splitted[0], '-')) {\n      splitted[0] = splitted[0].slice(1);\n      isBC = true;\n    }\n    const dateSplitted = splitted[0].split('-');\n    for (i = 0; i < dateSplitted.length; i++) {\n      const val = parseInt(dateSplitted[i], 10);\n      // validate month\n      if (i === 1) {\n        if (val < 1 || val > 12) {\n          _throwInvalidISOStringRange(isoString, 'month', val, 1, 12);\n        }\n      }\n      // validate day\n      if (i === 2) {\n        const nbDays = getDaysInMonth(datetime[0], datetime[1] - 1);\n        if (val < 1 || val > nbDays) {\n          _throwInvalidISOStringRange(isoString, 'day', val, 1, nbDays);\n        }\n      }\n      datetime[i] = val;\n    }\n    if (isBC) {\n      datetime[0] = -datetime[0];\n    }\n  }\n\n  if (tIndex !== -1) {\n    const milliSecSplitted = splitted[1].split('.'); // contain millseconds\n    const timeSplitted = milliSecSplitted[0].split(':'); // contain hours, minutes, seconds\n\n    for (i = 0; i < timeSplitted.length; i++) {\n      const tVal = parseInt(timeSplitted[i], 10);\n      // validate hour\n      if (i === 0) {\n        if (tVal < 0 || tVal > 24) {\n          _throwInvalidISOStringRange(isoString, 'hour', tVal, 0, 24);\n        }\n      }\n      // validate minute\n      if (i === 1) {\n        if (tVal < 0 || tVal > 59) {\n          _throwInvalidISOStringRange(isoString, 'minute', tVal, 0, 59);\n        }\n      }\n      // validate second\n      if (i === 2) {\n        if (tVal < 0 || tVal > 59) {\n          _throwInvalidISOStringRange(isoString, 'second', tVal, 0, 59);\n        }\n      }\n      datetime[3 + i] = tVal;\n    }\n\n    if (milliSecSplitted.length === 2 && milliSecSplitted[1]) {\n      datetime[6] = parseInt(zeroPad(milliSecSplitted[1], 3, false), 10);\n    }\n  }\n  return datetime;\n}\n\nfunction _toBoolean(value: any) {\n  if (typeof value === 'string') {\n    const s = value.toLowerCase().trim();\n    switch (s) {\n      case 'true':\n      case '1':\n        return true;\n      case 'false':\n      case '0':\n        return false;\n      default:\n        return value;\n    }\n  }\n  return value;\n}\n\n// Return a function getOption.\n// The getOption function extracts the value of the property named\n// property from the provided options object, converts it to the required type,\n// checks whether it is one of a List of allowed values, and fills in a\n// fallback value if necessary.\nexport function getGetOption(options: NativeDateTimeResolvedOptions, getOptionCaller: string) {\n  if (options === undefined) {\n    throw new Error('Internal ' + getOptionCaller + ' error. Default options missing.');\n  }\n\n  const getOption = function (property: any, type: any, values: any, defaultValue: any) {\n    if ((options as any)[property] !== undefined) {\n      let value = (options as any)[property];\n      switch (type) {\n        case 'boolean':\n          value = _toBoolean(value);\n          break;\n        case 'string':\n          value = String(value);\n          break;\n        case 'number':\n          value = Number(value);\n          break;\n        default:\n          throw new Error('Internal error. Wrong value type.');\n      }\n      if (values !== undefined && values.indexOf(value) === -1) {\n        const expectedValues = [];\n        for (let i = 0; i < values.length; i++) {\n          expectedValues.push(values[i]);\n        }\n        const msg =\n          \"The value '\" +\n          (options as any)[property] +\n          \"' is out of range for '\" +\n          getOptionCaller +\n          \"' options property '\" +\n          property +\n          \"'. Valid values: \" +\n          expectedValues;\n        const rangeError = new RangeError(msg);\n        const errorInfo = {\n          errorCode: 'optionOutOfRange',\n          parameterMap: {\n            propertyName: property,\n            propertyValue: (options as any)[property],\n            propertyValueValid: expectedValues,\n            caller: getOptionCaller\n          }\n        };\n        (rangeError as any).errorInfo = errorInfo;\n        throw rangeError;\n      }\n\n      return value;\n    }\n    return defaultValue;\n  };\n\n  return getOption;\n}\n\nexport function partsToIsoString(parts: any) {\n  let isoStr =\n    padZeros(parts[0], 4) +\n    '-' +\n    padZeros(parts[1], 2) +\n    '-' +\n    padZeros(parts[2], 2) +\n    'T' +\n    padZeros(parts[3], 2) +\n    ':' +\n    padZeros(parts[4], 2) +\n    ':' +\n    padZeros(parts[5], 2);\n  if (parts[6] > 0) {\n    isoStr += '.' + trimRightZeros(padZeros(parts[6], 3));\n  }\n  return isoStr;\n}\n\n/**\n * Returns a local Date object from a local ISO string. This method is only meant\n * to work with local ISO strings. If the input ISO string contain Z or offset,\n * they will be ignored.\n * @param {string} isoString\n * @memberof oj.OraI18nUtils\n * @method isoToLocalDate\n */\nexport function isoToLocalDate(isoString: string) {\n  if (!isoString || typeof isoString !== 'string') {\n    return null;\n  }\n  return _isoToLocalDateIgnoreTimezone(isoString);\n}\n\nfunction _isoToLocalDateIgnoreTimezone(isoString: string) {\n  const datetime = IsoStrParts(isoString);\n  const date = new Date(\n    datetime[0],\n    datetime[1] - 1,\n    datetime[2],\n    datetime[3],\n    datetime[4],\n    datetime[5],\n    datetime[6]\n  );\n  // As per the documentation:\n  // new Date(year, monthIndex [, day [, hours [, minutes [, seconds [, milliseconds]]]]]);\n  // year - Integer value representing the year and\n  // values from 0 to 99 map to the years 1900 to 1999; all other values are the actual year.\n  // Use Date.prototype.setFullYear to create dates between the years 0 and 99.\n  date.setFullYear(datetime[0]);\n  return date;\n}\n\nexport function getISOStrFormatInfo(isoStr: string) {\n  const res: any = {\n    format: null,\n    dateTime: null,\n    timeZone: '',\n    isoStrParts: null\n  };\n  const exe: any = _ISO_DATE_REGEXP.exec(isoStr);\n\n  if (exe === null) {\n    _throwInvalidISOStringSyntax(isoStr);\n  }\n  if (exe && exe[1] === undefined && exe[2] === undefined) {\n    res.format = 'local';\n    res.dateTime = isoStr;\n    res.isoStrParts = IsoStrParts(res.dateTime);\n    return res;\n  }\n  res.timeZone = exe[1] !== undefined ? exe[1] : exe[2];\n  if (res.timeZone === 'Z') {\n    res.format = 'zulu';\n  } else {\n    res.format = 'offset';\n  }\n  const isoStrLen = isoStr.length;\n  const timeZoneLen = res.timeZone.length;\n  res.dateTime = isoStr.substring(0, isoStrLen - timeZoneLen);\n  res.isoStrParts = IsoStrParts(res.dateTime);\n  return res;\n}\n\nexport function getTimeStringFromOffset(\n  prefix: string,\n  offset: number,\n  reverseSign: boolean,\n  alwaysMinutes: boolean\n) {\n  const isNegative = reverseSign ? offset > 0 : offset < 0;\n  const absOffset = Math.abs(offset);\n  let hours: any = Math.floor(absOffset / 60);\n  const minutes: any = absOffset % 60;\n  const sign = isNegative ? '-' : '+';\n\n  if (alwaysMinutes) {\n    hours = zeroPad(hours, 2, true);\n  }\n  let str = prefix + sign + hours;\n  if (minutes > 0 || alwaysMinutes) {\n    str += ':' + zeroPad(minutes, 2, true);\n  }\n  return str;\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { CalendarNodeType } from './CalendarUtils';\nimport { DateDef } from './ISODateTimezoneOffset';\nimport { FormatParseError, FormatParseErrorOptions } from '../UNSAFE_IntlFormatParse';\nimport { getISODateOffset } from './ISODateTimezoneOffset';\nimport { NativeDateTimeConstants } from './NativeDateTimeConstants';\nimport { NativeDateTimeOptions } from './NativeDateTimeOptions';\nimport { NativeDateTimeResolvedOptions } from './NativeDateTimeOptions';\n\nimport * as LocalOraI18nUtils from './dateTimeUtils';\n\ninterface ParsedObjectType {\n  value: string;\n  warning: string;\n}\n\ninterface RangeType {\n  name: string;\n  value: number;\n  low: number;\n  high: number;\n  displayValue: number;\n  displayLow: number;\n  displayHigh: number;\n}\n// cache locale system time zone\nlet localSystemTimeZone: string | null = null;\n\nexport class NativeParserImpl {\n  public static parseImpl(\n    str: string,\n    pattern: string,\n    resOptions: NativeDateTimeResolvedOptions,\n    cal: CalendarNodeType\n  ): ParsedObjectType {\n    let dtStyle = 0;\n    // First try if str is an iso 8601 string\n    const testIsoStr = LocalOraI18nUtils._ISO_DATE_REGEXP.test(str);\n    let parsedIsoStr = '';\n    let isoStrInfo = null;\n    let res: any;\n    if (testIsoStr === true) {\n      parsedIsoStr = str;\n      dtStyle = this._isoStrDateTimeStyle(str);\n    } else {\n      dtStyle = this._dateTimeStyle(resOptions);\n      res = this._parseExact(str, pattern, resOptions, cal);\n      parsedIsoStr = res.value;\n    }\n    isoStrInfo = LocalOraI18nUtils.getISOStrFormatInfo(parsedIsoStr);\n    if (resOptions.timeZone !== undefined && isoStrInfo.format !== NativeDateTimeConstants._LOCAL) {\n      this._adjustHours(isoStrInfo, resOptions);\n    }\n    parsedIsoStr = this._createParseISOStringFromDate(dtStyle, isoStrInfo, resOptions);\n    if (res === undefined) {\n      res = { value: parsedIsoStr, warning: null };\n    } else {\n      res.value = parsedIsoStr;\n      res.warning = null;\n    }\n    // If the returned ISO string is date-time and isoStrFormat is local,\n    // log a warning saying that local is not supported for date-time iso strings\n    // and return offset instead\n    if (dtStyle === 2 && resOptions.isoStrFormat === NativeDateTimeConstants._LOCAL) {\n      // Disable warning since it causes noise in test runs.\n      // TODO: Re-enable once JET-59083 is fixed.\n      //Logger.warn(\n      //  'isoStrFormat was set to local for date-time ISO string. local was ignored and parse returned an ISO string with offset.'\n      //);\n    }\n    return res;\n  }\n  // appends pre- and post- token match strings while removing escaped\n  // characters.\n  // Returns a single quote count which is used to determine if the\n  // token occurs\n  // in a string literal.\n  private static _appendPreOrPostMatch(preMatch: string, strings: Array<string>): number {\n    let quoteCount = 0;\n    let escaped = false;\n    for (let i = 0, il = preMatch.length; i < il; i++) {\n      const c = preMatch.charAt(i);\n      switch (c) {\n        case \"'\":\n          if (escaped) {\n            strings.push(\"'\");\n          } else {\n            quoteCount += 1;\n          }\n          escaped = false;\n          break;\n        case '\\\\':\n          if (escaped) {\n            strings.push('\\\\');\n          }\n          escaped = !escaped;\n          break;\n        default:\n          strings.push(c);\n          escaped = false;\n          break;\n      }\n    }\n    return quoteCount;\n  }\n\n  private static _validateRange(range: RangeType) {\n    if (range.value < range.low || range.value > range.high) {\n      const msg =\n        range.displayValue +\n        ' is out of range.  Enter a value between ' +\n        range.displayLow +\n        ' and ' +\n        range.displayHigh +\n        ' for ' +\n        range.name;\n\n      const errorInfo: FormatParseErrorOptions = {\n        cause: {\n          code: 'datetimeOutOfRange',\n          parameterMap: {\n            value: range.displayValue,\n            minValue: range.displayLow,\n            maxValue: range.displayHigh,\n            propertyName: range.name\n          }\n        }\n      };\n      const rangeError = new (RangeError as any)(msg, errorInfo);\n      throw rangeError;\n    }\n  }\n\n  // Throw an exception if date-time pattern is invalid\n  private static _throwInvalidDateFormat(\n    format: string,\n    options: NativeDateTimeOptions | NativeDateTimeResolvedOptions,\n    m: string\n  ) {\n    const isDate =\n      options.year !== undefined ||\n      options.month !== undefined ||\n      options.weekday !== undefined ||\n      options.day !== undefined;\n    const isTime =\n      options.hour !== undefined || options.minute !== undefined || options.second !== undefined;\n\n    let samplePattern = '';\n    if (isDate && isTime) {\n      samplePattern = 'MM/dd/yy hh:mm:ss a';\n    } else if (isDate) {\n      samplePattern = 'MM/dd/yy';\n    } else {\n      samplePattern = 'hh:mm:ss a';\n    }\n\n    const msg =\n      'Unexpected character(s) ' +\n      m +\n      ' encountered in the pattern \"' +\n      format +\n      ' An example of a valid pattern is \"' +\n      samplePattern +\n      '\".';\n    const errorInfo: FormatParseErrorOptions = {\n      cause: {\n        code: 'optionValueInvalid',\n        parameterMap: {\n          propertyName: 'pattern',\n          propertyValue: format\n        }\n      }\n    };\n    const error = new (SyntaxError as any)(msg, errorInfo);\n    throw error;\n  }\n  // parse functions\n  private static _throwWeekdayMismatch(weekday: string, day: number) {\n    const msg = 'The weekday ' + weekday + ' does not match the date ' + day;\n    const errorInfo: FormatParseErrorOptions = {\n      cause: {\n        code: 'dateToWeekdayMismatch',\n        parameterMap: {\n          weekday: weekday,\n          date: day\n        }\n      }\n    };\n    const error = new FormatParseError(msg, errorInfo);\n    throw error;\n  }\n\n  private static _throwDateFormatMismatch(value: string, format: string, style: number) {\n    let msg = '';\n    let errorCodeType = '';\n\n    if (style === 2) {\n      msg =\n        'The value \"' + value + '\" does not match the expected date-time format \"' + format + '\"';\n      errorCodeType = 'datetimeFormatMismatch';\n    } else if (style === 0) {\n      msg = 'The value \"' + value + '\" does not match the expected date format \"' + format + '\"';\n      errorCodeType = 'dateFormatMismatch';\n    } else {\n      msg = 'The value \"' + value + '\" does not match the expected time format \"' + format + '\"';\n      errorCodeType = 'timeFormatMismatch';\n    }\n\n    const errorInfo: FormatParseErrorOptions = {\n      cause: {\n        code: errorCodeType,\n        parameterMap: {\n          value: value,\n          format: format\n        }\n      }\n    };\n    const error = new FormatParseError(msg, errorInfo);\n    throw error;\n  }\n\n  private static _parseTimezoneOffset(_offset: string): Array<number> {\n    const parts: Array<string> = _offset.split(':');\n    const offsetParts = new Array<number>(2);\n\n    // offset is +hh:mm\n    if (parts.length === 2) {\n      offsetParts[0] = parseInt(parts[0], 10);\n      offsetParts[1] = parseInt(parts[1], 10);\n    } else if (_offset.length === 2 || _offset.length === 3) {\n      // offset is +hh or +h\n      offsetParts[0] = parseInt(_offset, 10);\n      offsetParts[1] = 0;\n    } else {\n      // offset is +hhmm\n      offsetParts[0] = parseInt(_offset.substr(0, 3), 10);\n      offsetParts[1] = parseInt(_offset.substr(3), 10);\n    }\n    return offsetParts;\n  }\n\n  private static _expandYear(start2DigitYear: number, year: number): number {\n    // expands 2-digit year into 4 digits.\n    year = Number(year);\n    if (year < 100) {\n      const ambiguousTwoDigitYear = start2DigitYear % 100;\n\n      year += Math.floor(start2DigitYear / 100) * 100 + (year < ambiguousTwoDigitYear ? 100 : 0);\n    }\n    return year;\n  }\n\n  private static _arrayIndexOfMonthOrDay(\n    monthsDaysData: any,\n    userInput: string,\n    type: 'months' | 'days'\n  ): number {\n    const trimUserInput = NativeParserImpl.toUpperTrimmedNoPeriod(userInput);\n    const keys = Object.keys(monthsDaysData);\n    for (let i = 0; i < keys.length; i++) {\n      const valueFromData = monthsDaysData[keys[i]];\n      const trimValueFromData = NativeParserImpl.toUpperTrimmedNoPeriod(valueFromData);\n      // first try an exact match.\n      if (trimUserInput === trimValueFromData) {\n        return i;\n      }\n\n      // Test if user input is a number. We don't use parseInt because we want\n      // to make sure trimUserInput is only number lie '5' and not '5abc'\n      if (type === 'months') {\n        const trimUserInputNumber = Number(trimUserInput);\n        // In some locales the month name is something like 1月. Remove the literal\n        // before compare in case the user enters only 1.\n        const numberPartFromData = parseInt(trimValueFromData);\n        if (Number.isInteger(numberPartFromData) && Number.isInteger(trimUserInputNumber)) {\n          if (numberPartFromData === trimUserInputNumber) {\n            return i;\n          }\n        }\n      }\n    }\n    return -1;\n  }\n\n  private static toUpperTrimmedNoPeriod(value: string) {\n    let trimItem = LocalOraI18nUtils.toUpper(value);\n    trimItem = LocalOraI18nUtils.trim(trimItem);\n    // In some locales the short month name ends with '.', remove it in case\n    // the user does not enter the dot at the end of the month name.\n    trimItem = trimItem.replace(/\\.$/, '');\n    return trimItem;\n  }\n\n  private static _getDayIndex(calNode: CalendarNodeType, value: string) {\n    let ret = 0;\n    let days = [];\n    const calDaysFmt = calNode.days.format;\n    const calDaysStdAlone = calNode.days['stand-alone'];\n    days = [\n      calDaysFmt.abbreviated,\n      calDaysFmt.wide,\n      calDaysStdAlone.abbreviated,\n      calDaysStdAlone.wide\n    ];\n    for (let m = 0; m < days.length; m++) {\n      ret = this._arrayIndexOfMonthOrDay(days[m], value, 'days');\n      if (ret !== -1) {\n        return ret;\n      }\n    }\n    return ret;\n  }\n\n  private static _getMonthIndex(calNode: CalendarNodeType, value: string) {\n    let ret = -1;\n    const calMonthsFmt = calNode.months.format;\n    const calMonthsStdAlone = calNode.months['stand-alone'];\n    const months = [\n      calMonthsFmt.wide,\n      calMonthsFmt.abbreviated,\n      calMonthsStdAlone.wide,\n      calMonthsStdAlone.abbreviated\n    ];\n    for (let m = 0; m < months.length; m++) {\n      ret = this._arrayIndexOfMonthOrDay(months[m], value, 'months');\n      if (ret !== -1) {\n        return ret;\n      }\n    }\n    return ret;\n  }\n\n  // converts a format string into a regular expression with groups that\n  // can be used to extract date fields from a date string.\n  // check for a cached parse regex.\n  private static _getParseRegExp(format: string, options: NativeDateTimeResolvedOptions): any {\n    //let re = {};\n    // expand single digit formats, then escape regular expression\n    //  characters.\n    const expFormat = format.replace(NativeDateTimeConstants._ESCAPE_REGEXP, '\\\\\\\\$1');\n    const regexp = ['^'];\n    const groups = [];\n    let index = 0;\n    let quoteCount = 0;\n    // iterate through each date token found.\n    let match = NativeDateTimeConstants._TOKEN_REGEXP.exec(expFormat);\n    while (match !== null) {\n      const preMatch = expFormat.slice(index, match.index);\n      index = NativeDateTimeConstants._TOKEN_REGEXP.lastIndex;\n\n      // don't replace any matches that occur inside a string literal.\n      quoteCount += this._appendPreOrPostMatch(preMatch, regexp);\n      if (quoteCount % 2) {\n        regexp.push(match[0]);\n      } else {\n        // add a regex group for the token.\n        const m = match[0];\n        let add = '';\n        if ((NativeDateTimeConstants._PROPERTIES_MAP as any)[m] !== undefined) {\n          add = (NativeDateTimeConstants._PROPERTIES_MAP as any)[m].regExp;\n        } else {\n          this._throwInvalidDateFormat(format, options, m);\n        }\n        if (add) {\n          regexp.push(add);\n        }\n        groups.push(match[0]);\n      }\n      match = NativeDateTimeConstants._TOKEN_REGEXP.exec(expFormat);\n    }\n    this._appendPreOrPostMatch(expFormat.slice(index), regexp);\n    regexp.push('$');\n\n    // allow whitespace to differ when matching formats.\n    const regexpStr = regexp.join('').replace(/\\s+/g, '\\\\s+');\n    const parseRegExp = {\n      regExp: regexpStr,\n      groups: groups\n    };\n    // cache the regex for this format.\n    //re[format] = parseRegExp;\n    return parseRegExp;\n  }\n\n  private static _getTokenIndex(arr: Array<any>, token: string): number {\n    for (let i = 0; i < arr.length; i++) {\n      if (arr[i][token] !== undefined) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  // time lenient parse\n  private static _parseLenienthms(\n    result: Date,\n    timepart: string,\n    format: string,\n    dtype: number,\n    calNode: CalendarNodeType\n  ) {\n    // hour, optional minutes and optional seconds\n    (NativeDateTimeConstants._TIME_REGEXP as any).lastIndex = 0;\n    let hour = 0;\n    let minute = 0;\n    let second = 0;\n    let msec = 0;\n    let idx;\n    let match: any = NativeDateTimeConstants._TIME_REGEXP.exec(timepart);\n    let range: RangeType;\n    if (match === null) {\n      this._throwDateFormatMismatch(timepart, format, dtype);\n    }\n    if (match[1] !== undefined) {\n      hour = parseInt(match[1], 10);\n    }\n    if (match[2] !== undefined) {\n      minute = parseInt(match[2], 10);\n    }\n    if (match[3] !== undefined) {\n      second = parseInt(match[3], 10);\n    }\n    if (match[4] !== undefined) {\n      msec = parseInt(match[4], 10);\n    }\n\n    (NativeDateTimeConstants._TIME_FORMAT_REGEXP as any).lastIndex = 0;\n    match = NativeDateTimeConstants._TIME_FORMAT_REGEXP.exec(format);\n    switch (match[0]) {\n      case 'h':\n        // Hour in am/pm (1-12)\n        if (hour === 12) {\n          hour = 0;\n        }\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 11,\n          displayValue: hour,\n          displayLow: 1,\n          displayHigh: 12\n        };\n        this._validateRange(range);\n        idx = this._matchPMSymbol(calNode, timepart);\n        if (idx && hour < 12) {\n          hour += 12;\n        }\n        break;\n      case 'K':\n        // Hour in am/pm (0-11)\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 11,\n          displayValue: hour,\n          displayLow: 0,\n          displayHigh: 11\n        };\n        this._validateRange(range);\n        idx = this._matchPMSymbol(calNode, timepart);\n        if (idx && hour < 12) {\n          hour += 12;\n        }\n        break;\n      case 'H':\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 23,\n          displayValue: hour,\n          displayLow: 0,\n          displayHigh: 23\n        };\n        this._validateRange(range);\n        break;\n      case 'k':\n        if (hour === 24) {\n          hour = 0;\n        }\n        range = {\n          name: 'hour',\n          value: hour,\n          low: 0,\n          high: 23,\n          displayValue: hour,\n          displayLow: 1,\n          displayHigh: 24\n        };\n        break;\n      default:\n        break;\n    }\n    // Minutes.\n    range = {\n      name: 'minute',\n      value: minute,\n      low: 0,\n      high: 59,\n      displayValue: minute,\n      displayLow: 0,\n      displayHigh: 59\n    };\n    this._validateRange(range);\n    // Seconds.\n    range = {\n      name: 'second',\n      value: second,\n      low: 0,\n      high: 59,\n      displayValue: second,\n      displayLow: 0,\n      displayHigh: 59\n    };\n    this._validateRange(range);\n    // millisec\n    range = {\n      name: 'farctionalSecond',\n      value: msec,\n      low: 0,\n      high: 999,\n      displayValue: msec,\n      displayLow: 0,\n      displayHigh: 999\n    };\n    this._validateRange(range);\n    result.setHours(hour, minute, second, msec);\n  }\n\n  private static _getWeekdayName(value: string, calNode: CalendarNodeType): string | null {\n    const calDaysFmt = calNode.days.format;\n    const calDaysStandAlone = calNode.days['stand-alone'];\n    const days = [\n      calDaysFmt.wide,\n      calDaysFmt.abbreviated,\n      calDaysStandAlone.wide,\n      calDaysStandAlone.abbreviated\n    ];\n\n    for (let i = 0; i < days.length; i++) {\n      const dayKeys = Object.keys(days[i]);\n      for (let j = 0; j < dayKeys.length; j++) {\n        const dName = (days as any)[i][dayKeys[j]];\n        const dRegExp = new RegExp(dName + '\\\\b', 'i');\n        if (dRegExp.test(value)) {\n          return dName;\n        }\n      }\n    }\n    return null;\n  }\n\n  // lenient parse yMd and yMEd patterm. Must have year, moth,\n  // date all numbers. Ex: 5/3/2013\n  // weekday is optional. If present it must match date.\n  // Ex:  Tuesday 11/19/2013\n  // if year is 3-digits it can be anywhere in the string.\n  // Otherwise assume its position based on pattern\n  // if date > 12 it can be anywhere in the string.\n  // Otherwise assume its position based on pattern\n  // separators can be any non digit characters\n  private static _parseLenientyMEd(\n    value: string,\n    format: string,\n    options: NativeDateTimeResolvedOptions,\n    cal: any,\n    isDateTime: boolean\n  ): ParsedObjectType {\n    (NativeDateTimeConstants._YMD_REGEXP as any).lastIndex = 0;\n    const match: any = NativeDateTimeConstants._YMD_REGEXP.exec(value);\n    let dtype = 0;\n    if (match === null) {\n      dtype = isDateTime ? 2 : 0;\n      this._throwDateFormatMismatch(value, format, dtype);\n    }\n    const tokenIndexes = [\n      {\n        y: format.indexOf('y')\n      },\n      {\n        M: format.indexOf('M')\n      },\n      {\n        d: format.indexOf('d')\n      }\n    ];\n    tokenIndexes.sort(function (a, b) {\n      const n1 = Object.keys(a)[0];\n      const n2 = Object.keys(b)[0];\n      return (a as any)[n1] - (b as any)[n2];\n    });\n    let year = 0;\n    let month = 0;\n    let day = 0;\n    let yearIndex = 0;\n    let foundDayIndex = 0;\n    let i = 0;\n    const dayIndex = this._getTokenIndex(tokenIndexes, 'd');\n    let foundYear = false;\n    let foundDay = false;\n\n    for (i = 1; i <= 3; i++) {\n      const tokenMatch: string = match[i];\n      // find year if year is yyy|yyyy\n      const intToken = parseInt(tokenMatch);\n      if (tokenMatch.length > 2 || intToken > 31) {\n        year = intToken;\n        foundYear = true;\n        yearIndex = i - 1;\n      }\n    }\n    if (!foundYear) {\n      yearIndex = this._getTokenIndex(tokenIndexes, 'y');\n      year = match[this._getTokenIndex(tokenIndexes, 'y') + 1];\n    }\n    // find day if day value > 12\n    for (i = 0; i < 3; i++) {\n      if (i !== yearIndex && match[i + 1] > 12) {\n        day = match[i + 1];\n        foundDay = true;\n        foundDayIndex = i;\n        break;\n      }\n    }\n    if (!foundDay) {\n      if (yearIndex === this._getTokenIndex(tokenIndexes, 'd')) {\n        day = match[this._getTokenIndex(tokenIndexes, 'y') + 1];\n        month = match[this._getTokenIndex(tokenIndexes, 'M') + 1];\n      } else if (yearIndex === this._getTokenIndex(tokenIndexes, 'M')) {\n        day = match[this._getTokenIndex(tokenIndexes, 'd') + 1];\n        month = match[this._getTokenIndex(tokenIndexes, 'y') + 1];\n      } else {\n        day = match[this._getTokenIndex(tokenIndexes, 'd') + 1];\n        month = match[this._getTokenIndex(tokenIndexes, 'M') + 1];\n      }\n    } else {\n      for (i = 0; i < 3; i++) {\n        if (i !== foundDayIndex && i !== yearIndex) {\n          month = match[i + 1];\n          break;\n        }\n      }\n      if (month === undefined) {\n        month = match[this._getTokenIndex(tokenIndexes, 'M') + 1];\n      }\n    }\n    month -= 1;\n    const daysInMonth = LocalOraI18nUtils.getDaysInMonth(year, month);\n    let range: RangeType;\n    // if both month and day > 12 and swapped, throw exception\n    // based on original order\n    if (foundDay && dayIndex !== foundDayIndex && month > 12) {\n      range = {\n        name: 'month',\n        value: day,\n        low: 0,\n        high: 11,\n        displayValue: day,\n        displayLow: 1,\n        displayHigh: 12\n      };\n      this._validateRange(range);\n    }\n    range = {\n      name: 'month',\n      value: month,\n      low: 0,\n      high: 11,\n      displayValue: month + 1,\n      displayLow: 1,\n      displayHigh: 12\n    };\n    this._validateRange(range);\n    range = {\n      name: 'day',\n      value: day,\n      low: 1,\n      high: daysInMonth,\n      displayValue: day,\n      displayLow: 1,\n      displayHigh: daysInMonth\n    };\n    this._validateRange(range);\n    const start2DigitYear = options.twoDigitYearStart || 1950;\n    year = this._expandYear(start2DigitYear, year);\n    range = {\n      name: 'year',\n      value: year,\n      low: 0,\n      high: 9999,\n      displayValue: year,\n      displayLow: 0,\n      displayHigh: 9999\n    };\n    this._validateRange(range);\n    const parsedDate = new Date(year, month, day);\n    // need to setFullYear if _expandYear() returns < 100\n    if (year < 100) {\n      parsedDate.setFullYear(year);\n    }\n    // locate weekday\n    const dName = this._getWeekdayName(value, cal);\n    if (dName !== null) {\n      const weekDay = this._getDayIndex(cal, dName);\n      // day of week does not match date\n      if (parsedDate.getDay() !== weekDay) {\n        this._throwWeekdayMismatch(dName, parsedDate.getDate());\n      }\n    }\n    if (isDateTime) {\n      const timepart = value.substr(NativeDateTimeConstants._YMD_REGEXP.lastIndex);\n      if (timepart.length === 0) {\n        parsedDate.setHours(0, 0, 0, 0);\n      } else {\n        this._parseLenienthms(parsedDate, timepart, format, 2, cal);\n      }\n    }\n    const result: ParsedObjectType = {\n      value: LocalOraI18nUtils.dateToLocalIso(parsedDate),\n      warning: 'lenient parsing was used'\n    };\n    return result;\n  }\n\n  // lenient parse yMMMd and yMMMEd patterns. Must have year, date as numbers\n  // and month name.\n  // weekday is optional. If present it must match date.\n  // Ex:  Monday Nov, 11 2013\n  // weekday and month name can be anywhere in the string.\n  // if year > 2-digits it can be anywhere in the string.\n  // Otherwise assume its position based on pattern\n  // separators can be any non digit characters\n  private static _parseLenientyMMMEd(\n    value: string,\n    format: string,\n    options: NativeDateTimeResolvedOptions,\n    cal: any,\n    isDateTime: boolean\n  ): ParsedObjectType {\n    const origValue = value;\n\n    value = LocalOraI18nUtils.toUpper(value);\n    // locate month name\n    const calMonthsFmt = cal.months.format;\n    const calMonthsStandAlone = cal.months['stand-alone'];\n    const months = [\n      calMonthsFmt.wide,\n      calMonthsFmt.abbreviated,\n      calMonthsStandAlone.wide,\n      calMonthsStandAlone.abbreviated\n    ];\n    let foundMatch = false;\n    let reverseMonth = [];\n    let i = 0;\n    let mName = '';\n    for (i = 0; i < months.length; i++) {\n      reverseMonth = [];\n      const monthKeys = Object.keys(months[i]);\n      let j = 0;\n      for (j = 0; j < monthKeys.length; j++) {\n        mName = LocalOraI18nUtils.toUpper(months[i][monthKeys[j]]);\n        reverseMonth.unshift({\n          idx: j,\n          name: mName\n        });\n      }\n\n      reverseMonth.sort(function (a, b) {\n        return b.idx - a.idx;\n      });\n\n      for (j = 0; j < reverseMonth.length; j++) {\n        mName = reverseMonth[j].name;\n        // JET-65914. Do not match if month name is a number in locale data.\n        // Only match strings otherwise we match wrong field. for numeric\n        // month names _parseLenientyMEd will be invoked\n        if (value.indexOf(mName) !== -1 && isNaN(+mName)) {\n          foundMatch = true;\n\n          value = value.replace(mName, '');\n          break;\n        }\n      }\n      if (foundMatch) {\n        break;\n      }\n    }\n    // There is no month name. Try yMEd lenient parse.\n    if (!foundMatch) {\n      return this._parseLenientyMEd(origValue, format, options, cal, isDateTime);\n    }\n\n    const month = this._getMonthIndex(cal, mName);\n    let range: RangeType = {\n      name: 'month',\n      value: month,\n      low: 0,\n      high: 11,\n      displayValue: month,\n      displayLow: 1,\n      displayHigh: 12\n    };\n    this._validateRange(range);\n\n    // locate weekday\n    const dName = this._getWeekdayName(origValue, cal);\n    const dRegExp = new RegExp(dName + '\\\\W', 'i');\n    if (dName !== null) {\n      value = value.replace(dRegExp, '');\n    }\n    // find year and date\n    (NativeDateTimeConstants._YEAR_AND_DATE_REGEXP as any).lastIndex = 0;\n    const match: any = NativeDateTimeConstants._YEAR_AND_DATE_REGEXP.exec(value);\n    if (match === null) {\n      const dtype = isDateTime ? 2 : 0;\n      this._throwDateFormatMismatch(origValue, format, dtype);\n    }\n    const tokenIndexes = [\n      {\n        y: format.indexOf('y')\n      },\n      {\n        d: format.indexOf('d')\n      }\n    ];\n\n    tokenIndexes.sort(function (a, b) {\n      const n1 = Object.keys(a)[0];\n      const n2 = Object.keys(b)[0];\n      return (a as any)[n1] - (b as any)[n2];\n    });\n\n    let year = 0;\n    let day = 0;\n    let yearIndex = 0;\n    let foundYear = false;\n    for (i = 1; i <= 2; i++) {\n      const tokenMatch = match[i];\n      // find year if year is yyy|yyyy\n      const intToken = parseInt(tokenMatch);\n      if (tokenMatch.length > 2 || intToken > 31) {\n        year = intToken;\n        foundYear = true;\n        yearIndex = i - 1;\n      }\n    }\n    if (!foundYear) {\n      yearIndex = this._getTokenIndex(tokenIndexes, 'y');\n      year = parseInt(match[this._getTokenIndex(tokenIndexes, 'y') + 1], 10);\n    }\n    if (yearIndex === this._getTokenIndex(tokenIndexes, 'd')) {\n      day = parseInt(match[this._getTokenIndex(tokenIndexes, 'y') + 1], 10);\n    } else {\n      day = parseInt(match[this._getTokenIndex(tokenIndexes, 'd') + 1], 10);\n    }\n\n    const start2DigitYear = options.twoDigitYearStart || 1950;\n    year = this._expandYear(start2DigitYear, year);\n    range = {\n      name: 'year',\n      value: year,\n      low: 0,\n      high: 9999,\n      displayValue: year,\n      displayLow: 0,\n      displayHigh: 9999\n    };\n    this._validateRange(range);\n    const parsedDate = new Date(year, month, day);\n    // need to setFullYear if _expandYear() returns < 100\n    if (year < 100) {\n      parsedDate.setFullYear(year);\n    }\n    if (dName !== null) {\n      const weekDay = this._getDayIndex(cal, dName);\n      // day of week does not match date\n      if (parsedDate.getDay() !== weekDay) {\n        this._throwWeekdayMismatch(dName, parsedDate.getDate());\n      }\n    }\n    const daysInMonth = LocalOraI18nUtils.getDaysInMonth(year, month);\n    range = {\n      name: 'day',\n      value: day,\n      low: 1,\n      high: daysInMonth,\n      displayValue: day,\n      displayLow: 1,\n      displayHigh: daysInMonth\n    };\n    this._validateRange(range);\n\n    if (isDateTime) {\n      const timepart = value.substr(NativeDateTimeConstants._YEAR_AND_DATE_REGEXP.lastIndex);\n      if (timepart.length === 0) {\n        parsedDate.setHours(0, 0, 0, 0);\n      } else {\n        this._parseLenienthms(parsedDate, timepart, format, 2, cal);\n      }\n    }\n    const result: ParsedObjectType = {\n      value: LocalOraI18nUtils.dateToLocalIso(parsedDate),\n      warning: 'lenient parsing was used'\n    };\n    return result;\n  }\n\n  private static _parseLenient(\n    value: string,\n    format: string,\n    options: NativeDateTimeResolvedOptions,\n    cal: CalendarNodeType\n  ): ParsedObjectType {\n    const dtStyle = this._dateTimeStyle(options);\n    let result: ParsedObjectType;\n    switch (dtStyle) {\n      case 0:\n        // date style\n        result = this._parseLenientyMMMEd(value, format, options, cal, false);\n        break;\n      case 1:\n        // time style\n        const d = new Date();\n        this._parseLenienthms(d, value, format, 1, cal);\n        const isoStr = LocalOraI18nUtils.dateToLocalIso(d);\n        result = { value: isoStr, warning: 'lenient parsing was used' };\n        break;\n      case 2:\n        // date-time style\n        result = this._parseLenientyMMMEd(value, format, options, cal, true);\n        break;\n      default:\n        result = { value: '', warning: 'lenient parsing was used' };\n        break;\n    }\n    // convert result to gregorian\n    const parts = LocalOraI18nUtils.IsoStrParts(result.value);\n    const gregParts = [parts[0], parts[1], parts[2]];\n    const isoParts = result.value.split('T');\n    result.value =\n      LocalOraI18nUtils.padZeros(gregParts[0], 4) +\n      '-' +\n      LocalOraI18nUtils.padZeros(gregParts[1], 2) +\n      '-' +\n      LocalOraI18nUtils.padZeros(gregParts[2], 2) +\n      'T' +\n      isoParts[1];\n    return result;\n  }\n\n  private static _getNameIndex(\n    calNode: CalendarNodeType,\n    datePart: string,\n    matchGroup: string,\n    mLength: any,\n    style: any,\n    // @ts-ignore\n    matchIndex: number,\n    start1: number,\n    end1: number,\n    start2: string,\n    end2: string,\n    name: string\n  ): number {\n    let index = 0;\n    const monthsFormat = (calNode as any)[datePart][style];\n    if (datePart === 'months') {\n      index = this._getMonthIndex(calNode, matchGroup);\n    } else {\n      index = this._getDayIndex(calNode, matchGroup);\n    }\n    const startName = monthsFormat[mLength][start2];\n    const endName = monthsFormat[mLength][end2];\n    const range = {\n      name: name,\n      value: index,\n      low: start1,\n      high: end1,\n      displayValue: parseInt(matchGroup),\n      displayLow: startName,\n      displayHigh: endName\n    };\n    this._validateRange(range);\n    return index;\n  }\n\n  private static _validateTimePart(\n    matchInt: number,\n    _timeObj: any,\n    objMap: any,\n    timeToken: string\n  ) {\n    const timeObj = _timeObj;\n    timeObj[objMap.timePart] = matchInt;\n    if (timeToken === 'h' || timeToken === 'hh') {\n      if (matchInt === 12) {\n        timeObj[objMap.timePart] = 0;\n      }\n    } else if (timeToken === 'k' || timeToken === 'kk') {\n      timeObj.htoken = timeToken;\n      if (matchInt === 24) {\n        timeObj[objMap.timePart] = 0;\n      }\n    } else if (timeToken === 'K' || timeToken === 'KK') {\n      if (matchInt === 12) {\n        timeObj[objMap.timePart] = 0;\n      }\n    }\n    const range: RangeType = {\n      name: objMap.timePart,\n      value: timeObj[objMap.timePart],\n      low: objMap.start1,\n      high: objMap.end1,\n      displayValue: matchInt,\n      displayLow: objMap.start2,\n      displayHigh: objMap.end2\n    };\n    this._validateRange(range);\n  }\n\n  // test if the pattern/options is date, time or date-time\n  // 0: date, 1:time, 2:date-time\n  private static _dateTimeStyle(resOptions: NativeDateTimeResolvedOptions): number {\n    const isTime =\n      resOptions.hour !== undefined ||\n      resOptions.minute !== undefined ||\n      resOptions.second !== undefined ||\n      resOptions.fractionalSecondDigits !== undefined;\n    const isDate =\n      resOptions.year !== undefined ||\n      resOptions.month !== undefined ||\n      resOptions.day !== undefined ||\n      resOptions.weekday !== undefined;\n    if (isDate && isTime) {\n      return 2;\n    } else if (isTime) {\n      return 1;\n    } else if (isDate) {\n      return 0;\n    }\n    // try predefined style\n    if (resOptions.dateStyle !== undefined && resOptions.timeStyle !== undefined) {\n      return 2;\n    }\n    if (resOptions.timeStyle !== undefined) {\n      return 1;\n    }\n    return 0;\n  }\n\n  // for zh-TW locales the pm symbol can vary depending on the time. We need\n  // to iterate through the pm symbols in order to find a match.\n  // matchGroup is the input to parse, like '3pm' or '3 p. m.'\n  private static _matchPMSymbol(cal: CalendarNodeType, matchGroup: string) {\n    const loc = cal.locale;\n    let isPM = false;\n    let i = 0;\n    if (NativeDateTimeConstants._zh_tw_locales.includes(loc)) {\n      const pmSymbols = NativeDateTimeConstants._zh_tw_pm_symbols;\n      for (i = 0; i < pmSymbols.length; i++) {\n        const pmSymbol = pmSymbols[i];\n        if (matchGroup.indexOf(pmSymbol) !== -1) {\n          return true;\n        }\n      }\n    } else {\n      // See if what we get from Intl.DateTimeFormat for the dayPeriod for the locale\n      // is in the string we want to parse, e.g., the string user typed into the field.\n      // We ignore whitespace and case when we do the comparison.\n      // calPM is the string for the locale for pm. E.g., 'p.m.' for 'es-MX'. 'PM' for 'en-US'.\n      const calPM = cal.dayPeriods.format.wide.pm;\n      const upperMatchGroupNoSpace = LocalOraI18nUtils.toUpper(matchGroup).replace(/\\s/g, '');\n      const upperCalPMNoSpace = LocalOraI18nUtils.toUpper(calPM).replace(/\\s/g, '');\n      // We leniently match on the locale's 'pm' string, and if that doesn't match then English 'PM'.\n      // E.g., We also want 9PM to be parsed to 9 p.m. if the locale's pm is 'p.m.'\n      const exactMatchWithLocalePM = upperMatchGroupNoSpace.indexOf(upperCalPMNoSpace) !== -1;\n      const exactMatchWithEnglishPM = upperMatchGroupNoSpace.indexOf('PM') !== -1;\n      isPM = exactMatchWithLocalePM || exactMatchWithEnglishPM;\n    }\n    return isPM;\n  }\n\n  // exact match parsing for date-time. If it fails, try lenient parse.\n  private static _parseExact(\n    value: string,\n    format: string,\n    resOptions: NativeDateTimeResolvedOptions,\n    cal: CalendarNodeType\n  ): any {\n    // remove spaces from era.\n    const eraPart = cal.eras.eraAbbr['1'];\n    const trimEraPart = LocalOraI18nUtils.trimNumber(eraPart);\n\n    value = value.replace(eraPart, trimEraPart);\n    const getOption = LocalOraI18nUtils.getGetOption(resOptions, 'NativeDateTimeConverter.parse');\n    const lenientParse = getOption('lenientParse', 'string', ['none', 'full'], 'full');\n    const dtStyle = this._dateTimeStyle(resOptions);\n\n    // convert date formats into regular expressions with groupings.\n    // use the regexp to determine the input format and extract the date\n    //  fields.\n    const parseInfo = this._getParseRegExp(format, resOptions);\n    const match: any = new RegExp(parseInfo.regExp).exec(value);\n    if (match === null) {\n      if (lenientParse === 'full') {\n        return this._parseLenient(value, format, resOptions, cal);\n      }\n      this._throwDateFormatMismatch(value, format, dtStyle);\n    }\n    // found a date format that matches the input.\n    const groups = parseInfo.groups;\n    let year = null;\n    let month: any = null;\n    let date = null;\n    let weekDay = null;\n    let hourOffset = '';\n    let tzID = null;\n    let pmHour = undefined;\n    let weekDayName = '';\n    let range: RangeType;\n    const timeObj = {\n      hour: 0,\n      minute: 0,\n      second: 0,\n      millisec: 0,\n      htoken: ''\n    };\n    const start2DigitYear = resOptions.twoDigitYearStart || 1950;\n    // iterate the format groups to extract and set the date fields.\n    for (let j = 0, jl = groups.length; j < jl; j++) {\n      const matchGroup = match[j + 1];\n      if (matchGroup) {\n        const current = groups[j];\n        const matchInt = parseInt(matchGroup, 10);\n        const currentGroup = (NativeDateTimeConstants._PROPERTIES_MAP as any)[current];\n\n        switch (currentGroup.token) {\n          case 'months':\n            month = this._getNameIndex(\n              cal,\n              currentGroup.token,\n              matchGroup,\n              currentGroup.mLen,\n              currentGroup.style,\n              currentGroup.matchIndex,\n              0,\n              11,\n              '1',\n              '12',\n              'month name'\n            );\n            break;\n          case 'days':\n            weekDayName = matchGroup;\n            weekDay = this._getNameIndex(\n              cal,\n              currentGroup.token,\n              matchGroup,\n              currentGroup.dLen,\n              currentGroup.style,\n              currentGroup.matchIndex,\n              0,\n              6,\n              'sun',\n              'sat',\n              'weekday'\n            );\n            break;\n          case 'time':\n            this._validateTimePart(matchInt, timeObj, currentGroup, current);\n            break;\n          case 'dayOfMonth':\n            date = matchInt;\n            break;\n          case 'monthIndex':\n            // Month.\n            month = matchInt - 1;\n            // try lenient parse for date style only\n            if (month > 11 && lenientParse === 'full') {\n              try {\n                return this._parseLenient(value, format, resOptions, cal);\n              } catch (e) {\n                range = {\n                  name: 'month',\n                  value: month,\n                  low: 0,\n                  high: 11,\n                  displayValue: month + 1,\n                  displayLow: 1,\n                  displayHigh: 12\n                };\n                this._validateRange(range);\n              }\n            }\n            break;\n          case 'year':\n            year = this._expandYear(start2DigitYear, matchInt);\n            break;\n          case 'ampm':\n            pmHour = this._matchPMSymbol(cal, matchGroup);\n            break;\n          case 'tzhm':\n            // Time zone hours minutes: -0800\n            hourOffset = matchGroup.substr(-2);\n            hourOffset = matchGroup.substr(0, 3) + ':' + hourOffset;\n            break;\n          case 'tzhsepm':\n            // Time zone hours minutes: -08:00\n            hourOffset = matchGroup;\n            break;\n          case 'tzh':\n            // Time zone hours minutes: -08\n            hourOffset = matchGroup + ':00';\n            break;\n          case 'tzid':\n            // Time zone ID: America/Los_Angeles\n            tzID = matchGroup;\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    const parsedDate = new Date();\n    if (year === null) {\n      year = parsedDate.getFullYear();\n    }\n    // if day and month are unspecified,the defaults are current\n    // day and month.\n    if (month === null && date === null) {\n      month = parsedDate.getMonth();\n      date = parsedDate.getDate();\n    } else if (date === null) {\n      // if day is unspecified, default 1st day of month.\n      date = 1;\n    }\n    parsedDate.setFullYear(year, month, date);\n    // validate month days\n    const MonthDays = LocalOraI18nUtils.getDaysInMonth(year, month);\n    range = {\n      name: 'day',\n      value: date,\n      low: 1,\n      high: MonthDays,\n      displayValue: date,\n      displayLow: 1,\n      displayHigh: MonthDays\n    };\n    this._validateRange(range);\n    // if pm designator token was found make sure the hours fit the\n    // 24-hour clock.\n    if (pmHour == true && timeObj.hour < 12) {\n      timeObj.hour += 12;\n    }\n    // when hour is 12 AM and hour cycle is h24, set hour to 00\n    if (\n      pmHour == false &&\n      timeObj.hour == 12 &&\n      (timeObj.htoken == 'k' || timeObj.htoken == 'kk')\n    ) {\n      timeObj.hour = 0;\n    }\n    // use the Date object to set hours, minutes, ... so that it can\n    // adjust the hour correctly in case we are in missing hour during dst\n    // transition, like 2:30 AM\n    parsedDate.setHours(timeObj.hour, timeObj.minute, timeObj.second, timeObj.millisec);\n    const parts = [year, month + 1, date, 0, 0, 0, 0];\n    parts[3] = parsedDate.getHours();\n    parts[4] = parsedDate.getMinutes();\n    parts[5] = parsedDate.getSeconds();\n    parts[6] = parsedDate.getMilliseconds();\n\n    let isoParsedDate = LocalOraI18nUtils.partsToIsoString(parts);\n    if (tzID !== null) {\n      const zoneOffset = this._getTimeZoneOffset(parts, tzID);\n      hourOffset = LocalOraI18nUtils.getTimeStringFromOffset('', zoneOffset, false, true);\n    }\n    if (hourOffset !== '') {\n      isoParsedDate += hourOffset;\n    }\n    // validate year\n    range = {\n      name: 'year',\n      value: year,\n      low: 0,\n      high: 9999,\n      displayValue: year,\n      displayLow: 0,\n      displayHigh: 9999\n    };\n    this._validateRange(range);\n    // validate month\n    range = {\n      name: 'month',\n      value: month,\n      low: 0,\n      high: 11,\n      displayValue: month + 1,\n      displayLow: 1,\n      displayHigh: 12\n    };\n    this._validateRange(range);\n    // validate day range, depending on the month and year\n    const daysInMonth = LocalOraI18nUtils.getDaysInMonth(parts[0], parts[1] - 1);\n    range = {\n      name: 'day',\n      value: parts[2],\n      low: 1,\n      high: daysInMonth,\n      displayValue: parts[2],\n      displayLow: 1,\n      displayHigh: daysInMonth\n    };\n    this._validateRange(range);\n    // day of week does not match date\n    if (weekDay !== null) {\n      const validateDay = LocalOraI18nUtils.isoToLocalDate(isoParsedDate);\n      if (validateDay && validateDay.getDay() !== weekDay) {\n        this._throwWeekdayMismatch(weekDayName, validateDay.getDate());\n      }\n    }\n    const result = { value: isoParsedDate };\n    return result;\n  }\n\n  // test if the isoStr is date, time or date-time\n  // 0: date, 1:time, 2:date-time\n  private static _isoStrDateTimeStyle(isoStr: string): number {\n    const timeIndex = isoStr.indexOf('T');\n    if (timeIndex === -1) {\n      return 0;\n    }\n    if (timeIndex > 0) {\n      return 2;\n    }\n    return 1;\n  }\n\n  /*\n   * Returns the offset of a time zone at a given moment-in-time.\n   *\n   * @param {Object} localeElements - locale data bundle, it also contain the\n   * timezone data.\n   * @param {string} tzName - The IANA time zone name for which we want to get the\n   * offset. If it is the same as the local system's time zone, return the local\n   * system's time zone offset by using Date.getTimezoneOffset() instead of\n   * going through time zone data.\n   * @param {array} parts - An array conataining year, month, day, hour, minute,\n   * second that are used to create The Date object representing the moment-in-time.\n   */\n  private static _getTimeZoneOffset(parts: any, tzName: any) {\n    // if The timeZone in the options is the same as local system's\n    // timezone, use Date.getTimezoneOffset\n    const localTtimeZone = this.getLocalSystemTimeZone();\n    if (localTtimeZone === tzName) {\n      const d = new Date(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5]);\n      if (parts[0] < 100) {\n        d.setFullYear(parts[0]);\n      }\n      const localOffset = d.getTimezoneOffset();\n      return -localOffset;\n    }\n    const dateParts: DateDef = {\n      year: parts[0],\n      month: parts[1],\n      date: parts[2],\n      hours: parts[3],\n      minutes: parts[4]\n    };\n    const offset = getISODateOffset(dateParts, tzName);\n    return offset;\n  }\n\n  private static _getAdjustedOffset(timezone: any, isoStrInfo: any) {\n    const parts: Array<number> = isoStrInfo.isoStrParts;\n    return this._getTimeZoneOffset(parts, timezone);\n  }\n\n  private static _adjustHours(isoStrInfo: any, options: NativeDateTimeResolvedOptions) {\n    const value: Array<number> = isoStrInfo.isoStrParts;\n    const isoStrFormat = isoStrInfo.format;\n    let origOffset = 0;\n    switch (isoStrFormat) {\n      case NativeDateTimeConstants._OFFSET:\n        const tzParts = this._parseTimezoneOffset(isoStrInfo.timeZone);\n        const hoursOffset = tzParts[0];\n        const minOffset = tzParts[1];\n        origOffset = hoursOffset * 60 + (hoursOffset < 0 ? -minOffset : minOffset);\n        break;\n      case NativeDateTimeConstants._ZULU:\n        origOffset = 0;\n        break;\n      default:\n        break;\n    }\n    let newOffset = this._getAdjustedOffset(options.timeZone, isoStrInfo);\n    newOffset -= origOffset;\n    // target time zone might have switched to dst before orig timezone, or\n    // orig time zone might have switched to dst before target timezone.\n    // Need to get the correct offset at target time zone. This happens when\n    // we are very close to after target or orig time zones switched to dst.\n    const newDate = new Date(value[0], value[1] - 1, value[2], value[3], value[4], value[4]);\n    newDate.setHours(value[3] + ((newOffset / 60) << 0), newOffset % 60);\n    const newDateIso = LocalOraI18nUtils.dateToLocalIso(newDate);\n    const newDateIsoStrInfo = LocalOraI18nUtils.getISOStrFormatInfo(newDateIso);\n    newOffset = this._getAdjustedOffset(options.timeZone, newDateIsoStrInfo);\n    newOffset -= origOffset;\n    // Do the offset math through the Date object.\n    const adjustD = new Date(\n      Date.UTC(value[0], value[1] - 1, value[2], value[3], value[4], value[5])\n    );\n    const adjustedMin = adjustD.getUTCMinutes() + newOffset;\n\n    adjustD.setUTCHours(adjustD.getUTCHours() + ((adjustedMin / 60) << 0), adjustedMin % 60);\n    value[0] = adjustD.getUTCFullYear();\n    value[1] = adjustD.getUTCMonth() + 1;\n    value[2] = adjustD.getUTCDate();\n    value[3] = adjustD.getUTCHours();\n    value[4] = adjustD.getUTCMinutes();\n    value[5] = adjustD.getUTCSeconds();\n  }\n\n  // Returns a time-only, date-only or date-time ISO string based on dtStyle.\n  private static _createISOStrParts(dtStyle: number, d: Array<any>): string {\n    let ms: any = 0;\n    let val = '';\n    switch (dtStyle) {\n      // Date only\n      case 0:\n        val =\n          LocalOraI18nUtils.padZeros(d[0], 4) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[1], 2) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[2], 2);\n        break;\n      // Time only\n      case 1:\n        val =\n          'T' +\n          LocalOraI18nUtils.padZeros(d[3], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[4], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[5], 2);\n        ms = d[6];\n        if (ms > 0) {\n          val += '.' + LocalOraI18nUtils.trimRightZeros(ms);\n        }\n        break;\n      // Date-Time\n      default:\n        val =\n          LocalOraI18nUtils.padZeros(d[0], 4) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[1], 2) +\n          '-' +\n          LocalOraI18nUtils.padZeros(d[2], 2) +\n          'T' +\n          LocalOraI18nUtils.padZeros(d[3], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[4], 2) +\n          ':' +\n          LocalOraI18nUtils.padZeros(d[5], 2);\n        ms = d[6];\n        if (ms > 0) {\n          val += '.' + LocalOraI18nUtils.trimRightZeros(ms);\n        }\n        break;\n    }\n    return val;\n  }\n\n  private static _getParseISOStringOffset(tzName: string, parts: Array<number>): string {\n    const offset = this._getTimeZoneOffset(parts, tzName);\n    return LocalOraI18nUtils.getTimeStringFromOffset('', offset, false, true);\n  }\n\n  private static _createParseISOStringFromDate(\n    dtStyle: number,\n    isoStrInfo: any,\n    options: NativeDateTimeResolvedOptions\n  ): string {\n    const getOption = LocalOraI18nUtils.getGetOption(options, 'NativeDateTimeConverter.parse');\n    const isoFormat = getOption(\n      'isoStrFormat',\n      'string',\n      [\n        NativeDateTimeConstants._ZULU,\n        NativeDateTimeConstants._OFFSET,\n        NativeDateTimeConstants._INVARIANT,\n        NativeDateTimeConstants._LOCAL,\n        NativeDateTimeConstants._AUTO\n      ],\n      NativeDateTimeConstants._AUTO\n    );\n    const parts = isoStrInfo.isoStrParts;\n    const tzName = options.timeZone;\n    let val = this._createISOStrParts(dtStyle, parts);\n    // do not include timezone if date-only\n    if (dtStyle === 0) {\n      return val;\n    }\n    switch (isoFormat) {\n      case NativeDateTimeConstants._OFFSET:\n      case NativeDateTimeConstants._AUTO:\n        val += this._getParseISOStringOffset(tzName, parts);\n        break;\n      case NativeDateTimeConstants._LOCAL:\n        // if iso string is date-time, consider LOCAL as OFFSET\n        if (dtStyle === 2) {\n          val += this._getParseISOStringOffset(tzName, parts);\n        }\n        break;\n      case NativeDateTimeConstants._ZULU:\n        let adjustedMin = 0;\n        adjustedMin = -this._getTimeZoneOffset(parts, tzName);\n        if (adjustedMin !== 0) {\n          // Do the offset math through date object.\n          const adjustD = new Date(\n            Date.UTC(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5], parts[6])\n          );\n          adjustedMin = adjustD.getUTCMinutes() + adjustedMin;\n\n          adjustD.setUTCHours(adjustD.getUTCHours() + ((adjustedMin / 60) << 0), adjustedMin % 60);\n          parts[0] = adjustD.getUTCFullYear();\n          parts[1] = adjustD.getUTCMonth() + 1;\n          parts[2] = adjustD.getUTCDate();\n          parts[3] = adjustD.getUTCHours();\n          parts[4] = adjustD.getUTCMinutes();\n          parts[5] = adjustD.getUTCSeconds();\n          val = this._createISOStrParts(dtStyle, parts);\n        }\n        val += 'Z';\n        break;\n      default:\n        break;\n    }\n    return val;\n  }\n\n  /*\n   * Returns the current date at the specified timeZone. If timeZone is\n   * null, return current date of the local system.\n   */\n  public static getTimeZoneCurrentDate(tzName: string | null): string {\n    const options: Intl.DateTimeFormatOptions = {\n      year: 'numeric',\n      day: '2-digit',\n      month: '2-digit'\n    };\n    if (tzName) {\n      options.timeZone = tzName;\n    }\n    const cnv = Intl.DateTimeFormat('en-US', options);\n    const fmt = cnv.format(new Date()); // fmt looks something like 03/05/2020\n    const parts = fmt.split('/');\n    const result = parts[2] + '-' + parts[0] + '-' + parts[1];\n    return result;\n  }\n\n  /*\n   * Returns the current offset of the specified timeZone.\n   */\n  public static getTimeZoneCurrentOffset(timezone: string, timeOnlyIsoString?: string): number {\n    const d = new Date();\n    const localDateTimeIsoString = LocalOraI18nUtils.dateToLocalIso(d);\n    let dateTimeIso;\n    // Add the time to the date instead of using the current time.\n    if (timeOnlyIsoString && timeOnlyIsoString.startsWith('T')) {\n      const datePart = localDateTimeIsoString.split('T')[0];\n      dateTimeIso = datePart + timeOnlyIsoString;\n    }\n    const isoStrInfo: any = LocalOraI18nUtils.getISOStrFormatInfo(\n      dateTimeIso ?? localDateTimeIsoString\n    );\n    return this._getAdjustedOffset(timezone, isoStrInfo);\n  }\n\n  /*\n   * Returns the local system's time zone.\n   */\n  public static getLocalSystemTimeZone(): string {\n    if (!localSystemTimeZone) {\n      const intlCnv = new Intl.DateTimeFormat('en-US');\n      localSystemTimeZone = intlCnv.resolvedOptions().timeZone;\n    }\n    return localSystemTimeZone;\n  }\n}\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { CalendarUtils } from './CalendarUtils';\nimport { DateDef } from './ISODateTimezoneOffset';\nimport { FormatParseError } from '../UNSAFE_IntlFormatParse';\nimport { getISODateOffset } from './ISODateTimezoneOffset';\nimport { warn } from '../utils/UNSAFE_logger';\nimport { NativeDateTimeConstants } from './NativeDateTimeConstants';\nimport { NativeDateTimeOptions } from './NativeDateTimeOptions';\nimport { NativeParserImpl } from './NativeParserImpl';\nimport { NativeDateTimeResolvedOptions } from './NativeDateTimeOptions';\nimport * as LocalOraI18nUtils from './dateTimeUtils';\n\n/**\n * Create an Intl.DateTimeFormat from the options.\n */\nexport const getFormatter = (options: NativeDateTimeOptions) => {\n  return new Intl.DateTimeFormat(options.locale, options);\n};\n\n/**\n * Get the resolved options from the Intl.DateTimeFormat instance, plus any custom options used by our implementation.\n */\nexport const getResolvedOptions = (\n  formatter: Intl.DateTimeFormat,\n  options: NativeDateTimeOptions\n): NativeDateTimeResolvedOptions => {\n  const resOptions = formatter.resolvedOptions();\n  const isoStrFormat = options.isoStrFormat ?? 'auto';\n  const twoDigitYearStart = options.twoDigitYearStart ?? 1950;\n  const lenientParse = options.lenientParse ?? 'full';\n  const patternFromOptions = getPatternFromOptions(formatter, resOptions);\n  return { ...resOptions, isoStrFormat, twoDigitYearStart, lenientParse, patternFromOptions };\n};\n\n/**\n * Create an Intl.DateTimeFormat that can merge in the year in the desired format during the call to 'format'.\n * This is useful if you always want year: 'numeric' for dateStyle: 'short' even if\n * in some locales dateStyle: 'short' yields a 2-digit year. 2-digit years are ambiguous.\n */\nexport const getYearFormatter = (\n  options: NativeDateTimeOptions,\n  resOptions: NativeDateTimeResolvedOptions\n) => {\n  let formatter: Intl.DateTimeFormat | null = null;\n  // Set up the yearFormatter if dateStyle is short and the dateStyleShortYear option is defined.\n  // If we do not add numberingSystem/calendar, then Intl.DateTimeFormat defaults to the locale's\n  // numberingSystem, and that is not what JET uses.\n  if (options.dateStyle === 'short' && options.dateStyleShortYear) {\n    formatter = new Intl.DateTimeFormat(options.locale, {\n      year: options.dateStyleShortYear,\n      numberingSystem: resOptions.numberingSystem,\n      calendar: resOptions.calendar,\n      timeZone: resOptions.timeZone\n    });\n  }\n  return formatter;\n};\n\n/**\n * Merge in the year in the desired format rather than whatever the locale default is for dateStyle: 'short'.\n */\nexport const formatWithYearFormat = (\n  formatInstance: Intl.DateTimeFormat,\n  yearInstance: Intl.DateTimeFormat,\n  value: Date\n) => {\n  // first get the formatted numeric year\n  const yearParts = yearInstance.formatToParts(value);\n  const formattedYear = yearParts.find((part) => part.type === 'year')?.value;\n  // next get the formatToParts of the formatInstance and substitute in formattedYear.\n  const parts = formatInstance.formatToParts(value);\n  return parts.reduce((acc, part) => {\n    if (part.type === 'year') {\n      return acc + (formattedYear ?? part.value);\n    }\n    return acc + part.value;\n  }, '');\n};\n\n/**\n * Formats a date time string based on the given options.\n */\nexport const formatDateTimeWithOptions = (options: NativeDateTimeOptions, value: string) => {\n  const intlFormatter = getFormatter(options);\n  const resOptions = getResolvedOptions(intlFormatter, options);\n  const yearFormatter = getYearFormatter(options, resOptions);\n  return formatDateTime(intlFormatter, yearFormatter, resOptions.timeZone, value);\n};\n\n/**\n * Formats a date time string using Intl.DateTimeFormat.\n */\nexport const formatDateTime = (\n  intlFormatter: Intl.DateTimeFormat,\n  yearFormatter: Intl.DateTimeFormat | null,\n  timeZone: string,\n  value: string\n) => {\n  // if (timeZone && value legal iso string and Z or offset), then you adjust it.\n  const isoStr = normalizeIsoString(timeZone, value);\n  const isoStrDate = new Date(isoStr);\n  return yearFormatter\n    ? formatWithYearFormat(intlFormatter, yearFormatter, isoStrDate)\n    : intlFormatter.format(isoStrDate);\n};\n\n/**\n * Parses a string into an iso string based on the given options.\n */\nexport const parseDateTimeWithOptions = (options: NativeDateTimeOptions, str: string) => {\n  const intlFormatter = getFormatter(options);\n  const resOptions = getResolvedOptions(intlFormatter, options);\n  return parseDateTime(options.locale, intlFormatter, resOptions, str);\n};\n\n/**\n * Parses the formatted string, and returns an iso string.\n * @returns an iso string\n * @throws Error if undefined, null, or '' or not an iso string, or if something went wrong in the call to parse.\n */\nexport const parseDateTime = (\n  locale: string,\n  formatter: Intl.DateTimeFormat,\n  resOptions: NativeDateTimeResolvedOptions,\n  str: string\n) => {\n  if (str === undefined || str === null || str === '') {\n    throw new FormatParseError('The parse value cannot be empty.', {\n      cause: { code: 'emptyParseValue' }\n    });\n  }\n  const cal = CalendarUtils.getCalendar(locale, resOptions.calendar);\n  const pattern = getPatternFromOptions(formatter, resOptions);\n  const result = NativeParserImpl.parseImpl(str, pattern, resOptions, cal);\n  const parsed = result.value;\n  if (parsed) {\n    if (result.warning) {\n      warn('The value ' + str + ' was leniently parsed to represent a date ' + parsed);\n    }\n  }\n  return parsed;\n};\n\n/**\n * Checks if it is a valid iso string.\n * Also fixes up the iso string if needed, i.e. if local and timezone are specified in the options.\n * @param timeZone\n * @param value\n * @returns\n * @throws Error if undefined, null, or '' or if it is an invalid iso string.\n */\nexport const normalizeIsoString = (timeZone: string, value: string) => {\n  if (value === undefined || value === null || value === '') {\n    throw new FormatParseError('The format value cannot be empty.', {\n      cause: { code: 'emptyFormatValue' }\n    });\n  }\n\n  // Check if year < 100.\n  // const valueParts = LocalOraI18nUtils.IsoStrParts(value);\n  // const isYearBelow100 = valueParts[0] < 100;\n\n  if (value.startsWith('T')) {\n    // Intl Object takes Date object as parameter. new Date() throws an\n    // exception with time only ISO string. Prepend current date to time\n    // only iso string.\n    let curDate = '';\n    if (timeZone) {\n      // if options contain a timeZone, get the current date at this time zone\n      curDate = NativeParserImpl.getTimeZoneCurrentDate(timeZone);\n    } else {\n      // get the current date of the local system\n      curDate = LocalOraI18nUtils.dateToLocalIso(new Date()).split('T')[0];\n    }\n    value = curDate + value;\n  } else if (value.indexOf('T') === -1) {\n    value = value + 'T00:00:00';\n  }\n\n  // test if value is a valid ISO string\n  const exe = LocalOraI18nUtils._ISO_DATE_REGEXP.exec(value);\n  if (!exe) {\n    const e = new FormatParseError('The format value must be a valid iso string.', {\n      cause: { code: 'invalidISOString', parameterMap: { isoStr: value } }\n    });\n    throw e;\n  }\n  // If value is local ISO string and timeZone is specified in options, adjust\n  // offset to avoid time zone conversion from local system's timezone to target timezone\n  if (timeZone) {\n    // Also test if timeZone in the options is the same as local system time zone\n    let islocalTimeZone = false;\n    const localTimeZone = NativeParserImpl.getLocalSystemTimeZone();\n    if (localTimeZone === timeZone) {\n      islocalTimeZone = true;\n    }\n    const timePart = value.substring(value.indexOf('T'));\n    const isLocalValue =\n      timePart.indexOf('Z') === -1 && timePart.indexOf('+') === -1 && timePart.indexOf('-') === -1;\n    if (isLocalValue && !islocalTimeZone) {\n      const parts = LocalOraI18nUtils.IsoStrParts(value);\n      const dateParts: DateDef = {\n        year: parts[0],\n        month: parts[1],\n        date: parts[2],\n        hours: parts[3],\n        minutes: parts[4]\n      };\n      const offset = getISODateOffset(dateParts, timeZone);\n      value = value + LocalOraI18nUtils.getTimeStringFromOffset('', offset, false, true);\n    }\n  }\n  //if ISO string time zone offset is hh, replace it with hh:00 so that new Date() does not fail\n  value = value.replace(/(T.*?[+-]..$)/, '$1:00');\n  return value;\n};\n\nconst getPatternFromOptions = (\n  formatter: Intl.DateTimeFormat,\n  options: NativeDateTimeResolvedOptions\n) => {\n  const isoSTr = '2000-01-02T00:00:00';\n  const date = new Date(isoSTr);\n  let pattern = '';\n  let optVal = '';\n  let token: any = null;\n  let dtokenMap: any = null;\n  let ttokenMap: any = null;\n  let dateStyle = false;\n  let timeStyle = false;\n  if (options.dateStyle !== undefined) {\n    dtokenMap = NativeDateTimeConstants._dateTimeFormats.dateStyle;\n    dtokenMap = dtokenMap[options.dateStyle];\n    dateStyle = true;\n  }\n  if (options.timeStyle !== undefined) {\n    ttokenMap = NativeDateTimeConstants._dateTimeFormats.timeStyle;\n    ttokenMap = ttokenMap[options.timeStyle];\n    timeStyle = true;\n  }\n  const tokenMap = NativeDateTimeConstants._tokenMap;\n\n  formatter.formatToParts(date).map(({ type, value }) => {\n    // TODO: Intl.DateTimeFormatPartType type does not have 'fractionalSecond' even though it is in the api.\n    // so to workaround getting a typescript error, I'm setting as string here.\n    // Fix when the typescript for Intl.DateTimeFormat gets fixed.\n    switch (type as string) {\n      case 'literal':\n        token = value.replace(NativeDateTimeConstants._ALPHA_REGEXP, \"'$1'\");\n        break;\n      case 'dayPeriod':\n        token = 'a';\n        break;\n      case 'hour':\n        if (timeStyle) {\n          token = ttokenMap[type];\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        let ish12 = options.hour12;\n        if (ish12 === undefined) {\n          ish12 = false;\n        }\n        // take hourCycle into consideration\n        if (options.hourCycle) {\n          token = token.replace(\n            NativeDateTimeConstants._HOUR12_REGEXP,\n            NativeDateTimeConstants._hourCycleMap[options.hourCycle]\n          );\n        }\n        // h12 takes precedence over hourCycle\n        if (ish12 === true) {\n          token = token.replace(NativeDateTimeConstants._HOUR12_REGEXP, 'h');\n        }\n        break;\n      case 'month':\n        // some locales have month as numeric for medium style and some have month\n        // as medium style check the value to get accurate pattern\n        if (dateStyle) {\n          if (isNaN(+value)) {\n            token = dtokenMap.month_m;\n          } else {\n            token = dtokenMap.month_s;\n          }\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        break;\n      case 'year':\n      case 'day':\n      case 'weekday':\n        if (dateStyle) {\n          token = dtokenMap[type];\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        break;\n      case 'minute':\n      case 'second':\n      case 'timeZoneName':\n        if (timeStyle) {\n          token = ttokenMap[type];\n        } else {\n          optVal = (options as any)[type];\n          token = (tokenMap as any)[type][optVal];\n        }\n        break;\n      case 'era':\n        optVal = (options as any)[type] || 'short';\n        token = (tokenMap as any)[type][optVal];\n        break;\n      case 'fractionalSecond':\n        token = options.fractionalSecondDigits;\n        token = (tokenMap as any)[type][token];\n        break;\n      default:\n        break;\n    }\n    pattern += token;\n  });\n  return pattern;\n};\n","/**\n * @license\n * Copyright (c) 2004 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  formatDateTime,\n  getFormatter,\n  getResolvedOptions,\n  getYearFormatter,\n  parseDateTime\n} from './formatParse';\nimport { NativeDateTimeOptions } from './NativeDateTimeOptions';\n\n/**\n * This function is used to retrieve 'format'and 'parse' methods for formatting or parsing date,\n * time, or datetime values according to the provided options. The options may include:\n *\n * Using the standard date, datetime and time format lengths defined by Unicode CLDR; these\n * include the dateStyle and timeStyle properties (full | long | medium | short).\n *\n * Using options defined by the ECMA 402 Specification, including the properties year,\n * month, day, hour, minute, second, weekday, era, timeZoneName, hour12, timeZone.\n *\n * Passing the BCP47Locale is the only required option. If no other options are specified,\n * the default is to use the 'short' format length for the provided locale.\n *\n * Once the function has been called with a set of options, there is no need to call it again unless\n * you want to change the options being used to format and parse, or the locale.\n */\nexport function getFormatParse(options: NativeDateTimeOptions) {\n  const intlFormatter = getFormatter(options);\n  const resolvedOptions = getResolvedOptions(intlFormatter, options);\n  const yearFormatter = getYearFormatter(options, resolvedOptions);\n\n  const format = (value: Parameters<typeof formatDateTime>[3]) =>\n    formatDateTime(intlFormatter, yearFormatter, resolvedOptions.timeZone, value);\n  const parse = (str: Parameters<typeof parseDateTime>[3]) =>\n    parseDateTime(options.locale, intlFormatter, resolvedOptions, str);\n\n  return { format, parse, resolvedOptions, formatter: intlFormatter };\n}\n"],"names":["CalendarUtils","_getDayPeriods","locale","calendar","date","Date","getDayPeriodsFromFormatToParts","formatter","eraPart","formatToParts","find","value","type","formatterLocale","getFormatterLocale","Intl","DateTimeFormat","hour","hour12","amValue","setHours","format","wide","am","pm","_getEras","eras","era","start","cal","eraNarrow","eraAbbr","eraName","getEraFromFormatToParts","eraLenArray","eraMap","narrow","short","long","i","length","j","eraLenName","options","year","month","day","eraForLength","eraObj","_fillMonthAndDays","widthVal","isStandAlone","dates","getMonthFromFormatToParts","formatParts","monthPart","getWeekdayFromFormatToParts","weekdayPart","calMonthFormat","calDayFormat","index","dayIndexVal","_weekdaysFormatMap","weekday","undefined","monthFormat","dayFormat","_getFormatMonthAndDays","calMonths","calDays","types","_monthNamesFormatMap","monthDayObjForWidth","myMonthObj","Object","assign","myDayObj","myMonthFormatObj","myDayFormatObj","monthsNode","daysNode","_getStandAloneDays","dayObjForWidth","myDayStandAloneObj","_getStandAloneMonths","monthObjForWidth","myMonthStandAloneObj","getCalendar","calendars","dayPeriodsObj","erasObj","standAloneMonths","standAloneDays","exceptionLocales","includes","monthsDaysNodeObj","monthsNodes","daysNodes","dayPeriods","months","days","formatterCache","Map","getISODateOffset","timeZone","hours","minutes","d","UTC","setFullYear","offset","original","asUTC","originalMins","utcMinutes","delta","_getOffset","_applyTimezoneToDate","adjustment","setTime","getTime","_compareDates","formattedUTC","timezone","get","minute","second","hourCycle","set","_getConverter","localDate","localTime","split","trim","parseInt","date1","date2","NativeDateTimeConstants","_YEAR_AND_DATE_REGEXP","_YMD_REGEXP","_TIME_REGEXP","_TIME_FORMAT_REGEXP","_YEAR_REGEXP","_MONTH_REGEXP","_DAY_REGEXP","_WEEK_DAY_REGEXP","_HOUR_REGEXP","_MINUTE_REGEXP","_SECOND_REGEXP","_FRACTIONAL_SECOND_REGEXP","_AMPM_REGEXP","_WORD_REGEXP","_ESCAPE_REGEXP","_TOKEN_REGEXP","_ZULU","_LOCAL","_AUTO","_INVARIANT","_OFFSET","_ALNUM_REGEXP","_NON_DIGIT_REGEXP","_NON_DIGIT_OPT_REGEXP","_STR_REGEXP","_TWO_DIGITS_REGEXP","_THREE_DIGITS_REGEXP","_FOUR_DIGITS_REGEXP","_SLASH_REGEXP","_PROPERTIES_MAP","MMM","token","style","mLen","matchIndex","key","regExp","MMMM","MMMMM","LLL","LLLL","LLLLL","E","dLen","EE","EEE","EEEE","EEEEE","c","cc","ccc","cccc","ccccc","h","timePart","start1","end1","start2","end2","hh","K","KK","H","HH","k","kk","m","mm","s","ss","S","SS","SSS","getPartIdx","dd","M","MM","L","LL","y","yy","yyyy","a","z","v","zz","zzz","zzzz","Z","ZZ","ZZZ","X","XX","XXX","VV","G","GG","GGG","GGGG","GGGGG","FRACTIONAL_SECOND_MAP","_tokenMap","numeric","fractionalSecond","timeZoneName","_dateTimeFormats","dateStyle","full","month_s","month_m","medium","timeStyle","_ALPHA_REGEXP","_HOUR12_REGEXP","_hourCycleMap","h12","h23","h11","h24","_zh_tw_locales","_zh_tw_pm_symbols","regexTrim","regexTrimNumber","regexTrimRightZeros","zeros","_ISO_DATE_REGEXP","_ISO_DATE_ONLY_REGEXP","_ISO_TIME_ONLY_REGEXP","isDateOnlyIsoString","test","isTimeOnlyIsoString","IsoStrParts","_","startsWith","pattern","indexOf","replace","trimRightZeros","trimNumber","toUpper","join","toUpperCase","padZeros","num","isNegative","substr","zeroPad","str","count","left","result","l","_throwInvalidISOStringRange","isoStr","name","displayValue","displayLow","displayHigh","RangeError","cause","code","parameterMap","minValue","maxValue","propertyName","_throwInvalidISOStringSyntax","Error","dateToLocalIso","_date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","isLeapYear","getDaysInMonth","isoString","splitted","tIndex","today","isBC","datetime","slice","dateSplitted","val","nbDays","milliSecSplitted","timeSplitted","tVal","getGetOption","getOptionCaller","property","values","defaultValue","toLowerCase","_toBoolean","String","Number","expectedValues","push","msg","rangeError","errorInfo","errorCode","propertyValue","propertyValueValid","caller","partsToIsoString","parts","isoToLocalDate","_isoToLocalDateIgnoreTimezone","getISOStrFormatInfo","res","dateTime","isoStrParts","exe","exec","isoStrLen","timeZoneLen","substring","getTimeStringFromOffset","prefix","reverseSign","alwaysMinutes","absOffset","Math","abs","floor","sign","localSystemTimeZone","NativeParserImpl","parseImpl","resOptions","dtStyle","parsedIsoStr","isoStrInfo","LocalOraI18nUtils._ISO_DATE_REGEXP","this","_isoStrDateTimeStyle","_dateTimeStyle","_parseExact","LocalOraI18nUtils.getISOStrFormatInfo","_adjustHours","_createParseISOStringFromDate","warning","isoStrFormat","_appendPreOrPostMatch","preMatch","strings","quoteCount","escaped","il","charAt","_validateRange","range","low","high","_throwInvalidDateFormat","isDate","isTime","samplePattern","SyntaxError","_throwWeekdayMismatch","FormatParseError","_throwDateFormatMismatch","errorCodeType","_parseTimezoneOffset","_offset","offsetParts","Array","_expandYear","start2DigitYear","ambiguousTwoDigitYear","_arrayIndexOfMonthOrDay","monthsDaysData","userInput","trimUserInput","toUpperTrimmedNoPeriod","keys","valueFromData","trimValueFromData","trimUserInputNumber","numberPartFromData","isInteger","trimItem","LocalOraI18nUtils.toUpper","LocalOraI18nUtils.trim","_getDayIndex","calNode","ret","calDaysFmt","calDaysStdAlone","abbreviated","_getMonthIndex","calMonthsFmt","calMonthsStdAlone","_getParseRegExp","expFormat","regexp","groups","match","lastIndex","add","_getTokenIndex","arr","_parseLenienthms","timepart","dtype","idx","msec","_matchPMSymbol","_getWeekdayName","calDaysStandAlone","dayKeys","dName","RegExp","_parseLenientyMEd","isDateTime","tokenIndexes","sort","b","n1","n2","yearIndex","foundDayIndex","dayIndex","foundYear","foundDay","tokenMatch","intToken","daysInMonth","LocalOraI18nUtils.getDaysInMonth","twoDigitYearStart","parsedDate","weekDay","getDay","LocalOraI18nUtils.dateToLocalIso","_parseLenientyMMMEd","origValue","calMonthsStandAlone","foundMatch","reverseMonth","mName","monthKeys","unshift","isNaN","dRegExp","_parseLenient","LocalOraI18nUtils.IsoStrParts","gregParts","isoParts","LocalOraI18nUtils.padZeros","_getNameIndex","datePart","matchGroup","mLength","monthsFormat","startName","endName","_validateTimePart","matchInt","_timeObj","objMap","timeToken","timeObj","htoken","fractionalSecondDigits","loc","isPM","pmSymbols","pmSymbol","calPM","upperMatchGroupNoSpace","upperCalPMNoSpace","exactMatchWithLocalePM","exactMatchWithEnglishPM","trimEraPart","LocalOraI18nUtils.trimNumber","lenientParse","LocalOraI18nUtils.getGetOption","getOption","parseInfo","pmHour","hourOffset","tzID","weekDayName","millisec","jl","current","currentGroup","e","MonthDays","isoParsedDate","LocalOraI18nUtils.partsToIsoString","LocalOraI18nUtils.getTimeStringFromOffset","_getTimeZoneOffset","validateDay","LocalOraI18nUtils.isoToLocalDate","timeIndex","tzName","getLocalSystemTimeZone","getTimezoneOffset","_getAdjustedOffset","origOffset","tzParts","hoursOffset","minOffset","newOffset","newDate","newDateIsoStrInfo","adjustD","adjustedMin","getUTCMinutes","setUTCHours","getUTCHours","getUTCFullYear","getUTCMonth","getUTCDate","getUTCSeconds","_createISOStrParts","ms","LocalOraI18nUtils.trimRightZeros","_getParseISOStringOffset","isoFormat","getTimeZoneCurrentDate","getTimeZoneCurrentOffset","timeOnlyIsoString","localDateTimeIsoString","dateTimeIso","intlCnv","resolvedOptions","formatWithYearFormat","formatInstance","yearInstance","yearParts","formattedYear","part","reduce","acc","normalizeIsoString","curDate","islocalTimeZone","getPatternFromOptions","optVal","dtokenMap","ttokenMap","tokenMap","map","ish12","intlFormatter","getFormatter","patternFromOptions","getResolvedOptions","yearFormatter","dateStyleShortYear","numberingSystem","getYearFormatter","isoStrDate","formatDateTime","parse","parsed","warn","parseDateTime"],"mappings":"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"}