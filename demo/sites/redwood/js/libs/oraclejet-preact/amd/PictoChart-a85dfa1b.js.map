{"version":3,"file":"PictoChart-a85dfa1b.js","sources":["../../src/UNSAFE_PictoChart/PictoChartContext.tsx","../../src/UNSAFE_PictoChart/pictoChartLayoutUtils.ts","../../src/UNSAFE_PictoChart/pictoChartUtils.tsx","../../src/UNSAFE_PictoChart/pictoChartNavUtils.ts","../../src/UNSAFE_PictoChart/usePictoChartDatatip.ts","../../src/UNSAFE_PictoChart/PictoChartElement.tsx","../../src/UNSAFE_PictoChart/PictoChartWithDimensions.tsx","../../src/UNSAFE_PictoChart/useEvents.ts","../../src/UNSAFE_PictoChart/usePictoChartContextMenu.ts","../../src/UNSAFE_PictoChart/PictoChart.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { createContext } from 'preact';\nimport { useContext } from 'preact/hooks';\n\ntype PictoChartContextValue = {\n  supportsSelection?: boolean;\n};\n\nconst PictoChartContext = createContext<PictoChartContextValue>({} as PictoChartContextValue);\nconst usePictoChartContext = () => useContext(PictoChartContext);\n\nexport { PictoChartContext, usePictoChartContext };\n","import type { PictoChartItemData } from './pictoChart.type';\nimport { DEFAULT_SIZE } from './themes/PictoChartStyles.css';\n\nconst GAP_RATIO = 0.25;\n\nfunction _ceil(a: number, b: number) {\n  return Math.ceil(a / b) * b;\n}\n\nexport function getFlowingInfo<K, D extends PictoChartItemData<K>>(\n  items: D[],\n  isVert: boolean,\n  width: number,\n  height: number,\n  isFlowingWidth: boolean,\n  isFlowingHeight: boolean,\n  colCount?: number,\n  rowCount?: number,\n  colWidth?: number,\n  rowHeight?: number\n) {\n  let numCells = 0;\n  let maxColSpan = 1;\n  let maxRowSpan = 1;\n  let minSpan = Infinity;\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const columnSpan = item.columnSpan || 1;\n    const rowSpan = item.rowSpan || 1;\n    if (columnSpan <= 0 || rowSpan <= 0) continue;\n\n    // Compute the maximum columnSpan and rowSpan\n    if (columnSpan > maxColSpan) maxColSpan = columnSpan;\n    if (rowSpan > maxRowSpan) maxRowSpan = rowSpan;\n\n    // Compute minimum span for gap computation\n    if (columnSpan < minSpan) minSpan = columnSpan;\n    if (rowSpan < minSpan) minSpan = rowSpan;\n\n    numCells += columnSpan * rowSpan * (item.count || 1);\n  }\n\n  if (numCells === 0) return {};\n\n  // Default colWidth and rowHeight for flowing layout\n  if (isFlowingWidth || isFlowingHeight) {\n    if (!colWidth) colWidth = rowHeight ? rowHeight : DEFAULT_SIZE;\n    if (!rowHeight) rowHeight = colWidth;\n  }\n\n  // Default colCount and rowCount for both layouts\n  // We set the default colCount (or rowCount) to be an integer multiple of the maxColSpan (or maxRowSpan) to\n  // ensure that all the items can find a spot to occupy in the mixed sizes case.\n\n  if (!colCount && !rowCount) {\n    // Try to achieve square cells, (width / colCount) = (height / rowCount)\n    if (!isFlowingWidth && !isFlowingHeight) {\n      if (isVert) rowCount = _ceil(Math.sqrt((numCells * height) / width), maxRowSpan);\n      else colCount = _ceil(Math.sqrt((numCells * width) / height), maxColSpan);\n    } else if (!isFlowingWidth) colCount = Math.max(Math.floor(width / (colWidth || 1)), 1);\n    else if (!isFlowingHeight) rowCount = Math.max(Math.floor(height / (rowHeight || 1)), 1);\n    else {\n      if (isVert) rowCount = _ceil(Math.sqrt(numCells), maxRowSpan);\n      else colCount = _ceil(Math.sqrt(numCells), maxColSpan);\n    }\n  }\n\n  // Now only either colCount or rowCount is undefined\n  if (!colCount) colCount = _ceil(numCells / (rowCount || 1), maxColSpan);\n  else if (!rowCount) rowCount = _ceil(numCells / colCount, maxRowSpan);\n\n  const gridGap = GAP_RATIO * minSpan;\n  // Default colWidth and rowHeight for fixed layout\n  if (!isFlowingWidth && !isFlowingHeight) {\n    if (!colWidth)\n      colWidth = rowHeight ? rowHeight : Math.min(width / colCount, height / (rowCount || 1));\n    if (!rowHeight) rowHeight = colWidth;\n  }\n\n  if (\n    colCount <= 0 ||\n    !rowCount ||\n    rowCount <= 0 ||\n    !colWidth ||\n    colWidth <= 0 ||\n    !rowHeight ||\n    rowHeight <= 0\n  )\n    return {};\n\n  return {\n    calcColCount: colCount,\n    calcRowCount: rowCount,\n    calcColWidth: colWidth ? colWidth - gridGap : colWidth,\n    calcRowHeight: rowHeight ? rowHeight - gridGap : rowHeight,\n    gridGap: gridGap\n  };\n}\n\n/**\n * Returns whether the pictoChart is layout from bottom to top.\n */\nconst isOriginBottom = (origin: string) => {\n  return origin === 'bottomStart' || origin === 'bottomEnd';\n};\n\n/**\n * Returns whether the pictoChart is layout from right to left.\n */\nconst isOriginRight = (origin: string) => {\n  const isEnd = origin === 'topEnd' || origin === 'bottomEnd';\n  return isEnd;\n};\n\n/**\n * Returns whether the cells are available given col, row and columnSpan, rowSpan needed.\n */\nconst areCellsAvailable = (\n  map: boolean[][],\n  col: number,\n  row: number,\n  columnSpan: number,\n  rowSpan: number\n) => {\n  for (let r = 0; r < rowSpan; r++) {\n    for (let c = 0; c < columnSpan; c++) {\n      if (map[row + r][col + c]) return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Occupies the cell in the map given col, row and columnSpan, rowSpan.\n */\nconst occupyCells = (\n  map: boolean[][],\n  col: number,\n  row: number,\n  columnSpan: number,\n  rowSpan: number\n) => {\n  for (let r = 0; r < rowSpan; r++) {\n    for (let c = 0; c < columnSpan; c++) {\n      map[row + r][col + c] = true;\n    }\n  }\n};\n\n/**\n * Returns whether the cells are available given col, row and the colCount and rowCount of the pictochart.\n */\nconst findNextAvailableCell = (\n  map: boolean[][],\n  columnSpan: number,\n  rowSpan: number,\n  colCount: number,\n  rowCount: number,\n  isVert: boolean\n): { row: number; col: number } | undefined => {\n  if (isVert) {\n    for (let c = 0; c <= colCount - columnSpan; c++) {\n      for (let r = 0; r <= rowCount - rowSpan; r++) {\n        if (areCellsAvailable(map, c, r, columnSpan, rowSpan)) {\n          occupyCells(map, c, r, columnSpan, rowSpan);\n          return { col: c, row: r };\n        }\n      }\n    }\n    return;\n  }\n  \n  for (let r = 0; r < rowCount - rowSpan + 1; r++) {\n    for (let c = 0; c < colCount - columnSpan + 1; c++) {\n      if (areCellsAvailable(map, c, r, columnSpan, rowSpan)) {\n        occupyCells(map, c, r, columnSpan, rowSpan);\n        return { col: c, row: r };\n      }\n    }\n  }\n\n  return;\n};\n\n/**\n * Returns the picto items with row and col of the pictochart.\n */\nexport function generateElementCoords<K, D extends PictoChartItemData<K>>(\n  items: D[],\n  row: number,\n  column: number,\n  layoutOrigin: 'topStart' | 'topEnd' | 'bottomStart' | 'bottomEnd',\n  isVert: boolean) {\n  const rowCount = row;\n  const colCount = column;\n  const isLayoutBottom = isOriginBottom(layoutOrigin);\n  const isLayoutRight = isOriginRight(layoutOrigin);\n  const pictoItems = [];\n\n  const map: boolean[][] = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    map[i] = new Array(colCount).fill(false);\n  }\n\n  const isFractionalLeft = true;\n  let lastFractionalCell = {\n    row: -1, \n    col: -1, \n    count: 0, \n    direction: isFractionalLeft,\n    rowSpan: 1,\n    columnSpan: 1\n   };\n\n  for (let i = 0; i < items.length; i++) {\n    const currItem = items[i];\n    const rowSpan = currItem.rowSpan ?? 1;\n    const columnSpan = currItem.columnSpan ?? 1;\n    let totalCount = currItem.count ?? 1;\n\n    // fill previous fractional cell if needed\n    if (lastFractionalCell.count > 0 && lastFractionalCell.count < 1\n      && lastFractionalCell.rowSpan === rowSpan &&\n      lastFractionalCell.columnSpan === columnSpan) {\n      const amountToFill = 1 - lastFractionalCell.count;\n      const fillAmount = Math.min(amountToFill, totalCount);\n\n      const filledRow = isLayoutBottom\n        ? rowCount - lastFractionalCell.row - rowSpan\n        : lastFractionalCell.row;\n      const filledCol = isLayoutRight\n        ? colCount - lastFractionalCell.col - columnSpan\n        : lastFractionalCell.col;\n\n      pictoItems.push({\n        row: filledRow,\n        col: filledCol,\n        countIdx: i,\n        itemIdx: i,\n        item: currItem,\n        fractionalStart: lastFractionalCell.count,\n        fractionalEnd: lastFractionalCell.count + fillAmount\n      });\n\n      lastFractionalCell.count += fillAmount;\n      totalCount -= fillAmount;\n\n      if (lastFractionalCell.count >= 1) {\n        lastFractionalCell = { row: -1, col: -1, count: 0, direction: isFractionalLeft, rowSpan, columnSpan};\n      } else {\n        continue;\n      }\n    }\n\n    // fill with full units first\n    const fullUnits = Math.floor(totalCount);\n    for (let j = 0; j < fullUnits; j++) {\n      const cell = findNextAvailableCell(map, columnSpan, rowSpan, colCount, rowCount, isVert);\n      if (cell) {\n        const currRow = isLayoutBottom ? rowCount - cell.row - rowSpan : cell.row;\n        const currCol = isLayoutRight ? colCount - cell.col - columnSpan : cell.col;\n\n        pictoItems.push({\n          row: currRow,\n          col: currCol,\n          countIdx: j,\n          itemIdx: i,\n          item: currItem,\n          fractionalStart: 0,\n          fractionalEnd: 1\n        });\n      }\n    }\n\n    // fill with the current item's remaining fractional cell\n    const remainder = totalCount - fullUnits;\n    if (remainder > 0 && remainder < 1) {\n      const cell = findNextAvailableCell(map, columnSpan, rowSpan, colCount, rowCount, isVert);\n      if (cell) {\n        lastFractionalCell = {\n          row: cell.row,\n          col: cell.col,\n          count: remainder,\n          direction: true,\n          rowSpan,\n          columnSpan        \n        };\n\n        const newRow = isLayoutBottom ? rowCount - cell.row - rowSpan : cell.row;\n        const newCol = isLayoutRight ? colCount - cell.col - columnSpan : cell.col;\n\n        pictoItems.push({\n          row: newRow,\n          col: newCol,\n          countIdx: remainder,\n          itemIdx: i,\n          item: currItem,\n          fractionalStart: 0,\n          fractionalEnd: remainder\n        });\n      }\n    }\n  }\n  return pictoItems;\n}","import type { ComponentChildren, JSX } from 'preact';\nimport type {\n  ItemInfo,\n  PictoChartItemData,\n  MarkerRendererContext,\n  PictoRendererOptions,\n  DatatipContext\n} from './pictoChart.type';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport { MarkerShapes } from '#utils/UNSAFE_visTypes/common';\nimport { colorSchemeVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\nimport { rgb, rgba } from '#UNSAFE_Theme';\nimport { SvgSymbol } from '#PRIVATE_SvgShapes';\nimport { usePictoChartContext } from './PictoChartContext';\nimport { Property } from 'csstype';\nimport { ColorProps } from '#utils/UNSAFE_interpolations/colors';\nimport { generateAriaLabel } from '#utils/UNSAFE_visUtils/accUtils';\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param highlighted The set of highlighted item\n */\nexport function isItemHighlighted<K>(id: K, highlightedIds?: K[]) {\n  if (!highlightedIds || highlightedIds.length === 0) {\n    return true;\n  }\n  return new Set(highlightedIds).has(id);\n}\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param selectedIds The set of highlighted item\n */\nexport function isItemSelected<K>(id: K, selectedIds?: K[]) {\n  if (!selectedIds || selectedIds.length === 0) {\n    return false;\n  }\n  return new Set(selectedIds).has(id);\n}\n\n/**\n * Returns the value of the data-oj-private-item-index attribute for a given element.\n * @param element The HTML element.\n */\nexport function getItemInfo(element: HTMLElement) {\n  const itemIdx = element.dataset['idx'];\n  if (itemIdx === undefined) return;\n\n  return {\n    idx: Number(itemIdx)\n  };\n}\n\n/**\n * Returns the item props for PictoChart.\n * @param item The picto chart item.\n * @param itemIdx The item index of the item.\n * @param countIdx The item count of the item.\n * @param isReadOnly Whether the picto chart is readonly.\n * @param hoveredItem The info of the currently hovered item.\n * @param selectedIds The selected Ids\n * @param focusedItem The info of currently focused item.\n * @param highlightedIds The highlighted ids.\n * @param activeId The active Id\n */\nexport function getItemProps<K, D extends PictoChartItemData<K>>(\n  item: D,\n  itemIdx: number,\n  countIdx: number,\n  isReadOnly: boolean,\n  hoveredItem?: ItemInfo,\n  selectedIds?: Array<K>,\n  focusedItem?: ItemInfo,\n  highlightedIds?: Array<K>,\n  activeId?: string,\n  isVert?: boolean,\n  layoutOrigin?: string\n) {\n  let isCurrent = false;\n  if (!isReadOnly) {\n    const isFocusedItem = !!focusedItem && itemIdx === focusedItem.idx;\n    const isHoveredItem = !!hoveredItem && itemIdx === hoveredItem.idx;\n    isCurrent = !!(\n      (isFocusedItem && focusedItem?.isCurrent) ||\n      (isHoveredItem && hoveredItem?.isCurrent)\n    );\n  }\n  const isHighlighted = isItemHighlighted<K>(item.id, highlightedIds);\n  const isSelected = isItemSelected(item.id, selectedIds);\n  const hasSelection = selectedIds && selectedIds.length !== 0;\n\n  return {\n    isCurrent,\n    isHighlighted: isHighlighted,\n    isSelected: isSelected,\n    hasSelection,\n    isFocused: focusedItem ? hasFocusRing(focusedItem, itemIdx) : false,\n    key: item.id,\n    itemIdx,\n    countIdx,\n    activeId: isCurrent ? activeId : undefined,\n    isReadOnly,\n    item: item,\n    isVerticalLayout: isVert,\n    layoutOrigin: layoutOrigin\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n * @param item1\n * @param item2\n * @returns\n */\nexport function isEqualItem(item1?: ItemInfo, item2?: ItemInfo) {\n  return item1?.idx === item2?.idx;\n}\n\n/**\n * Checks if the item is the currentItem and if the focus ring\n * is visible.\n * @param itemInfo ItemInfo\n * @param itemIdx Item index\n */\nexport function hasFocusRing(itemInfo: ItemInfo, itemIdx: number) {\n  if (!itemInfo.isFocusVisible) return false;\n  return itemInfo.idx === itemIdx;\n}\n\n/**\n *\n */\nexport function getCountWithTotal(itemCount: number, totalCount: number, translations: BundleType) {\n  const totalWithCountLabel = `${translations?.vis_labelCountWithTotal({\n    itemCount: itemCount.toString(),\n    totalCount: totalCount.toString()\n  })}`;\n  return totalWithCountLabel;\n}\n\n/**\n * Returns the aria properties for the picto chart.\n * @param isReadOnly { boolean } If the picto chart is readonly.\n * @param accessibleLabel { string } The aria-label set by the app.\n * @returns The aria props.\n */\nexport function getItemAriaProps(\n  itemCount: number,\n  totalCount: number,\n  supportsSelection: boolean,\n  label?: string,\n  translations?: BundleType,\n  isSelected?: boolean,\n  hasSelection?: boolean,\n  accessibleLabel?: string,\n  activeId?: string\n): {\n  'aria-label'?: UnpackSignals<JSX.AriaAttributes>['aria-label'];\n  role: UnpackSignals<JSX.HTMLAttributes['role']>;\n  id?: string;\n} {\n  const totalWithCountLabel = translations\n    ? getCountWithTotal(itemCount, totalCount, translations)\n    : '';\n\n  accessibleLabel = accessibleLabel || `${label ? label + ': ' : ''}${totalWithCountLabel}`; // TODO: use a translation string for :\n\n  return {\n    'aria-label':\n      generateAriaLabel(translations!, accessibleLabel, {\n        isSelected: !supportsSelection && !hasSelection ? undefined : isSelected\n      }) || undefined,\n    role: 'img',\n    id: activeId\n  };\n}\n\n/**\n * Returns the marker props for SVGSymbol\n */\nexport function getMarkerProps(\n  shape: MarkerShapes,\n  color?: ColorProps['color'],\n  isFocused?: boolean,\n  isSelected?: boolean,\n  isCurrent?: boolean,\n  supportsSelection?: boolean\n) {\n  const isHuman = shape === 'human';\n  const applyHover = isFocused || (isCurrent && supportsSelection);\n  const isNoneEqualSides = shape === 'ellipse' || shape === 'rectangle';\n  color = color !== '' ? color : rgba(colorSchemeVars.palette.neutral['190'], 0.15);\n  const outerBorderColor = isSelected ? colorSchemeVars.textIcon.primary : applyHover ? color : '';\n\n  return {\n    markerShape: shape,\n    tx: isHuman ? 70 : undefined,\n    ty: isHuman ? 60 : undefined,\n    markerColor: color,\n    borderColor: isSelected || applyHover ? rgb(colorSchemeVars.palette.neutral[0]) : color,\n    outerBorderColor,\n    markerScale: isNoneEqualSides && !outerBorderColor ? 1 : 0.85,\n    setAspectRatioNone: isNoneEqualSides ? true : false\n  };\n}\n\n// Creating component to read the context\nconst PictoRenderer = <K,>({\n  context,\n  markerProps\n}: {\n  context: MarkerRendererContext<K>;\n  markerProps: PictoRendererOptions;\n}) => {\n  const { supportsSelection } = usePictoChartContext();\n  const markerProp = getMarkerProps(\n    markerProps.shape,\n    markerProps.color,\n    context.state.focused,\n    context.state.selected,\n    context.state.hovered,\n    supportsSelection\n  );\n\n  return <SvgSymbol {...markerProp} />;\n};\n\n/**\n * Returns the marker renderer for SVGSymbol\n */\nexport function getPictoDefaultRenderers<\n  K,\n  D extends PictoChartItemData<K> = PictoChartItemData<K>\n>(rendererOptions: (data: D) => PictoRendererOptions) {\n  return {\n    markerRenderer: (context: MarkerRendererContext<D>) => {\n      const props = rendererOptions(context.data); // TODO: should we add default values\n      return <PictoRenderer context={context} markerProps={props} />;\n    },\n    datatipRenderer: (context: DatatipContext<D>) => {\n      const props = rendererOptions(context.data);\n      return { borderColor: props.color };\n    }\n  };\n}\n\nexport function getTotalCount<K>(items: PictoChartItemData<K>[]) {\n  let totalCount = 0;\n  for (let i = 0; i < items.length; i++) {\n    totalCount += items[i].count || 1;\n  }\n  return totalCount;\n}\n\n/**\n * Returns the text for the picto chart datatip.\n * @param items The picto chart items data.\n * @param focusedItem The item currently keyboard focused.\n * @param hoveredItem The item that is currently hovered.\n * @param datatip The datatip.\n */\nexport function getDatatipContent<K, D extends PictoChartItemData<K>>(\n  items: D[],\n  getItem: (itemInfo: ItemInfo, items: D[]) => D | undefined,\n  totalCount: number,\n  focusedItem: ItemInfo,\n  hoveredItem?: ItemInfo,\n  datatip?: (context: DatatipContext<D>) => {\n    content?: ComponentChildren;\n    borderColor?: Property.BorderColor;\n  },\n  translations?: BundleType\n) {\n  let itemInfo;\n  const isPointerActive = hoveredItem?.isCurrent;\n  if (isPointerActive && items[hoveredItem.idx].id != null) {\n    itemInfo = hoveredItem;\n  }\n  if (focusedItem && focusedItem.isCurrent) {\n    itemInfo = focusedItem;\n  }\n  let _content, countWithTotal;\n  let _borderColor: string = rgba(colorSchemeVars.palette.neutral['190'], 0.15);\n  const item = itemInfo && getItem(itemInfo, items);\n  if (item && datatip) {\n    // custom datatip\n    const datatipContext = item && { data: item };\n    const { content, borderColor } = datatip(datatipContext);\n    _content = content;\n    _borderColor = borderColor || _borderColor;\n    countWithTotal = translations\n      ? getCountWithTotal(item.count || 1, totalCount, translations)\n      : '';\n  }\n  return {\n    borderColor: _borderColor,\n    content:\n      _content ||\n      (itemInfo && getItem(itemInfo, items)?.accessibleLabel) ||\n      (itemInfo && getItem(itemInfo, items)?.label + ': ' + countWithTotal) ||\n      countWithTotal\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type {\n  ItemHoverDetail,\n  ItemFocusDetail,\n  ItemInfo,\n  PictoChartItemData\n} from './pictoChart.type';\n\n/**\n * Returns the item based on item info in a picto chart.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getItem<K, D extends PictoChartItemData<K>>(itemInfo: ItemInfo, items: D[]) {\n  const { idx } = itemInfo;\n  return items[idx];\n}\n\n/**\n * Returns the next item's info in a picto chart.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getNextItemInfo<K, D extends PictoChartItemData<K>>(itemInfo: ItemInfo, items: D[]) {\n  let idx = itemInfo.idx;\n\n  idx = Math.min(items.length - 1, idx + 1);\n  return { idx: idx };\n}\n\n/**\n * Returns the previous item's info in a picto chart.\n * @param itemInfo\n * @returns\n */\nfunction getPrevItemInfo(itemInfo: ItemInfo) {\n  let idx = itemInfo.idx;\n\n  idx = Math.max(0, idx - 1);\n  return { idx: idx };\n}\n\n/**\n * Returns utils functions for navigation in a picto chart.\n * @param items\n * @returns\n */\nexport function getPictoChartNavUtils<K, D extends PictoChartItemData<K>>(items: D[]) {\n  return {\n    getItem: (itemInfo: ItemInfo) => {\n      return getItem(itemInfo, items);\n    },\n    getDetailFromInfo: (itemInfo?: ItemInfo): ItemHoverDetail<K, D> | ItemFocusDetail<K, D> => {\n      if (!itemInfo) {\n        return { id: undefined, data: undefined };\n      }\n      const item = getItem(itemInfo, items);\n      return { id: item ? item.id : undefined, data: item };\n    },\n    getPrevItemInfo: (itemInfo: ItemInfo) => {\n      return getPrevItemInfo(itemInfo);\n    },\n    getNextItemInfo: (itemInfo: ItemInfo) => {\n      return getNextItemInfo(itemInfo, items);\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { RefObject } from 'preact';\nimport type { ItemInfo } from './pictoChart.type';\nimport { useDatatip } from '#hooks/PRIVATE_useDatatip';\nimport { calculateOffset } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport { ComponentChildren } from 'preact';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { Property } from 'csstype';\n\ntype Props = {\n  touchResponse: 'touchStart' | 'touchHold';\n  content?: ComponentChildren;\n  borderColor?: Property.BorderColor;\n  focusedItemInfo: ItemInfo;\n  width: number;\n  focusedItemRef: RefObject<HTMLDivElement>;\n};\n\n/**\n * Returns the datatip.\n * @param content The text string for the picto chart item.\n * @param focusedItemRef The ref for focused item node.\n * @param focusedItemInfo The ItemInfo for focused item node.\n * @returns\n */\nexport const usePictoChartDatatip = ({\n  touchResponse,\n  content,\n  borderColor,\n  width,\n  focusedItemRef,\n  focusedItemInfo\n}: Props) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const itemDim = focusedItemRef.current?.getBoundingClientRect();\n  const { datatipContent, datatipProps } = useDatatip({\n    content,\n    placement: 'top-start',\n    offset: calculateOffset(isRtl, width, focusedItemInfo.isCurrent ? itemDim : undefined),\n    borderColor,\n    anchor: focusedItemInfo?.isCurrent ? 'element' : 'pointer',\n    touchResponse\n  });\n  return { datatipContent: datatipContent, datatipProps: datatipProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { styles } from './themes/PictoChartStyles.css';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { BundleType } from '#resources/nls/bundle';\nimport { getItemAriaProps } from './pictoChartUtils';\nimport type { RefObject } from 'preact';\nimport { PictoChartItemData } from './pictoChart.type';\nimport { useUser } from '#hooks/UNSAFE_useUser';\n\nexport type PictoElementProps<K, D extends PictoChartItemData<K>> = {\n  item: D;\n  children: ComponentChildren;\n  row: number;\n  column: number;\n  totalCount: number;\n  class?: string;\n  activeId?: string;\n  isHighlighted?: boolean;\n  isSelected?: boolean;\n  hasSelection?: boolean;\n  itemIdx?: number;\n  countIdx?: number;\n  supportsSelection?: boolean;\n  supportsDrill?: boolean;\n  translations?: BundleType;\n  focusedItemRef?: RefObject<HTMLDivElement>;\n  fractionalStart?: number;\n  fractionalEnd?: number;\n  isVerticalLayout?: boolean;\n  layoutOrigin?: string;\n};\n\nconst PictoChartElement = <K, D extends PictoChartItemData<K>>(props: PictoElementProps<K, D>) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const isVert = props.isVerticalLayout;\n  let start = props.fractionalStart ?? 0;\n  let end = props.fractionalEnd ?? 1;\n  const layoutOrigin = props.layoutOrigin;\n  if (isVert) {\n    if (layoutOrigin === 'bottomStart' || layoutOrigin === 'bottomEnd') {\n      [start, end] = [1 - end, 1 - start];\n    }  \n  }\n  else {\n    if (layoutOrigin === 'bottomEnd' || layoutOrigin === 'topEnd') {\n      [start, end] = [1 - end, 1 - start];\n    }\n  }\n  const shouldClip = start !== 0 || end !== 1;\n  const clipPolygon = shouldClip ?\n  (isVert ? \n  `polygon(0% ${start * 100}%, 100% ${start * 100}%, 100% ${end * 100}%, 0% ${end * 100}%)`\n  : isRtl\n  ? `polygon(${100 - end * 100}% 0%, ${100 - start * 100}% 0%, ${100 - start * 100}% 100%, ${100 - end * 100}% 100%)`\n  : `polygon(${start * 100}% 0%, ${end * 100}% 0%, ${end * 100}% 100%, ${start * 100}% 100%)`)\n  : undefined;\n  const isInteractive = props.supportsSelection || props.supportsDrill;\n  const { dimmedItemStyle, interactiveItemStyle } = styles;\n  const itemClasses = classNames([\n    isInteractive && interactiveItemStyle,\n    !props.isHighlighted && dimmedItemStyle\n  ]);\n  const isFirstElement = props.countIdx === 0;\n  const itemAriaProps =\n    (isFirstElement &&\n      getItemAriaProps(\n        props.item.count || 1,\n        props.totalCount,\n        !!props.supportsSelection,\n        props.item.label,\n        props.translations,\n        props.isSelected,\n        props.hasSelection,\n        props.item.accessibleLabel,\n        props.activeId\n      )) ||\n    {};\n\n  return (\n    <div\n      ref={isFirstElement ? props.focusedItemRef : undefined}\n      id={props.activeId}\n      data-idx={props.itemIdx}\n      data-count-idx={props.countIdx}\n      style={{\n        gridRow: `${props.row + 1} / span ${props.item.rowSpan || 1}`,\n        gridColumn: `${props.column + 1} / span ${props.item.columnSpan || 1}`,\n        clipPath: clipPolygon\n      }}\n      class={itemClasses}\n      {...itemAriaProps}>\n      {props.children}\n    </div>\n  );\n};\n\nexport { PictoChartElement };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { baseStyles } from './themes/PictoChartStyles.css';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { generateElementCoords, getFlowingInfo } from './pictoChartLayoutUtils';\nimport { useSelection } from '#hooks/PRIVATE_useVisSelection';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '#resources/nls/bundle';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { getItemInfo, getDatatipContent, getItemProps, getTotalCount } from './pictoChartUtils';\nimport { getPictoChartNavUtils } from './pictoChartNavUtils';\nimport { useEvents } from './useEvents';\nimport { usePictoChartDatatip } from './usePictoChartDatatip';\nimport { useItemFocus } from '#hooks/PRIVATE_useVisEvents';\nimport { useTestId } from '#hooks/UNSAFE_useTestId';\nimport { PictoChartProps, PictoChartItemData } from './pictoChart.type';\nimport { PictoChartElement } from './PictoChartElement';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { merge } from '@oracle/oraclejet-internal-utilities/stringUtils';\nimport { usePictoChartContextMenu } from './usePictoChartContextMenu';\nimport { useRef } from 'preact/hooks';\n\ntype PictoChartWithDimensionsProps<K, D> = Omit<PictoChartProps<K, D>, 'width' | 'height'> & {\n  width: number;\n  height: number;\n  isFlowingWidth: boolean;\n  isFlowingHeight: boolean;\n};\n\nexport function PictoChartWithDimensions<\n  K extends string | number,\n  D extends PictoChartItemData<K> = PictoChartItemData<K>\n>({\n  width,\n  height,\n  columnWidth,\n  rowHeight,\n  items,\n  columnCount,\n  rowCount,\n  layout,\n  layoutOrigin = 'topStart',\n  selectionMode = 'none',\n  highlightedIds = [],\n  selectedIds = [],\n  drilling = 'off',\n  onItemDrill,\n  onItemHover,\n  isFlowingWidth,\n  isFlowingHeight,\n  onItemFocus,\n  contextMenuConfig,\n  ...props\n}: PictoChartWithDimensionsProps<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const hasData = items.length !== 0;\n  const totalCount = getTotalCount(items);\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const supportsSelection = !!(selectionMode && selectionMode !== 'none');\n  const supportsDrill = onItemDrill != null;\n  const isReadOnly =\n    !supportsSelection && !supportsDrill && onItemHover === null && onItemFocus === null;\n  const testIdProps = useTestId(props.testId);\n  const idToDataMap = new Map(items.map((obj) => [obj.id, obj]));\n\n  const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getPictoChartNavUtils<\n    K,\n    D\n  >(items);\n\n  const { touchResponse, touchResponseStyle } = useVisTouchResponse({ type: 'touchStart' });\n\n  const { hoveredItemInfo, focusedItemInfo, activeId, eventsProps, onContextMenuDismissed } =\n    useEvents<K, D>(\n      touchResponse,\n      !isReadOnly && hasData,\n      selectionMode,\n      getDetailFromInfo,\n      getPrevItemInfo,\n      getNextItemInfo,\n      drilling,\n      onItemDrill,\n      onItemHover,\n      onItemFocus\n    );\n\n  const idExtracter = (event: Event) => {\n    // return focused item for keyboard event.\n    // eventsProps should have already updated the focused item\n    const info =\n      event.type === 'keyup' ? focusedItemInfo : getItemInfo(event.target as HTMLElement);\n    return getDetailFromInfo(info).id;\n  };\n\n  const { selectionContent, selectionProps } = useSelection<K, D>({\n    idExtracter,\n    isDrillEnabled: drilling != 'off',\n    selection: selectedIds,\n    selectionMode: selectionMode,\n    getDataById: (id) => idToDataMap.get(id),\n    onChange: props.onSelectionChange\n  });\n\n  const rectangleWidth = columnWidth && parseFloat(columnWidth);\n  const rectangleHeight = rowHeight && parseFloat(rowHeight);\n  const pictoStyleClasses = classNames([baseStyles]);\n  const { focusedItemRef } = useItemFocus(focusedItemInfo);\n  const { content, borderColor } = getDatatipContent(\n    items,\n    getItem,\n    totalCount,\n    focusedItemInfo,\n    hoveredItemInfo,\n    props.datatip,\n    translations\n  );\n  const { calcColCount, calcRowCount, calcColWidth, calcRowHeight, gridGap } = getFlowingInfo<K, D>(\n    items,\n    layout === 'vertical',\n    width,\n    height,\n    isFlowingWidth,\n    isFlowingHeight,\n    columnCount,\n    rowCount,\n    rectangleWidth,\n    rectangleHeight\n  );\n\n  const {\n    datatipContent,\n    datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps }\n  } = usePictoChartDatatip({\n    touchResponse,\n    content,\n    width,\n    borderColor,\n    focusedItemRef,\n    focusedItemInfo\n  });\n\n  const { contextMenuContent, contextMenuProps } = usePictoChartContextMenu<D>({\n    getItemInfo,\n    focusedItemInfo,\n    rootRef,\n    contextMenuConfig: hasData ? contextMenuConfig : undefined,\n    items,\n    onContextMenuDismissed\n  });\n\n  if (!calcColCount)\n    // Nothing to render.\n    return null;\n\n  const elements = generateElementCoords(\n    items,\n    calcRowCount,\n    calcColCount,\n    layoutOrigin,\n    layout === 'vertical'\n  );\n  const mergedEventProps = mergeProps(eventsProps, datatipProps, selectionProps, contextMenuProps);\n  return (\n    <div\n      ref={rootRef}\n      tabIndex={0}\n      aria-label={props['aria-label']}\n      aria-describedby={merge([props['aria-describedby'], datatipAriaDescribedby])}\n      aria-labelledby={props['aria-labelledby']}\n      aria-activedescendant={activeId}\n      role=\"application\"\n      style={{\n        width: isFlowingWidth ? 'max-content' : `${width}px`,\n        height: isFlowingHeight ? 'max-content' : `${height}px`,\n        gridTemplateRows: `repeat(${calcRowCount}, ${calcRowHeight}px)`,\n        gridTemplateColumns: `repeat(${calcColCount}, ${calcColWidth}px)`,\n        gap: `${gridGap}px`,\n        ...touchResponseStyle\n      }}\n      class={pictoStyleClasses}\n      {...testIdProps}\n      {...mergedEventProps}>\n      {elements.map((elt) => {\n        const isFocusedItem = focusedItemInfo.idx === elt.itemIdx;\n        const itemProps = getItemProps(\n          elt.item,\n          elt.itemIdx,\n          elt.countIdx,\n          isReadOnly,\n          hoveredItemInfo,\n          selectedIds,\n          focusedItemInfo,\n          highlightedIds,\n          activeId,\n          layout === 'vertical',\n          layoutOrigin\n        );\n        const context = {\n          data: elt.item,\n          state: {\n            selected: itemProps.isSelected,\n            focused: itemProps.isFocused,\n            hovered: itemProps.isCurrent\n          }\n        };\n        return (\n          <PictoChartElement<K, D>\n            focusedItemRef={isFocusedItem ? focusedItemRef : undefined}\n            row={elt.row}\n            column={elt.col}\n            supportsSelection={supportsSelection}\n            supportsDrill={supportsDrill}\n            translations={translations}\n            totalCount={totalCount}\n            fractionalStart={elt.fractionalStart}\n            fractionalEnd={elt.fractionalEnd}\n            {...itemProps}>\n            {props.children(context)}\n          </PictoChartElement>\n        );\n      })}\n      {datatipContent}\n      {contextMenuContent}\n      {selectionContent}\n    </div>\n  );\n}\n","import { useCallback, useRef, useState } from 'preact/hooks';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport type {\n  ItemHoverDetail,\n  ItemFocusDetail,\n  ItemInfo,\n  PictoChartItemData,\n  ItemDrillDetail\n} from './pictoChart.type';\nimport { getItemInfo, isEqualItem } from './pictoChartUtils';\nimport { getRandomId } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport { cancelEvent } from '#utils/UNSAFE_visUtils/eventsUtils';\nimport { useVisHover } from '#hooks/PRIVATE_useVisHover';\nimport { useVisDrill } from '#hooks/PRIVATE_useVisDrill';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { gestureTypes } from '#hooks/PRIVATE_useVisContextMenu';\n\nexport function useEvents<K, D extends PictoChartItemData<K>>(\n  touchResponse: 'touchStart' | 'touchHold',\n  isInteractive: boolean,\n  selectionMode: 'none' | 'single' | 'multiple',\n  getDetailFromInfo: (info?: ItemInfo) => ItemHoverDetail<K, D> | ItemFocusDetail<K, D>,\n  getPrevItemInfo: (info: ItemInfo) => ItemInfo,\n  getNextItemInfo: (info: ItemInfo) => ItemInfo,\n  drilling?: 'on' | 'off',\n  onItemDrill?: (detail: ItemDrillDetail<K, D>) => void,\n  onItemHover?: (detail: ItemHoverDetail<K, D>) => void,\n  onItemFocus?: (detail: ItemFocusDetail<K, D>) => void\n) {\n  const [focusedItemInfo, setfocusedItemInfo] = useState<ItemInfo>({ idx: 0 });\n  const [hoveredItemInfo, sethoveredItemInfo] = useState<ItemInfo>();\n\n  const activeId = useRef<string>();\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const onHover = (event: PointerEvent) => {\n    const itemInfo = getItemInfo(event.target as HTMLElement);\n    if (!isEqualItem(itemInfo, hoveredItemInfo)) {\n      sethoveredItemInfo(itemInfo && { ...itemInfo, isCurrent: true });\n      activeId.current = getRandomId();\n      if (isInteractive) {\n        setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });\n        onItemHover?.(getDetailFromInfo(itemInfo));\n      }\n    }\n  };\n\n  const onHoverLeave = () => {\n    sethoveredItemInfo(undefined);\n    activeId.current = undefined;\n    if (isInteractive) {\n      onItemHover?.(getDetailFromInfo());\n    }\n  };\n\n  const hoverHandlers = useVisHover(onHover, undefined, onHoverLeave, touchResponse);\n\n  const processDrill = useCallback(\n    (info?: ItemInfo) => {\n      const { id, data } = getDetailFromInfo(info);\n      if (id != null && data) {\n        onItemDrill?.({ id, data });\n        activeId.current = getRandomId();\n      }\n    },\n    [getDetailFromInfo, onItemDrill]\n  );\n\n  const onDrill = useCallback(\n    (event: Event) => {\n      if (event.type === 'keydown') {\n        if (drilling == 'on') processDrill(focusedItemInfo);\n      } else {\n        processDrill(getItemInfo(event.target as HTMLElement));\n      }\n    },\n    [drilling, focusedItemInfo, processDrill]\n  );\n\n  const drillProps = useVisDrill(selectionMode, onDrill);\n\n  if (!isInteractive) {\n    return {\n      focusedItemInfo,\n      hoveredItemInfo,\n      // include relevant hover handlers for datatip\n      eventsProps: hoverHandlers\n    };\n  }\n\n  function updatefocusedItemInfo(itemInfo: ItemInfo) {\n    onItemFocus?.(getDetailFromInfo(itemInfo));\n    activeId.current = getRandomId();\n    setfocusedItemInfo(itemInfo);\n  }\n\n  function handleKeyboardInput(item: ItemInfo) {\n    if (!isEqualItem(item, focusedItemInfo)) {\n      item.isCurrent = true;\n      item.isFocusVisible = true;\n      if (hoveredItemInfo) {\n        sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });\n      }\n      updatefocusedItemInfo(item);\n    }\n  }\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    const key = event.key;\n    switch (key) {\n      case 'Tab':\n        return;\n      case 'ArrowDown': {\n        const nextItemInfo = getNextItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowUp': {\n        const nextItemInfo = getPrevItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowRight': {\n        const nextItemInfo = isRtl\n          ? getPrevItemInfo(focusedItemInfo)\n          : getNextItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowLeft': {\n        const nextItemInfo = isRtl\n          ? getNextItemInfo(focusedItemInfo)\n          : getPrevItemInfo(focusedItemInfo);\n        handleKeyboardInput(nextItemInfo);\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  const onKeyUp = (event: KeyboardEvent) => {\n    const key = event.code;\n    switch (key) {\n      case 'Tab': {\n        updatefocusedItemInfo({\n          ...focusedItemInfo,\n          isCurrent: true,\n          isFocusVisible: true\n        });\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  const onBlur = () => {\n    if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {\n      onItemFocus?.(getDetailFromInfo(undefined));\n    }\n    const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };\n    setfocusedItemInfo(itemInfo);\n  };\n\n  const onContextMenuDismissed = (gesture: gestureTypes) => {\n    if (gesture === 'keyboard') {\n      updatefocusedItemInfo({\n        ...focusedItemInfo,\n        isFocusVisible: true,\n        isCurrent: true\n      });\n    }\n  };\n  return {\n    focusedItemInfo,\n    hoveredItemInfo,\n    activeId: activeId.current,\n    onContextMenuDismissed,\n    eventsProps: mergeProps(drillProps, hoverHandlers, {\n      onKeyUp,\n      onKeyDown,\n      onBlur\n    })\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { type gestureTypes, useContextMenu } from '#hooks/PRIVATE_useVisContextMenu';\nimport type {\n  PictoChartContextMenuContext,\n  PictoChartContextMenuConfig,\n  ItemInfo\n} from './pictoChart.type';\n\ntype Props<D> = {\n  focusedItemInfo: ItemInfo;\n  items: D[];\n  rootRef: RefObject<HTMLDivElement>;\n  contextMenuConfig?: PictoChartContextMenuConfig<D>;\n  onContextMenuDismissed?: (gesture: gestureTypes) => void;\n  getItemInfo: (element: HTMLElement) =>\n    | {\n        idx: number;\n      }\n    | undefined;\n};\nexport const usePictoChartContextMenu = <D>({\n  rootRef,\n  contextMenuConfig,\n  focusedItemInfo,\n  items,\n  onContextMenuDismissed,\n  getItemInfo\n}: Props<D>) => {\n  const { contextMenuProps, contextMenuContent } = useContextMenu<PictoChartContextMenuContext<D>>({\n    onContextMenuHandler: ({ gesture, target }) => {\n      if (gesture === 'keyboard') {\n        const idx = focusedItemInfo.idx;\n        const elem = rootRef.current?.querySelector(`[data-idx=\"${idx}\"]`) || null;\n        const data = items[idx];\n\n        return {\n          type: 'element',\n          context: {\n            type: 'item' as const,\n            data\n          },\n          elem\n        };\n      }\n\n      const idx = getItemInfo(target as HTMLElement)?.idx;\n      const data = idx !== undefined ? items[idx] : null;\n      if (data) {\n        return {\n          type: 'pointer',\n          context: {\n            type: 'item' as const,\n            data\n          }\n        };\n      }\n\n      return {\n        type: 'pointer',\n        context: { type: 'background' as const }\n      };\n    },\n    contextMenuOptions: {\n      isDisabled: !contextMenuConfig //If there is no context menu renderer we disable the hook\n    },\n    rootRef,\n    contextMenuConfig,\n    onContextMenuDismissed\n  });\n\n  return { contextMenuContent, contextMenuProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { PictoChartItemData, PictoChartProps } from './pictoChart.type';\nimport { TrackResizeContainer } from '#UNSAFE_TrackResizeContainer';\nimport { PictoChartContext } from './PictoChartContext';\nimport { PictoChartWithDimensions } from './PictoChartWithDimensions';\n\n/**\n * A picto chart displays information using icons to visualize an absolute number or the relative sizes of the different parts of a population.\n */\nexport function PictoChart<\n  K extends string | number,\n  D extends PictoChartItemData<K> = PictoChartItemData<K>\n>({ width, height, ...props }: PictoChartProps<K, D>) {\n  //  TODO: investigate if we need to handle empty items for performance reasons.\n  const supportsSelection = !!(props.selectionMode && props.selectionMode !== 'none');\n\n  const isFlowingWidth = width === undefined;\n  const isFlowingHeight = height === undefined;\n\n  return (\n    <PictoChartContext.Provider value={{ supportsSelection }}>\n      <TrackResizeContainer\n        width={isFlowingWidth ? 'initial' : width}\n        height={isFlowingHeight ? 'initial' : height}>\n        {(width, height) => (\n          <PictoChartWithDimensions\n            width={width}\n            height={height}\n            isFlowingWidth={isFlowingWidth}\n            isFlowingHeight={isFlowingHeight}\n            {...props}\n          />\n        )}\n      </TrackResizeContainer>\n    </PictoChartContext.Provider>\n  );\n}\n"],"names":["PictoChartContext","createContext","_ceil","a","b","Math","ceil","areCellsAvailable","map","col","row","columnSpan","rowSpan","r","c","occupyCells","findNextAvailableCell","colCount","rowCount","isVert","getItemInfo","element","itemIdx","dataset","undefined","idx","Number","getItemProps","item","countIdx","isReadOnly","hoveredItem","selectedIds","focusedItem","highlightedIds","activeId","layoutOrigin","isCurrent","isFocusedItem","isHoveredItem","isHighlighted","id","length","Set","has","isItemHighlighted","isSelected","isItemSelected","hasSelection","isFocused","hasFocusRing","key","isVerticalLayout","isEqualItem","item1","item2","itemInfo","isFocusVisible","getCountWithTotal","itemCount","totalCount","translations","vis_labelCountWithTotal","toString","PictoRenderer","context","markerProps","supportsSelection","useContext","markerProp","shape","color","isHuman","applyHover","isNoneEqualSides","rgba","colorSchemeVars","palette","neutral","outerBorderColor","textIcon","primary","markerShape","tx","ty","markerColor","borderColor","rgb","markerScale","setAspectRatioNone","getMarkerProps","state","focused","selected","hovered","_jsx","jsx","SvgSymbol","getItem","items","getPictoChartNavUtils","getDetailFromInfo","data","getPrevItemInfo","max","getNextItemInfo","min","PictoChartElement","props","direction","useUser","isRtl","start","fractionalStart","end","fractionalEnd","clipPolygon","isInteractive","supportsDrill","dimmedItemStyle","interactiveItemStyle","styles","itemClasses","classNames","isFirstElement","itemAriaProps","label","accessibleLabel","totalWithCountLabel","generateAriaLabel","role","getItemAriaProps","count","ref","focusedItemRef","style","gridRow","gridColumn","column","clipPath","class","children","PictoChartWithDimensions","width","height","columnWidth","rowHeight","columnCount","layout","selectionMode","drilling","onItemDrill","onItemHover","isFlowingWidth","isFlowingHeight","onItemFocus","contextMenuConfig","rootRef","useRef","hasData","i","getTotalCount","useTranslationBundle","testIdProps","useTestId","testId","idToDataMap","Map","obj","touchResponse","touchResponseStyle","useVisTouchResponse","type","hoveredItemInfo","focusedItemInfo","eventsProps","onContextMenuDismissed","setfocusedItemInfo","useState","sethoveredItemInfo","hoverHandlers","useVisHover","event","target","current","getRandomId","processDrill","useCallback","info","onDrill","drillProps","useVisDrill","updatefocusedItemInfo","handleKeyboardInput","gesture","mergeProps","onKeyUp","code","cancelEvent","onKeyDown","onBlur","useEvents","selectionContent","selectionProps","useSelection","idExtracter","isDrillEnabled","selection","getDataById","get","onChange","onSelectionChange","rectangleWidth","parseFloat","rectangleHeight","pictoStyleClasses","baseStyles","useItemFocus","content","datatip","isPointerActive","_content","countWithTotal","_borderColor","datatipContext","getDatatipContent","calcColCount","calcRowCount","calcColWidth","calcRowHeight","gridGap","colWidth","numCells","maxColSpan","maxRowSpan","minSpan","Infinity","DEFAULT_SIZE","sqrt","floor","getFlowingInfo","datatipContent","datatipProps","datatipAriaDescribedby","itemDim","getBoundingClientRect","useDatatip","placement","offset","calculateOffset","anchor","usePictoChartDatatip","contextMenuContent","contextMenuProps","useContextMenu","onContextMenuHandler","elem","querySelector","contextMenuOptions","isDisabled","usePictoChartContextMenu","elements","isLayoutBottom","origin","isLayoutRight","isOriginRight","pictoItems","Array","fill","isFractionalLeft","lastFractionalCell","currItem","amountToFill","fillAmount","filledRow","filledCol","push","fullUnits","j","cell","currRow","currCol","remainder","newRow","newCol","generateElementCoords","mergedEventProps","_jsxs","tabIndex","merge","l","gridTemplateRows","gridTemplateColumns","gap","elt","itemProps","Provider","value","TrackResizeContainer","rendererOptions","markerRenderer","datatipRenderer"],"mappings":"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"}