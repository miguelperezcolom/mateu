{"version":3,"file":"Diagram-c8ca8f7a.js","sources":["../../src/UNSAFE_Diagram/utils/diagramUtils.ts","../../src/UNSAFE_Diagram/DiagramNodeElement.tsx","../../src/UNSAFE_Diagram/DiagramNodeLayer.tsx","../../src/UNSAFE_Diagram/DiagramLinkElement.tsx","../../src/UNSAFE_Diagram/DiagramLinkLayer.tsx","../../src/UNSAFE_Diagram/DiagramLabel.tsx","../../src/UNSAFE_Diagram/DiagramLabelLayer.tsx","../../src/UNSAFE_Diagram/DiagramLayers.tsx","../../src/UNSAFE_Diagram/DiagramPanZoomContainer.tsx","../../src/UNSAFE_Diagram/utils/navUtils.ts","../../src/UNSAFE_Diagram/hooks/useDiagramNavigation.ts","../../src/UNSAFE_Diagram/hooks/useEvents.ts","../../src/UNSAFE_Diagram/hooks/useDiagramDatatip.ts","../../src/UNSAFE_Diagram/hooks/usePointerGesture.ts","../../src/UNSAFE_Diagram/utils/panUtils.ts","../../src/UNSAFE_Diagram/hooks/useDragPan.ts","../../src/UNSAFE_Diagram/hooks/useDrag.ts","../../src/UNSAFE_Diagram/utils/zoomUtils.ts","../../src/UNSAFE_Diagram/hooks/usePinch.ts","../../src/UNSAFE_Diagram/hooks/usePinchZoom.ts","../../src/UNSAFE_Diagram/hooks/usePanZoom.ts","../../src/UNSAFE_Diagram/hooks/useWheelZoom.ts","../../src/UNSAFE_Diagram/hooks/useWheel.ts","../../src/UNSAFE_Diagram/DiagramWithDimensions.tsx","../../src/UNSAFE_Diagram/hooks/useDiagramSelection.ts","../../src/UNSAFE_Diagram/hooks/useDiagramContextMenu.ts","../../src/UNSAFE_Diagram/utils/contextMenuUtils.ts","../../src/UNSAFE_Diagram/Diagram.tsx"],"sourcesContent":["import type {\n  Pan,\n  Zoom,\n  DiagramNodeData,\n  DiagramLinkData,\n  DiagramLayoutOutput,\n  ItemInfo,\n  Bounds,\n  Position,\n  Dimensions,\n  DatatipContext,\n  DiagramLabelStyles,\n  DiagramLabelPosition\n} from '../diagram.types';\nimport type { RefObject } from 'preact';\nimport type { BundleType } from '#resources/nls/bundle';\nimport type { Font, GetTextDimensionsType, TextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { ComponentChildren } from 'preact';\nimport { Property } from 'csstype';\nimport { generateAriaLabel } from '#utils/UNSAFE_visUtils/accUtils';\n\nconst ZOOM_TO_FIT_PADDING = 20;\n/**\n * Returns the pan properties for the diagram.\n */\nexport function getPanProps(\n  props: Pan,\n  contentBounds: Bounds,\n  userDragMode: string | undefined,\n  isDeviceTouch: boolean\n) {\n  return {\n    panning: isDeviceTouch\n      ? userDragMode === 'pan' && props.panning\n        ? props.panning\n        : 'off'\n      : props.panning\n      ? props.panning\n      : 'off',\n    panDirection: props.panDirection ? props.panDirection : 'any',\n    centerX:\n      props.centerX !== undefined ? props.centerX : contentBounds.width / 2 + contentBounds.x,\n    centerY:\n      props.centerY !== undefined ? props.centerY : contentBounds.height / 2 + contentBounds.y,\n    onPan: props.onPan\n  };\n}\n\n/**\n * Returns the zoom properties for the diagram.\n */\nexport function getZoomProps(props: Zoom, width: number, height: number, contentBounds: Bounds) {\n  const zoomTofitZoom = getZoomToFitZoom(width, height, contentBounds);\n  const maxZoom = props.maxZoom || 1;\n  const minZoom = props.minZoom || Math.min(maxZoom, zoomTofitZoom);\n  const zoom = props.zoomValue ? props.zoomValue : zoomTofitZoom;\n  return {\n    zooming: props.zooming ? props.zooming : 'off',\n    // default value of 0 indicates zoom-to-fit level\n    minZoom: minZoom,\n    maxZoom: maxZoom,\n    // zoom value of 0 will default to zoom to fit\n    zoomValue: constrainZoom(zoom, minZoom, maxZoom),\n    onZoom: props.onZoom\n  };\n}\n\n/**\n * Constructs the json object to be passed into the layout function\n */\nexport function constructLayoutJSON<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  nodes: D1[],\n  nodeItems: Map<K1, D1>,\n  linkItems: Map<K2, D2>,\n  dimensions: Dimensions[],\n  width: number,\n  height: number,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  const labelDims: Map<K1 | K2, TextDimensions> = new Map();\n  const nodeKeys = Array.from(nodeItems.keys());\n  for (const id of nodeKeys) {\n    const item = nodeItems.get(id as K1);\n    if (item && getTextDimensions && item.label) {\n      const label = item.label;\n      const fontProps = _getFontProps(item.labelStyle);\n      labelDims.set(id as K1 | K2, getTextDimensions(label, fontProps));\n    }\n  }\n  const linkKeys = Array.from(linkItems.keys());\n  for (const id of linkKeys) {\n    const item = linkItems.get(id as K2);\n    if (item && getTextDimensions && item.label) {\n      const label = item.label;\n      const fontProps = _getFontProps(item.labelStyle);\n      labelDims.set(id as K1 | K2, getTextDimensions(label, fontProps));\n    }\n  }\n  const getLabelDimensions = function (data: D1 | D2) {\n    return labelDims.get(data.id);\n  };\n  const getNodeDimensions = function (data: D1) {\n    for (let i = 0; i < nodes.length; i++) {\n      if (data.id === nodes[i].id) {\n        return dimensions[i];\n      }\n    }\n    return dimensions[0];\n  };\n\n  return {\n    layoutJSON: {\n      getNodeDimensions: getNodeDimensions,\n      getLabelDimensions: getLabelDimensions,\n      componentSize: {\n        width: width,\n        height: height\n      }\n    },\n    labelDims: labelDims\n  };\n}\n\n/**\n * Deconstructs the output of the layout function\n */\nexport function deconstructLayoutJSON<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2>\n>(layoutJSON: L, nodeData: D1[], linkData: D2[]) {\n  const nodes = layoutJSON.nodes;\n  const links = layoutJSON.links;\n  const positions: Position[] = [];\n  const nodeLabelPos: (DiagramLabelPosition | undefined)[] = [];\n  const linkLabelPos: DiagramLabelPosition[] = [];\n  const ids: K1[] = [];\n  let hasNodeLabels = false;\n  let hasLinkLabels = false;\n  let node, link;\n  for (let i = 0; i < nodeData.length; i++) {\n    node = nodes[nodeData[i].id];\n    positions.push(node.position);\n    ids.push(nodeData[i].id);\n    if (node.label) hasNodeLabels = true;\n    nodeLabelPos.push(node.label);\n  }\n  if (links) {\n    for (let i = 0; i < linkData.length; i++) {\n      link = links[linkData[i].id];\n      if (link.label) hasLinkLabels = true;\n      linkLabelPos.push(link.label);\n    }\n  }\n  return {\n    nodeIds: ids,\n    nodePoints: positions,\n    nodeLabelPos: hasNodeLabels ? nodeLabelPos : undefined,\n    linkLabelPos: hasLinkLabels ? linkLabelPos : undefined\n  };\n}\n\n/**\n * Merges the node points into the dimensions\n */\nexport function mergeDimensions<K1>(dimensions: Dimensions[], nodePoints: Position[], ids: K1[]) {\n  const newBounds: Bounds[] = [];\n  const newBoundsMap = new Map<K1, Bounds>();\n  for (let i = 0; i < dimensions.length; i++) {\n    const point = nodePoints[i];\n    const dim = dimensions[i];\n    newBoundsMap.set(ids[i], { x: point.x, y: point.y, width: dim.width, height: dim.height });\n    newBounds.push({ x: point.x, y: point.y, width: dim.width, height: dim.height });\n  }\n  return { newBounds, newBoundsMap };\n}\n\n/**\n * Deep equality check for whether two arrays of bounds are the same\n */\nexport function isEqualBounds(bounds1: Bounds[], bounds2: Bounds[]) {\n  if (bounds1.length !== bounds2.length) return false;\n  return bounds1.every(\n    ({ x, y, width, height }, i) =>\n      bounds2[i].x === x &&\n      bounds2[i].y === y &&\n      bounds2[i].width === width &&\n      bounds2[i].width === height\n  );\n}\n\n/**\n * Returns the text for the diagram datatip.\n */\nexport function getDatatipContent<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  nodesMap: Map<K1, D1>,\n  linksMap: Map<K2, D2>,\n  focusedItem?: ItemInfo<K1, K2>,\n  hoveredItem?: ItemInfo<K1, K2>,\n  datatip?: (detail: DatatipContext<D1, D2>) => {\n    content: ComponentChildren;\n    borderColor?: Property.BorderColor;\n  }\n) {\n  let itemInfo;\n  const isPointerActive = hoveredItem?.isCurrent;\n  if (isPointerActive && hoveredItem.id != null) {\n    itemInfo = hoveredItem;\n  }\n  if (focusedItem && focusedItem.isCurrent) {\n    itemInfo = focusedItem;\n  }\n  if (itemInfo && datatip) {\n    return datatip(\n      itemInfo.isNode\n        ? { data: nodesMap.get(itemInfo.id as K1) as D1, type: 'node' }\n        : { data: linksMap.get(itemInfo.id as K2) as D2, type: 'link' }\n    );\n  }\n  if (itemInfo) {\n    const text = (\n      itemInfo.isNode ? nodesMap.get(itemInfo.id as K1) : linksMap.get(itemInfo.id as K2)\n    )?.accessibleLabel;\n    return {\n      content: text\n    };\n  }\n  return;\n}\n\n/**\n * Creates a map with key id and value node or link data\n */\nexport function createItemMap<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(items: (D1 | D2)[]) {\n  const itemIdToDataMap = new Map();\n  const itemIdToIndexMap = new Map();\n  const itemIndexToIdMap = new Map();\n  for (let i = 0; i < items.length; i++) {\n    itemIdToDataMap.set(items[i].id, items[i]);\n    itemIdToIndexMap.set(items[i].id, i);\n    itemIndexToIdMap.set(i, items[i].id);\n  }\n  return {\n    itemIdToDataMap,\n    itemIdToIndexMap,\n    itemIndexToIdMap\n  };\n}\n\n/**\n * Filter out links with no start or end nodes\n */\nexport function filterLinksWithNoEndNodes<K2, K1, D1, D2 extends DiagramLinkData<K2, K1>>(\n  links: D2[],\n  nodesMap: Map<K1, D1>\n) {\n  const newLinks: D2[] = [];\n  for (let i = 0; i < links.length; i++) {\n    const link = links[i];\n    if (nodesMap.get(link.startNode) && nodesMap.get(link.endNode)) {\n      newLinks.push(link);\n    }\n  }\n  return newLinks;\n}\n\n/**\n * Pulls out the dimensions from an array of bounds\n */\nexport function getDimensionsFromBounds(bounds: Bounds[]) {\n  const dims: Dimensions[] = [];\n  for (let i = 0; i < bounds.length; i++) {\n    dims.push({ width: bounds[i].width, height: bounds[i].height });\n  }\n  return dims;\n}\n\n/**\n * Returns true if event is a selection event\n */\nexport function isSelectionEvent(event: KeyboardEvent): boolean {\n  if (event.altKey && (event.key === '≥' || event.key === '≤')) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns the center position of the node or link\n * For links, draws a straight line between the centers of the start/end node\n * and returns the center of that line\n */\nexport function getFocusedItemBounds<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  focusedItemInfo: ItemInfo<K1, K2>,\n  bounds: Bounds[],\n  links: D2[],\n  nodeIdToIndexMap: Map<K1, number>,\n  linkIdToIndexMap: Map<K2, number>\n) {\n  if (focusedItemInfo.isNode) {\n    const idx = nodeIdToIndexMap.get(focusedItemInfo.id as K1);\n    // Return the first element if cannot find the Node index\n    return bounds[idx || 0];\n  } else {\n    // Center of a straight line between start/end node centers\n    const link = links[linkIdToIndexMap.get(focusedItemInfo.id as K2) || 0];\n    const startNB = bounds[nodeIdToIndexMap.get(link.startNode) || 0];\n    const endNB = bounds[nodeIdToIndexMap.get(link.endNode) || 0];\n    const startNCenter = { x: startNB.x + startNB.width / 2, y: startNB.y + startNB.height / 2 };\n    const endNCenter = { x: endNB.x + endNB.width / 2, y: endNB.y + endNB.height / 2 };\n    const minX = Math.min(startNCenter.x, endNCenter.x);\n    const minY = Math.min(startNCenter.y, endNCenter.y);\n    return {\n      x: minX,\n      y: minY,\n      width: Math.abs(startNCenter.x - endNCenter.x),\n      height: Math.abs(startNCenter.y - endNCenter.y)\n    };\n  }\n}\n/**\n * Combines the node and link ids into one array\n */\nexport function combineIds<K1, K2>(nodeIds?: K1[], linkIds?: K2[]) {\n  const combinedIds: (K1 | K2)[] = [];\n  if (nodeIds) {\n    for (let i = 0; i < nodeIds.length; i++) {\n      combinedIds.push(nodeIds[i]);\n    }\n  }\n  if (linkIds) {\n    for (let i = 0; i < linkIds.length; i++) {\n      combinedIds.push(linkIds[i]);\n    }\n  }\n  return combinedIds;\n}\n\n/**\n * Returns the bounds of the diagram content\n */\nexport function getContentBounds(nodeBounds: Bounds[], labelBounds?: Bounds): Bounds {\n  if (nodeBounds.length === 0) return { x: 0, width: Infinity, y: 0, height: Infinity };\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let dims;\n  for (let i = 0; i < nodeBounds.length; i++) {\n    dims = nodeBounds[i];\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.width > maxX ? dims.x + dims.width : maxX;\n    maxY = dims.y + dims.height > maxY ? dims.y + dims.height : maxY;\n  }\n  if (labelBounds) {\n    minX = labelBounds.x < minX ? labelBounds.x : minX;\n    minY = labelBounds.y < minY ? labelBounds.y : minY;\n    maxX = labelBounds.x + labelBounds.width > maxX ? labelBounds.x + labelBounds.width : maxX;\n    maxY = labelBounds.y + labelBounds.height > maxY ? labelBounds.y + labelBounds.height : maxY;\n  }\n  return { x: minX, width: maxX - minX, y: minY, height: maxY - minY };\n}\n\n/**\n * Returns the label bounds\n */\nexport function getAllLabelBounds<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  labelDims: Map<K1 | K2, TextDimensions>,\n  nodes: D1[],\n  links: D2[],\n  nodeLabelPos: (DiagramLabelPosition | undefined)[] = [],\n  linkLabelPos: DiagramLabelPosition[] = [],\n  isRTL: boolean\n) {\n  if (nodeLabelPos.length === 0 && linkLabelPos.length === 0) return undefined;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  let dims, label;\n  for (let i = 0; i < nodeLabelPos.length; i++) {\n    label = nodeLabelPos[i];\n    if (!label) continue;\n    dims = getLabelBounds(label, labelDims.get(nodes[i].id)!, isRTL);\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.width > maxX ? dims.x + dims.width : maxX;\n    maxY = dims.y + dims.height > maxY ? dims.y + dims.height : maxY;\n  }\n  for (let i = 0; i < linkLabelPos.length; i++) {\n    label = linkLabelPos[i];\n    if (!label) continue;\n    dims = getLabelBounds(label, labelDims.get(links[i].id)!, isRTL);\n    minX = dims.x < minX ? dims.x : minX;\n    minY = dims.y < minY ? dims.y : minY;\n    maxX = dims.x + dims.width > maxX ? dims.x + dims.width : maxX;\n    maxY = dims.y + dims.height > maxY ? dims.y + dims.height : maxY;\n  }\n  return { x: minX, width: maxX - minX, y: minY, height: maxY - minY };\n}\n\nfunction getLabelBounds(label: DiagramLabelPosition, dims: TextDimensions, isRTL: boolean) {\n  const labelPos = getLabelPosition(dims, label, isRTL);\n  const isRotating = label.rotationAngle;\n  if (!isRotating) {\n    return { x: labelPos.x, y: labelPos.y, width: dims.width, height: dims.height };\n  } else {\n    // Find the 4 corners of the label bounds relative to the rotation point\n    const rotationPoint = label.rotationPoint\n      ? label.rotationPoint\n      : { x: dims.width / 2, y: dims.height / 2 };\n    const angle = label.rotationAngle!;\n    const topLeft = getCoordsRelToRotPoint({ x: 0, y: 0 }, rotationPoint);\n    const topRight = getCoordsRelToRotPoint({ x: dims.width, y: 0 }, rotationPoint);\n    const bottomLeft = getCoordsRelToRotPoint({ x: 0, y: dims.height }, rotationPoint);\n    const bottomRight = getCoordsRelToRotPoint({ x: dims.width, y: dims.height }, rotationPoint);\n    const rotTopLeft = rotatePoint(topLeft, angle);\n    const rotBotLeft = rotatePoint(bottomLeft, angle);\n    const rotTopRight = rotatePoint(topRight, angle);\n    const rotBotRight = rotatePoint(bottomRight, angle);\n    const points = [rotTopLeft, rotBotLeft, rotTopRight, rotBotRight].map((pos: Position) => {\n      return {\n        x: pos.x + labelPos.x + rotationPoint.x,\n        y: pos.y + labelPos.y + rotationPoint.y\n      };\n    });\n    return getBoundsFromPoints(points);\n  }\n}\n\nfunction getCoordsRelToRotPoint(labelPoint: Position, rotPoint: Position) {\n  return { x: labelPoint.x - rotPoint.x, y: labelPoint.y - rotPoint.y };\n}\n\nfunction rotatePoint(pos: Position, angle: number) {\n  return {\n    x: pos.x * Math.cos(angle) - pos.y * Math.sin(angle),\n    y: pos.x * Math.sin(angle) + pos.y * Math.cos(angle)\n  };\n}\n\nfunction getBoundsFromPoints(points: Position[]) {\n  let minX = points[0].x;\n  let minY = points[0].y;\n  let maxX = points[0].x;\n  let maxY = points[0].y;\n  for (let i = 1; i < points.length; i++) {\n    const point = points[i];\n    if (point.x < minX) minX = point.x;\n    else if (point.x > maxX) maxX = point.x;\n    if (point.y < minY) minY = point.y;\n    else if (point.y > maxY) maxY = point.y;\n  }\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n\n/**\n * Returns the position of the label\n * @param dimensions\n * @param positionProps\n * @returns position of the label\n */\nexport function getLabelPosition(\n  dimensions: TextDimensions,\n  positionProps: DiagramLabelPosition,\n  isRTL: boolean\n) {\n  const position = positionProps.position;\n  const hAlign = positionProps.hAlign ? positionProps.hAlign : isRTL ? 'right' : 'left';\n  const vAlign = positionProps.vAlign;\n  let x, y;\n  if (hAlign === 'center') {\n    x = position.x - dimensions.width / 2;\n  } else if (hAlign === 'right') {\n    x = position.x - dimensions.width;\n  } else {\n    x = position.x;\n  }\n\n  if (vAlign === 'middle') {\n    y = position.y - dimensions.height / 2;\n  } else if (vAlign === 'bottom') {\n    y = position.y - dimensions.height;\n  } else if (vAlign === 'baseline') {\n    y = position.y + dimensions.y;\n  } else {\n    y = position.y;\n  }\n  return {\n    x: x,\n    y: y\n  };\n}\n\n/**\n * Converts centerX,Y coordinates to panX,Y coordinates\n */\nexport function centerXYToPanXY(\n  centerX: number,\n  centerY: number,\n  zoom: number,\n  width: number,\n  height: number\n) {\n  return {\n    panX: width / 2 - centerX * zoom,\n    panY: height / 2 - centerY * zoom\n  };\n}\n/**\n * Converts panX,Y coordinates to centerX,Y coordinates\n */\nexport function panXYToCenterXY(\n  panX: number,\n  panY: number,\n  zoom: number,\n  width: number,\n  height: number\n) {\n  return {\n    centerX: (width / 2 - panX) / zoom,\n    centerY: (height / 2 - panY) / zoom\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n */\nexport function isEqualItem<K1, K2>(item1?: ItemInfo<K1, K2>, item2?: ItemInfo<K1, K2>) {\n  return item1?.id === item2?.id && item1?.isNode === item2?.isNode;\n}\n\n/**\n * Returns the item info of the data-oj-private-node or data-oj-private-link attribute for a given element.\n */\nexport function getNavigableInfo<K1, K2>(\n  element: HTMLElement,\n  rootElementRef?: RefObject<HTMLDivElement>\n): ItemInfo<K1, K2> {\n  let isNode = false;\n  let elem = element;\n  let navigableId;\n  while (!navigableId) {\n    navigableId = elem.dataset['ojPrivateNode'];\n    if (navigableId) {\n      isNode = true;\n    } else {\n      navigableId = elem.dataset['ojPrivateLink'];\n    }\n    if (!navigableId) {\n      if (elem.parentElement && elem.parentElement !== rootElementRef?.current) {\n        elem = elem.parentElement;\n      } else {\n        break;\n      }\n    }\n  }\n  return {\n    id: navigableId as K1 | K2,\n    isNode: isNode\n  };\n}\n\n/**\n * Returns the id of the focused item.\n */\nexport function getFocusedItem<K1, K2>(\n  focusedItemInfo: ItemInfo<K1, K2>,\n  hoveredItemInfo?: ItemInfo<K1, K2>\n) {\n  let focused;\n  if (focusedItemInfo.isCurrent && focusedItemInfo.isFocusVisible) {\n    focused = focusedItemInfo.id;\n  } else if (hoveredItemInfo?.isCurrent) {\n    focused = hoveredItemInfo.id;\n  }\n  return focused;\n}\n\n/**\n * Returns the aria label\n */\nexport function getItemAriaLabel(\n  translations: BundleType,\n  supportsSelection: boolean,\n  isSelected?: boolean,\n  accessibleLabel?: string\n) {\n  return generateAriaLabel(translations, accessibleLabel || '', {\n    isSelected: !supportsSelection ? undefined : isSelected\n  });\n}\n\n/**\n * Returns the zoom to fit zoom level\n */\nexport function getZoomToFitZoom(width: number, height: number, contentBounds: Bounds) {\n  const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.width;\n  const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / contentBounds.height;\n  return Math.min(zoomX, zoomY);\n}\n\n/**\n * Constrains the zoom level\n */\nfunction constrainZoom(zoom: number, minZoom: number, maxZoom: number) {\n  let newZoom = Math.max(minZoom, zoom);\n  newZoom = Math.min(maxZoom, newZoom);\n  return newZoom;\n}\n\n/**\n * Returns the font props for a node or link\n */\nfunction _getFontProps(styles?: DiagramLabelStyles) {\n  const fontProps: Font = {};\n  if (!styles) return fontProps;\n  if (styles.fontFamily) fontProps.fontFamily = styles.fontFamily;\n  if (styles.fontSize) fontProps.fontSize = styles.fontSize;\n  if (styles.fontStyle) fontProps.fontStyle = styles.fontStyle;\n  if (styles.fontWeight) fontProps.fontWeight = styles.fontWeight;\n  return fontProps;\n}\n\n/**\n * Returns the panX, panY, and zoom when zooming and centering an item\n */\nexport function zoomAndCenterItemFromInfo<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  info: ItemInfo<K1, K2>,\n  linkIdToDataMap: Map<K2, D2>,\n  bounds: Bounds[],\n  nodeIdToIndex: Map<K1, number>,\n  width: number,\n  height: number,\n  maxZoom: number\n) {\n  const isNode = info.isNode;\n  let totalBounds;\n  if (isNode) {\n    const nodeIndex = nodeIdToIndex.get(info.id as K1)!;\n    totalBounds = bounds[nodeIndex];\n  } else {\n    const link = linkIdToDataMap.get(info.id as K2)!;\n    const startNodeBounds = bounds[nodeIdToIndex.get(link.startNode)!];\n    const endNodeBounds = bounds[nodeIdToIndex.get(link.endNode)!];\n    const minX = Math.min(startNodeBounds.x, endNodeBounds.x);\n    const minY = Math.min(startNodeBounds.y, endNodeBounds.y);\n    const maxX = Math.max(\n      startNodeBounds.x + startNodeBounds.width,\n      endNodeBounds.x + startNodeBounds.height\n    );\n    const maxY = Math.max(\n      startNodeBounds.y + startNodeBounds.height,\n      endNodeBounds.y + endNodeBounds.height\n    );\n    totalBounds = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };\n  }\n  return getPanZoomToCenterNode(totalBounds, maxZoom, width, height);\n}\n\n/**\n * Returns the pan and zoom values in order\n * to center a node or link\n */\nfunction getPanZoomToCenterNode(bounds: Bounds, maxZoom: number, width: number, height: number) {\n  const zoomX = (width - 2 * ZOOM_TO_FIT_PADDING) / bounds.width;\n  const zoomY = (height - 2 * ZOOM_TO_FIT_PADDING) / bounds.height;\n  const zoom = Math.min(zoomX, zoomY, maxZoom);\n  const cX = bounds.width / 2 + bounds.x;\n  const cY = bounds.height / 2 + bounds.y;\n  return { centerX: cX, centerY: cY, zoom: zoom };\n}\n","import type { Position, State, NodeRendererContext } from './diagram.types';\nimport { useResizeObserver } from '#hooks/UNSAFE_useResizeObserver';\nimport { useCallback, useRef } from 'preact/hooks';\nimport { getItemAriaLabel } from './utils/diagramUtils';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { itemStyles } from './themes/DiagramStyles.css';\nimport { ComponentChildren } from 'preact';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '#resources/nls/bundle';\n\n/**\n * Props for node component\n */\ntype NodeProps<K1, D1> = {\n  id: K1;\n  position: Position;\n  label?: string;\n  state: State;\n  previousState: State;\n  isDimmed?: boolean;\n  activeId?: string;\n  accessibleLabel?: string;\n  nodeIndex: number;\n  data: D1;\n  nodeRenderer: (context: NodeRendererContext<D1>) => ComponentChildren;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  supportsSelection: boolean;\n};\n\nexport const DiagramNodeElement = <K1, D1>({\n  id,\n  state,\n  previousState,\n  position,\n  activeId,\n  nodeRenderer,\n  onNodeSizeChanged,\n  nodeIndex,\n  data,\n  accessibleLabel,\n  isDimmed,\n  supportsSelection\n}: NodeProps<K1, D1>) => {\n  const { nodeStyles, dimmedItemStyle } = itemStyles;\n  const context = {\n    state: state,\n    previousState: previousState,\n    data: data\n  };\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const ref = useRef<HTMLDivElement>(null);\n  // TODO JET-62472 change to one resize observer function\n  const optionsRef = useRef({ box: 'border-box' as const });\n  useResizeObserver(\n    ref,\n    useCallback(\n      (entry: ResizeObserverEntry) => {\n        const boxSize = entry.borderBoxSize;\n        const width = boxSize[0].inlineSize;\n        const height = boxSize[0].blockSize;\n        onNodeSizeChanged(width, height, nodeIndex);\n      },\n      [nodeIndex, onNodeSizeChanged]\n    ),\n    optionsRef.current\n  );\n  return (\n    <div\n      ref={ref}\n      key={id}\n      class={classNames([nodeStyles, isDimmed ? dimmedItemStyle : undefined])}\n      data-oj-private-node={id}\n      role=\"img\"\n      aria-label={getItemAriaLabel(\n        translations,\n        supportsSelection,\n        state.selected,\n        accessibleLabel\n      )}\n      style={{\n        top: position.y,\n        left: position.x\n      }}\n      id={state.focused || state.hovered ? activeId : undefined}>\n      {nodeRenderer(context)}\n    </div>\n  );\n};\n","import { ComponentChildren } from 'preact';\nimport type { States, NodeRendererContext, Bounds, DiagramNodeData } from './diagram.types';\nimport { DiagramNodeElement } from './DiagramNodeElement';\nimport { layerStyles } from './themes/DiagramStyles.css';\n\ntype Props<K1, K2, D1> = {\n  nodes: D1[];\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  nodeRenderer: (context: NodeRendererContext<D1>) => ComponentChildren;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  nodeBounds?: Bounds[];\n  supportsSelection: boolean;\n};\n\nexport function DiagramNodeLayer<K1, K2, D1 extends DiagramNodeData<K1>>({\n  nodes,\n  states,\n  previousStates,\n  nodeRenderer,\n  nodeBounds,\n  onNodeSizeChanged,\n  supportsSelection\n}: Props<K1, K2, D1>) {\n  return (\n    <div class={layerStyles}>\n      {nodes.map((node, i) => {\n        // this is for initial render before the layout function so render all nodes at 0,0\n        const position =\n          nodeBounds && nodeBounds[i] ? { x: nodeBounds[i].x, y: nodeBounds[i].y } : { x: 0, y: 0 };\n        const state = {\n          selected: states.selectedNodeIds.includes(node.id),\n          focused: states.focusedId === node.id,\n          hovered: states.hoveredId === node.id,\n          zoom: states.zoom\n        };\n        const previousState = {\n          selected: previousStates.selectedNodeIds.includes(node.id),\n          focused: previousStates.focusedId === node.id,\n          hovered: previousStates.hoveredId === node.id,\n          zoom: previousStates.zoom\n        };\n        return (\n          <DiagramNodeElement\n            id={node.id}\n            position={position}\n            state={state}\n            previousState={previousState}\n            isDimmed={\n              states.highlightedIds.length !== 0 && !states.highlightedIds.includes(node.id)\n            }\n            activeId={states.activeId}\n            nodeRenderer={nodeRenderer}\n            onNodeSizeChanged={onNodeSizeChanged}\n            nodeIndex={i}\n            accessibleLabel={node.accessibleLabel}\n            data={node}\n            supportsSelection={supportsSelection}\n          />\n        );\n      })}\n    </div>\n  );\n}\n","import type { State, LinkRendererContext } from './diagram.types';\nimport { getItemAriaLabel } from './utils/diagramUtils';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { itemStyles } from './themes/DiagramStyles.css';\nimport { ComponentChildren } from 'preact';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '#resources/nls/bundle';\n\n/**\n * Props for Link\n */\nexport type LinkProps<K2, D2, L> = {\n  id: K2;\n  label?: string;\n  state: State;\n  previousState: State;\n  isDimmed?: boolean;\n  activeId?: string;\n  accessibleLabel?: string;\n  data: D2;\n  linkRenderer: (context: LinkRendererContext<D2, L>) => ComponentChildren;\n  supportsSelection: boolean;\n  layoutOutput: L;\n};\n\nexport const DiagramLinkElement = <K2, D2, L>({\n  id,\n  state,\n  previousState,\n  activeId,\n  data,\n  linkRenderer,\n  accessibleLabel,\n  isDimmed,\n  supportsSelection,\n  layoutOutput\n}: LinkProps<K2, D2, L>) => {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { dimmedItemStyle, linkStyles } = itemStyles;\n  const context = {\n    state: state,\n    previousState: previousState,\n    data: data,\n    layoutOutput: layoutOutput\n  };\n  return (\n    <g\n      key={id}\n      id={state.focused ? activeId : undefined}\n      aria-label={getItemAriaLabel(\n        translations,\n        supportsSelection,\n        state.selected,\n        accessibleLabel\n      )}\n      data-oj-private-link={id}\n      role=\"img\"\n      class={classNames([linkStyles, isDimmed && dimmedItemStyle])}>\n      {linkRenderer(context)}\n    </g>\n  );\n};\n","import { ComponentChildren } from 'preact';\nimport type {\n  States,\n  LinkRendererContext,\n  DiagramLinkData,\n  DiagramLayoutOutput,\n  Bounds\n} from './diagram.types';\nimport { DiagramLinkElement } from './DiagramLinkElement';\nimport { layerStyles } from './themes/DiagramStyles.css';\nimport { getZoomToFitZoom } from './utils/diagramUtils';\n\ntype Props<K2, K1, D2, L> = {\n  links: D2[];\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  linkRenderer: (context: LinkRendererContext<D2, L>) => ComponentChildren;\n  width: number;\n  height: number;\n  supportsSelection: boolean;\n  layoutOutput: L;\n  combinedNodeBounds: Bounds;\n};\n\nexport function DiagramLinkLayer<\n  K2 extends string | number,\n  K1 extends string | number,\n  D2 extends DiagramLinkData<K2, K1> = DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2> = DiagramLayoutOutput<K1, K2>\n>({\n  links,\n  states,\n  previousStates,\n  linkRenderer,\n  width,\n  height,\n  supportsSelection,\n  layoutOutput,\n  combinedNodeBounds\n}: Props<K2, K1, D2, L>) {\n  const zoom = getZoomToFitZoom(width, height, combinedNodeBounds);\n  return (\n    <svg class={layerStyles} width={width / zoom} height={height / zoom}>\n      {links.map((link) => {\n        const state = {\n          selected: states.selectedLinkIds.includes(link.id),\n          focused: states.focusedId === link.id,\n          hovered: states.hoveredId === link.id,\n          zoom: states.zoom\n        };\n        const previousState = {\n          selected: previousStates.selectedLinkIds.includes(link.id),\n          focused: previousStates.focusedId === link.id,\n          hovered: previousStates.hoveredId === link.id,\n          zoom: previousStates.zoom\n        };\n        return (\n          <DiagramLinkElement\n            id={link.id}\n            label={link.label}\n            state={state}\n            previousState={previousState}\n            isDimmed={\n              states.highlightedIds.length !== 0 && !states.highlightedIds.includes(link.id)\n            }\n            activeId={states.activeId}\n            accessibleLabel={link.accessibleLabel}\n            data={link}\n            linkRenderer={linkRenderer}\n            supportsSelection={supportsSelection}\n            layoutOutput={layoutOutput}\n          />\n        );\n      })}\n    </svg>\n  );\n}\n","import type { DiagramLabelPosition, DiagramLabelStyles } from './diagram.types';\nimport { getLabelPosition } from './utils/diagramUtils';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { labelStyles } from './themes/DiagramStyles.css';\nimport type { TextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { Property } from 'csstype';\n\n/**\n * Props for the label component\n */\ntype LabelProps = {\n  styles?: LabelStyles;\n  text: string;\n  position: DiagramLabelPosition;\n  dimensions: TextDimensions;\n  isRTL: boolean;\n};\n\n/**\n * Label styles\n */\ntype LabelStyles = DiagramLabelStyles & {\n  borderStyle?: Property.BorderStyle;\n};\n\nexport const DiagramLabel = ({ text, position, styles, dimensions, isRTL }: LabelProps) => {\n  const { labelStyle, labelBorderStyle } = labelStyles;\n\n  const labelPosition = getLabelPosition(dimensions, position, isRTL);\n  const labelRotation = getLabelRotation(position);\n  return (\n    <div\n      class={classNames([labelStyle, styles && styles.borderColor && labelBorderStyle])}\n      style={{\n        top: labelPosition.y,\n        left: labelPosition.x,\n        ...styles,\n        ...labelRotation\n      }}>\n      {text}\n    </div>\n  );\n};\n\n/**\n * Returns the label rotation props\n * @param position\n * @returns rotation props\n */\nfunction getLabelRotation(position: DiagramLabelPosition) {\n  const rotationAngle = position.rotationAngle;\n  const rotationPoint = position.rotationPoint;\n  const rotation: {\n    transform?: string;\n    'transform-origin'?: string;\n  } = {};\n  if (rotationAngle) {\n    rotation['transform'] = `rotate(${rotationAngle}deg)`;\n  }\n  if (rotationPoint) {\n    rotation['transform-origin'] = `${rotationPoint.x}px ${rotationPoint.y}px`;\n  }\n  return rotation;\n}\n","import type { DiagramLabelPosition, DiagramNodeData, DiagramLinkData } from './diagram.types';\nimport { DiagramLabel } from './DiagramLabel';\nimport type { TextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { layerStyles } from './themes/DiagramStyles.css';\nimport { useUser } from '#hooks/UNSAFE_useUser';\n\ntype Props<K1, K2, D1, D2> = {\n  labelPosition: (DiagramLabelPosition | undefined)[];\n  itemProps: (D1 | D2)[];\n  labelDimensions: Map<K1 | K2, TextDimensions>;\n};\n\nexport function DiagramLabelLayer<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>({ labelPosition, itemProps, labelDimensions }: Props<K1, K2, D1, D2>) {\n  const { direction } = useUser();\n  return (\n    <div class={layerStyles}>\n      {itemProps.map((item, i) => {\n        if (item.label && labelPosition[i]) {\n          return (\n            <DiagramLabel\n              styles={item.labelStyle}\n              text={item.label}\n              position={labelPosition[i]!}\n              dimensions={labelDimensions.get(item.id)!}\n              isRTL={direction === 'rtl'}\n            />\n          );\n        }\n        return undefined;\n      })}\n    </div>\n  );\n}\n","import type {\n  NodeRendererContext,\n  LinkRendererContext,\n  States,\n  Bounds,\n  DiagramLabelPosition,\n  DiagramNodeData,\n  DiagramLinkData,\n  DiagramLayoutOutput\n} from './diagram.types';\nimport { DiagramNodeLayer } from './DiagramNodeLayer';\nimport { DiagramLinkLayer } from './DiagramLinkLayer';\nimport { DiagramLabelLayer } from './DiagramLabelLayer';\nimport { ComponentChildren } from 'preact';\nimport type { TextDimensions } from '#hooks/PRIVATE_useTextDimensions';\n\n/**\n * Props for Diagram layers component\n */\ntype DiagramLayersProps<K1, K2, D1, D2, L> = {\n  nodes: D1[];\n  links: D2[];\n  nodeRenderer: (context: NodeRendererContext<D1>) => ComponentChildren;\n  linkRenderer?: (context: LinkRendererContext<D2, L>) => ComponentChildren;\n  states: States<K1, K2>;\n  previousStates: States<K1, K2>;\n  nodeBounds: Bounds[];\n  // width height are for svg for links\n  width: number;\n  height: number;\n  onNodeSizeChanged: (width: number, height: number, idx: number) => void;\n  nodeLabelPositions?: (DiagramLabelPosition | undefined)[];\n  linkLabelPositions?: (DiagramLabelPosition | undefined)[];\n  labelDimensions?: Map<K1 | K2, TextDimensions>;\n  supportsSelection: boolean;\n  layoutOutput?: L;\n  combinedNodeBounds?: Bounds;\n};\n\nexport function DiagramLayers<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2>\n>({\n  nodes,\n  links,\n  nodeRenderer,\n  linkRenderer,\n  states,\n  previousStates,\n  nodeBounds,\n  onNodeSizeChanged,\n  width,\n  height,\n  nodeLabelPositions,\n  linkLabelPositions,\n  labelDimensions,\n  supportsSelection,\n  layoutOutput,\n  combinedNodeBounds\n}: DiagramLayersProps<K1, K2, D1, D2, L>) {\n  return (\n    <>\n      {links.length > 0 &&\n        layoutOutput &&\n        linkRenderer &&\n        width !== Infinity &&\n        combinedNodeBounds && (\n          <DiagramLinkLayer\n            links={links}\n            states={states}\n            previousStates={previousStates}\n            linkRenderer={linkRenderer}\n            width={width}\n            height={height}\n            supportsSelection={supportsSelection}\n            layoutOutput={layoutOutput}\n            combinedNodeBounds={combinedNodeBounds}\n          />\n        )}\n      <DiagramNodeLayer\n        nodes={nodes}\n        nodeBounds={nodeBounds}\n        states={states}\n        previousStates={previousStates}\n        nodeRenderer={nodeRenderer}\n        onNodeSizeChanged={onNodeSizeChanged}\n        supportsSelection={supportsSelection}\n      />\n      {labelDimensions ? (\n        <div>\n          {nodeLabelPositions ? (\n            <DiagramLabelLayer\n              labelPosition={nodeLabelPositions}\n              itemProps={nodes}\n              labelDimensions={labelDimensions}\n            />\n          ) : undefined}\n          {links && linkLabelPositions ? (\n            <DiagramLabelLayer\n              labelPosition={linkLabelPositions}\n              itemProps={links}\n              labelDimensions={labelDimensions}\n            />\n          ) : undefined}\n        </div>\n      ) : undefined}\n    </>\n  );\n}\n","import { ComponentChildren } from 'preact';\nimport { centerXYToPanXY } from './utils/diagramUtils';\nimport { panZoomStyles } from './themes/DiagramStyles.css';\n\ntype Props = {\n  centerX: number;\n  centerY: number;\n  zoom: number;\n  width: number;\n  height: number;\n  children: ComponentChildren;\n};\n\nexport function DiagramPanZoomContainer({\n  centerX,\n  centerY,\n  children,\n  zoom,\n  width,\n  height\n}: Props) {\n  const panValues = centerXYToPanXY(centerX, centerY, zoom, width, height);\n  return (\n    <div\n      class={panZoomStyles}\n      style={{\n        //TODO JET-62471 look at using matrices or both in transform instead\n        translate: `${panValues.panX}px ${panValues.panY}px`,\n        transform: `scale(${zoom})`\n      }}>\n      {children}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { DiagramNodeData, DiagramLinkData, Bounds, ItemInfo } from '../diagram.types';\n\n/**\n * Navigation direction\n */\nexport type NavDirection = 'right' | 'left' | 'up' | 'down';\n\ntype linkDetailType<K2> = {\n  id: K2;\n  angle: number;\n  distance: number;\n  /**\n   * Ingoing = 1, outgoing = 0\n   */\n  direction: 0 | 1;\n};\n\n/**\n * Returns the node data based on node info in a diagram.\n * @param itemInfo\n * @returns\n */\nexport function getNodeDetailFromInfo<K1, K2, D1 extends DiagramNodeData<K1>>(\n  itemInfo: ItemInfo<K1, K2>,\n  nodes: D1[]\n): D1 | undefined {\n  let node;\n  for (let i = 0; i < nodes.length; i++) {\n    node = nodes[i];\n    if (itemInfo.id === node.id) {\n      return node;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Returns the link data based on link info in a diagram.\n * @param itemInfo\n * @returns\n */\nexport function getLinkDetailFromInfo<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  itemInfo: ItemInfo<K1, K2>,\n  links: D2[]\n): D2 | undefined {\n  let link;\n  for (let i = 0; i < links.length; i++) {\n    link = links[i];\n    if (itemInfo.id === link.id) {\n      return link;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Creates a map with key node id and value node bounds\n */\nexport function createNodeBoundsMap<K1, D1 extends DiagramNodeData<K1>>(\n  nodes: D1[],\n  bounds: Bounds[]\n) {\n  const nodeBounds: Map<K1, Bounds> = new Map();\n  for (let i = 0; i < nodes.length; i++) {\n    nodeBounds.set(nodes[i].id, bounds[i]);\n  }\n  return nodeBounds;\n}\n\n/**\n * Utility method that adds sorting attributes of each link to an array\n */\nexport function addSortingAttributes<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(node: D1, listOfLinks: D2[], nodes: D1[], nodeBounds: Map<K1, Bounds>) {\n  let angle, distance, direction;\n  const linkDetail: linkDetailType<K2>[] = [];\n  for (let i = 0; i < listOfLinks.length; i++) {\n    const link = listOfLinks[i];\n    angle = _getClockwiseAngle(node, link, nodes, nodeBounds);\n    distance = _getNodesDistance(link, nodes, nodeBounds);\n    direction = _getLinkDirection(node, link);\n    linkDetail.push({ id: link.id, angle: angle, distance: distance, direction: direction });\n  }\n  return linkDetail;\n}\n\n/**\n * Returns a function that compares two link around a given node\n * The links are analyzed by angle, distance from the node and direction. The sorting attributes are added to the links before sorting.\n */\nexport function getLinkComparator<K2>() {\n  return (link1: linkDetailType<K2>, link2: linkDetailType<K2>) => {\n    const { angle: linkAngle1, distance: linkDistance1, direction: linkDirection1 } = link1;\n    const { angle: linkAngle2, distance: linkDistance2, direction: linkDirection2 } = link2;\n    let res = -1;\n\n    if (!_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2) && linkAngle1 > linkAngle2) {\n      res = 1;\n    } else if (_anglesAreEqualWithinTolerance(linkAngle1, linkAngle2)) {\n      //check distance and direction\n      if (linkDistance1 > linkDistance2) {\n        res = 1;\n      } else if (linkDistance2 == linkDistance1 && linkDirection1 > linkDirection2) {\n        //outgoing to ingoing\n        res = 1;\n      } else if (linkDistance2 == linkDistance1 && linkDirection1 == linkDirection2) {\n        res = 0;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns navigable links for a given node\n */\nexport function getNavigableLinksForNodeId<K1, K2, D2 extends DiagramLinkData<K2, K1>>(\n  nodeId: K1,\n  listOfLinks: D2[]\n) {\n  const links: D2[] = [];\n  listOfLinks.forEach((link) => {\n    const startId = link.startNode;\n    const endId = link.endNode;\n\n    if (startId == nodeId || endId == nodeId) links.push(link);\n  });\n  return links;\n}\n\n/**\n * Get the clockwise angle for the link given node as a center\n */\nfunction _getClockwiseAngle<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(node: D1, link: D2, nodes: D1[], nodeBounds: Map<K1, Bounds>) {\n  //find opposite node\n  let currNode;\n  let startNode = nodes[0];\n  let endNode = nodes[0];\n  for (let i = 0; i < nodes.length; i++) {\n    currNode = nodes[i];\n    if (currNode.id === link.startNode) {\n      startNode = currNode;\n    } else if (currNode.id === link.endNode) {\n      endNode = currNode;\n    }\n  }\n  const oppositeNode = node.id == startNode.id ? endNode : startNode;\n\n  const p1 = _getNodeCenter(node, nodeBounds);\n  const p2 = _getNodeCenter(oppositeNode, nodeBounds);\n  let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n  angle = angle < 0 ? angle + Math.PI * 2 : angle;\n  return angle;\n}\n\n/**\n * Get the distance between start and end nodes for the given link\n */\nfunction _getNodesDistance<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(link: D2, nodes: D1[], nodeBounds: Map<K1, Bounds>) {\n  let currNode;\n  let startNode = nodes[0];\n  let endNode = nodes[0];\n  for (let i = 0; i < nodes.length; i++) {\n    currNode = nodes[i];\n    if (currNode.id === link.startNode) {\n      startNode = currNode;\n    } else if (currNode.id === link.endNode) {\n      endNode = currNode;\n    }\n  }\n  const p1 = _getNodeCenter(startNode, nodeBounds);\n  const p2 = _getNodeCenter(endNode, nodeBounds);\n  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));\n}\n\n/**\n * Get link direction for the given node.  1 if the node is the end node\n * and 0 if it is the start node\n */\nfunction _getLinkDirection<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(node: D1, link: D2): 0 | 1 {\n  if (link.endNode === node.id) {\n    return 1;\n  }\n  return 0;\n}\n\n/**\n * Get node center\n */\nfunction _getNodeCenter<K1, D1 extends DiagramNodeData<K1>>(node: D1, nodeBounds: Map<K1, Bounds>) {\n  const nodeBB = nodeBounds.get(node.id)!;\n  return { x: nodeBB.x + nodeBB.width / 2, y: nodeBB.y + nodeBB.height / 2 };\n}\n\n/**\n * Calculates the angle weighted by distance\n */\nexport function calcDistanceAngleWeighted(\n  objectBB: Bounds,\n  currentBB: Bounds,\n  direction: NavDirection\n) {\n  // Variables used for calculating penalties when calculating distances between two navigables.\n  const optimalAngle1 = (15 / 180) * Math.PI;\n  const optimalAngle2 = (40 / 180) * Math.PI;\n  const suboptimalAnglePenalty1 = 2; // multiplier to the distance\n  const suboptimalAnglePenalty2 = 6; // multiplier to the distance\n\n  const objCenterX = objectBB.x + objectBB.width / 2;\n  const objCenterY = objectBB.y + objectBB.height / 2;\n\n  const curCenterX = currentBB.x + currentBB.width / 2;\n  const curCenterY = currentBB.y + currentBB.height / 2;\n\n  const x_dist = Math.abs(objCenterX - curCenterX);\n  const y_dist = Math.abs(objCenterY - curCenterY);\n\n  const angle = Math.atan2(y_dist, x_dist);\n\n  let distance = Math.sqrt(x_dist * x_dist + y_dist * y_dist);\n\n  // Angle penalty based on direction\n  if (\n    (angle > optimalAngle1 && (direction == 'right' || direction == 'left')) ||\n    (angle < Math.PI / 2 - optimalAngle1 && (direction == 'up' || direction == 'down'))\n  ) {\n    if (\n      (angle > optimalAngle2 && (direction == 'right' || direction == 'left')) ||\n      (angle < Math.PI / 2 - optimalAngle2 && (direction == 'up' || direction == 'down'))\n    ) {\n      distance *= suboptimalAnglePenalty2;\n    } else {\n      distance *= suboptimalAnglePenalty1;\n    }\n  }\n\n  return distance;\n}\n\n/**\n * Given a direction, is a certain node is a valid destination to navigate to\n */\nexport function isValidDestination(\n  objBB: Bounds,\n  curBB: Bounds,\n  direction: NavDirection,\n  compareCenters: boolean\n) {\n  // compare the centers of the navigable and to be valid, the navigable must be in the right direction\n  // without tolerance\n  if (compareCenters) {\n    const objCenterX = objBB.x + 0.5 * objBB.width;\n    const curCenterX = curBB.x + 0.5 * curBB.width;\n    const objCenterY = objBB.y + 0.5 * objBB.height;\n    const curCenterY = curBB.y + 0.5 * curBB.height;\n\n    switch (direction) {\n      case 'up':\n        return objCenterY < curCenterY;\n      case 'down':\n        return objBB.y > curCenterY;\n      case 'right':\n        return objCenterX > curCenterX;\n      case 'left':\n        return objCenterX < curCenterX;\n      default:\n        break;\n    }\n    return true;\n  }\n\n  switch (direction) {\n    case 'up':\n      return objBB.y < curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);\n    case 'down':\n      return objBB.y > curBB.y || _areEqualWithinTolerance(objBB.y, curBB.y);\n    case 'right':\n      return objBB.x > curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);\n    case 'left':\n      return objBB.x < curBB.x || _areEqualWithinTolerance(objBB.x, curBB.x);\n    default:\n      break;\n  }\n  return true;\n}\n\n/**\n * Returns true if two nodes are in contact\n */\nexport function calcInContact(objRect: Bounds, curRect: Bounds, direction: NavDirection) {\n  switch (direction) {\n    case 'up':\n      return (\n        _isVerticallyAligned(objRect, curRect) &&\n        (curRect.y <= objRect.y + objRect.height ||\n          _areEqualWithinTolerance(curRect.y, objRect.y + objRect.height))\n      );\n    case 'down':\n      return (\n        _isVerticallyAligned(objRect, curRect) &&\n        (objRect.y <= curRect.y + curRect.height ||\n          _areEqualWithinTolerance(objRect.y, curRect.y + curRect.height))\n      );\n    case 'right':\n      return (\n        _isHorizontallyAligned(objRect, curRect) &&\n        (objRect.x <= curRect.x + curRect.width ||\n          _areEqualWithinTolerance(objRect.x, curRect.x + curRect.width))\n      );\n    case 'left':\n      return (\n        _isHorizontallyAligned(objRect, curRect) &&\n        (curRect.x <= objRect.x + objRect.width ||\n          _areEqualWithinTolerance(curRect.x, objRect.x + objRect.width))\n      );\n    default:\n      break;\n  }\n\n  return false;\n}\n\nfunction _isVerticallyAligned(rect1: Bounds, rect2: Bounds) {\n  return (\n    (rect1.x >= rect2.x && rect1.x <= rect2.x + rect2.width) ||\n    (rect2.x >= rect1.x && rect2.x <= rect1.x + rect1.width)\n  );\n}\n\nfunction _isHorizontallyAligned(rect1: Bounds, rect2: Bounds) {\n  return (\n    (rect1.y >= rect2.y && rect1.y <= rect2.y + rect2.height) ||\n    (rect2.y >= rect1.y && rect2.y <= rect1.y + rect1.height)\n  );\n}\n\nfunction _areEqualWithinTolerance(a: number, b: number) {\n  return Math.abs(a - b) <= 0.0000001;\n}\n\nfunction _anglesAreEqualWithinTolerance(a1: number, a2: number) {\n  let res = Math.abs(a1 - a2) <= 0.0000001;\n  if (!res) {\n    res = Math.abs(Math.PI * 2 + Math.min(a1, a2) - Math.max(a1, a2)) <= 0.0000001;\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  NavDirection,\n  addSortingAttributes,\n  calcDistanceAngleWeighted,\n  calcInContact,\n  createNodeBoundsMap,\n  getLinkComparator,\n  getNavigableLinksForNodeId,\n  getNodeDetailFromInfo,\n  isValidDestination\n} from '../utils/navUtils';\nimport type { DiagramNodeData, DiagramLinkData, Bounds, ItemInfo } from '../diagram.types';\nimport { useRef } from 'preact/hooks';\n\nexport function useDiagramNavigation<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(nodes: D1[], links: D2[], bounds: Bounds[], linkIdToDataMap: Map<K2, D2>) {\n  const currentKeyboardFocusNode = useRef<K1>();\n  const nodeBoundsById = createNodeBoundsMap<K1, D1>(nodes, bounds);\n\n  function getNextNavigableNode(\n    direction: NavDirection,\n    compareCenters: boolean,\n    current?: D1,\n    listOfObjects?: D1[]\n  ) {\n    if (!listOfObjects) return current;\n\n    if (!current) return listOfObjects[0];\n    const currBB = nodeBoundsById.get(current.id);\n    if (!currBB) return listOfObjects[0];\n\n    let nextObject = current; //init to current object\n    let nextDistance = Number.MAX_VALUE;\n\n    // If an object is in contact it overrules all other attributes\n    // Only another in contact object with better attributes will have higher precedence\n    let nextInContact = false;\n\n    // Whether or not the for loop has encountered the current object\n    let hasFoundCurrent = false;\n\n    let object, inContact, distance;\n    for (let i = 0; i < listOfObjects.length; i++) {\n      object = listOfObjects[i];\n\n      if (object === current) {\n        hasFoundCurrent = true;\n        continue;\n      }\n      const objBB = nodeBoundsById.get(object.id);\n      if (!objBB) continue;\n\n      const objBounds = { x: objBB.x, y: objBB.y, width: objBB.width, height: objBB.height };\n      const currBounds = { x: currBB.x, y: currBB.y, width: currBB.width, height: currBB.height };\n      if (!isValidDestination(objBounds, currBounds, direction, compareCenters)) continue;\n\n      inContact = calcInContact(objBounds, currBounds, direction);\n\n      if (nextInContact && !inContact) continue;\n\n      distance = calcDistanceAngleWeighted(objBounds, currBounds, direction);\n\n      if (distance == 0 && !hasFoundCurrent) continue;\n\n      // Make sure incontact flag have highest precedence\n      if (\n        (!nextInContact && inContact) ||\n        (distance < nextDistance && ((nextInContact && inContact) || !nextInContact))\n      ) {\n        nextDistance = distance;\n        nextObject = object;\n        nextInContact = inContact;\n      }\n    }\n    return nextObject;\n  }\n\n  /**\n   * Get next navigavle link depending on direction - clockwise or conter clockwise.\n   * The decision is made based on location of nodes centers rather than link paths or link angles.\n   */\n  function getNextNavigableLink(\n    direction: string,\n    listOfNodes: D1[],\n    currentLink?: D2,\n    listOfLinks?: D2[]\n  ) {\n    if (!listOfLinks) return currentLink;\n\n    if (!currentLink) return listOfLinks[0];\n    const keyboardFocusNode = currentKeyboardFocusNode.current;\n    const nodeId = keyboardFocusNode ? keyboardFocusNode : currentLink.startNode;\n    const node = getNodeDetailFromInfo({ id: nodeId, isNode: true }, listOfNodes);\n\n    if (!node) return currentLink;\n    const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);\n    listOfLinks = adjLinks;\n    const linksWithSortingAttributes = addSortingAttributes<K1, K2, D1, D2>(\n      node,\n      listOfLinks,\n      listOfNodes,\n      nodeBoundsById\n    );\n    linksWithSortingAttributes.sort(getLinkComparator());\n    //clockwise direction\n    const bForward = direction == 'down' ? true : false;\n    let index = 0;\n    for (let i = 0; i < linksWithSortingAttributes.length; i++) {\n      const link = linksWithSortingAttributes[i];\n      if (link.id === currentLink.id) {\n        if (bForward) index = i == linksWithSortingAttributes.length - 1 ? 0 : i + 1;\n        else index = i == 0 ? linksWithSortingAttributes.length - 1 : i - 1;\n        break;\n      }\n    }\n    return linksWithSortingAttributes[index];\n  }\n\n  /**\n   * Returns the link detail when a node to link navigation occurs\n   */\n  function navigateFromNodeToLink(listOfLinks: D2[], event: KeyboardEvent, node?: D1) {\n    if (!node) return undefined;\n    const adjLinks = getNavigableLinksForNodeId(node.id, listOfLinks);\n    if (adjLinks.length < 1) return undefined;\n    let link = adjLinks[0];\n    const nodeBB = nodeBoundsById.get(node.id)!;\n    let object, currNode, currNodeBB, currNodeBBCenterX;\n    const nodeCenterX = nodeBB.x + nodeBB.width / 2;\n    currentKeyboardFocusNode.current = node.id;\n    for (let i = 0; i < adjLinks.length; i++) {\n      object = adjLinks[i];\n      currNode = object.startNode === node.id ? object.endNode : object.startNode;\n      currNodeBB = nodeBoundsById.get(currNode);\n      currNodeBBCenterX = currNodeBB!.x + currNodeBB!.width / 2;\n      if (\n        // equivalent of ≤ and ≥\n        (event.altKey && event.code === 'Comma' && currNodeBBCenterX <= nodeCenterX) ||\n        (event.altKey && event.code === 'Period' && currNodeBBCenterX >= nodeCenterX)\n      ) {\n        link = object;\n        break;\n      }\n    }\n    return { id: link.id, isNode: false };\n  }\n\n  /**\n   * Returns the node detail when a link to node navigation occurs\n   */\n  function navigateFromLinkToNode(linkId: K2, event: KeyboardEvent) {\n    const key = event.key;\n    const linkData = linkIdToDataMap.get(linkId)!;\n    const startNodeBB = nodeBoundsById.get(linkData.startNode);\n    const endNodeBB = nodeBoundsById.get(linkData.endNode);\n    if (!startNodeBB || !endNodeBB) return undefined;\n    const startNodeCenterX = startNodeBB.x + startNodeBB.width / 2;\n    const endNodeCenterX = endNodeBB.x + endNodeBB.width / 2;\n    const newNode =\n      (endNodeCenterX > startNodeCenterX && key === 'ArrowRight') ||\n      (endNodeCenterX < startNodeCenterX && key === 'ArrowLeft')\n        ? linkData.endNode\n        : linkData.startNode;\n    return { id: newNode, isNode: true };\n  }\n\n  return {\n    isNode: (itemInfo: ItemInfo<K1, K2>): boolean => {\n      let node, link;\n      for (let i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        link = links[i];\n        if (itemInfo.id === node.id) {\n          return true;\n        }\n        if (itemInfo.id === link.id) {\n          return true;\n        }\n      }\n      return false;\n    },\n    getNextNavigableNode,\n    getNextNavigableLink,\n    navigateFromNodeToLink,\n    navigateFromLinkToNode\n  };\n}\n","import {\n  ItemInfo,\n  ItemHoverDetail,\n  ItemFocusDetail,\n  Bounds,\n  DiagramNodeData,\n  DiagramLinkData\n} from '../diagram.types';\nimport { useRef, useState } from 'preact/hooks';\nimport { isEqualItem, getNavigableInfo, zoomAndCenterItemFromInfo } from '../utils/diagramUtils';\nimport { getRandomId } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport { getNodeDetailFromInfo, getLinkDetailFromInfo } from '../utils/navUtils';\nimport { useDiagramNavigation } from './useDiagramNavigation';\nimport type { NavDirection } from '../utils/navUtils';\nimport { useVisHover } from '#hooks/PRIVATE_useVisHover';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { gestureTypes } from '#hooks/PRIVATE_useVisContextMenu';\n\nconst DEFAULT_KB_PAN = 15;\nconst DEFAULT_KB_ZOOM = 0.15;\n\nexport function useEvents<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>(\n  touchResponse: 'touchStart' | 'touchHold',\n  initNode: D1,\n  nodes: D1[],\n  links: D2[],\n  nodeBounds: Bounds[],\n  linkIdToDataMap: Map<K2, D2>,\n  nodeIdToDataMap: Map<K1, D1>,\n  nodeIdToIndexMap: Map<K1, number>,\n  width: number,\n  height: number,\n  maxZoom: number,\n  onItemHover?: (detail: ItemHoverDetail<K1, K2, D1, D2>) => void,\n  onItemFocus?: (detail: ItemFocusDetail<K1, K2, D1, D2>) => void,\n  kbPanCallback?: (props: {\n    dPan?: { dx: number; dy: number };\n    nPan?: { cx: number; cy: number };\n    center?: boolean;\n  }) => void,\n  kbZoomCallback?: (props: { dZoom?: number; nZoom?: number }) => void\n) {\n  const {\n    getNextNavigableNode,\n    getNextNavigableLink,\n    navigateFromNodeToLink,\n    navigateFromLinkToNode\n  } = useDiagramNavigation<K1, K2, D1, D2>(nodes, links, nodeBounds, linkIdToDataMap);\n  const [focusedItemInfo, setfocusedItemInfo] = useState<ItemInfo<K1, K2>>({\n    id: initNode.id,\n    isNode: true\n  });\n  const [hoveredItemInfo, sethoveredItemInfo] = useState<ItemInfo<K1, K2>>();\n  const activeId = useRef<string>();\n\n  const cancelEvent = (event: Event) => {\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const keyDownHandler = (event: KeyboardEvent) => {\n    const key = event.key;\n    let eventConsumed = false;\n    // tabbing out of the diagram\n    if (key === 'TAB') {\n      return;\n    }\n    // if this a switch from node to link or vice versa\n    if (isChangeItemType(event)) {\n      const nextItemInfo = focusedItemInfo.isNode\n        ? navigateFromNodeToLink(links, event, getNodeDetailFromInfo(focusedItemInfo, nodes))\n        : navigateFromLinkToNode(focusedItemInfo.id as K2, event);\n      handleKeyboardInput(nextItemInfo);\n      eventConsumed = true;\n    } else if (isNavigationEvent(key)) {\n      const nextItemInfo = handleKeyboardNavigationEvent(key);\n      handleKeyboardInput(nextItemInfo);\n      eventConsumed = true;\n    } else {\n      switch (key) {\n        case 'PageUp': {\n          kbPanCallback &&\n            kbPanCallback({\n              dPan: {\n                dx: event.shiftKey ? -DEFAULT_KB_PAN : 0,\n                dy: event.shiftKey ? 0 : -DEFAULT_KB_PAN\n              }\n            });\n          eventConsumed = true;\n          break;\n        }\n        case 'PageDown': {\n          kbPanCallback &&\n            kbPanCallback({\n              dPan: {\n                dx: event.shiftKey ? DEFAULT_KB_PAN : 0,\n                dy: event.shiftKey ? 0 : DEFAULT_KB_PAN\n              }\n            });\n          eventConsumed = true;\n          eventConsumed = true;\n          break;\n        }\n        case '+':\n        case '=': {\n          kbZoomCallback && kbZoomCallback({ dZoom: DEFAULT_KB_ZOOM });\n          eventConsumed = true;\n          break;\n        }\n        case '-':\n        case '_': {\n          kbZoomCallback && kbZoomCallback({ dZoom: -DEFAULT_KB_ZOOM });\n          eventConsumed = true;\n          break;\n        }\n        case '0': {\n          if (event.ctrlKey && event.altKey) {\n            const { centerX, centerY, zoom } = zoomAndCenterItemFromInfo(\n              focusedItemInfo,\n              linkIdToDataMap,\n              nodeBounds,\n              nodeIdToIndexMap,\n              width,\n              height,\n              maxZoom\n            );\n            kbZoomCallback && kbZoomCallback({ nZoom: zoom });\n            kbPanCallback && kbPanCallback({ nPan: { cx: centerX, cy: centerY } });\n          } else {\n            // zoom to fit\n            kbZoomCallback && kbZoomCallback({});\n            kbPanCallback && kbPanCallback({ center: true });\n          }\n          eventConsumed = true;\n        }\n      }\n    }\n    if (eventConsumed) {\n      cancelEvent(event);\n    }\n  };\n\n  const keyUpHandler = (event: KeyboardEvent) => {\n    const key = event.code;\n    switch (key) {\n      case 'Tab': {\n        updatefocusedItemInfo({\n          ...focusedItemInfo,\n          isCurrent: true,\n          isFocusVisible: true\n        });\n        break;\n      }\n    }\n  };\n\n  const blurHandler = () => {\n    if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {\n      onItemFocus?.({ id: undefined, data: undefined });\n    }\n    const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };\n    setfocusedItemInfo(itemInfo);\n  };\n\n  const onHover = (event: PointerEvent) => {\n    const itemInfo = getNavigableInfo<K1, K2>(event.target as HTMLElement);\n    if (itemInfo && !isEqualItem(itemInfo, hoveredItemInfo)) {\n      sethoveredItemInfo({ ...itemInfo, isCurrent: true });\n      activeId.current = getRandomId();\n      setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });\n      if (itemInfo.isNode) {\n        onItemHover?.({\n          id: itemInfo.id,\n          type: 'node',\n          data: nodeIdToDataMap.get(itemInfo.id as K1)\n        });\n      } else {\n        onItemHover?.({\n          id: itemInfo.id,\n          type: 'link',\n          data: linkIdToDataMap.get(itemInfo.id as K2)\n        });\n      }\n    }\n  };\n\n  const onHoverLeave = () => {\n    sethoveredItemInfo(undefined);\n    activeId.current = undefined;\n    onItemHover?.({ id: undefined, data: undefined });\n  };\n\n  const hoverHandlers = useVisHover(onHover, undefined, onHoverLeave, touchResponse);\n\n  const pointerUpHandler = (event: PointerEvent) => {\n    const itemInfo = getNavigableInfo<K1, K2>(event.target as HTMLElement);\n    if (itemInfo.id != null) {\n      setfocusedItemInfo(itemInfo);\n      activeId.current = getRandomId();\n    }\n  };\n\n  function updatefocusedItemInfo(itemInfo: ItemInfo<K1, K2>) {\n    if (itemInfo.isNode) {\n      onItemFocus?.({\n        id: itemInfo.id,\n        type: 'node',\n        data: nodeIdToDataMap.get(itemInfo.id as K1)\n      });\n    } else {\n      onItemFocus?.({\n        id: itemInfo.id,\n        type: 'link',\n        data: linkIdToDataMap.get(itemInfo.id as K2)\n      });\n    }\n    activeId.current = getRandomId();\n    setfocusedItemInfo(itemInfo);\n  }\n\n  function handleKeyboardInput(item?: ItemInfo<K1, K2>) {\n    if (!item) return;\n    if (!isEqualItem(item, focusedItemInfo)) {\n      item.isCurrent = true;\n      item.isFocusVisible = true;\n      if (hoveredItemInfo) {\n        sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });\n      }\n      updatefocusedItemInfo(item);\n    }\n  }\n\n  function isNavigationEvent(key: string) {\n    switch (key) {\n      case 'ArrowDown':\n      case 'ArrowUp':\n      case 'ArrowRight':\n      case 'ArrowLeft': {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function isChangeItemType(event: KeyboardEvent) {\n    const key = event.code;\n    // check if switching from node to link\n    // equivalent of ≤ and ≥\n    if (focusedItemInfo.isNode && event.altKey && (key === 'Period' || key === 'Comma')) {\n      return true;\n      // check if switching from link to node\n    } else if (!focusedItemInfo.isNode && (key === 'ArrowLeft' || key === 'ArrowRight')) {\n      return true;\n    }\n    return false;\n  }\n\n  function handleKeyboardNavigationEvent(key: string) {\n    let direction: NavDirection = 'down';\n    switch (key) {\n      case 'ArrowDown': {\n        direction = 'down';\n        break;\n      }\n      case 'ArrowUp': {\n        direction = 'up';\n        break;\n      }\n      case 'ArrowRight': {\n        direction = 'right';\n        break;\n      }\n      case 'ArrowLeft': {\n        direction = 'left';\n        break;\n      }\n    }\n    if (focusedItemInfo.isNode) {\n      const itemDetail = getNextNavigableNode(\n        direction,\n        true,\n        getNodeDetailFromInfo(focusedItemInfo, nodes),\n        nodes\n      );\n      return itemDetail ? { id: itemDetail.id, isNode: true } : focusedItemInfo;\n    } else {\n      const linkDetail = getLinkDetailFromInfo(focusedItemInfo, links);\n      const itemDetail = getNextNavigableLink(direction, nodes, linkDetail, links);\n      return itemDetail ? { id: itemDetail.id } : { id: focusedItemInfo.id };\n    }\n  }\n\n  const onContextMenuDismissed = (gesture: gestureTypes) => {\n    if (gesture === 'keyboard') {\n      updatefocusedItemInfo({\n        ...focusedItemInfo,\n        isFocusVisible: true,\n        isCurrent: true\n      });\n    }\n  };\n  return {\n    focusedItemInfo,\n    hoveredItemInfo,\n    activeId: activeId.current,\n    onContextMenuDismissed,\n    eventsProps: mergeProps(hoverHandlers, {\n      onKeyUp: keyUpHandler,\n      onKeyDown: keyDownHandler,\n      onBlur: blurHandler,\n      onPointerUp: pointerUpHandler\n    })\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  ItemInfo,\n  Bounds,\n  DatatipContext,\n  DiagramNodeData,\n  DiagramLinkData\n} from '../diagram.types';\nimport type { RefObject } from 'preact';\nimport { useDatatip } from '#hooks/PRIVATE_useDatatip';\nimport { calculateOffset } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport type { Pan } from '../utils/panUtils';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { getDatatipContent } from '../utils/diagramUtils';\nimport { ComponentChildren } from 'preact';\nimport { Property } from 'csstype';\n\ntype props<K1, K2, D1, D2> = {\n  touchResponse: 'touchStart' | 'touchHold';\n  datatip?: (context: DatatipContext<D1, D2>) => {\n    content: ComponentChildren;\n    borderColor?: Property.BorderColor;\n  };\n  text?: string;\n  focusedItemInfo: ItemInfo<K1, K2>;\n  focusedItemBoundsRef: RefObject<Bounds | null>;\n  panState: Pan;\n  zoom: number;\n  width: number;\n  nodesMap: Map<K1, D1>;\n  linksMap: Map<K2, D2>;\n  hoveredItem?: ItemInfo<K1, K2>;\n};\n\n/**\n * Returns the datatip.\n * @param text The text string for the diagram item.\n * @param rootRef The ref for root of the diagram.\n * @param focusedItemBoundsRef The ref for focused item bounds.\n * @param focusedItemInfo The ItemInfo for focused item.\n * @returns\n */\nexport const useDiagramDatatip = <\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>({\n  touchResponse,\n  datatip,\n  focusedItemBoundsRef,\n  focusedItemInfo,\n  panState,\n  zoom,\n  width,\n  nodesMap,\n  linksMap,\n  hoveredItem\n}: props<K1, K2, D1, D2>) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const datatipC = getDatatipContent(nodesMap, linksMap, focusedItemInfo, hoveredItem, datatip);\n\n  const elementBounds = focusedItemBoundsRef.current\n    ? {\n        x: focusedItemBoundsRef.current.x * zoom + panState.panX,\n        y: focusedItemBoundsRef.current.y * zoom + panState.panY,\n        width: focusedItemBoundsRef.current.width * zoom,\n        height: focusedItemBoundsRef.current.height * zoom\n      }\n    : undefined;\n  const offset = focusedItemInfo.isCurrent\n    ? calculateOffset(isRtl, width, elementBounds)\n    : calculateOffset(isRtl, width);\n\n  const { datatipContent, datatipProps } = useDatatip({\n    content: datatipC?.content,\n    borderColor: datatipC?.borderColor,\n    placement: 'top-start',\n    offset,\n    anchor: focusedItemInfo?.isCurrent ? 'element' : 'pointer',\n    touchResponse\n  });\n  return { datatipContent: datatipContent, datatipProps: datatipProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useRef } from 'preact/hooks';\n\ntype PointerGesture = {\n  pointers: PointerEvent[];\n};\n\ntype UsePointerGestureOptions = {\n  captureTargetRef: RefObject<HTMLDivElement>;\n  numPointers: number;\n  onPointerGestureDown?: (detail: PointerGesture) => void;\n  onPointerGestureMove?: (detail: PointerGesture) => void;\n  onPointerGestureEnd?: (detail: PointerGesture) => void;\n  onExtraneousPointerDown?: (detail: PointerGesture) => void;\n  isDisabled?: boolean;\n};\n\nconst usePointerGesture = ({\n  captureTargetRef,\n  numPointers = 1,\n  onPointerGestureDown,\n  onPointerGestureMove,\n  onPointerGestureEnd,\n  onExtraneousPointerDown,\n  isDisabled = false\n}: UsePointerGestureOptions) => {\n  const activePointers = useRef<PointerEvent[]>([]);\n\n  if (isDisabled) {\n    activePointers.current = [];\n  }\n\n  const onPointerDown = (e: PointerEvent) => {\n    activePointers.current.push(e);\n    if (activePointers.current.length === numPointers) {\n      onPointerGestureDown && onPointerGestureDown({ pointers: activePointers.current });\n    } else if (activePointers.current.length > numPointers) {\n      onExtraneousPointerDown && onExtraneousPointerDown({ pointers: activePointers.current });\n    }\n  };\n\n  const onPointerMove = (e: PointerEvent) => {\n    if (activePointers.current.length === 0) return;\n\n    const index = activePointers.current.findIndex(\n      (pointerEvent) => pointerEvent.pointerId === e.pointerId\n    );\n    if (index === -1) return;\n\n    activePointers.current[index] = e;\n    if (activePointers.current.length === numPointers) {\n      activePointers.current.forEach((e) =>\n        captureTargetRef.current!.setPointerCapture(e.pointerId)\n      );\n\n      onPointerGestureMove && onPointerGestureMove({ pointers: activePointers.current });\n    }\n  };\n\n  const onPointerUp = (e: PointerEvent) => {\n    const index = activePointers.current.findIndex(\n      (pointerEvent) => pointerEvent.pointerId === e.pointerId\n    );\n    if (index === -1) return;\n\n    activePointers.current[index] = e;\n    if (activePointers.current.length === numPointers) {\n      onPointerGestureEnd && onPointerGestureEnd({ pointers: activePointers.current });\n    }\n    activePointers.current.splice(index, 1);\n  };\n\n  const onPointerCancel = onPointerUp;\n  const onPointerLeave = onPointerUp;\n\n  return isDisabled\n    ? {}\n    : {\n        onPointerDown,\n        onPointerMove,\n        onPointerUp,\n        onPointerCancel,\n        onPointerLeave\n      };\n};\n\nexport { usePointerGesture };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Bounds, PanState } from '../diagram.types';\nimport { panXYToCenterXY } from './diagramUtils';\nexport type PanBounds = {\n  minX: number;\n  minY: number;\n  maxX: number;\n  maxY: number;\n};\n\n/**\n * The pan values that describes where the diagram content\n * is panned\n */\nexport type Pan = {\n  panX: number;\n  panY: number;\n};\n\nconst constrainPan = (\n  previousPan: Pan,\n  nextPan: Pan,\n  panBounds: PanBounds,\n  panDirection: 'x' | 'y' | 'any'\n) => {\n  const panX = panDirection !== 'y' ? nextPan.panX : previousPan.panX;\n  const panY = panDirection !== 'x' ? nextPan.panY : previousPan.panY;\n  return {\n    panX: panX > panBounds.maxX ? panBounds.maxX : panX < panBounds.minX ? panBounds.minX : panX,\n    panY: panY > panBounds.maxY ? panBounds.maxY : panY < panBounds.minY ? panBounds.minY : panY\n  };\n};\n\nexport const pan = (\n  previousPan: Pan,\n  nextPan: Pan,\n  panDirection: 'x' | 'y' | 'any',\n  zoom: number,\n  width: number,\n  height: number,\n  panBounds?: PanBounds,\n  onPanChange?: (detail: PanState) => void\n) => {\n  if (!panBounds) {\n    //On initial render before nodes are rendered\n    return { newPan: { panX: 0, panY: 0 } };\n  }\n  const newPan = constrainPan(previousPan, nextPan, panBounds, panDirection);\n  const isPanChanged = newPan.panX !== previousPan.panX || newPan.panY !== previousPan.panY;\n  const center = panXYToCenterXY(newPan.panX, newPan.panY, zoom, width, height);\n  isPanChanged &&\n    onPanChange &&\n    onPanChange({\n      centerX: center.centerX,\n      centerY: center.centerY\n    });\n  return { newPan };\n};\n\nexport const getPanBounds = (\n  widthArg: number,\n  heightArg: number,\n  elemBounds: Bounds,\n  zoom: number,\n  minZoom: number,\n  initPanZoomState: {\n    zoom: number;\n    centerX?: number;\n    centerY?: number;\n  },\n  panType?: string\n): PanBounds => {\n  const { x, y, width, height } = elemBounds;\n  let minX, maxX, minY, maxY;\n  if (panType === 'centerContent') {\n    minX = widthArg / 2 - (width + x) * zoom;\n    minY = heightArg / 2 - (height + y) * zoom;\n    maxX = widthArg / 2 - x * zoom;\n    maxY = heightArg / 2 - y * zoom;\n  } else {\n    // panType equals fixed\n    const zoomRatio = zoom / minZoom;\n    // Find left corner of the content at min zoom and content is centered\n    const minZoomX = (widthArg - width * minZoom) / 2 - x * minZoom;\n    const minZoomY = (heightArg - height * minZoom) / 2 - y * minZoom;\n    // When we pan all the way to the right, the left corner of displayable area is 0,0 as in min zoom.\n    // When we pan all the way to the left, lets find the corner of the displayable area\n    const leftCornerX = widthArg - width * zoomRatio;\n    const leftCornerY = heightArg - height * zoomRatio;\n    // Now we have everything to calculate pan zoom constraints\n    minX = leftCornerX + minZoomX * zoomRatio;\n    minY = leftCornerY + minZoomY * zoomRatio;\n    maxX = minZoomX * zoomRatio;\n    maxY = minZoomY * zoomRatio;\n  }\n  const initZoom = initPanZoomState.zoom;\n  const initCenterX = initPanZoomState.centerX;\n  const initCenterY = initPanZoomState.centerY;\n  // If an initial panZoomState is set, should expand pan bounds to include it\n  let dx, dy;\n  if (initCenterX) {\n    const boundsX = initCenterX * initZoom - widthArg / 2;\n    if (-boundsX * initZoom < minX) {\n      dx = minX - boundsX * initZoom;\n      minX -= dx;\n      maxX += dx;\n    } else if (-boundsX * initZoom > maxX) {\n      dx = -boundsX * initZoom - maxX;\n      minX -= dx;\n      maxX += dx;\n    }\n  }\n  if (initCenterY) {\n    const boundsY = initCenterY * initZoom - heightArg / 2;\n    if (-boundsY * initZoom < minY) {\n      dy = minY - boundsY * initZoom;\n      minY -= dy;\n      maxY += dy;\n    } else if (-boundsY * initZoom > maxY) {\n      dy = -boundsY * initZoom - maxY;\n      minY -= dy;\n      maxY += dy;\n    }\n  }\n  return {\n    minX: minX,\n    maxX: maxX,\n    minY: minY,\n    maxY: maxY\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { PanState } from '../diagram.types';\nimport type { RefObject } from 'preact';\nimport { useRef } from 'preact/hooks';\nimport { useDrag } from './useDrag';\nimport { PanBounds, pan } from '../utils/panUtils';\nimport { centerXYToPanXY } from '../utils/diagramUtils';\n/**\n * Options for useDragPan hook\n */\ntype UseDragPanOptions = {\n  panProps: {\n    centerX: number;\n    centerY: number;\n    panDirection: 'x' | 'y' | 'any';\n    onPan?: (detail: PanState) => void;\n    panning?: 'centerContent' | 'fixed' | 'off';\n  };\n  captureTargetRef: RefObject<HTMLDivElement>;\n  panBounds?: PanBounds;\n  onDragPanStart?: () => void;\n  onDragPanEnd?: () => void;\n  zoom: number;\n  width: number;\n  height: number;\n};\n\nconst useDragPan = ({\n  panProps,\n  captureTargetRef,\n  panBounds,\n  width,\n  height,\n  zoom,\n  onDragPanStart,\n  onDragPanEnd\n}: UseDragPanOptions) => {\n  const prevPanState = useRef({ panX: 0, panY: 0 });\n  const initialPanState = useRef({ panX: 0, panY: 0 });\n  const dragProps = useDrag({\n    captureTargetRef,\n    onDragStart: () => {\n      const panValues = centerXYToPanXY(panProps.centerX, panProps.centerY, zoom, width, height);\n      initialPanState.current = {\n        panX: panValues.panX,\n        panY: panValues.panY\n      };\n      onDragPanStart && onDragPanStart();\n    },\n    onDragMove: ({ dx, dy }) => {\n      const nextPan = {\n        panX: initialPanState.current.panX + dx,\n        panY: initialPanState.current.panY + dy\n      };\n      const { newPan } = pan(\n        prevPanState.current,\n        nextPan,\n        panProps.panDirection,\n        zoom,\n        width,\n        height,\n        panBounds,\n        panProps.onPan\n      );\n      prevPanState.current = newPan;\n    },\n    onDragEnd: ({ originalEvent }) => {\n      // If panning occurred, call preventDefault to prevent selection from occurring\n      if (\n        initialPanState.current.panX !== prevPanState.current.panX ||\n        initialPanState.current.panY !== prevPanState.current.panY\n      )\n        originalEvent.preventDefault();\n      onDragPanEnd && onDragPanEnd();\n    },\n    isDisabled: panProps.panning === 'off'\n  });\n\n  return dragProps;\n};\n\nexport { useDragPan };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useRef } from 'preact/hooks';\nimport { usePointerGesture } from './usePointerGesture';\n/**\n * Draggable region\n */\ntype DraggableRegion = {\n  xMin: number;\n  xMax: number;\n  yMin: number;\n  yMax: number;\n};\n\ntype DragDetail = {\n  x: number;\n  y: number;\n  dx: number;\n  dy: number;\n  regionOffsetX: number;\n  regionOffsetY: number;\n  originalEvent: PointerEvent;\n};\n\ntype UseDragOptions = {\n  captureTargetRef: RefObject<HTMLDivElement>;\n  draggableRegion?: DraggableRegion;\n  onDragStart?: (detail: Omit<DragDetail, 'dx' | 'dy'>) => void;\n  onDragMove?: (detail: DragDetail) => void;\n  onDragEnd?: (detail: DragDetail) => void;\n  isDisabled?: boolean;\n};\n/**\n * Whether point with coordinates are in the draggable region\n */\nconst inDraggableRegion = (x: number, y: number, region?: DraggableRegion) => {\n  if (!region) return true;\n  const { xMin, xMax, yMin, yMax } = region;\n  return x >= xMin && x <= xMax && y >= yMin && y <= yMax;\n};\n\n/**\n * Returns region offset\n */\nconst getRegionOffset = (x: number, y: number, region?: DraggableRegion) => {\n  if (!region) return { regionOffsetX: x, regionOffsetY: y };\n  return { regionOffsetX: x - region.xMin, regionOffsetY: y - region.yMin };\n};\n\nconst useDrag = ({\n  captureTargetRef,\n  draggableRegion,\n  onDragStart,\n  onDragMove,\n  onDragEnd,\n  isDisabled = false\n}: UseDragOptions) => {\n  const inactiveState = { isDragging: false, x0: -1, y0: -1, regionOffsetX: -1, regionOffsetY: -1 };\n  const dragState = useRef(inactiveState);\n\n  const handlePointerEvent = (e: PointerEvent, cb?: (detail: DragDetail) => void) => {\n    const { isDragging, x0, y0, regionOffsetX, regionOffsetY } = dragState.current;\n    if (!isDragging) return;\n    const x = e.pageX;\n    const y = e.pageY;\n    cb && cb({ x, y, dx: x - x0, dy: y - y0, regionOffsetX, regionOffsetY, originalEvent: e });\n  };\n\n  const dragProps = usePointerGesture({\n    captureTargetRef,\n    numPointers: 1, // Only allow 1 pointer dragging\n    onExtraneousPointerDown: () => {\n      dragState.current = inactiveState;\n    },\n    onPointerGestureDown: ({ pointers: [e] }) => {\n      const x = e.pageX;\n      const y = e.pageY;\n      if (e.button !== 0 || !inDraggableRegion(x, y, draggableRegion)) return;\n      const { regionOffsetX, regionOffsetY } = getRegionOffset(x, y, draggableRegion);\n      dragState.current = { isDragging: true, x0: x, y0: y, regionOffsetX, regionOffsetY };\n      onDragStart && onDragStart({ x, y, regionOffsetX, regionOffsetY, originalEvent: e });\n    },\n    onPointerGestureMove: ({ pointers: [e] }) => {\n      handlePointerEvent(e, onDragMove);\n    },\n    onPointerGestureEnd: ({ pointers: [e] }) => {\n      handlePointerEvent(e, onDragEnd);\n      dragState.current = inactiveState;\n    }\n  });\n\n  return isDisabled ? {} : dragProps;\n};\n\nexport { useDrag };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport const ZOOM_INCREMENT = 0.05;\n\nexport const zoom = (\n  nextZoom: number,\n  zoom: number,\n  minZoom: number,\n  maxZoom: number,\n  onZoomChange?: (detail: { zoomValue: number }) => void\n) => {\n  const newZoom = nextZoom > maxZoom || nextZoom < minZoom ? zoom : nextZoom;\n  const isZoomChanged = newZoom !== zoom;\n  isZoomChanged &&\n    onZoomChange &&\n    onZoomChange({\n      zoomValue: newZoom\n    });\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useRef } from 'preact/hooks';\nimport { usePointerGesture } from './usePointerGesture';\n\ntype Point = { x: number; y: number };\n\nconst getMidpoint = (p1: Point, p2: Point) => ({ x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 });\nconst getDistance = (p1: Point, p2: Point) => Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p2.y) ** 2);\n\ntype PinchDetail = {\n  origin: Point;\n  delta: number;\n};\n\ntype UsePinchOptions = {\n  captureTargetRef: RefObject<HTMLDivElement>;\n  onPinchZoomStart?: (detail: PinchDetail) => void;\n  onPinchZoomChange?: (detail: PinchDetail) => void;\n  onPinchZoomEnd?: () => void;\n  isDisabled?: boolean;\n};\n\nconst usePinch = ({\n  captureTargetRef,\n  onPinchZoomStart,\n  onPinchZoomChange,\n  onPinchZoomEnd,\n  isDisabled = false\n}: UsePinchOptions) => {\n  const origin = useRef({ x: -1, y: -1 });\n  const prevDistance = useRef(-1);\n  const reset = () => {\n    origin.current = { x: -1, y: -1 };\n    prevDistance.current = -1;\n  };\n\n  if (isDisabled) reset();\n\n  const pinchProps = usePointerGesture({\n    captureTargetRef,\n    numPointers: 2, // Pinch gesture requires 2 pointers\n    onPointerGestureDown: ({ pointers: [pointer1, pointer2] }) => {\n      const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };\n      const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };\n      origin.current = getMidpoint(p1, p2);\n      prevDistance.current = getDistance(p1, p2);\n      onPinchZoomStart &&\n        onPinchZoomStart({\n          origin: origin.current,\n          delta: 0\n        });\n    },\n    onPointerGestureMove: ({ pointers: [pointer1, pointer2] }) => {\n      const p1 = { x: pointer1.offsetX, y: pointer1.offsetY };\n      const p2 = { x: pointer2.offsetX, y: pointer2.offsetY };\n      const distance = getDistance(p1, p2);\n      const delta = distance - prevDistance.current;\n      prevDistance.current = distance;\n      onPinchZoomChange &&\n        onPinchZoomChange({\n          origin: origin.current,\n          delta\n        });\n    },\n    onPointerGestureEnd: () => {\n      reset();\n      onPinchZoomEnd && onPinchZoomEnd();\n    }\n  });\n\n  return isDisabled ? {} : pinchProps;\n};\n\nexport { usePinch };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { usePinch } from './usePinch';\nimport { zoom, ZOOM_INCREMENT } from '../utils/zoomUtils';\n\ntype UsePinchZoomOptions = {\n  captureTargetRef: RefObject<HTMLDivElement>;\n  zooming: 'on' | 'off';\n  minZoom: number;\n  maxZoom: number;\n  zoomValue: number;\n  onZoom?: (detail: { zoomValue: number }) => void;\n};\n\nconst usePinchZoom = ({\n  captureTargetRef,\n  zooming,\n  minZoom,\n  maxZoom,\n  zoomValue,\n  onZoom\n}: UsePinchZoomOptions) => {\n  const pinchProps = usePinch({\n    captureTargetRef,\n    onPinchZoomChange: ({ delta }) => {\n      const newZoom = zoomValue * (1 + ZOOM_INCREMENT * delta);\n      zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);\n    },\n    isDisabled: zooming === 'off'\n  });\n\n  return pinchProps;\n};\n\nexport { usePinchZoom };\n","import { Pan, Zoom, Bounds } from '../diagram.types';\nimport type { RefObject } from 'preact';\nimport { useState, useRef } from 'preact/hooks';\nimport { useDragPan } from './useDragPan';\nimport { useWheelZoom } from './useWheelZoom';\nimport { usePinchZoom } from './usePinchZoom';\nimport {\n  centerXYToPanXY,\n  getPanProps,\n  getZoomProps,\n  getZoomToFitZoom\n} from '../utils/diagramUtils';\nimport { PanBounds, getPanBounds, pan } from '../utils/panUtils';\nimport { zoom } from '../utils/zoomUtils';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { isTouch } from '#utils/UNSAFE_visUtils/clientUtils';\nimport { Property } from 'csstype';\nimport { useVisDragModeControls } from '#hooks/PRIVATE_useVisDragModeControls';\n\nexport type PanZoomProps = {\n  props: Pan & Zoom;\n  captureTargetRef: RefObject<HTMLDivElement>;\n  width: number;\n  height: number;\n  contentBounds: Bounds;\n  isRtl: boolean;\n};\n\nexport const usePanZoom = ({\n  props,\n  captureTargetRef,\n  width,\n  height,\n  contentBounds,\n  isRtl\n}: PanZoomProps) => {\n  const [cursor, setCursor] = useState<Property.Cursor>();\n  const zoomProps = getZoomProps(props, width, height, contentBounds);\n  const panBounds = useRef<PanBounds>();\n  const prevZoom = useRef<number>();\n  const panning = useRef<string>();\n  const initPanZoomState = useRef({\n    zoom: props.zoomValue || 0,\n    centerX: props.centerX,\n    centerY: props.centerY\n  });\n\n  const isDeviceTouch = isTouch();\n  const plotArea = {\n    width: width,\n    height: height,\n    x: 0,\n    y: 0\n  };\n\n  const showPanButton = isDeviceTouch ? props.panning && props.panning !== 'off' : undefined;\n  const dragModeOptions = {\n    isZoomScroll: true,\n    plotAreaSpace: plotArea,\n    componentWidth: width,\n    isRtl,\n    showPanButton: showPanButton ?? false,\n    showZoomButton: false,\n    showSelectButton: false,\n    isDisabled: !isDeviceTouch\n  };\n\n  const { toggleButtonContent, userDragMode } = useVisDragModeControls(dragModeOptions);\n  const panProps = getPanProps(props, contentBounds, userDragMode, isDeviceTouch);\n  if (\n    contentBounds.width !== Infinity &&\n    (zoomProps.zoomValue !== prevZoom.current || panProps.panning !== panning.current)\n  ) {\n    panBounds.current = getPanBounds(\n      width,\n      height,\n      contentBounds,\n      zoomProps.zoomValue,\n      zoomProps.minZoom,\n      initPanZoomState.current,\n      panProps.panning\n    );\n    prevZoom.current = zoomProps.zoomValue;\n    panning.current = panProps.panning;\n  }\n  const dragPanProps = useDragPan({\n    panProps: panProps,\n    captureTargetRef: captureTargetRef,\n    panBounds: panBounds.current,\n    zoom: zoomProps.zoomValue,\n    width,\n    height,\n    onDragPanStart: () => setCursor('grabbing'),\n    onDragPanEnd: () => setCursor('auto')\n  });\n  //dZoom or nZoom is required\n  const kbZoomCallback = (props: { dZoom?: number; nZoom?: number }) => {\n    const newZoom = props.dZoom\n      ? zoomProps.zoomValue + props.dZoom\n      : getZoomToFitZoom(width, height, contentBounds);\n    zoom(\n      props.nZoom ? props.nZoom : newZoom,\n      zoomProps.zoomValue,\n      zoomProps.minZoom,\n      zoomProps.maxZoom,\n      zoomProps.onZoom\n    );\n  };\n  const prevPanState = useRef({ panX: 0, panY: 0 });\n\n  // dPan or nPan is required\n  const kbPanCallback = (props: {\n    dPan?: { dx: number; dy: number };\n    nPan?: { cx: number; cy: number };\n    center?: boolean;\n  }) => {\n    let centerX;\n    let centerY;\n    if (props.center) {\n      centerX = contentBounds.x + contentBounds.width / 2;\n      centerY = contentBounds.y + contentBounds.height / 2;\n    } else if (props.dPan) {\n      centerX = panProps.centerX + props.dPan.dx;\n      centerY = panProps.centerY + props.dPan.dy;\n    } else {\n      centerX = props.nPan!.cx;\n      centerY = props.nPan!.cy;\n    }\n    const panValues = centerXYToPanXY(centerX, centerY, zoomProps.zoomValue, width, height);\n    const { newPan } = pan(\n      prevPanState.current,\n      panValues,\n      panProps.panDirection,\n      zoomProps.zoomValue,\n      width,\n      height,\n      panBounds.current,\n      panProps.onPan\n    );\n    prevPanState.current = newPan;\n  };\n  const wheelZoomProps = useWheelZoom(zoomProps);\n  const pinchZoomProps = usePinchZoom({\n    captureTargetRef,\n    zooming: zoomProps.zooming,\n    minZoom: zoomProps.minZoom,\n    maxZoom: zoomProps.maxZoom,\n    zoomValue: zoomProps.zoomValue,\n    onZoom: zoomProps.onZoom\n  });\n  const panZoomProps = mergeProps(dragPanProps, wheelZoomProps, pinchZoomProps);\n\n  return {\n    panZoomProps,\n    panProps,\n    zoomProps,\n    toggleButtonContent,\n    cursor,\n    centerX: panProps.centerX,\n    centerY: panProps.centerY,\n    zoomValue: zoomProps.zoomValue,\n    kbPanCallback: panProps.panning !== 'off' ? kbPanCallback : undefined,\n    kbZoomCallback: zoomProps.zooming !== 'off' ? kbZoomCallback : undefined\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useWheel } from './useWheel';\nimport { zoom, ZOOM_INCREMENT } from '../utils/zoomUtils';\n\ntype UseWheelZoomOptions = {\n  zooming: 'on' | 'off';\n  minZoom: number;\n  maxZoom: number;\n  zoomValue: number;\n  onZoom?: (detail: { zoomValue: number }) => void;\n};\n\nconst useWheelZoom = ({ zooming, minZoom, maxZoom, zoomValue, onZoom }: UseWheelZoomOptions) => {\n  const wheelProps = useWheel({\n    onWheel: ({ deltaY }) => {\n      const newZoom = zoomValue * (1 + ZOOM_INCREMENT * deltaY);\n      zoom(newZoom, zoomValue, minZoom, maxZoom, onZoom);\n    },\n    isDisabled: zooming === 'off'\n  });\n\n  return wheelProps;\n};\n\nexport { useWheelZoom };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\ntype WheelDetail = {\n  x: number;\n  y: number;\n  deltaX: number;\n  deltaY: number;\n  ctrlKey: boolean;\n};\n\ntype UseWheelOptions = {\n  onWheel: (detail: WheelDetail) => void;\n  preventDefault?: boolean;\n  isDisabled?: boolean;\n};\n\nconst PX_FACTOR_PER_LINE = 15; // Value used in Toolkit\nconst PX_FACTOR_PER_PAGE = 40; // Value copied from datagrid; this is not handled in Toolkit\n\nconst getNormalizedDelta = (e: WheelEvent) => {\n  const { deltaX, deltaY, deltaMode } = e;\n\n  switch (deltaMode) {\n    case e.DOM_DELTA_PIXEL:\n      return { deltaX: -deltaX, deltaY: -deltaY };\n    case e.DOM_DELTA_LINE:\n      return { deltaX: -deltaX * PX_FACTOR_PER_LINE, deltaY: -deltaY * PX_FACTOR_PER_LINE };\n    case e.DOM_DELTA_PAGE:\n      return { deltaX: -deltaX * PX_FACTOR_PER_PAGE, deltaY: -deltaY * PX_FACTOR_PER_PAGE };\n    default:\n      return { deltaX: -deltaX, deltaY: -deltaY };\n  }\n};\n\nconst useWheel = ({\n  onWheel: onWheelCallback,\n  preventDefault = true,\n  isDisabled = false\n}: UseWheelOptions) => {\n  const onWheel = (e: WheelEvent) => {\n    const { deltaX, deltaY } = getNormalizedDelta(e);\n    if (preventDefault) e.preventDefault();\n    onWheelCallback({\n      x: e.offsetX,\n      y: e.offsetY,\n      deltaX,\n      deltaY,\n      ctrlKey: e.ctrlKey || e.metaKey\n    });\n  };\n  return isDisabled ? {} : { onWheel };\n};\n\nexport { useWheel, PX_FACTOR_PER_LINE };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  DiagramProps,\n  Bounds,\n  DiagramLabelPosition,\n  States,\n  DiagramNodeData,\n  DiagramLinkData,\n  DiagramLayoutOutput\n} from './diagram.types';\nimport type { TextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { DiagramLayers } from './DiagramLayers';\nimport { DiagramPanZoomContainer } from './DiagramPanZoomContainer';\nimport { useEvents } from './hooks/useEvents';\nimport { useDiagramDatatip } from './hooks/useDiagramDatatip';\nimport { useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { usePanZoom } from './hooks/usePanZoom';\nimport { useRef, useState } from 'preact/hooks';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useDiagramSelection } from './hooks/useDiagramSelection';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport {\n  constructLayoutJSON,\n  deconstructLayoutJSON,\n  createItemMap,\n  getFocusedItemBounds,\n  mergeDimensions,\n  isEqualBounds,\n  getDimensionsFromBounds,\n  combineIds,\n  getContentBounds,\n  centerXYToPanXY,\n  filterLinksWithNoEndNodes,\n  getAllLabelBounds\n} from './utils/diagramUtils';\nimport { outerStyles } from './themes/DiagramStyles.css';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { merge } from '@oracle/oraclejet-internal-utilities/stringUtils';\nimport { useDiagramContextMenu } from './hooks/useDiagramContextMenu';\n\ntype DiagramWithDimensionsProps<K1, K2, D1, D2, L> = Omit<\n  DiagramProps<K1, K2, D1, D2, L>,\n  'width' | 'height'\n> & {\n  width: number;\n  height: number;\n};\n\nexport function DiagramWithDimensions<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1> = DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1> = DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2> = DiagramLayoutOutput<K1, K2>\n>({\n  nodes = [],\n  links = [],\n  width,\n  height,\n  selectedIds = {},\n  selectionMode = 'none',\n  layout,\n  nodeRenderer,\n  linkRenderer,\n  onSelectionChange,\n  onItemHover,\n  onItemFocus,\n  highlightedIds = {},\n  datatip,\n  contextMenuConfig,\n  ...otherProps\n}: DiagramWithDimensionsProps<K1, K2, D1, D2, L>) {\n  const focusedItemBoundsRef = useRef<Bounds | null>(null);\n  const rootRef = useRef<HTMLDivElement>(null);\n  //TODO JET-62563 change bounds to a MAP\n  const [bounds, setBounds] = useState<Bounds[]>([]);\n\n  const [combinedLabelBounds, setCombinedLabelBounds] = useState<Bounds>();\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const diagramNodes = nodes;\n  const nodeMap = createItemMap<K1, K2, D1, D2>(diagramNodes);\n  const nodeIdToDataMap = nodeMap.itemIdToDataMap;\n  const diagramLinks = filterLinksWithNoEndNodes(links, nodeIdToDataMap);\n  const linkMap = createItemMap<K1, K2, D1, D2>(diagramLinks);\n  const linkIdToDataMap = linkMap.itemIdToDataMap;\n  const resizeThrottling = useRef<boolean>(false);\n  const newDimensions = getDimensionsFromBounds(bounds);\n  const { textMeasureContent, getTextDimensions } = useTextDimensions();\n  const labelDimensions = useRef<Map<K1 | K2, TextDimensions>>(new Map());\n  const nodeLabelPosRef = useRef<(DiagramLabelPosition | undefined)[] | undefined>([]);\n  const linkLabelPosRef = useRef<(DiagramLabelPosition | undefined)[] | undefined>([]);\n  const layoutOutputRef = useRef<L>();\n\n  const contentBounds = getContentBounds(bounds, combinedLabelBounds);\n  const {\n    panZoomProps,\n    panProps,\n    zoomProps,\n    toggleButtonContent,\n    cursor,\n    centerX,\n    centerY,\n    zoomValue,\n    kbPanCallback,\n    kbZoomCallback\n  } = usePanZoom({\n    props: otherProps,\n    captureTargetRef: rootRef,\n    width: width,\n    height: height,\n    contentBounds,\n    isRtl\n  });\n\n  const { touchResponse, touchResponseStyle } = useVisTouchResponse({\n    type: 'auto',\n    supportsTouchDragGestures: zoomProps.zooming === 'on' || panProps.panning !== 'off',\n    rootRef\n  });\n\n  const { onContextMenuDismissed, focusedItemInfo, hoveredItemInfo, activeId, eventsProps } =\n    useEvents<K1, K2, D1, D2>(\n      touchResponse,\n      diagramNodes[0],\n      diagramNodes,\n      diagramLinks,\n      bounds,\n      linkIdToDataMap,\n      nodeIdToDataMap,\n      nodeMap.itemIdToIndexMap,\n      width,\n      height,\n      otherProps.maxZoom || 1,\n      onItemHover,\n      onItemFocus,\n      kbPanCallback,\n      kbZoomCallback\n    );\n\n  const { selectionProps, selectionContent } = useDiagramSelection<K1, K2, D1, D2>({\n    selectedIds,\n    selectionMode,\n    nodeMap,\n    linkMap,\n    focusedItemInfo,\n    onSelectionChange,\n    rootRef\n  });\n\n  // This is for the datatip kb position\n  if (focusedItemInfo && bounds.length > 0) {\n    focusedItemBoundsRef.current = getFocusedItemBounds(\n      focusedItemInfo,\n      bounds,\n      diagramLinks,\n      nodeMap.itemIdToIndexMap,\n      linkMap.itemIdToIndexMap\n    );\n  }\n\n  const {\n    datatipContent,\n    datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps }\n  } = useDiagramDatatip({\n    touchResponse,\n    datatip,\n    focusedItemInfo,\n    focusedItemBoundsRef,\n    panState: centerXYToPanXY(centerX, centerY, zoomValue, width, height),\n    zoom: zoomValue,\n    width: width,\n    nodesMap: nodeIdToDataMap,\n    linksMap: linkIdToDataMap,\n    hoveredItem: hoveredItemInfo\n  });\n\n  const style = {\n    width: width,\n    height: height,\n    cursor: cursor,\n    ...touchResponseStyle\n  };\n\n  const states = useRef<States<K1, K2>>();\n  const previousState = states.current // states.current is previous state\n    ? states.current\n    : {\n        selectedNodeIds: [],\n        selectedLinkIds: [],\n        focusedId: undefined,\n        hoveredId: undefined,\n        activeId: undefined,\n        highlightedIds: [],\n        zoom: 0\n      };\n\n  states.current = {\n    // update states to new state\n    selectedNodeIds: selectedIds.nodes ?? [],\n    selectedLinkIds: selectedIds.links ?? [],\n    focusedId:\n      focusedItemInfo.isCurrent && focusedItemInfo.isFocusVisible ? focusedItemInfo.id : undefined,\n    hoveredId: hoveredItemInfo?.isCurrent ? hoveredItemInfo.id : undefined,\n    activeId,\n    highlightedIds: combineIds(highlightedIds.nodes, highlightedIds.links),\n    zoom: zoomValue\n  };\n\n  const { contextMenuContent, contextMenuProps } = useDiagramContextMenu<K1, K2, D1, D2>({\n    focusedItemInfo,\n    rootRef,\n    contextMenuConfig: nodes.length > 0 ? contextMenuConfig : undefined,\n    onContextMenuDismissed,\n    nodesMap: nodeIdToDataMap,\n    linksMap: linkIdToDataMap\n  });\n\n  const mergedEventProps = mergeProps(\n    panZoomProps,\n    eventsProps,\n    selectionProps,\n    datatipProps,\n    contextMenuProps\n  );\n\n  // Called anytime node changes size\n  const onNodeSizeChanged = (nodeWidth: number, nodeHeight: number, idx: number) => {\n    newDimensions[idx] = { width: nodeWidth, height: nodeHeight };\n    if (resizeThrottling.current) {\n      return;\n    }\n\n    resizeThrottling.current = true;\n    // performs layout at the next available animation frame when all measurements should be ready\n    window.requestAnimationFrame(() => {\n      const { labelDims, layoutJSON } = constructLayoutJSON(\n        diagramNodes,\n        nodeIdToDataMap,\n        linkIdToDataMap,\n        newDimensions,\n        width,\n        height,\n        getTextDimensions\n      );\n      labelDimensions.current = labelDims;\n      const layoutOutput = layout(layoutJSON);\n      const { nodeIds, nodePoints, nodeLabelPos, linkLabelPos } = deconstructLayoutJSON<\n        K1,\n        K2,\n        D1,\n        D2,\n        L\n      >(layoutOutput, diagramNodes, diagramLinks);\n      nodeLabelPosRef.current = nodeLabelPos;\n      linkLabelPosRef.current = linkLabelPos;\n      layoutOutputRef.current = layoutOutput;\n      const { newBounds: nodeBounds } = mergeDimensions<K1>(\n        newDimensions,\n        nodePoints,\n        nodeIds\n      );\n      if (!isEqualBounds(nodeBounds, bounds)) {\n        setBounds(nodeBounds);\n      }\n      const labelBounds = getAllLabelBounds(\n        labelDims,\n        diagramNodes,\n        diagramLinks,\n        nodeLabelPos,\n        linkLabelPos,\n        direction === 'rtl'\n      );\n      setCombinedLabelBounds(labelBounds);\n      resizeThrottling.current = false;\n    });\n  };\n  return (\n    <div\n      ref={rootRef}\n      class={outerStyles}\n      {...mergedEventProps}\n      style={style}\n      tabIndex={0}\n      role=\"application\"\n      aria-label={otherProps['aria-label']}\n      aria-labelledby={otherProps['aria-labelledby']}\n      aria-describedby={merge([otherProps['aria-describedby'], datatipAriaDescribedby])}\n      aria-activedescendant={activeId}>\n      {getTextDimensions ? (\n        <DiagramPanZoomContainer\n          centerX={centerX}\n          centerY={centerY}\n          zoom={zoomValue}\n          width={width}\n          height={height}>\n          <DiagramLayers\n            nodes={diagramNodes}\n            links={diagramLinks}\n            nodeRenderer={nodeRenderer}\n            linkRenderer={linkRenderer}\n            width={width}\n            height={height}\n            nodeBounds={bounds}\n            states={states.current!}\n            previousStates={previousState}\n            onNodeSizeChanged={onNodeSizeChanged}\n            nodeLabelPositions={nodeLabelPosRef.current}\n            linkLabelPositions={linkLabelPosRef.current}\n            labelDimensions={labelDimensions.current}\n            supportsSelection={\n              selectionMode !== 'none' ||\n              !!(selectedIds?.nodes && selectedIds.nodes.length > 0) ||\n              !!(selectedIds?.links && selectedIds.links.length > 0)\n            }\n            layoutOutput={layoutOutputRef.current}\n            combinedNodeBounds={contentBounds}\n          />\n        </DiagramPanZoomContainer>\n      ) : undefined}\n      {textMeasureContent}\n      {datatipContent}\n      {contextMenuContent}\n      {selectionContent}\n      {toggleButtonContent}\n    </div>\n  );\n}\n","import { useSelection } from '#hooks/PRIVATE_useVisSelection';\nimport type { DiagramLinkData, DiagramNodeData, ItemInfo } from '../diagram.types';\nimport { getNavigableInfo } from '../utils/diagramUtils';\nimport type { RefObject } from 'preact';\n\ntype SelectionProps<K1, K2, D1, D2> = {\n  selectedIds: {\n    nodes?: K1[];\n    links?: K2[];\n  };\n  selectionMode: 'none' | 'single' | 'multiple';\n  nodeMap: {\n    itemIdToDataMap: Map<K1, D1>;\n    itemIdToIndexMap: Map<K1, number>;\n    itemIndexToIdMap: Map<number, K1>;\n  };\n  linkMap: {\n    itemIdToDataMap: Map<K2, D2>;\n    itemIdToIndexMap: Map<K2, number>;\n    itemIndexToIdMap: Map<number, K2>;\n  };\n  focusedItemInfo: ItemInfo<K1, K2>;\n  onSelectionChange?: (detail: {\n    nodes: K1[];\n    links: K2[];\n    nodeData: (D1 | undefined)[];\n    linkData: (D2 | undefined)[];\n  }) => void;\n  rootRef: RefObject<HTMLDivElement>;\n};\n\ntype EncodedNodeId = `N_${number}`;\ntype EncodedLinkId = `L_${number}`;\n\nexport function useDiagramSelection<\n  K1,\n  K2,\n  D1 extends DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1>\n>({\n  selectedIds,\n  selectionMode,\n  nodeMap,\n  linkMap,\n  focusedItemInfo,\n  onSelectionChange,\n  rootRef\n}: SelectionProps<K1, K2, D1, D2>) {\n  const nodeIdToIndexMap = nodeMap.itemIdToIndexMap;\n  const nodeIndexToIdMap = nodeMap.itemIndexToIdMap;\n  const nodeIdToDataMap = nodeMap.itemIdToDataMap;\n  const linkIdToIndexMap = linkMap.itemIdToIndexMap;\n  const linkIndexToIdMap = linkMap.itemIndexToIdMap;\n  const linkIdToDataMap = linkMap.itemIdToDataMap;\n  const encodeNodeId = (id: K1) => `N_${nodeIdToIndexMap.get(id)}` as EncodedNodeId;\n  const decodeNodeId = (id: EncodedNodeId) => nodeIndexToIdMap.get(Number(id.slice(2)));\n  const encodeLinkId = (id: K2) => `L_${linkIdToIndexMap.get(id)}` as EncodedLinkId;\n  const decodeLinkId = (id: EncodedLinkId) => linkIndexToIdMap.get(Number(id.slice(2)));\n\n  const encodedNodesSelection = selectedIds.nodes ? selectedIds.nodes.map(encodeNodeId) : [];\n  const encodedLinksSelection = selectedIds.links ? selectedIds.links.map(encodeLinkId) : [];\n  const encodedSelection = [...encodedNodesSelection, ...encodedLinksSelection];\n  const idExtracter = (event: Event) => {\n    // return encodeNodeId(id) or encodeLinkId(id) depending on node or link selection or undefined if clicked on empty space\n    const info =\n      event.type === 'keyup'\n        ? focusedItemInfo\n        : getNavigableInfo<K1, K2>(event.target as HTMLElement, rootRef);\n    return info.id !== undefined\n      ? info.isNode\n        ? encodeNodeId(info.id as K1)\n        : encodeLinkId(info.id as K2)\n      : undefined;\n  };\n\n  const onEncodedSelectionChange = (detail: { ids: (EncodedNodeId | EncodedLinkId)[] }) => {\n    const newNodeIds = detail.ids\n      .filter((encId) => encId[0] === 'N')\n      .map((encId) => decodeNodeId(encId as EncodedNodeId)!);\n    const newLinkIds = detail.ids\n      .filter((encId) => encId[0] === 'L')\n      .map((encId) => decodeLinkId(encId as EncodedLinkId)!);\n\n    const newSelectedNodeIds = newNodeIds.filter(\n      (id) => nodeIdToDataMap.get(id)?.selectable !== 'off'\n    );\n    const newSelectedLinkIds = newLinkIds.filter(\n      (id) => linkIdToDataMap.get(id)?.selectable !== 'off'\n    );\n\n    const nodeData = newSelectedNodeIds.map((selectedId) => {\n      return nodeIdToDataMap.get(selectedId);\n    });\n    const linkData = newSelectedLinkIds.map((selectedId) => {\n      return linkIdToDataMap.get(selectedId);\n    });\n    return (\n      onSelectionChange &&\n      onSelectionChange({\n        nodes: newSelectedNodeIds,\n        links: newSelectedLinkIds,\n        nodeData,\n        linkData\n      })\n    );\n  };\n\n  const getDataById = (id: EncodedNodeId | EncodedLinkId) => {\n    let data;\n    if (id[0] === 'N') {\n      const nodeId = decodeNodeId(id as EncodedNodeId)!;\n      data = nodeMap.itemIdToDataMap.get(nodeId);\n    } else if (id[0] === 'L') {\n      const linkId = decodeLinkId(id as EncodedLinkId)!;\n      data = linkMap.itemIdToDataMap.get(linkId);\n    }\n    return data;\n  };\n\n  const { selectionContent, selectionProps } = useSelection<`N_${number}` | `L_${number}`, D1 | D2>(\n    {\n      selection: encodedSelection,\n      idExtracter,\n      selectionMode,\n      getDataById,\n      onChange: onEncodedSelectionChange\n    }\n  );\n\n  return { selectionContent, selectionProps };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { RefObject } from 'preact';\nimport type {\n  DiagramContextMenuConfig,\n  DiagramContextMenuContext,\n  ItemInfo\n} from '../diagram.types';\nimport { type gestureTypes, useContextMenu } from '#hooks/PRIVATE_useVisContextMenu';\nimport { getDiagramContextMenuContext } from '../utils/contextMenuUtils';\n\ntype Props<K1, K2, D1, D2> = {\n  nodesMap: Map<K1, D1>;\n  linksMap: Map<K2, D2>;\n  focusedItemInfo: ItemInfo<K1, K2>;\n  rootRef: RefObject<HTMLDivElement>;\n  contextMenuConfig?: DiagramContextMenuConfig<D1, D2>;\n  onContextMenuDismissed?: (gesture: gestureTypes) => void;\n};\n\nexport const useDiagramContextMenu = <K1, K2, D1, D2>({\n  focusedItemInfo,\n  rootRef,\n  contextMenuConfig,\n  onContextMenuDismissed,\n  nodesMap,\n  linksMap\n}: Props<K1, K2, D1, D2>) => {\n  const { contextMenuProps, contextMenuContent } = useContextMenu<\n    DiagramContextMenuContext<D1, D2>\n  >({\n    onContextMenuHandler: ({ gesture, target }) => {\n      let idx;\n      let elementType: 'node' | 'link' | 'background' = 'background';\n      const currentTarget = target as HTMLElement;\n      if (gesture === 'keyboard') {\n        idx = focusedItemInfo.id;\n        if (focusedItemInfo.isNode) {\n          elementType = 'node';\n        } else if (idx !== undefined && !focusedItemInfo.isNode) {\n          elementType = 'link';\n        }\n      } else if (\n        (currentTarget.closest('[data-oj-private-node]') as HTMLElement)?.dataset['ojPrivateNode']\n      ) {\n        idx = (currentTarget.closest('[data-oj-private-node]') as HTMLElement)?.dataset[\n          'ojPrivateNode'\n        ] as K1;\n        elementType = 'node';\n      } else if (\n        (currentTarget.closest('[data-oj-private-link]') as SVGElement)?.dataset[\n          'ojPrivateLink'\n        ] as K2\n      ) {\n        idx = (currentTarget.closest('[data-oj-private-link]') as SVGElement)?.dataset[\n          'ojPrivateLink'\n        ] as K2;\n        elementType = 'link';\n      }\n\n      const { context } = getDiagramContextMenuContext<K1, K2, D1, D2>(\n        nodesMap,\n        linksMap,\n        elementType,\n        idx\n      );\n      if (gesture === 'keyboard') {\n        let element;\n        if (focusedItemInfo.isNode) {\n          element = rootRef.current?.querySelector(`[data-oj-private-node=\"${idx}\"]`);\n        } else {\n          element = rootRef.current?.querySelector(`[data-oj-private-link=\"${idx}\"]`);\n        }\n        return {\n          type: 'element',\n          context,\n          elem: element ? element : null\n        };\n      }\n      return { type: 'pointer', context };\n    },\n    contextMenuOptions: {\n      isDisabled: !contextMenuConfig //If there is not a context menu renderer we disable the hook\n    },\n    rootRef,\n    contextMenuConfig,\n    onContextMenuDismissed\n  });\n\n  return { contextMenuContent, contextMenuProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { DiagramContextMenuContext } from '../diagram.types.ts';\n\nexport function getDiagramContextMenuContext<K1, K2, D1, D2>(\n  nodesMap: Map<K1, D1>,\n  linksMap: Map<K2, D2>,\n  type: 'node' | 'link' | 'background',\n  idx?: K1 | K2\n) {\n  let context: DiagramContextMenuContext<D1, D2>;\n\n  if (type === 'node') {\n    context = {\n      data: nodesMap.get(idx as K1)!,\n      type\n    };\n  } else if (type === 'link') {\n    context = {\n      data: linksMap.get(idx as K2)!,\n      type\n    };\n  } else {\n    context = {\n      type: 'background'\n    };\n  }\n\n  return {\n    context: context as DiagramContextMenuContext<D1, D2>\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  DiagramProps,\n  DiagramNodeData,\n  DiagramLinkData,\n  DiagramLayoutOutput\n} from './diagram.types';\nimport { TrackResizeContainer } from '#UNSAFE_TrackResizeContainer';\nimport { dimensionStyle } from './themes/DiagramStyles.css';\nimport { DiagramWithDimensions } from './DiagramWithDimensions';\n\n/**\n * Diagrams are used to display a set of nodes and the links between them.\n */\nexport function Diagram<\n  K1 extends string | number,\n  K2 extends string | number,\n  D1 extends DiagramNodeData<K1> = DiagramNodeData<K1>,\n  D2 extends DiagramLinkData<K2, K1> = DiagramLinkData<K2, K1>,\n  L extends DiagramLayoutOutput<K1, K2> = DiagramLayoutOutput<K1, K2>\n>({ width, height, ...otherProps }: DiagramProps<K1, K2, D1, D2, L>) {\n  return otherProps.nodes && otherProps.nodes.length > 0 ? (\n    <TrackResizeContainer width={width} height={height} class={dimensionStyle}>\n      {(width, height) => <DiagramWithDimensions width={width} height={height} {...otherProps} />}\n    </TrackResizeContainer>\n  ) : null;\n}\n"],"names":["createItemMap","items","itemIdToDataMap","Map","itemIdToIndexMap","itemIndexToIdMap","i","length","set","id","combineIds","nodeIds","linkIds","combinedIds","push","getLabelBounds","label","dims","isRTL","labelPos","getLabelPosition","rotationAngle","rotationPoint","x","width","y","height","angle","topLeft","getCoordsRelToRotPoint","topRight","bottomLeft","bottomRight","points","minX","minY","maxX","maxY","point","getBoundsFromPoints","rotatePoint","map","pos","labelPoint","rotPoint","Math","cos","sin","dimensions","positionProps","position","hAlign","vAlign","centerXYToPanXY","centerX","centerY","zoom","panX","panY","isEqualItem","item1","item2","isNode","getNavigableInfo","element","rootElementRef","navigableId","elem","dataset","parentElement","current","getItemAriaLabel","translations","supportsSelection","isSelected","accessibleLabel","generateAriaLabel","undefined","getZoomToFitZoom","contentBounds","zoomX","zoomY","min","constrainZoom","minZoom","maxZoom","newZoom","max","_getFontProps","styles","fontProps","fontFamily","fontSize","fontStyle","fontWeight","zoomAndCenterItemFromInfo","info","linkIdToDataMap","bounds","nodeIdToIndex","totalBounds","get","link","startNodeBounds","startNode","endNodeBounds","endNode","cX","cY","getPanZoomToCenterNode","DiagramNodeElement","state","previousState","activeId","nodeRenderer","onNodeSizeChanged","nodeIndex","data","isDimmed","nodeStyles","dimmedItemStyle","itemStyles","context","useTranslationBundle","ref","useRef","optionsRef","box","useResizeObserver","useCallback","entry","boxSize","borderBoxSize","inlineSize","blockSize","_jsx","class","classNames","role","selected","style","top","left","focused","hovered","children","DiagramNodeLayer","nodes","states","previousStates","nodeBounds","layerStyles","node","selectedNodeIds","includes","focusedId","hoveredId","jsx","highlightedIds","DiagramLinkElement","linkRenderer","layoutOutput","linkStyles","DiagramLinkLayer","links","combinedNodeBounds","selectedLinkIds","DiagramLabel","text","labelStyle","labelBorderStyle","labelStyles","labelPosition","labelRotation","rotation","getLabelRotation","borderColor","DiagramLabelLayer","itemProps","labelDimensions","direction","useUser","item","DiagramLayers","nodeLabelPositions","linkLabelPositions","_jsxs","_Fragment","Infinity","DiagramPanZoomContainer","panValues","panZoomStyles","translate","transform","getNodeDetailFromInfo","itemInfo","getNavigableLinksForNodeId","nodeId","listOfLinks","forEach","startId","endId","_getClockwiseAngle","currNode","oppositeNode","p1","_getNodeCenter","p2","atan2","PI","_getNodesDistance","sqrt","pow","_getLinkDirection","nodeBB","calcDistanceAngleWeighted","objectBB","currentBB","optimalAngle1","optimalAngle2","objCenterX","objCenterY","curCenterX","curCenterY","x_dist","abs","y_dist","distance","isValidDestination","objBB","curBB","compareCenters","_areEqualWithinTolerance","calcInContact","objRect","curRect","_isVerticallyAligned","_isHorizontallyAligned","rect1","rect2","a","b","_anglesAreEqualWithinTolerance","a1","a2","res","useDiagramNavigation","currentKeyboardFocusNode","nodeBoundsById","createNodeBoundsMap","getNextNavigableNode","listOfObjects","currBB","object","inContact","nextObject","nextDistance","Number","MAX_VALUE","nextInContact","hasFoundCurrent","objBounds","currBounds","getNextNavigableLink","listOfNodes","currentLink","keyboardFocusNode","linksWithSortingAttributes","linkDetail","addSortingAttributes","sort","link1","link2","linkAngle1","linkDistance1","linkDirection1","linkAngle2","linkDistance2","linkDirection2","bForward","index","navigateFromNodeToLink","event","adjLinks","currNodeBB","currNodeBBCenterX","nodeCenterX","altKey","code","navigateFromLinkToNode","linkId","key","linkData","startNodeBB","endNodeBB","startNodeCenterX","endNodeCenterX","useEvents","touchResponse","initNode","nodeIdToDataMap","nodeIdToIndexMap","onItemHover","onItemFocus","kbPanCallback","kbZoomCallback","focusedItemInfo","setfocusedItemInfo","useState","hoveredItemInfo","sethoveredItemInfo","hoverHandlers","useVisHover","target","isCurrent","getRandomId","type","updatefocusedItemInfo","handleKeyboardInput","isFocusVisible","onContextMenuDismissed","gesture","eventsProps","mergeProps","onKeyUp","onKeyDown","eventConsumed","isChangeItemType","isNavigationEvent","nextItemInfo","itemDetail","getLinkDetailFromInfo","handleKeyboardNavigationEvent","dPan","dx","shiftKey","dy","dZoom","ctrlKey","nZoom","nPan","cx","cy","center","preventDefault","stopPropagation","cancelEvent","onBlur","onPointerUp","usePointerGesture","captureTargetRef","numPointers","onPointerGestureDown","onPointerGestureMove","onPointerGestureEnd","onExtraneousPointerDown","isDisabled","activePointers","e","findIndex","pointerEvent","pointerId","pointers","splice","onPointerDown","onPointerMove","setPointerCapture","onPointerCancel","onPointerLeave","pan","previousPan","nextPan","panDirection","panBounds","onPanChange","newPan","constrainPan","isPanChanged","panXYToCenterXY","useDragPan","panProps","onDragPanStart","onDragPanEnd","prevPanState","initialPanState","dragProps","draggableRegion","onDragStart","onDragMove","onDragEnd","inactiveState","isDragging","x0","y0","regionOffsetX","regionOffsetY","dragState","handlePointerEvent","cb","pageX","pageY","originalEvent","button","region","xMin","xMax","yMin","yMax","inDraggableRegion","getRegionOffset","useDrag","onPan","panning","nextZoom","onZoomChange","zoomValue","getDistance","usePinchZoom","zooming","onZoom","pinchProps","onPinchZoomStart","onPinchZoomChange","onPinchZoomEnd","origin","prevDistance","reset","pointer1","pointer2","offsetX","offsetY","getMidpoint","delta","usePinch","usePanZoom","props","isRtl","cursor","setCursor","zoomProps","zoomTofitZoom","getZoomProps","prevZoom","initPanZoomState","isDeviceTouch","isTouch","plotArea","showPanButton","dragModeOptions","isZoomScroll","plotAreaSpace","componentWidth","showZoomButton","showSelectButton","toggleButtonContent","userDragMode","useVisDragModeControls","getPanProps","widthArg","heightArg","elemBounds","panType","zoomRatio","minZoomX","minZoomY","initZoom","initCenterX","initCenterY","boundsX","boundsY","getPanBounds","dragPanProps","wheelZoomProps","onWheel","onWheelCallback","deltaX","deltaY","deltaMode","DOM_DELTA_PIXEL","DOM_DELTA_LINE","DOM_DELTA_PAGE","getNormalizedDelta","metaKey","useWheel","useWheelZoom","pinchZoomProps","panZoomProps","DiagramWithDimensions","selectedIds","selectionMode","layout","onSelectionChange","datatip","contextMenuConfig","otherProps","focusedItemBoundsRef","rootRef","setBounds","combinedLabelBounds","setCombinedLabelBounds","diagramNodes","nodeMap","diagramLinks","nodesMap","newLinks","filterLinksWithNoEndNodes","linkMap","resizeThrottling","newDimensions","getDimensionsFromBounds","textMeasureContent","getTextDimensions","useTextDimensions","nodeLabelPosRef","linkLabelPosRef","layoutOutputRef","labelBounds","getContentBounds","touchResponseStyle","useVisTouchResponse","supportsTouchDragGestures","selectionProps","selectionContent","nodeIndexToIdMap","linkIdToIndexMap","linkIndexToIdMap","encodeNodeId","decodeNodeId","slice","encodeLinkId","decodeLinkId","encodedSelection","useSelection","selection","idExtracter","getDataById","onChange","detail","newNodeIds","ids","filter","encId","newLinkIds","newSelectedNodeIds","selectable","newSelectedLinkIds","nodeData","selectedId","useDiagramSelection","startNB","endNB","startNCenter","endNCenter","getFocusedItemBounds","datatipContent","datatipProps","datatipAriaDescribedby","panState","linksMap","hoveredItem","datatipC","focusedItem","isPointerActive","content","getDatatipContent","elementBounds","offset","calculateOffset","useDatatip","placement","anchor","useDiagramDatatip","contextMenuContent","contextMenuProps","useContextMenu","onContextMenuHandler","idx","elementType","currentTarget","closest","getDiagramContextMenuContext","querySelector","contextMenuOptions","useDiagramContextMenu","mergedEventProps","jsxs","outerStyles","tabIndex","merge","nodeWidth","nodeHeight","window","requestAnimationFrame","labelDims","layoutJSON","nodeItems","linkItems","nodeKeys","Array","from","keys","linkKeys","getNodeDimensions","getLabelDimensions","componentSize","constructLayoutJSON","nodePoints","nodeLabelPos","linkLabelPos","positions","hasNodeLabels","hasLinkLabels","deconstructLayoutJSON","newBounds","newBoundsMap","dim","mergeDimensions","bounds1","bounds2","every","getAllLabelBounds","TrackResizeContainer","dimensionStyle"],"mappings":"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"}