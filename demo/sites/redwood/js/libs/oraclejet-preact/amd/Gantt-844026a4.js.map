{"version":3,"file":"Gantt-844026a4.js","sources":["../../src/UNSAFE_Gantt/GanttContainer.tsx","../../src/UNSAFE_Gantt/GanttWithRowAxisLayout.tsx","../../src/UNSAFE_Gantt/utils/rowAxisUtils.tsx","../../../../node_modules/flatqueue/index.js","../../../../node_modules/flatbush/index.js","../../src/UNSAFE_Gantt/utils/spatialUtils.ts","../../src/UNSAFE_Gantt/utils/dataLayoutUtils.ts","../../src/UNSAFE_Gantt/utils/ariaUtils.ts","../../src/UNSAFE_Gantt/GanttRowLabelContainer.tsx","../../src/UNSAFE_Gantt/hooks/useDatatip_FORK.tsx","../../src/UNSAFE_Gantt/hooks/useGanttRowLabelDatatip.ts","../../src/UNSAFE_Gantt/hooks/useGanttRowLabelPointerGestures.ts","../../src/UNSAFE_Gantt/GanttRowAxis.tsx","../../src/PRIVATE_TimeComponent/utils/panUtils.ts","../../src/UNSAFE_Gantt/utils/navigationUtils.ts","../../src/UNSAFE_Gantt/hooks/useGanttKbPan.ts","../../src/PRIVATE_TimeComponent/hooks/useKbPan.ts","../../src/UNSAFE_Gantt/hooks/useGanttPanZoomGestures.ts","../../src/PRIVATE_TimeComponent/hooks/useDragPan.ts","../../src/PRIVATE_TimeComponent/hooks/useWheelPan.ts","../../src/PRIVATE_TimeComponent/hooks/usePinchZoom.ts","../../src/PRIVATE_TimeComponent/hooks/useWheelZoom.ts","../../src/PRIVATE_TimeComponent/hooks/useKbZoom.ts","../../src/UNSAFE_Gantt/hooks/useGanttTaskDatatip.ts","../../src/UNSAFE_Gantt/utils/datatipUtils.tsx","../../src/UNSAFE_Gantt/GanttTimeAxisDataBody.tsx","../../src/UNSAFE_Gantt/hooks/useGanttTaskPointerGestures.ts","../../src/UNSAFE_Gantt/GanttHorizontalGridlinesLayer.tsx","../../src/UNSAFE_Gantt/GanttDesktopTaskAccContent.tsx","../../src/UNSAFE_Gantt/GanttMobileTaskAccContent.tsx","../../src/UNSAFE_Gantt/GanttTaskAccLayer.tsx","../../src/UNSAFE_Gantt/GanttRowBackgroundsLayer.tsx","../../src/UNSAFE_Gantt/utils/canvasDrawUtils.ts","../../src/UNSAFE_Gantt/GanttTaskFocusEffectsLayer.tsx","../../src/UNSAFE_Gantt/GanttTaskHoverEffectsLayer.tsx","../../src/UNSAFE_Gantt/GanttTaskSelectionEffectsLayer.tsx","../../src/UNSAFE_Gantt/GanttTaskEffectsLayer.tsx","../../src/UNSAFE_Gantt/GanttTaskLabel.tsx","../../src/UNSAFE_Gantt/GanttTaskLabelsLayer.tsx","../../src/UNSAFE_Gantt/GanttTasksLayer.tsx","../../src/UNSAFE_Gantt/GanttDataBody.tsx","../../src/UNSAFE_Gantt/GanttView.tsx","../../src/PRIVATE_TimeComponent/utils/timeAxisLayoutUtils.ts","../../src/PRIVATE_TimeComponent/utils/timeComponentStyleUtils.ts","../../src/UNSAFE_Gantt/utils/ganttStyleUtils.ts","../../src/UNSAFE_Gantt/utils/rowAxisLayoutUtils.ts","../../src/UNSAFE_Gantt/hooks/useGanttLayout.tsx","../../src/PRIVATE_TimeComponent/utils/validationUtils.ts","../../src/UNSAFE_Gantt/utils/panZoomCanvasLayoutUtils.ts","../../src/PRIVATE_TimeComponent/utils/scrollbarLayoutUtils.ts","../../src/PRIVATE_TimeComponent/hooks/useTimeComponentKeyboard.ts","../../src/PRIVATE_TimeComponent/utils/keyboardUtils.ts","../../src/UNSAFE_Gantt/hooks/useGanttTaskNavigation.ts","../../src/UNSAFE_Gantt/hooks/useGanttRowLabelNavigation.ts","../../src/UNSAFE_Gantt/hooks/useGanttKeyboard.ts","../../src/UNSAFE_Gantt/Gantt.tsx","../../src/PRIVATE_TimeComponent/hooks/useTimeComponentEvents.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject, JSX } from 'preact';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { styles as timeComponentStyles } from '#PRIVATE_TimeComponent/themes/TimeComponentStyles.css';\nimport { styles as ganttStyles } from './themes/GanttStyles.css';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\nimport { Size, sizeToCSS } from '#utils/UNSAFE_size';\nimport { type TestIdProps, useTestId } from '#hooks/UNSAFE_useTestId';\n\ntype IntrinsicProps = UnpackSignals<JSX.IntrinsicElements['div']>;\ntype Props = IntrinsicProps &\n  TestIdProps & {\n    innerRef: RefObject<HTMLDivElement>;\n    width?: Size;\n    height?: Size;\n  };\n\nexport function GanttContainer({\n  innerRef,\n  width,\n  height,\n  testId,\n  children,\n  ...otherProps\n}: Props) {\n  const testIdProps = useTestId(testId);\n\n  return (\n    <div\n      ref={innerRef}\n      tabIndex={0}\n      {...testIdProps}\n      {...otherProps}\n      class={classNames([timeComponentStyles.baseStyle, ganttStyles.baseStyle])}\n      style={{ width: width && sizeToCSS(width), height: height && sizeToCSS(height) }}>\n      {children}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { rowAxisLayoutStyles } from './themes/GanttStyles.css';\nimport { TrackResizeContainer } from '#UNSAFE_TrackResizeContainer';\n\ntype Props = {\n  rowAxisTopGap?: string;\n  rowAxisBottomGap?: string;\n  resolvedRowAxisWidth: { value: number; suffix?: 'px' | '%' };\n  resolvedRowAxisMaxWidth: { value: number; suffix?: 'px' | '%' };\n  rowAxis: (resolvedWidth: number, resolvedMaxWidth: number) => ComponentChildren;\n  ganttView: ComponentChildren;\n};\n\nexport function GanttWithRowAxisLayout({\n  rowAxisTopGap = '0',\n  rowAxisBottomGap = '0',\n  resolvedRowAxisWidth,\n  resolvedRowAxisMaxWidth,\n  rowAxis,\n  ganttView\n}: Props) {\n  const isRelativeWidth = resolvedRowAxisWidth.suffix === '%';\n  const isRelativeMaxWidth = resolvedRowAxisMaxWidth.suffix === '%';\n  return isRelativeWidth || isRelativeMaxWidth ? (\n    <TrackResizeContainer width=\"100%\" height=\"100%\">\n      {(width, _) => (\n        <div\n          class={rowAxisLayoutStyles.base}\n          style={{ gridTemplateRows: `${rowAxisTopGap} minmax(0, 1fr) ${rowAxisBottomGap}` }}>\n          <div class={rowAxisLayoutStyles.rowAxis}>\n            {rowAxis(\n              isRelativeWidth\n                ? width * (resolvedRowAxisWidth.value / 100)\n                : resolvedRowAxisWidth.value,\n              isRelativeMaxWidth\n                ? width * (resolvedRowAxisMaxWidth.value / 100)\n                : resolvedRowAxisMaxWidth.value\n            )}\n          </div>\n          <div class={rowAxisLayoutStyles.ganttView}>{ganttView}</div>\n        </div>\n      )}\n    </TrackResizeContainer>\n  ) : (\n    <div\n      class={rowAxisLayoutStyles.base}\n      style={{ gridTemplateRows: `${rowAxisTopGap} minmax(0, 1fr) ${rowAxisBottomGap}` }}>\n      <div class={rowAxisLayoutStyles.rowAxis}>\n        {rowAxis(resolvedRowAxisWidth.value, resolvedRowAxisMaxWidth.value)}\n      </div>\n      <div class={rowAxisLayoutStyles.ganttView}>{ganttView}</div>\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { GanttRowData, GanttRowAxisProps, GanttTaskData } from '../gantt.types';\nimport { Text } from '#UNSAFE_Text';\nimport type { getRowDataLayout } from './dataLayoutUtils';\n\ntype RowDataLayout<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = ReturnType<typeof getRowDataLayout<K1, K2, D1, D2>>;\n\ntype RowAxisLabelRenderContext<D1> = Parameters<\n  NonNullable<GanttRowAxisProps<D1>['labelRenderer']>\n>[0];\n\n/**\n * Gets the default row axis label renderer.\n * @param param0\n * @returns The default renderer.\n */\nconst defaultRowAxisLabelRender = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  maxWidth,\n  maxHeight,\n  data: { label = '', labelStyle }\n}: RowAxisLabelRenderContext<D1>) => {\n  return (\n    <div\n      style={{\n        width: maxWidth > -1 ? maxWidth : undefined,\n        height: maxHeight,\n        display: 'flex',\n        alignItems: 'center',\n        ...labelStyle\n      }}>\n      <Text size=\"md\" variant={labelStyle?.color ? 'inherit' : 'primary'} truncation=\"ellipsis\">\n        {label}\n      </Text>\n    </div>\n  );\n};\n\n/**\n * Gets the row label renderer context.\n * @param layoutObj The row layout object.\n * @param rowData The rows data.\n * @param maxWidth The max width of the row axis.\n * @returns The renderer context.\n */\nconst getRenderContext = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  layoutObj: RowDataLayout<K1, K2, D1, D2>['rowObjs'][0],\n  rowData: RowDataLayout<K1, K2, D1, D2>['rowData'],\n  maxWidth: number\n): RowAxisLabelRenderContext<D1> => {\n  return {\n    maxWidth,\n    maxHeight: layoutObj.height,\n    data: rowData[layoutObj.index]\n  };\n};\n\nexport { defaultRowAxisLabelRender, getRenderContext };\n","\nexport default class FlatQueue {\n\n    constructor() {\n        this.ids = [];\n        this.values = [];\n        this.length = 0;\n    }\n\n    clear() {\n        this.length = 0;\n    }\n\n    push(id, value) {\n        let pos = this.length++;\n\n        while (pos > 0) {\n            const parent = (pos - 1) >> 1;\n            const parentValue = this.values[parent];\n            if (value >= parentValue) break;\n            this.ids[pos] = this.ids[parent];\n            this.values[pos] = parentValue;\n            pos = parent;\n        }\n\n        this.ids[pos] = id;\n        this.values[pos] = value;\n    }\n\n    pop() {\n        if (this.length === 0) return undefined;\n\n        const top = this.ids[0];\n        this.length--;\n\n        if (this.length > 0) {\n            const id = this.ids[0] = this.ids[this.length];\n            const value = this.values[0] = this.values[this.length];\n            const halfLength = this.length >> 1;\n            let pos = 0;\n\n            while (pos < halfLength) {\n                let left = (pos << 1) + 1;\n                const right = left + 1;\n                let bestIndex = this.ids[left];\n                let bestValue = this.values[left];\n                const rightValue = this.values[right];\n\n                if (right < this.length && rightValue < bestValue) {\n                    left = right;\n                    bestIndex = this.ids[right];\n                    bestValue = rightValue;\n                }\n                if (bestValue >= value) break;\n\n                this.ids[pos] = bestIndex;\n                this.values[pos] = bestValue;\n                pos = left;\n            }\n\n            this.ids[pos] = id;\n            this.values[pos] = value;\n        }\n\n        return top;\n    }\n\n    peek() {\n        if (this.length === 0) return undefined;\n        return this.ids[0];\n    }\n\n    peekValue() {\n        if (this.length === 0) return undefined;\n        return this.values[0];\n    }\n\n    shrink() {\n        this.ids.length = this.values.length = this.length;\n    }\n}\n","import FlatQueue from 'flatqueue';\n\nconst ARRAY_TYPES = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];\nconst VERSION = 3; // serialized format version\n\n/** @typedef {Int8ArrayConstructor | Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int16ArrayConstructor | Uint16ArrayConstructor | Int32ArrayConstructor | Uint32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor} TypedArrayConstructor */\n\nexport default class Flatbush {\n\n    /**\n     * Recreate a Flatbush index from raw `ArrayBuffer` or `SharedArrayBuffer` data.\n     * @param {ArrayBuffer | SharedArrayBuffer} data\n     * @returns {Flatbush} index\n     */\n    static from(data) {\n        // @ts-expect-error duck typing array buffers\n        if (!data || data.byteLength === undefined || data.buffer) {\n            throw new Error('Data must be an instance of ArrayBuffer or SharedArrayBuffer.');\n        }\n        const [magic, versionAndType] = new Uint8Array(data, 0, 2);\n        if (magic !== 0xfb) {\n            throw new Error('Data does not appear to be in a Flatbush format.');\n        }\n        const version = versionAndType >> 4;\n        if (version !== VERSION) {\n            throw new Error(`Got v${version} data when expected v${VERSION}.`);\n        }\n        const ArrayType = ARRAY_TYPES[versionAndType & 0x0f];\n        if (!ArrayType) {\n            throw new Error('Unrecognized array type.');\n        }\n        const [nodeSize] = new Uint16Array(data, 2, 1);\n        const [numItems] = new Uint32Array(data, 4, 1);\n\n        return new Flatbush(numItems, nodeSize, ArrayType, undefined, data);\n    }\n\n    /**\n     * Create a Flatbush index that will hold a given number of items.\n     * @param {number} numItems\n     * @param {number} [nodeSize=16] Size of the tree node (16 by default).\n     * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).\n     * @param {ArrayBufferConstructor | SharedArrayBufferConstructor} [ArrayBufferType=ArrayBuffer] The array buffer type used to store data (`ArrayBuffer` by default).\n     * @param {ArrayBuffer | SharedArrayBuffer} [data] (Only used internally)\n     */\n    constructor(numItems, nodeSize = 16, ArrayType = Float64Array, ArrayBufferType = ArrayBuffer, data) {\n        if (numItems === undefined) throw new Error('Missing required argument: numItems.');\n        if (isNaN(numItems) || numItems <= 0) throw new Error(`Unexpected numItems value: ${numItems}.`);\n\n        this.numItems = +numItems;\n        this.nodeSize = Math.min(Math.max(+nodeSize, 2), 65535);\n\n        // calculate the total number of nodes in the R-tree to allocate space for\n        // and the index of each tree level (used in search later)\n        let n = numItems;\n        let numNodes = n;\n        this._levelBounds = [n * 4];\n        do {\n            n = Math.ceil(n / this.nodeSize);\n            numNodes += n;\n            this._levelBounds.push(numNodes * 4);\n        } while (n !== 1);\n\n        this.ArrayType = ArrayType;\n        this.IndexArrayType = numNodes < 16384 ? Uint16Array : Uint32Array;\n\n        const arrayTypeIndex = ARRAY_TYPES.indexOf(this.ArrayType);\n        const nodesByteSize = numNodes * 4 * this.ArrayType.BYTES_PER_ELEMENT;\n\n        if (arrayTypeIndex < 0) {\n            throw new Error(`Unexpected typed array class: ${ArrayType}.`);\n        }\n\n        // @ts-expect-error duck typing array buffers\n        if (data && data.byteLength !== undefined && !data.buffer) {\n            this.data = data;\n            this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n            this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n\n            this._pos = numNodes * 4;\n            this.minX = this._boxes[this._pos - 4];\n            this.minY = this._boxes[this._pos - 3];\n            this.maxX = this._boxes[this._pos - 2];\n            this.maxY = this._boxes[this._pos - 1];\n\n        } else {\n            this.data = new ArrayBufferType(8 + nodesByteSize + numNodes * this.IndexArrayType.BYTES_PER_ELEMENT);\n            this._boxes = new this.ArrayType(this.data, 8, numNodes * 4);\n            this._indices = new this.IndexArrayType(this.data, 8 + nodesByteSize, numNodes);\n            this._pos = 0;\n            this.minX = Infinity;\n            this.minY = Infinity;\n            this.maxX = -Infinity;\n            this.maxY = -Infinity;\n\n            new Uint8Array(this.data, 0, 2).set([0xfb, (VERSION << 4) + arrayTypeIndex]);\n            new Uint16Array(this.data, 2, 1)[0] = nodeSize;\n            new Uint32Array(this.data, 4, 1)[0] = numItems;\n        }\n\n        // a priority queue for k-nearest-neighbors queries\n        /** @type FlatQueue<number> */\n        this._queue = new FlatQueue();\n    }\n\n    /**\n     * Add a given rectangle to the index.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @returns {number} A zero-based, incremental number that represents the newly added rectangle.\n     */\n    add(minX, minY, maxX, maxY) {\n        const index = this._pos >> 2;\n        const boxes = this._boxes;\n        this._indices[index] = index;\n        boxes[this._pos++] = minX;\n        boxes[this._pos++] = minY;\n        boxes[this._pos++] = maxX;\n        boxes[this._pos++] = maxY;\n\n        if (minX < this.minX) this.minX = minX;\n        if (minY < this.minY) this.minY = minY;\n        if (maxX > this.maxX) this.maxX = maxX;\n        if (maxY > this.maxY) this.maxY = maxY;\n\n        return index;\n    }\n\n    /** Perform indexing of the added rectangles. */\n    finish() {\n        if (this._pos >> 2 !== this.numItems) {\n            throw new Error(`Added ${this._pos >> 2} items when expected ${this.numItems}.`);\n        }\n        const boxes = this._boxes;\n\n        if (this.numItems <= this.nodeSize) {\n            // only one node, skip sorting and just fill the root box\n            boxes[this._pos++] = this.minX;\n            boxes[this._pos++] = this.minY;\n            boxes[this._pos++] = this.maxX;\n            boxes[this._pos++] = this.maxY;\n            return;\n        }\n\n        const width = (this.maxX - this.minX) || 1;\n        const height = (this.maxY - this.minY) || 1;\n        const hilbertValues = new Uint32Array(this.numItems);\n        const hilbertMax = (1 << 16) - 1;\n\n        // map item centers into Hilbert coordinate space and calculate Hilbert values\n        for (let i = 0, pos = 0; i < this.numItems; i++) {\n            const minX = boxes[pos++];\n            const minY = boxes[pos++];\n            const maxX = boxes[pos++];\n            const maxY = boxes[pos++];\n            const x = Math.floor(hilbertMax * ((minX + maxX) / 2 - this.minX) / width);\n            const y = Math.floor(hilbertMax * ((minY + maxY) / 2 - this.minY) / height);\n            hilbertValues[i] = hilbert(x, y);\n        }\n\n        // sort items by their Hilbert value (for packing later)\n        sort(hilbertValues, boxes, this._indices, 0, this.numItems - 1, this.nodeSize);\n\n        // generate nodes at each tree level, bottom-up\n        for (let i = 0, pos = 0; i < this._levelBounds.length - 1; i++) {\n            const end = this._levelBounds[i];\n\n            // generate a parent node for each block of consecutive <nodeSize> nodes\n            while (pos < end) {\n                const nodeIndex = pos;\n\n                // calculate bbox for the new node\n                let nodeMinX = boxes[pos++];\n                let nodeMinY = boxes[pos++];\n                let nodeMaxX = boxes[pos++];\n                let nodeMaxY = boxes[pos++];\n                for (let j = 1; j < this.nodeSize && pos < end; j++) {\n                    nodeMinX = Math.min(nodeMinX, boxes[pos++]);\n                    nodeMinY = Math.min(nodeMinY, boxes[pos++]);\n                    nodeMaxX = Math.max(nodeMaxX, boxes[pos++]);\n                    nodeMaxY = Math.max(nodeMaxY, boxes[pos++]);\n                }\n\n                // add the new node to the tree data\n                this._indices[this._pos >> 2] = nodeIndex;\n                boxes[this._pos++] = nodeMinX;\n                boxes[this._pos++] = nodeMinY;\n                boxes[this._pos++] = nodeMaxX;\n                boxes[this._pos++] = nodeMaxY;\n            }\n        }\n    }\n\n    /**\n     * Search the index by a bounding box.\n     * @param {number} minX\n     * @param {number} minY\n     * @param {number} maxX\n     * @param {number} maxY\n     * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.\n     * @returns {number[]} An array of indices of items intersecting or touching the given bounding box.\n     */\n    search(minX, minY, maxX, maxY, filterFn) {\n        if (this._pos !== this._boxes.length) {\n            throw new Error('Data not yet indexed - call index.finish().');\n        }\n\n        /** @type number | undefined */\n        let nodeIndex = this._boxes.length - 4;\n        const queue = [];\n        const results = [];\n\n        while (nodeIndex !== undefined) {\n            // find the end index of the node\n            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n            // search through child nodes\n            for (let /** @type number */ pos = nodeIndex; pos < end; pos += 4) {\n                // check if node bbox intersects with query bbox\n                if (maxX < this._boxes[pos]) continue; // maxX < nodeMinX\n                if (maxY < this._boxes[pos + 1]) continue; // maxY < nodeMinY\n                if (minX > this._boxes[pos + 2]) continue; // minX > nodeMaxX\n                if (minY > this._boxes[pos + 3]) continue; // minY > nodeMaxY\n\n                const index = this._indices[pos >> 2] | 0;\n\n                if (nodeIndex >= this.numItems * 4) {\n                    queue.push(index); // node; add it to the search queue\n\n                } else if (filterFn === undefined || filterFn(index)) {\n                    results.push(index); // leaf item\n                }\n            }\n\n            nodeIndex = queue.pop();\n        }\n\n        return results;\n    }\n\n    /**\n     * Search items in order of distance from the given point.\n     * @param {number} x\n     * @param {number} y\n     * @param {number} [maxResults=Infinity]\n     * @param {number} [maxDistance=Infinity]\n     * @param {(index: number) => boolean} [filterFn] An optional function for filtering the results.\n     * @returns {number[]} An array of indices of items found.\n     */\n    neighbors(x, y, maxResults = Infinity, maxDistance = Infinity, filterFn) {\n        if (this._pos !== this._boxes.length) {\n            throw new Error('Data not yet indexed - call index.finish().');\n        }\n\n        /** @type number | undefined */\n        let nodeIndex = this._boxes.length - 4;\n        const q = this._queue;\n        const results = [];\n        const maxDistSquared = maxDistance * maxDistance;\n\n        outer: while (nodeIndex !== undefined) {\n            // find the end index of the node\n            const end = Math.min(nodeIndex + this.nodeSize * 4, upperBound(nodeIndex, this._levelBounds));\n\n            // add child nodes to the queue\n            for (let pos = nodeIndex; pos < end; pos += 4) {\n                const index = this._indices[pos >> 2] | 0;\n\n                const dx = axisDist(x, this._boxes[pos], this._boxes[pos + 2]);\n                const dy = axisDist(y, this._boxes[pos + 1], this._boxes[pos + 3]);\n                const dist = dx * dx + dy * dy;\n                if (dist > maxDistSquared) continue;\n\n                if (nodeIndex >= this.numItems * 4) {\n                    q.push(index << 1, dist); // node (use even id)\n\n                } else if (filterFn === undefined || filterFn(index)) {\n                    q.push((index << 1) + 1, dist); // leaf item (use odd id)\n                }\n            }\n\n            // pop items from the queue\n            // @ts-expect-error q.length check eliminates undefined values\n            while (q.length && (q.peek() & 1)) {\n                const dist = q.peekValue();\n                // @ts-expect-error\n                if (dist > maxDistSquared) break outer;\n                // @ts-expect-error\n                results.push(q.pop() >> 1);\n                if (results.length === maxResults) break outer;\n            }\n\n            // @ts-expect-error\n            nodeIndex = q.length ? q.pop() >> 1 : undefined;\n        }\n\n        q.clear();\n        return results;\n    }\n}\n\n/**\n * 1D distance from a value to a range.\n * @param {number} k\n * @param {number} min\n * @param {number} max\n */\nfunction axisDist(k, min, max) {\n    return k < min ? min - k : k <= max ? 0 : k - max;\n}\n\n/**\n * Binary search for the first value in the array bigger than the given.\n * @param {number} value\n * @param {number[]} arr\n */\nfunction upperBound(value, arr) {\n    let i = 0;\n    let j = arr.length - 1;\n    while (i < j) {\n        const m = (i + j) >> 1;\n        if (arr[m] > value) {\n            j = m;\n        } else {\n            i = m + 1;\n        }\n    }\n    return arr[i];\n}\n\n/**\n * Custom quicksort that partially sorts bbox data alongside the hilbert values.\n * @param {Uint32Array} values\n * @param {InstanceType<TypedArrayConstructor>} boxes\n * @param {Uint16Array | Uint32Array} indices\n * @param {number} left\n * @param {number} right\n * @param {number} nodeSize\n */\nfunction sort(values, boxes, indices, left, right, nodeSize) {\n    if (Math.floor(left / nodeSize) >= Math.floor(right / nodeSize)) return;\n\n    const pivot = values[(left + right) >> 1];\n    let i = left - 1;\n    let j = right + 1;\n\n    while (true) {\n        do i++; while (values[i] < pivot);\n        do j--; while (values[j] > pivot);\n        if (i >= j) break;\n        swap(values, boxes, indices, i, j);\n    }\n\n    sort(values, boxes, indices, left, j, nodeSize);\n    sort(values, boxes, indices, j + 1, right, nodeSize);\n}\n\n/**\n * Swap two values and two corresponding boxes.\n * @param {Uint32Array} values\n * @param {InstanceType<TypedArrayConstructor>} boxes\n * @param {Uint16Array | Uint32Array} indices\n * @param {number} i\n * @param {number} j\n */\nfunction swap(values, boxes, indices, i, j) {\n    const temp = values[i];\n    values[i] = values[j];\n    values[j] = temp;\n\n    const k = 4 * i;\n    const m = 4 * j;\n\n    const a = boxes[k];\n    const b = boxes[k + 1];\n    const c = boxes[k + 2];\n    const d = boxes[k + 3];\n    boxes[k] = boxes[m];\n    boxes[k + 1] = boxes[m + 1];\n    boxes[k + 2] = boxes[m + 2];\n    boxes[k + 3] = boxes[m + 3];\n    boxes[m] = a;\n    boxes[m + 1] = b;\n    boxes[m + 2] = c;\n    boxes[m + 3] = d;\n\n    const e = indices[i];\n    indices[i] = indices[j];\n    indices[j] = e;\n}\n\n/**\n * Fast Hilbert curve algorithm by http://threadlocalmutex.com/\n * Ported from C++ https://github.com/rawrunprotected/hilbert_curves (public domain)\n * @param {number} x\n * @param {number} y\n */\nfunction hilbert(x, y) {\n    let a = x ^ y;\n    let b = 0xFFFF ^ a;\n    let c = 0xFFFF ^ (x | y);\n    let d = x & (y ^ 0xFFFF);\n\n    let A = a | (b >> 1);\n    let B = (a >> 1) ^ a;\n    let C = ((c >> 1) ^ (b & (d >> 1))) ^ c;\n    let D = ((a & (c >> 1)) ^ (d >> 1)) ^ d;\n\n    a = A; b = B; c = C; d = D;\n    A = ((a & (a >> 2)) ^ (b & (b >> 2)));\n    B = ((a & (b >> 2)) ^ (b & ((a ^ b) >> 2)));\n    C ^= ((a & (c >> 2)) ^ (b & (d >> 2)));\n    D ^= ((b & (c >> 2)) ^ ((a ^ b) & (d >> 2)));\n\n    a = A; b = B; c = C; d = D;\n    A = ((a & (a >> 4)) ^ (b & (b >> 4)));\n    B = ((a & (b >> 4)) ^ (b & ((a ^ b) >> 4)));\n    C ^= ((a & (c >> 4)) ^ (b & (d >> 4)));\n    D ^= ((b & (c >> 4)) ^ ((a ^ b) & (d >> 4)));\n\n    a = A; b = B; c = C; d = D;\n    C ^= ((a & (c >> 8)) ^ (b & (d >> 8)));\n    D ^= ((b & (c >> 8)) ^ ((a ^ b) & (d >> 8)));\n\n    a = C ^ (C >> 1);\n    b = D ^ (D >> 1);\n\n    let i0 = x ^ y;\n    let i1 = b | (0xFFFF ^ (i0 | a));\n\n    i0 = (i0 | (i0 << 8)) & 0x00FF00FF;\n    i0 = (i0 | (i0 << 4)) & 0x0F0F0F0F;\n    i0 = (i0 | (i0 << 2)) & 0x33333333;\n    i0 = (i0 | (i0 << 1)) & 0x55555555;\n\n    i1 = (i1 | (i1 << 8)) & 0x00FF00FF;\n    i1 = (i1 | (i1 << 4)) & 0x0F0F0F0F;\n    i1 = (i1 | (i1 << 2)) & 0x33333333;\n    i1 = (i1 | (i1 << 1)) & 0x55555555;\n\n    return ((i1 << 1) | i0) >>> 0;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport Flatbush from 'flatbush';\n\ntype RowObj = {\n  taskObjs: {\n    overallStartTime: number;\n    overallEndTime: number;\n    y: number;\n    height: number;\n  }[];\n};\n\ntype TimePoint = { time: number; y: number };\n\ntype SpatialIndex = {\n  tasks: Flatbush;\n};\n\n/**\n * Gets the task spatial index.\n * @param rowObjs The row layout objects (for the entier dataset).\n * @returns The task spatial index.\n */\nconst getTasksSpatialIndex = (rowObjs: RowObj[]) => {\n  const numTasks = rowObjs.map((r) => r.taskObjs.length).reduce((a, b) => a + b, 0);\n  const index = new Flatbush(numTasks);\n  rowObjs.forEach((r) =>\n    r.taskObjs.forEach(({ overallStartTime, overallEndTime, y, height }) => {\n      index.add(overallStartTime, y, overallEndTime, y + height);\n    })\n  );\n  index.finish();\n  return index;\n};\n\n/**\n * Gets all spatial indices of the component.\n * @param rowObjs The row layout objects (for the entier dataset).\n * @returns The spatial indices.\n */\nconst getSpatialIndex = (rowObjs: RowObj[]): SpatialIndex => {\n  // TODO: add more spatial indices for non task bar stuff\n  return {\n    tasks: getTasksSpatialIndex(rowObjs)\n  };\n};\n\n/**\n * Returns the target task that overlaps with the given point.\n * @param rowObjs The row layout objects (for the entier dataset).\n * @param index The spatial index to query.\n * @param param2 The point.\n * @returns The target task.\n */\nconst queryTasksSpatialIndex = (\n  rowObjs: RowObj[],\n  index: SpatialIndex['tasks'],\n  { time, y }: TimePoint\n) => {\n  const found = index.search(time, y, time, y);\n  if (found.length === 0) return;\n\n  // TODO: Handle task overlaps. Not a problem yet for V1.\n  // Instead of depending on order gaurantees from Flatbush (there might not be any), we should\n  // just check chronological task order and overlap behavior (when we support that API)\n  // to figure out the topmost task in the search result.\n  let flatIndex = found[0];\n\n  // TODO: improve this with binary search\n  for (let i = 0; i < rowObjs.length; i++) {\n    const rowObj = rowObjs[i];\n    for (let j = 0; j < rowObj.taskObjs.length; j++) {\n      if (flatIndex === 0) return { rowIndex: i, taskIndex: j };\n      flatIndex -= 1;\n    }\n  }\n  return;\n};\n\nexport { getSpatialIndex, queryTasksSpatialIndex };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  GanttCurrentTask,\n  GanttProps,\n  GanttRowData,\n  GanttSelection as GanttSelectionProps,\n  GanttTaskData,\n  GanttTaskHover\n} from '../gantt.types';\nimport { Property } from 'csstype';\nimport { getTimePosition, parseDate } from '#PRIVATE_TimeComponent/utils/timeUtils';\nimport { getResolvedRowVars, getResolvedTaskVars } from './ganttStyleUtils';\nimport { getSpatialIndex } from './spatialUtils';\n\ntype GanttRowLayoutObj<K1, K2> = {\n  id: K1;\n  y: number;\n  height: number;\n  depth?: number;\n  expanded?: boolean;\n  index: number;\n  parentIndex?: number;\n  isSelected: boolean;\n  taskObjs: GanttTaskLayoutObj<K2>[];\n};\n\ntype GanttTaskLayoutObj<K2> = {\n  id: K2;\n  renderIndex: number;\n  index: number;\n  rowIndex: number;\n  y: number;\n  height: number;\n  borderRadius: string;\n  fill: string;\n  stroke: string;\n  strokeWidth: number;\n  isSelectable: boolean;\n  isSelected: boolean;\n  selectionEffect: {\n    stroke: string;\n    strokeWidth: number;\n    padding: number;\n  };\n  hoverEffect: {\n    stroke: string;\n    strokeWidth: number;\n    padding: number;\n    shadow: {\n      shadowColor: string;\n      shadowOffsetX: number;\n      shadowOffsetY: number;\n      shadowBlur: number;\n    };\n  };\n  focusEffect: {\n    stroke: string;\n    strokeWidth: number;\n    padding: number;\n  };\n  startTime: number;\n  endTime: number;\n  overallStartTime: number;\n  overallEndTime: number;\n  rowLevel: number;\n  previousAdjacentTaskObj?: GanttTaskLayoutObj<K2>;\n  nextAdjacentTaskObj?: GanttTaskLayoutObj<K2>;\n  labelObj?: {\n    startTime: number;\n    endTime: number;\n    label: string;\n    isInner: boolean;\n    position: 'start' | 'center' | 'end';\n  };\n};\n\ntype GanttViewportRowLayoutObj<K1, K2> = Omit<GanttRowLayoutObj<K1, K2>, 'taskObjs'> & {\n  taskObjs: GanttViewportTaskLayoutObj<K2>[];\n};\n\ntype GanttViewportTaskLayoutObj<K2> = GanttTaskLayoutObj<K2> & {\n  x: number;\n  width: number;\n};\n\ntype GanttViewPortTaskLabelLayoutObj = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  label: string;\n  isInner: boolean;\n  textAlign: 'left' | 'center' | 'right';\n  labelStyle?: {\n    color?: Property.Color;\n    fontFamily?: Property.FontFamily;\n    fontSize?: Property.FontSize;\n    fontStyle?: Property.FontStyle;\n    fontWeight?: Property.FontWeight;\n    textDecoration?: Property.TextDecoration;\n  };\n};\n\ntype ViewportLayout<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = ReturnType<typeof getResolvedViewportLayout<K1, K2, D1, D2>>;\n\n/**\n * Determines whether given two intervals overlap\n * @param s1 interval 1 start\n * @param e1 interval 1 end\n * @param s2 interval 2 start\n * @param e2 interval 2 end\n * @param isClosedComparison True if closed interval comparison, else open\n * @returns Whether the two intervals overlap\n */\nconst isIntervalOverlap = (\n  s1: number,\n  e1: number,\n  s2: number,\n  e2: number,\n  isClosedComparison = true\n) => (isClosedComparison ? s1 <= e2 && s2 <= e1 : s1 < e2 && s2 < e1);\n\n/**\n * Determines whether given two tasks overlap chronologically\n * @param taskObj1 task layout object\n * @param taskObj2 task layout object\n * @returns Whether the two tasks overlap chronologically\n */\nconst isOverlap = (\n  taskObj1: { overallStartTime: number; overallEndTime: number },\n  taskObj2: { overallStartTime: number; overallEndTime: number }\n) => {\n  // Open interval comparison: if interval 1 ends at the same time interval 2 starts, they are still NOT overlapping.\n  return isIntervalOverlap(\n    taskObj1.overallStartTime,\n    taskObj1.overallEndTime,\n    taskObj2.overallStartTime,\n    taskObj2.overallEndTime,\n    false\n  );\n};\n\n/**\n * Binary search for the index of the leftmost element that equals the target.\n * If the target is not in the array, then the returned value is:\n *     - the index of rightmost element less than the target if approximateMode is 'predecessor'\n *     - the index of the leftmost element greater than the target if approximateMode is 'successor'\n * Search is O(lgN), N being the length of the array.\n * @param array The array\n * @param target The target\n * @param approximateMode The behavior if target is not in the array. 'predecessor' or 'successor'\n * @returns The leftmost index at which the target is found, or the index of the predecessor/successor element as per approximateMode param\n */\nconst binarySearchLeftMost = (\n  array: number[],\n  target: number,\n  approximateMode: 'predecessor' | 'successor'\n) => {\n  if (array.length === 0) return 0;\n\n  let L = 0;\n  let R = array.length;\n  while (L < R) {\n    const m = Math.floor((L + R) / 2);\n    const value = array[m];\n    if (value < target) L = m + 1;\n    else R = m;\n  }\n  // If target is not in the array, then L at this point is the rank of the target in the array,\n  // i.e. the number of elements in the array that are less than the target.\n  if (L < array.length) {\n    const value = array[L];\n    if (value === target || approximateMode === 'successor') return L;\n  }\n  // L - 1 would give the index of the rightmost element less than the target (predecessor)\n  return L > 0 ? L - 1 : 0;\n};\n\n/**\n * Finds the minimum and maximum row indices relevant to the given viewport bounds\n * @param rowYs The row y coords\n * @param yMin The minimum y bound\n * @param yMax The maximum y bound\n * @returns The minimum and maximum row indices\n */\nconst findRowIndRange = (rowYs: number[], yMin: number, yMax: number) => {\n  // O(lgN) binary search for first row (intersecting yMin)\n  const minRowInd = binarySearchLeftMost(rowYs, yMin, 'predecessor');\n  let maxRowInd = minRowInd;\n\n  // linear search from that row to search for last row (intersecting yMax)\n  for (let i = minRowInd; i < rowYs.length; i++) {\n    if (rowYs[i] <= yMax) {\n      maxRowInd = i;\n    } else {\n      break;\n    }\n  }\n  return { minRowInd, maxRowInd };\n};\n\n/**\n * Gets the height of an empty row.\n * @param resolvedVars The resolved CSS vars.\n * @returns The height of an empty row.\n */\nconst getEmptyRowHeight = (resolvedVars: {\n  rowPaddingTop: number;\n  rowPaddingBottom: number;\n  taskHeight: number;\n}) => resolvedVars.rowPaddingTop + resolvedVars.taskHeight + resolvedVars.rowPaddingBottom;\n\n/**\n * Computes the vertical layout of the given row and its tasks.\n * This method modifies the given task layout objects with resolved layout information.\n * @param param0\n * @returns The resolved height of the row.\n */\nconst calcRowTaskVerticalLayout = <K2>({\n  rowHeight,\n  rowY,\n  taskObjs,\n  resolvedVars\n}: {\n  rowHeight?: number;\n  rowY: number;\n  taskObjs: GanttTaskLayoutObj<K2>[];\n  resolvedVars: ReturnType<typeof getResolvedRowVars> & ReturnType<typeof getResolvedTaskVars>;\n}) => {\n  if (taskObjs.length === 0) return getEmptyRowHeight(resolvedVars);\n\n  // Handle properly in the future when we support these APIs\n  const overlapOffset = undefined;\n\n  taskObjs[0].rowLevel = 0;\n  taskObjs[0].y = 0;\n  const overlapChains = [[taskObjs[0]]];\n  const rowLevelRecentTaskObjs = [taskObjs[0]];\n  for (let i = 1; i < taskObjs.length; i++) {\n    const taskObj = taskObjs[i];\n    // Handle properly in the future when we support these APIs\n    const overlapBehavior = 'stack';\n\n    const previousTaskObj = taskObjs[i - 1];\n    const thisOverlapsPrevious = isOverlap(taskObj, previousTaskObj);\n    if (thisOverlapsPrevious) {\n      overlapChains[overlapChains.length - 1].push(taskObj);\n    } else {\n      overlapChains.push([taskObj]);\n    }\n\n    let rowLevel = 0;\n    let previousAdjacentTaskObj;\n    switch (overlapBehavior) {\n      case 'stack': {\n        let promote = true;\n        for (let j = 0; j < rowLevelRecentTaskObjs.length; j++) {\n          previousAdjacentTaskObj = undefined;\n          if (isOverlap(taskObj, rowLevelRecentTaskObjs[j])) {\n            rowLevel += 1;\n          } else {\n            previousAdjacentTaskObj = rowLevelRecentTaskObjs[j];\n            rowLevelRecentTaskObjs[j] = taskObj;\n            promote = false;\n            break;\n          }\n        }\n        if (promote) {\n          rowLevelRecentTaskObjs.push(taskObj);\n        }\n        taskObj.y = overlapOffset !== undefined ? rowLevel * overlapOffset : 0;\n        if (previousAdjacentTaskObj) {\n          taskObj.previousAdjacentTaskObj = previousAdjacentTaskObj;\n          previousAdjacentTaskObj.nextAdjacentTaskObj = taskObj;\n        }\n        break;\n      }\n      // More cases in the future when we support the overlap behavior APIs\n      default: {\n        const _exhaustiveCheck: never = overlapBehavior;\n        return _exhaustiveCheck;\n      }\n    }\n    taskObj.rowLevel = rowLevel;\n  }\n\n  // Add padding to task y when row height is not fixed\n  const rowPaddingTop = resolvedVars.rowPaddingTop;\n  const rowPaddingBottom = resolvedVars.rowPaddingBottom;\n\n  const rowLevelHeights = rowLevelRecentTaskObjs.map(() => 0);\n  if (rowHeight === undefined) {\n    // Figure out offset based on row level height\n    if (overlapOffset === undefined) {\n      taskObjs.forEach((taskObj) => {\n        if (taskObj.height > rowLevelHeights[taskObj.rowLevel]) {\n          rowLevelHeights[taskObj.rowLevel] = taskObj.height;\n        }\n      });\n      const rowLevelCumHeightsWithPadding = rowLevelHeights\n        .map((rowLevelHeight) => rowLevelHeight + rowPaddingTop + rowPaddingBottom)\n        .reduce((acc, curr, i) => {\n          acc.push((acc[i - 1] || 0) + curr);\n          return acc;\n        }, [] as number[]);\n      taskObjs.forEach((taskObj) => {\n        taskObj.y += (rowLevelCumHeightsWithPadding[taskObj.rowLevel - 1] || 0) + rowPaddingTop;\n      });\n    } else {\n      taskObjs.forEach((taskObj) => {\n        taskObj.y += rowPaddingTop;\n      });\n    }\n  }\n\n  const overlapChainHeights = overlapChains.map((chain) => {\n    let chainHeight = 0;\n    chain.forEach((chainTaskObj) => {\n      const distanceFromBottomToRowTop = chainTaskObj.y + chainTaskObj.height;\n      if (distanceFromBottomToRowTop > chainHeight) {\n        chainHeight = distanceFromBottomToRowTop;\n      }\n    });\n    return chainHeight;\n  });\n\n  let resolvedRowHeight: number;\n  if (rowHeight === undefined) {\n    // Grow the row height to accommodate everything\n    resolvedRowHeight =\n      overlapChainHeights.reduce((a, b) => {\n        return Math.max(a, b);\n      }) + rowPaddingTop;\n    // If no overlapping offset specified: Mid align task within its row level\n    if (overlapOffset === undefined) {\n      overlapChains.forEach((chain) => {\n        chain.forEach((taskObj) => {\n          const rowLevelHeight = rowLevelHeights[taskObj.rowLevel];\n          taskObj.y += (rowLevelHeight - taskObj.height) / 2 + rowY;\n        });\n      });\n    } else {\n      // Otherwise align all tasks to top (with offset)\n      overlapChains.forEach((chain) => {\n        chain.forEach((taskObj) => {\n          taskObj.y += rowY;\n        });\n      });\n    }\n  } else {\n    // Fix the row height and mid align everything\n    resolvedRowHeight = rowHeight;\n    overlapChains.forEach((chain, i) => {\n      const chainHeight = overlapChainHeights[i];\n      let minTaskY = Number.MAX_VALUE;\n      chain.forEach((taskObj) => {\n        taskObj.y += Math.floor((resolvedRowHeight - taskObj.height) / 2);\n        if (taskObj.y < minTaskY) {\n          minTaskY = taskObj.y;\n        }\n      });\n      const offsetFromRowCenter = Math.floor((resolvedRowHeight - chainHeight) / 2) - minTaskY;\n      chain.forEach((taskObj) => {\n        taskObj.y += rowY + offsetFromRowCenter;\n      });\n    });\n  }\n\n  return resolvedRowHeight;\n};\n\n/**\n * Computes the (unresolved) task labels layout.\n * This method modifies the given task layout objects with resolved layout information.\n * @param taskObjs The task layout object.\n * @param rowData The rows data.\n */\nconst calcTaskLabelLayout = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  taskObjs: GanttTaskLayoutObj<K2>[],\n  rowData: GanttProps<K2, D1, D2>['rows']\n) => {\n  // TODO: Support other label positions when we get to exposing those APIs\n  // For now, just take care of label position \"innerCenter\"\n  taskObjs.forEach((taskObj) => {\n    const { index, rowIndex } = taskObj;\n    const labelText = rowData[rowIndex].tasks[index].label;\n    if (labelText) {\n      taskObj.labelObj = {\n        startTime: taskObj.startTime,\n        endTime: taskObj.endTime,\n        label: labelText,\n        isInner: true,\n        position: 'center' // Future: unless inner, 'start' if labelPosition is 'end', 'end if labelPosition is 'start'\n        // TODO: Handle contrast color\n      };\n    }\n  });\n};\n\n/**\n * Computes the resolved task label layout given the unresolved label layout and the viewport.\n * @param labelObj The unresolved label layout object.\n * @param labelStyle The label style.\n * @param y The y position of the task.\n * @param height The height of the task.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @param viewportWidth The viewport width.\n * @param isRTL Whether the reading direction is rtl.\n * @returns The resolved label layout object.\n */\nconst getResolvedTaskLabelLayout = <K2>(\n  labelObj: GanttTaskLayoutObj<K2>['labelObj'],\n  labelStyle: GanttViewPortTaskLabelLayoutObj['labelStyle'],\n  y: number,\n  height: number,\n  viewportStartTime: number,\n  viewportEndTime: number,\n  viewportWidth: number,\n  isRTL: boolean\n) => {\n  if (!labelObj) return;\n  const startPos = getTimePosition(\n    labelObj.startTime,\n    viewportStartTime,\n    viewportEndTime,\n    viewportWidth,\n    isRTL\n  );\n  const endPos = getTimePosition(\n    labelObj.endTime,\n    viewportStartTime,\n    viewportEndTime,\n    viewportWidth,\n    isRTL\n  );\n  let textAlign: 'left' | 'center' | 'right';\n  switch (labelObj.position) {\n    case 'center':\n      textAlign = 'center';\n      break;\n    case 'start':\n      textAlign = isRTL ? 'right' : 'left';\n      break;\n    case 'end':\n      textAlign = isRTL ? 'left' : 'right';\n      break;\n    default: {\n      const _exhaustiveCheck: never = labelObj.position;\n      return _exhaustiveCheck;\n    }\n  }\n  return {\n    x: isRTL ? endPos : startPos,\n    y,\n    width: isRTL ? startPos - endPos : endPos - startPos,\n    height,\n    label: labelObj.label,\n    isInner: labelObj.isInner,\n    textAlign,\n    labelStyle\n  };\n};\n\n/**\n * Gets normalized start and end date strings from props,\n * e.g. one of them may be undefined in the props, but that really means both\n * start and end are the same.\n * @param task The task data containing the start and end date strings.\n * @returns Normalized start and end date strings.\n */\nconst getNormalizedStartEnd = (task: { start?: string; end?: string }) => {\n  const start = task.start ? task.start : task.end!;\n  const end = task.end ? task.end : task.start!;\n  return { start, end };\n};\n\n/**\n * Returns whether selection is supported given the selection mode.\n * @param selectionMode The selection mode from props.\n * @returns Whether selection is supported.\n */\nconst supportsSelection = (selectionMode?: 'none' | 'single' | 'multiple') => {\n  return !!(selectionMode && selectionMode !== 'none');\n};\n\n/**\n * Gets the (unresolved) rows data layout. Note that this is done for all rows in the data.\n * @param rowData The rows data.\n * @param resolvedVars The resolved CSS vars.\n * @param gridlines The gridlines prop value.\n * @param selectionProps The selection related props.\n * @returns The (unresolved) rows data layout.\n */\nconst getRowDataLayout = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  rowData: GanttProps<K2, D1, D2>['rows'],\n  resolvedVars: ReturnType<typeof getResolvedRowVars> & ReturnType<typeof getResolvedTaskVars>,\n  gridlines: { horizontal: 'on' | 'off'; vertical: 'on' | 'off' },\n  selectionProps: Omit<GanttSelectionProps<K2, D2>, 'onSelectionChange'>\n) => {\n  const selectionEnabled = supportsSelection(selectionProps.selectionMode);\n  const selectedIds = new Set(selectionProps.selectedIds);\n\n  let rowY = 0;\n  const rowObjs: GanttRowLayoutObj<K1, K2>[] = rowData.map((row, i) => {\n    const taskObjs: GanttTaskLayoutObj<K2>[] = row.tasks.map((task, j) => {\n      const { start, end } = getNormalizedStartEnd(task);\n      const startTime = parseDate(start);\n      const endTime = parseDate(end);\n      return {\n        id: task.id,\n        renderIndex: 0, // calculated downstream\n        index: j,\n        rowIndex: i,\n        y: -1, // calculated downstream\n        startTime,\n        endTime,\n        overallStartTime: startTime,\n        overallEndTime: endTime,\n        rowLevel: 0, // calculated downstream\n        height: task.height !== undefined ? task.height : resolvedVars.taskHeight,\n        borderRadius:\n          task.borderRadius !== undefined\n            ? task.borderRadius.toString()\n            : resolvedVars.taskBorderRadius,\n        fill: task.color ? task.color : resolvedVars.taskBgColor,\n        stroke: resolvedVars.taskBorderColor,\n        strokeWidth: 1,\n        isSelectable: selectionEnabled,\n        isSelected: selectedIds.has(task.id),\n        selectionEffect: {\n          stroke: resolvedVars.taskEffectBorderColor,\n          strokeWidth: 2,\n          padding: 2\n        },\n        hoverEffect: {\n          stroke: resolvedVars.taskEffectBorderColor,\n          strokeWidth: 1,\n          padding: 0,\n          shadow: {\n            ...resolvedVars.taskEffectBoxShadow\n          }\n        },\n        focusEffect: {\n          stroke: resolvedVars.taskEffectBorderColor,\n          strokeWidth: 1,\n          padding: 2\n        }\n      };\n    });\n\n    taskObjs.sort((a, b) => a.startTime - b.startTime);\n    taskObjs.forEach((t, i) => (t.renderIndex = i));\n\n    const resolvedRowHeight = calcRowTaskVerticalLayout({\n      rowHeight: row.height,\n      rowY,\n      taskObjs,\n      resolvedVars\n    });\n    calcTaskLabelLayout<K1, K2, D1, D2>(taskObjs, rowData);\n\n    const rowObj = {\n      id: row.id,\n      y: rowY,\n      height: resolvedRowHeight,\n      index: i,\n      isSelected: taskObjs.some((t) => t.isSelected),\n      taskObjs\n    };\n\n    const horizontalLineHeightOffset = gridlines.horizontal === 'on' ? 1 : 0;\n\n    rowY += resolvedRowHeight + horizontalLineHeightOffset;\n    return rowObj;\n  });\n\n  const lastRowLayoutObj = rowObjs[rowObjs.length - 1];\n  const totalRowsHeight = lastRowLayoutObj ? lastRowLayoutObj.y + lastRowLayoutObj.height : 0;\n\n  const idTaskObjMap = new Map<K2, GanttTaskLayoutObj<K2>>();\n  rowObjs.forEach((rowObj) =>\n    rowObj.taskObjs.forEach((taskObj) => idTaskObjMap.set(taskObj.id, taskObj))\n  );\n  const idRowObjMap = new Map<K1, GanttRowLayoutObj<K1, K2>>();\n  rowObjs.forEach((rowObj) => idRowObjMap.set(rowObj.id, rowObj));\n\n  const spatialIndex = getSpatialIndex(rowObjs);\n\n  return {\n    rowData,\n    rowObjs,\n    rowPadding: resolvedVars.rowPaddingTop,\n    totalRowsHeight,\n    gridlines,\n    spatialIndex,\n    idRowObjMap,\n    idTaskObjMap,\n    getTaskDataById: (id: K2) => {\n      const data = idTaskObjMap.get(id);\n      return data && rowData[data.rowIndex].tasks[data.index];\n    }\n  };\n};\n\n/**\n * Gets the corresponding task layout object given the id of the tasks, for each effect.\n * @param effectProps The task ids associated with each effect.\n * @param idTaskObjMap A Map between task ids and task layout objects.\n * @returns The task layout objects for each effect.\n */\nconst getEffectTaskObjs = <K2, D2>(\n  effectProps: {\n    selectionProps: Omit<GanttSelectionProps<K2, D2>, 'onSelectionChange'>;\n    hoverProps: Omit<GanttTaskHover<K2>, 'onTaskHoverChange'>;\n    currentProps: Omit<GanttCurrentTask<K2>, 'onCurrentTaskChange'>;\n  },\n  idTaskObjMap: Map<K2, GanttViewportTaskLayoutObj<K2>>\n) => {\n  // TODO: Decide whether the task selection source of truth should be in\n  // the rowObjs layout, or determined dynamically here, or both.\n  // Right now it's in both places.\n  // Let's decide after we figure out where eactly to memo for performance.\n  //\n  // Note we're rendering selectedIds regardless of selectionMode.\n  const selectedIds = effectProps.selectionProps.selectedIds || [];\n  const selectedTaskObjs: GanttViewportTaskLayoutObj<K2>[] = [];\n  selectedIds.forEach((id) => {\n    const selectedTaskObj = idTaskObjMap.get(id);\n    if (selectedTaskObj) selectedTaskObjs.push(selectedTaskObj);\n  });\n\n  const hoveredId = supportsSelection(effectProps.selectionProps.selectionMode)\n    ? effectProps.hoverProps.hoveredTaskId\n    : undefined;\n  const hoveredTaskObj = hoveredId !== undefined ? idTaskObjMap.get(hoveredId) : undefined;\n\n  const currentTask = effectProps.currentProps.currentTask;\n  const isTaskFocused = currentTask?.isFocused === true;\n  const currentTaskId = currentTask?.id;\n  const focusedTaskObj =\n    isTaskFocused && currentTaskId !== undefined ? idTaskObjMap.get(currentTaskId) : undefined;\n\n  return {\n    selectedTaskObjs,\n    hoveredTaskObj,\n    focusedTaskObj\n  };\n};\n\n/**\n * Gets the resolved task layout object for the given viewport, given the unresolved task layout object.\n * @param taskObj The unresolved task layout object.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @param viewportWidth The viewport width.\n * @param scrollPosition The scroll position.\n * @param isRTL Whether the reading direction is rtl.\n * @returns The resolved task layout object.\n */\nconst getResolvedTaskObj = <K2>(\n  taskObj: GanttTaskLayoutObj<K2>,\n  viewportStartTime: number,\n  viewportEndTime: number,\n  viewportWidth: number,\n  scrollPosition: number,\n  isRTL: boolean\n) => {\n  const startPos = getTimePosition(\n    taskObj.startTime,\n    viewportStartTime,\n    viewportEndTime,\n    viewportWidth,\n    isRTL\n  );\n  const endPos = getTimePosition(\n    taskObj.endTime,\n    viewportStartTime,\n    viewportEndTime,\n    viewportWidth,\n    isRTL\n  );\n  return {\n    ...taskObj,\n    x: isRTL ? endPos : startPos,\n    y: taskObj.y - scrollPosition,\n    width: isRTL ? startPos - endPos : endPos - startPos\n  };\n};\n\n/**\n * Gets the resolved rows data layout for the given viewport.\n * @param rowDataLayout The unresolved rows data layout object for all data.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @param scrollPosition The scroll position.\n * @param viewportWidth The viewport width.\n * @param viewportHeight The viewport height.\n * @param isRTL Whether the reading direction is rtl.\n * @returns The resolved rows data layout for the given viewport.\n */\nconst getResolvedViewportLayout = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  rowDataLayout: ReturnType<typeof getRowDataLayout<K1, K2, D1, D2>>,\n  viewportStartTime: number,\n  viewportEndTime: number,\n  scrollPosition: number,\n  viewportWidth: number,\n  viewportHeight: number,\n  isRTL: boolean\n) => {\n  const viewportYMin = scrollPosition;\n  const viewportYMax = scrollPosition + viewportHeight;\n  const rowYs = rowDataLayout.rowObjs.map((r) => r.y);\n  const { minRowInd, maxRowInd } = findRowIndRange(rowYs, viewportYMin, viewportYMax);\n\n  const viewportRowsLayout: GanttViewportRowLayoutObj<K1, K2>[] = [];\n  for (let i = minRowInd; i <= maxRowInd; i++) {\n    const rowObj = rowDataLayout.rowObjs[i];\n    const viewportTaskObjs = rowObj.taskObjs.filter(({ overallStartTime, overallEndTime }) =>\n      isIntervalOverlap(overallStartTime, overallEndTime, viewportStartTime, viewportEndTime)\n    );\n    const resolvedViewportTaskObjs = viewportTaskObjs.map((taskObj) =>\n      getResolvedTaskObj(\n        taskObj,\n        viewportStartTime,\n        viewportEndTime,\n        viewportWidth,\n        scrollPosition,\n        isRTL\n      )\n    );\n    const resolvedViewportRowObjs = {\n      ...rowObj,\n      y: rowObj.y - scrollPosition,\n      taskObjs: resolvedViewportTaskObjs\n    };\n    viewportRowsLayout.push(resolvedViewportRowObjs);\n  }\n\n  const viewportTaskLabelsLayout: GanttViewPortTaskLabelLayoutObj[] = [];\n  viewportRowsLayout.forEach((rowObj) => {\n    rowObj.taskObjs.forEach(({ index, rowIndex, labelObj, y, height }) => {\n      const labelStyle = rowDataLayout.rowData[rowIndex].tasks[index].labelStyle;\n      const labelLayout = getResolvedTaskLabelLayout(\n        labelObj,\n        labelStyle,\n        y,\n        height,\n        viewportStartTime,\n        viewportEndTime,\n        viewportWidth,\n        isRTL\n      );\n      if (labelLayout) viewportTaskLabelsLayout.push(labelLayout);\n    });\n  });\n\n  // due to pixel hinting, odd value stroke width needs it's position to be offset by 0.5 to ensure consistent behavior across browsers\n  // i.e. pos = pos + (strokeWidth % 2) * 0.5\n  // e.g. stroke-width of 1px means 0.5px above and below the reference coordinate. With pixel hinting, some browsers\n  // renders 1px above the reference, some renders 1px below the reference. If we offset the reference by 0.5px, the stroke location\n  // becomes unambiguous (it'll lock onto whole pixel grid) so all browsers will render this consistently.\n  const horizontalGridlinesPos =\n    rowDataLayout.gridlines.horizontal === 'on'\n      ? viewportRowsLayout.map(({ y, height }) => y + height + 0.5)\n      : undefined;\n\n  const idTaskObjMap = new Map<K2, GanttViewportTaskLayoutObj<K2>>();\n  viewportRowsLayout.forEach((rowObj) =>\n    rowObj.taskObjs.forEach((taskObj) => idTaskObjMap.set(taskObj.id, taskObj))\n  );\n\n  return {\n    spatialIndex: rowDataLayout.spatialIndex,\n    gridlines: rowDataLayout.gridlines,\n    horizontalGridlinesPos,\n    rowData: rowDataLayout.rowData,\n    allRowObjs: rowDataLayout.rowObjs,\n    allIdTaskObjMap: rowDataLayout.idTaskObjMap,\n    allIdRowObjMap: rowDataLayout.idRowObjMap,\n    rowPadding: rowDataLayout.rowPadding,\n    rowObjs: viewportRowsLayout,\n    taskLabelObjs: viewportTaskLabelsLayout,\n    idTaskObjMap,\n    getTaskDataById: rowDataLayout.getTaskDataById\n  };\n};\n\nexport {\n  getRowDataLayout,\n  getResolvedViewportLayout,\n  getEffectTaskObjs,\n  getNormalizedStartEnd,\n  supportsSelection,\n  getResolvedTaskObj\n};\nexport type {\n  GanttRowLayoutObj,\n  GanttTaskLayoutObj,\n  GanttViewportRowLayoutObj,\n  GanttViewportTaskLayoutObj,\n  ViewportLayout\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { generateAriaLabel } from '#utils/UNSAFE_visUtils/accUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport type { GanttProps, GanttRowData, GanttTaskData } from '../gantt.types';\nimport { GanttRowLayoutObj, GanttTaskLayoutObj, getNormalizedStartEnd } from './dataLayoutUtils';\n\n/**\n * Gets the default aria label for the task.\n * @param taskObj The task layout object.\n * @param rowData The rows data.\n * @param dateFormatter The date formatter.\n * @param translations The translations bundle.\n * @returns The default aria label.\n */\nconst getDefaultTaskAccessibleLabel = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  taskObj: GanttTaskLayoutObj<K2>,\n  rowData: GanttProps<K2, D1, D2>['rows'],\n  // TODO: take valueFormats instead of dateFormatter when we support the API\n  dateFormatter: (date: string) => string,\n  translations: BundleType\n) => {\n  const row = rowData[taskObj.rowIndex];\n  const task = row.tasks[taskObj.index];\n\n  const { start, end } = getNormalizedStartEnd(task);\n  const isMilestone = start === end;\n\n  const desc = [];\n  if (row.label) {\n    const rowDesc = translations.vis_labelAndValue({\n      LABEL: translations.gantt_labelRow(),\n      VALUE: row.label\n    });\n    desc.push(rowDesc);\n  }\n  if (!isMilestone) {\n    const startDesc = translations.vis_labelAndValue({\n      LABEL: translations.gantt_labelStart(),\n      VALUE: dateFormatter(start)\n    });\n    const endDesc = translations.vis_labelAndValue({\n      LABEL: translations.gantt_labelEnd(),\n      VALUE: dateFormatter(end)\n    });\n    desc.push(startDesc);\n    desc.push(endDesc);\n  } else {\n    const dateDesc = translations.vis_labelAndValue({\n      LABEL: translations.gantt_labelDate(),\n      VALUE: dateFormatter(start)\n    });\n    desc.push(dateDesc);\n  }\n  if (task.label) {\n    const labelDesc = translations.vis_labelAndValue({\n      LABEL: translations.gantt_labelLabel(),\n      VALUE: task.label\n    });\n    desc.push(labelDesc);\n  }\n  return desc.join('; ');\n};\n\n/**\n * Gets the aria label for the task.\n * @param taskObj The task layout object.\n * @param rowData The rows data.\n * @param dateFormatter The date formatter.\n * @param translations The translations bundle.\n * @returns The aria label for the task.\n */\nconst getTaskAriaLabel = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  taskObj: GanttTaskLayoutObj<K2>,\n  rowData: GanttProps<K2, D1, D2>['rows'],\n  dateFormatter: (date: string) => string,\n  translations: BundleType\n) => {\n  const data = rowData[taskObj.rowIndex].tasks[taskObj.index];\n  const accessibleLabel =\n    data.accessibleLabel !== undefined\n      ? data.accessibleLabel\n      : getDefaultTaskAccessibleLabel<K1, K2, D1, D2>(\n          taskObj,\n          rowData,\n          dateFormatter,\n          translations\n        );\n\n  return generateAriaLabel(translations, accessibleLabel, { isSelected: taskObj.isSelected });\n};\n\n/**\n * Gets the aria label for the row label\n * @param rowObj The row layout object.\n * @param rowData The rows data.\n * @returns The aria label for the row label.\n */\nconst getRowLabelAriaLabel = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  rowObj: GanttRowLayoutObj<K1, K2>,\n  rowData: GanttProps<K2, D1, D2>['rows']\n) => {\n  // TODO: There will be states when we support tree data\n  const data = rowData[rowObj.index];\n  const accessibleLabel = data.accessibleLabel || data.label;\n  return accessibleLabel;\n};\n\nexport { getTaskAriaLabel, getRowLabelAriaLabel };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { rowAxisStyles, rowBackgroundStyles } from './themes/GanttStyles.css';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport type { GanttProps, GanttRowData, GanttTaskData } from './gantt.types';\nimport { getRowLabelAriaLabel } from './utils/ariaUtils';\nimport { GanttRowLayoutObj } from './utils/dataLayoutUtils';\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  rowObj: GanttRowLayoutObj<K1, K2>;\n  rowData: GanttProps<K2, D1, D2>['rows'];\n  isRowSelected: boolean;\n  isFocused: boolean;\n  isHorizontalGridlinesVisible: boolean;\n  ariaActive?: { dataId: K1; ariaId: string; type: 'rowLabel' };\n  children: ComponentChildren;\n};\n\nexport function GanttRowLabelContainer<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  rowObj,\n  rowData,\n  isRowSelected,\n  isFocused,\n  isHorizontalGridlinesVisible,\n  ariaActive,\n  children\n}: Props<K1, K2, D1, D2>) {\n  const ariaLabel = getRowLabelAriaLabel(rowObj, rowData);\n  return (\n    <div\n      id={ariaActive?.dataId === rowObj.id ? ariaActive.ariaId : undefined}\n      key={rowObj.id}\n      data-oj-private-row-index={rowObj.index}\n      role=\"row\"\n      aria-label={ariaLabel}\n      class={classNames([\n        rowAxisStyles.labelContainer,\n        isRowSelected && rowBackgroundStyles.selected,\n        isFocused && rowAxisStyles.labelContainerFocused,\n        isHorizontalGridlinesVisible && rowAxisStyles.withLabelSeparatorBottom\n      ])}>\n      <div role=\"rowheader\">{children}</div>\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { RefObject, ComponentChildren } from 'preact';\nimport { Layer } from '#UNSAFE_Layer';\nimport { Floating, Placement } from '#UNSAFE_Floating';\nimport { useRef, useState } from 'preact/hooks';\nimport { styles } from '#hooks/PRIVATE_useDatatip/themes/useDatatip.css';\nimport { useId } from '#hooks/UNSAFE_useId';\nimport { Property } from 'csstype';\nimport { DATATIP_OFFSET } from '#utils/UNSAFE_visUtils/datatipUtils';\n\nexport type Dimension = { x: number; width: number; y: number; height: number };\n\ntype DatatipProps = {\n  /**\n   * The datatip content.\n   */\n  content?: ComponentChildren;\n\n  /**\n   * Whether the datatip is anchored to pointer or element.\n   *\n   */\n  anchor: 'element' | 'pointer';\n\n  /**\n   * The offset from the anchor element or pointer.\n   */\n  offset?: {\n    mainAxis?: number;\n    crossAxis?: number;\n  };\n\n  /**\n   * The border color of the datatip.\n   */\n  borderColor?: Property.BorderColor;\n\n  /**\n   * The placement of datatip from anchor point.\n   */\n  placement?: Placement;\n\n  targetFocusRef: RefObject<HTMLElement>;\n};\n\n/**\n * The hook to support custom datatip in visualization components.\n * TODO: THIS IS A TEMPORARY FORK OF PRIVATE_useDatatip until Gantt moves state up.\n */\nexport function useDatatip({\n  content,\n  placement = 'top-end-corner',\n  offset,\n  borderColor,\n  anchor,\n  targetFocusRef\n}: DatatipProps) {\n  const uniqueIdRef = useRef<string>(useId());\n  const [coords, setCoords] = useState({ x: 0, y: 0 });\n  const offsetValue = offset || { mainAxis: DATATIP_OFFSET, crossAxis: -1 * DATATIP_OFFSET };\n  const targetRef = useRef<HTMLElement | null>(null);\n\n  const onPointerMove = (event: PointerEvent) => {\n    setCoords({ x: event.clientX, y: event.clientY });\n  };\n\n  const onFocus = (event: FocusEvent) => {\n    if (event.eventPhase === Event.AT_TARGET || event.eventPhase === Event.BUBBLING_PHASE) {\n      targetRef.current = event.target as HTMLElement;\n    }\n  };\n\n  const onShowFocusDatatip = () => {\n    targetRef.current = targetFocusRef.current;\n  };\n\n  const onPointerEnter = (event: PointerEvent) => {\n    if (event.eventPhase === Event.AT_TARGET || event.eventPhase === Event.BUBBLING_PHASE) {\n      targetRef.current = event.currentTarget as HTMLElement;\n    }\n  };\n\n  // TODO: Why don't others need this? Find a way to remove this workaround\n  const onPointerLeave = () => {\n    setCoords({ x: -10000, y: -10000 });\n  };\n\n  const anchorRef = anchor === 'element' ? targetRef : { current: coords };\n  const datatipContent =\n    content != null ? (\n      <Layer>\n        <Floating\n          anchorRef={anchorRef}\n          placement={placement}\n          offsetValue={offsetValue}\n          flipOptions={{ crossAxis: true, mainAxis: true }}\n          shiftOptions={{ crossAxis: false, mainAxis: false }}>\n          <div id={uniqueIdRef.current} className={styles.visDatatipStyle} style={{ borderColor }}>\n            {content}\n          </div>\n        </Floating>\n      </Layer>\n    ) : null;\n\n  return {\n    datatipContent,\n    datatipProps: {\n      'aria-describedby': uniqueIdRef.current,\n      onPointerEnter,\n      onPointerLeave,\n      onPointerMove,\n      onFocus,\n      onShowFocusDatatip\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { RefObject } from 'preact';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useDatatip } from './useDatatip_FORK';\nimport { calculateOffset } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport type { GanttRowLayoutObj } from '../utils/dataLayoutUtils';\nimport type { GanttProps, GanttRowData, GanttTaskData } from '../gantt.types';\n\ntype UseGanttRowLabelDatatipOptions<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = {\n  targetRef: RefObject<HTMLElement>;\n  rowData: GanttProps<K2, D1, D2>['rows'];\n  hoveredRowObj?: GanttRowLayoutObj<K1, K2>;\n  focusedRowObj?: GanttRowLayoutObj<K1, K2>;\n  currentRowLabelInteraction: 'hover' | 'focus' | 'none';\n  rowAxisRegion: { x: number; y: number; w: number; h: number };\n};\n\n/**\n * Hook that handles row label datatip.\n */\nconst useGanttRowLabelDatatip = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  targetRef,\n  rowData,\n  hoveredRowObj,\n  focusedRowObj,\n  currentRowLabelInteraction,\n  rowAxisRegion\n}: UseGanttRowLabelDatatipOptions<K1, K2, D1, D2>) => {\n  const { direction } = useUser();\n  const isRTL = direction === 'rtl';\n\n  const config = {\n    hover: {\n      rowObj: hoveredRowObj,\n      anchor: 'pointer' as const\n    },\n    focus: {\n      rowObj: focusedRowObj,\n      anchor: 'element' as const\n    },\n    none: {\n      rowObj: undefined,\n      anchor: 'pointer' as const\n    }\n  };\n\n  const { anchor, rowObj: activeRowObj } = config[currentRowLabelInteraction];\n\n  const content = activeRowObj ? rowData[activeRowObj.index].accessibleLabel : undefined;\n\n  const elementBounds =\n    activeRowObj && anchor === 'element'\n      ? {\n          x: 0,\n          y: activeRowObj.y + rowAxisRegion.y,\n          width: rowAxisRegion.w,\n          height: activeRowObj.height\n        }\n      : undefined;\n\n  return useDatatip({\n    content,\n    anchor,\n    placement: 'top-start',\n    offset: calculateOffset(isRTL, rowAxisRegion.w, elementBounds),\n    targetFocusRef: targetRef\n  });\n};\n\nexport { useGanttRowLabelDatatip };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { GanttRowLabelHover } from '../gantt.types';\nimport { GanttRowLayoutObj } from '../utils/dataLayoutUtils';\n\ntype UseRowLabelPointerGestureOptions<K1, K2> = {\n  rowObjs: GanttRowLayoutObj<K1, K2>[];\n  hoverProps: GanttRowLabelHover<K1>;\n};\n\n/**\n * Hook that handles row labels pointer gestures.\n */\nconst useGanttRowLabelPointerGestures = <K1, K2>({\n  rowObjs,\n  hoverProps\n}: UseRowLabelPointerGestureOptions<K1, K2>) => {\n  const idExtracter = (event: PointerEvent) => {\n    const { clientX: x, clientY: y } = event;\n    // Just for fun, an alternative to getInfo -> getElementData that Chart is doing.\n    // TODO: think about whether this is more useful if we were to have a\n    // Visualization shared \"points to elements\" system. At face value, this actually might be slightly less\n    // efficient than the Chart method right now *in general*, because elementsFromPoint gives us ancestors\n    // beyond the root. For our row labels purpose however, there's no \"non-rowlabel\" whitespace\n    // so we'll definitely hit the element we want in like 2ish iterations so poor performance is not a concern.\n    const elements = document.elementsFromPoint(x, y) as HTMLElement[] | SVGElement[];\n    for (let i = 0; i < elements.length; i++) {\n      const dataRowIndex = elements[i].dataset['ojRowIndex'];\n      if (dataRowIndex) {\n        return rowObjs[Number(dataRowIndex)].id;\n      }\n    }\n    return undefined;\n  };\n\n  const onPointerMove = (event: PointerEvent) => {\n    const id = idExtracter(event);\n    if (id !== hoverProps.hoveredRowLabelId) {\n      hoverProps.onRowLabelHoverChange({ id });\n    }\n  };\n\n  return { onPointerMove };\n};\n\nexport { useGanttRowLabelPointerGestures };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport type {\n  GanttCurrentRowLabel,\n  GanttRowData,\n  GanttRowAxisProps as GanttRowAxisObject,\n  GanttRowLabelHover,\n  GanttTaskData,\n  GanttRowAxisLabelContext\n} from './gantt.types';\nimport { getRenderContext } from './utils/rowAxisUtils';\nimport type { getRowDataLayout } from './utils/dataLayoutUtils';\nimport { rowAxisStyles } from './themes/GanttStyles.css';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { GanttRowLabelContainer } from './GanttRowLabelContainer';\nimport { useGanttRowLabelDatatip } from './hooks/useGanttRowLabelDatatip';\nimport { useGanttRowLabelPointerGestures } from './hooks/useGanttRowLabelPointerGestures';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\n\ntype RowDataLayout<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = ReturnType<typeof getRowDataLayout<K1, K2, D1, D2>>;\ntype GanttRowAxisLabel<D1> = NonNullable<GanttRowAxisObject<D1>['labelRenderer']>;\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  innerRef: RefObject<HTMLDivElement>;\n  scrollPosition: number;\n  resolvedWidth: number;\n  resolvedMaxWidth: number;\n  currentRowLabel: GanttCurrentRowLabel<K1>['currentRowLabel'];\n  currentRowLabelInteraction: 'hover' | 'focus' | 'none';\n  layoutObj: {\n    labelPaddingInlineStart: number;\n    labelPaddingInlineEnd: number;\n    rowData: RowDataLayout<K1, K2, D1, D2>['rowData'];\n    rowObjs: RowDataLayout<K1, K2, D1, D2>['rowObjs'];\n    idRowObjMap: RowDataLayout<K1, K2, D1, D2>['idRowObjMap'];\n    isHorizontalGridlinesVisible: boolean;\n  };\n  ariaActive?: { dataId: K1; ariaId: string; type: 'rowLabel' };\n  children: GanttRowAxisLabel<D1>;\n} & GanttRowLabelHover<K1>;\n\nexport function GanttRowAxis<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  innerRef,\n  scrollPosition,\n  resolvedWidth,\n  resolvedMaxWidth,\n  currentRowLabel,\n  currentRowLabelInteraction,\n  hoveredRowLabelId,\n  onRowLabelHoverChange,\n  layoutObj: {\n    labelPaddingInlineStart,\n    labelPaddingInlineEnd,\n    rowData,\n    rowObjs,\n    idRowObjMap,\n    isHorizontalGridlinesVisible\n  },\n  ariaActive,\n  children\n}: Props<K1, K2, D1, D2>) {\n  const width = resolvedWidth !== Infinity ? resolvedWidth : undefined;\n  const maxWidth = resolvedMaxWidth !== Infinity ? resolvedMaxWidth : undefined;\n  const availableWidth = Math.min(resolvedWidth, resolvedMaxWidth);\n  const contextMaxWidth =\n    availableWidth === Infinity\n      ? -1\n      : availableWidth - (labelPaddingInlineStart + labelPaddingInlineEnd);\n\n  const gestureProps = useGanttRowLabelPointerGestures({\n    rowObjs,\n    hoverProps: { hoveredRowLabelId, onRowLabelHoverChange }\n  });\n\n  const { datatipContent, datatipProps } = useGanttRowLabelDatatip<K1, K2, D1, D2>({\n    rowData,\n    hoveredRowObj: hoveredRowLabelId && idRowObjMap.get(hoveredRowLabelId),\n    focusedRowObj: currentRowLabel?.isFocused ? idRowObjMap.get(currentRowLabel.id) : undefined,\n    currentRowLabelInteraction,\n    // TODO: Evaluate whether we should get real element bounds by measuring.\n    // It's unfortunate that we need to measure JUST for keyboard datatip positioning...\n    rowAxisRegion: {\n      x: 0,\n      y: -scrollPosition,\n      w: (labelPaddingInlineStart + labelPaddingInlineEnd) * 2,\n      h: -1\n    },\n    targetRef: innerRef\n  });\n\n  return (\n    <div\n      ref={innerRef}\n      {...mergeProps(gestureProps, datatipProps)}\n      class={classNames([\n        rowAxisStyles.base,\n        isHorizontalGridlinesVisible && rowAxisStyles.withSeparatorTop\n      ])}\n      style={{ width, maxWidth }}>\n      <div role=\"grid\" class={rowAxisStyles.contentContainer} style={{ top: -scrollPosition }}>\n        {rowObjs.map((rowObj) => {\n          return (\n            <GanttRowLabelContainer\n              ariaActive={ariaActive}\n              rowObj={rowObj}\n              rowData={rowData}\n              isRowSelected={rowObj.isSelected}\n              isFocused={!!currentRowLabel?.isFocused && currentRowLabel.id === rowObj.id}\n              isHorizontalGridlinesVisible={isHorizontalGridlinesVisible}>\n              {children(\n                getRenderContext(rowObj, rowData, contextMaxWidth) as GanttRowAxisLabelContext<D1>\n              )}\n            </GanttRowLabelContainer>\n          );\n        })}\n      </div>\n      {datatipContent}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\ntype Range = { min: number; max: number };\n\n/**\n * Gets the new range given the initial, global, and range ratio to apply. This applies a linear scale.\n * @param rangeRatio The range ratio to scale by.\n * @param initialRange The initial range.\n * @param globalRange The global range.\n * @returns The new linearly scaled range.\n */\nconst getNewRange = (rangeRatio: number, initialRange: Range, globalRange: Range) => {\n  const dRangeMin = initialRange.max - globalRange.max;\n  const dRangeMax = initialRange.min - globalRange.min;\n  const dRange = rangeRatio * (initialRange.max - initialRange.min);\n  const dRangeClamped = Math.max(dRangeMin, Math.min(dRange, dRangeMax));\n  return {\n    // Ensure positive min;\n    // For vertical scroll for example,\n    // it's possible for globalRange to be smaller than initialRange\n    // due to the component being taller than the height the data occupies\n    // e.g. tall Gantt with 1 row\n    min: Math.max(0, initialRange.min - dRangeClamped),\n    max: initialRange.max - dRangeClamped\n  };\n};\n\n/**\n * Performs a pan, by invoking the given onRangeChange callback with the new range.\n * @param rangeRatio The range ratio to scale by.\n * @param initialRange The initial range.\n * @param prevRange The previous range.\n * @param globalRange The global range.\n * @param onRangeChange The callback to invoke with the new range.\n * @returns The new range and whether the range actually changed.\n */\nconst pan = (\n  rangeRatio: number,\n  initialRange: Range,\n  prevRange: Range,\n  globalRange: Range,\n  onRangeChange: (detail: Range) => void\n) => {\n  const newRange = getNewRange(rangeRatio, initialRange, globalRange);\n  const { min: prevMin, max: prevMax } = prevRange;\n  const isRangeChanged = newRange.min !== prevMin || newRange.max !== prevMax;\n  isRangeChanged && onRangeChange(newRange);\n  return { newRange, isRangeChanged };\n};\n\nexport { type Range, pan };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { GanttRowData, GanttTaskData } from '#UNSAFE_Gantt/gantt.types';\nimport type { getRowDataLayout } from './dataLayoutUtils';\n\ntype RowDataLayout<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = ReturnType<typeof getRowDataLayout<K1, K2, D1, D2>>;\n\n/**\n * Gets the default task to initially receive logical focus upon component focus.\n * @param param0 The (unresolved) row data layout.\n * @returns The task (if there are any) to receive focus.\n */\nconst getDefaultInitialFocusTask = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  rowObjs\n}: RowDataLayout<K1, K2, D1, D2>) => {\n  // Default to the first task of the first row (if it exists)\n  if (rowObjs.length === 0) return;\n  if (rowObjs[0].taskObjs.length === 0) return;\n  return { id: rowObjs[0].taskObjs[0].id, isFocused: true };\n};\n\n/**\n * Gets next or previous navigable task from the current task.\n * @param currentTask The current task.\n * @param param1 The (unresolved) row data layout.\n * @param direction 'next' or 'prev'\n * @returns The adjacent navigable task according to the given direction.\n */\nconst getAdjacentTaskNavigable = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentTask: K2,\n  { rowObjs, idTaskObjMap }: RowDataLayout<K1, K2, D1, D2>,\n  direction: 'next' | 'prev'\n) => {\n  const currentTaskObj = idTaskObjMap.get(currentTask);\n  if (!currentTaskObj) return;\n\n  const indexOffset = direction === 'next' ? 1 : -1;\n  const { rowIndex, renderIndex: index } = currentTaskObj;\n\n  // Return adjacent task in the row if it exists\n  const adjTaskObj = rowObjs[rowIndex].taskObjs[index + indexOffset];\n  if (adjTaskObj) return adjTaskObj.id;\n\n  // Return a task in adjacent row if it exists\n  // For 'next' direction, this is the first task of the next row\n  // For 'prev' direction, this is the last task of the previous row\n  const adjRowObj = rowObjs[rowIndex + indexOffset];\n  if (adjRowObj) {\n    const adjTaskObj =\n      direction === 'next'\n        ? adjRowObj.taskObjs[0]\n        : adjRowObj.taskObjs[adjRowObj.taskObjs.length - 1];\n    if (adjTaskObj) return adjTaskObj.id;\n  }\n\n  return;\n};\n\n/**\n * Gets above or below navigable task from the current task.\n * @param currentTask The current task.\n * @param param1 The (unresolved) row data layout.\n * @param direction 'up' or 'down'\n * @returns The adjacent navigable task according to the given direction.\n */\nconst getVerticalTaskNavigable = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentTask: K2,\n  { rowObjs, idTaskObjMap }: RowDataLayout<K1, K2, D1, D2>,\n  direction: 'up' | 'down'\n) => {\n  const currentTaskObj = idTaskObjMap.get(currentTask);\n  if (!currentTaskObj) return;\n\n  const rowIndexOffset = direction === 'down' ? 1 : -1;\n  const { rowIndex } = currentTaskObj;\n\n  // Return first task in the adjacent row if it exists\n  const adjRowObj = rowObjs[rowIndex + rowIndexOffset];\n  if (!adjRowObj) return;\n\n  const adjTaskObj = adjRowObj.taskObjs[0];\n  if (adjTaskObj) return adjTaskObj.id;\n\n  return;\n};\n\n/**\n * Gets the next navigable task from the current task.\n * @param currentTask The current task.\n * @param rowDataLayout The (unresolved) row data layout.\n * @returns The next navigable task.\n */\nconst getNextTaskNavigable = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentTask: K2,\n  rowDataLayout: RowDataLayout<K1, K2, D1, D2>\n) => getAdjacentTaskNavigable(currentTask, rowDataLayout, 'next');\n\n/**\n * Gets the previous navigable task from the current task.\n * @param currentTask The current task.\n * @param rowDataLayout The (unresolved) row data layout.\n * @returns The previous navigable task.\n */\nconst getPrevTaskNavigable = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentTask: K2,\n  rowDataLayout: RowDataLayout<K1, K2, D1, D2>\n) => getAdjacentTaskNavigable(currentTask, rowDataLayout, 'prev');\n\n/**\n * Gets the navigable task above the current task.\n * @param currentTask The current task.\n * @param rowDataLayout The (unresolved) row data layout.\n * @returns The navigable task above.\n */\nconst getAboveTaskNavigable = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentTask: K2,\n  rowDataLayout: RowDataLayout<K1, K2, D1, D2>\n) => getVerticalTaskNavigable(currentTask, rowDataLayout, 'up');\n\n/**\n * Gets the navigable task below the current task.\n * @param currentTask The current task.\n * @param rowDataLayout The (unresolved) row data layout.\n * @returns The navigable task below.\n */\nconst getBelowTaskNavigable = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentTask: K2,\n  rowDataLayout: RowDataLayout<K1, K2, D1, D2>\n) => getVerticalTaskNavigable(currentTask, rowDataLayout, 'down');\n\n/**\n * Gets above or below navigable row label from the current row label.\n * @param currentRowLabel The current row label.\n * @param param1 The (unresolved) row data layout.\n * @param direction 'up' or 'down'\n * @returns The adjacent navigable row label according to the given direction.\n */\nconst getAdjacentRowLabelNavigable = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentRowLabel: K1,\n  { rowObjs, idRowObjMap }: RowDataLayout<K1, K2, D1, D2>,\n  direction: 'up' | 'down'\n) => {\n  const currentRowObj = idRowObjMap.get(currentRowLabel);\n  if (!currentRowObj) return;\n\n  const rowIndexOffset = direction === 'down' ? 1 : -1;\n  const { index: rowIndex } = currentRowObj;\n  const adjRowObj = rowObjs[rowIndex + rowIndexOffset];\n  if (!adjRowObj) return;\n\n  return adjRowObj.id;\n};\n\n/**\n * Gets the navigable row label above the current row label.\n * @param currentRowLabel The current row label.\n * @param rowDataLayout The (unresolved) row data layout.\n * @returns The navigable row label above.\n */\nconst getAboveRowLabelNavigable = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentRowLabel: K1,\n  rowDataLayout: RowDataLayout<K1, K2, D1, D2>\n) => getAdjacentRowLabelNavigable(currentRowLabel, rowDataLayout, 'up');\n\n/**\n * Gets the navigable row label below the current row label.\n * @param currentRowLabel The current row label.\n * @param rowDataLayout The (unresolved) row data layout.\n * @returns The navigable row label below.\n */\nconst getBelowRowLabelNavigable = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentRowLabel: K1,\n  rowDataLayout: RowDataLayout<K1, K2, D1, D2>\n) => getAdjacentRowLabelNavigable(currentRowLabel, rowDataLayout, 'down');\n\n/**\n * Gets the row label navigable from the current task.\n * @param currentTask The current task.\n * @param rowDataLayout The (unresolved) row data layout.\n * @returns The row label navigable from the current task.\n */\nconst getRowLabelNavigableFromTask = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentTask: K2,\n  rowDataLayout: RowDataLayout<K1, K2, D1, D2>\n) => {\n  // taskObj should not be undefined because you must start from\n  // a focused task to get to a rowlabel.\n  const taskObj = rowDataLayout.idTaskObjMap.get(currentTask)!;\n  const { rowIndex } = taskObj;\n  const rowObj = rowDataLayout.rowObjs[rowIndex];\n  return rowObj.id;\n};\n\n/**\n * Gets the task navigable from the current row label.\n * @param currentRowLabel The current row label.\n * @param rowDataLayout The (unresolved) row data layout.\n * @param currentTask If any, the last current task (e.g. the last focused task).\n * @returns The task navigable from the current row label.\n */\nconst getTaskNavigableFromRowLabel = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  currentRowLabel: K1,\n  rowDataLayout: RowDataLayout<K1, K2, D1, D2>,\n  currentTask?: K2\n) => {\n  if (currentTask !== undefined) {\n    const taskObj = rowDataLayout.idTaskObjMap.get(currentTask);\n    if (taskObj) {\n      const { rowIndex } = taskObj;\n      const rowObj = rowDataLayout.rowObjs[rowIndex];\n      if (rowObj.id === currentRowLabel) {\n        return currentTask;\n      }\n    }\n  }\n  const rowObj = rowDataLayout.idRowObjMap.get(currentRowLabel);\n  const firstTaskObj = rowObj?.taskObjs[0];\n  if (firstTaskObj) {\n    return firstTaskObj.id;\n  }\n  const defaultTask = getDefaultInitialFocusTask(rowDataLayout);\n  return defaultTask?.id;\n};\n\n/**\n * Gets the dx and dy necessary to pan the given region into view.\n * @param region The target region to pan into view.\n * @param viewportRegion The viewport region.\n * @param isRTL Whether the reading direction is rtl.\n * @param xPriority The side in the x direction to prioritize scroll into view.\n * @param yPriority The side in the y direction to prioritize scroll into view.\n * @param overShoot The extra amount of space to pan by.\n * @returns The dx and dy values.\n */\nconst getPanIntoViewValues = (\n  region: { x: number; y: number; w: number; h: number },\n  viewportRegion: { x: number; y: number; w: number; h: number },\n  isRTL: boolean,\n  xPriority: 'start' | 'end' | 'auto' = 'auto',\n  yPriority: 'top' | 'bottom' | 'auto' = 'auto',\n  overShoot = 0\n) => {\n  const deltaXLeftVisible = Math.min(region.x - viewportRegion.x - overShoot, 0);\n  const deltaXRightVisible = Math.max(\n    0,\n    region.x + region.w - (viewportRegion.x + viewportRegion.w) + overShoot\n  );\n  const deltaXStartVisible = isRTL ? deltaXRightVisible : deltaXLeftVisible;\n  const deltaXEndVisible = isRTL ? deltaXLeftVisible : deltaXRightVisible;\n\n  let deltaX = 0;\n  switch (xPriority) {\n    case 'start':\n      deltaX = deltaXStartVisible;\n      break;\n    case 'end':\n      deltaX = deltaXEndVisible;\n      break;\n    case 'auto':\n      deltaX = (!isRTL ? deltaXEndVisible > 0 : deltaXEndVisible < 0)\n        ? deltaXEndVisible\n        : deltaXStartVisible; // 'end' wins if just 'end', or both sides, require panning. 'start' otherwise.\n      break;\n    default: {\n      const _exhaustiveCheck: never = xPriority;\n      return _exhaustiveCheck;\n    }\n  }\n\n  const deltaYTopVisible = Math.min(region.y - viewportRegion.y - overShoot, 0);\n  const deltaYBottomVisible = Math.max(\n    0,\n    region.y + region.h - (viewportRegion.y + viewportRegion.h) + overShoot\n  );\n\n  let deltaY = 0;\n  switch (yPriority) {\n    case 'top':\n      deltaY = deltaYTopVisible;\n      break;\n    case 'bottom':\n      deltaY = deltaYBottomVisible;\n      break;\n    case 'auto':\n      deltaY = deltaYTopVisible < 0 ? deltaYTopVisible : deltaYBottomVisible; // 'top' wins if just 'top', or both sides, require panning. 'bottom' otherwise.\n      break;\n    default: {\n      const _exhaustiveCheck: never = yPriority;\n      return _exhaustiveCheck;\n    }\n  }\n\n  return { dx: -deltaX, dy: -deltaY };\n};\n\nexport {\n  getDefaultInitialFocusTask,\n  getNextTaskNavigable,\n  getPrevTaskNavigable,\n  getAboveTaskNavigable,\n  getBelowTaskNavigable,\n  getPanIntoViewValues,\n  getAboveRowLabelNavigable,\n  getBelowRowLabelNavigable,\n  getRowLabelNavigableFromTask,\n  getTaskNavigableFromRowLabel\n};\n","import { useRef } from 'preact/hooks';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useKbPan } from '#PRIVATE_TimeComponent/hooks/useKbPan';\nimport { getResolvedTaskObj, type ViewportLayout } from '../utils/dataLayoutUtils';\nimport { getPanIntoViewValues } from '../utils/navigationUtils';\nimport { pan } from '#PRIVATE_TimeComponent/utils/panUtils';\nimport type { GanttRowData, GanttTaskData } from '../gantt.types';\n\ntype UseGanttKbPan<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = Parameters<typeof useKbPan>[0] & {\n  viewportLayout: ViewportLayout<K1, K2, D1, D2>;\n  dataBodyWidth: number;\n  dataBodyHeight: number;\n  viewportStartTime: number;\n  viewportEndTime: number;\n  scrollPosition: number;\n};\n\n/**\n * Hook that handles keyboard panning related gestures on a Gantt.\n */\nconst useGanttKbPan = <K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>>({\n  viewportLayout,\n  dataBodyWidth,\n  dataBodyHeight,\n  viewportStartTime,\n  viewportEndTime,\n  scrollPosition,\n  ...panOptions\n}: UseGanttKbPan<K1, K2, D1, D2>) => {\n  const { direction } = useUser();\n  const isRTL = direction === 'rtl';\n  const kbPanProps = useKbPan(panOptions);\n\n  const prevRangeX = useRef({ min: 0, max: 0 });\n  const prevRangeY = useRef({ min: 0, max: 0 });\n  const panBy = (dx = 0, dy = 0) => {\n    if (dx !== 0) {\n      const { newRange: newRangeX } = pan(\n        dx / dataBodyWidth,\n        panOptions.getRangeX(),\n        prevRangeX.current,\n        panOptions.globalRangeX,\n        panOptions.onRangeXChange\n      );\n      prevRangeX.current = newRangeX;\n    }\n\n    if (dy !== 0) {\n      const { newRange: newRangeY } = pan(\n        dy / dataBodyHeight,\n        panOptions.getRangeY(),\n        prevRangeY.current,\n        panOptions.globalRangeY,\n        panOptions.onRangeYChange\n      );\n      prevRangeY.current = newRangeY;\n    }\n  };\n\n  const onKbPanTaskIntoView = (e: CustomEvent<{ id: K2 }>) => {\n    let taskObj = viewportLayout.idTaskObjMap.get(e.detail.id);\n    if (!taskObj) {\n      // task may be outside viewport\n      const unresolvedTaskObj = viewportLayout.allIdTaskObjMap.get(e.detail.id);\n      if (!unresolvedTaskObj) return;\n      taskObj = getResolvedTaskObj(\n        unresolvedTaskObj,\n        viewportStartTime,\n        viewportEndTime,\n        dataBodyWidth,\n        scrollPosition,\n        isRTL\n      );\n    }\n\n    const { x, y, width: w, height: h } = taskObj;\n\n    const region = { x, y, w, h };\n    const viewportRegion = { x: 0, y: 0, w: dataBodyWidth, h: dataBodyHeight };\n    const overShoot = viewportLayout.rowPadding;\n    const { dx, dy } = getPanIntoViewValues(\n      region,\n      viewportRegion,\n      isRTL,\n      'auto',\n      'auto',\n      overShoot\n    );\n    panBy(dx, dy);\n  };\n\n  const onKbPanRowIntoView = (e: CustomEvent<{ id: K1 }>) => {\n    const rowObj = viewportLayout.allIdRowObjMap.get(e.detail.id);\n    if (!rowObj) return;\n\n    const region = { x: 0, y: rowObj.y - scrollPosition, w: dataBodyWidth, h: rowObj.height };\n    const viewportRegion = { x: 0, y: 0, w: dataBodyWidth, h: dataBodyHeight };\n    const overShoot = viewportLayout.rowPadding;\n    const { dy } = getPanIntoViewValues(region, viewportRegion, isRTL, 'auto', 'auto', overShoot);\n    panBy(0, dy);\n  };\n\n  return panOptions.isDisabled\n    ? {}\n    : {\n        ...kbPanProps,\n        onKbPanTaskIntoView,\n        onKbPanRowIntoView\n      };\n};\n\nexport { useGanttKbPan };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useRef } from 'preact/hooks';\nimport { Range, pan } from '../utils/panUtils';\nimport { KbPanEvent } from '../utils/keyboardUtils';\n\ntype UseKbPanOptions = {\n  width: number;\n  height: number;\n  getRangeX: () => Range;\n  getRangeY: () => Range;\n  globalRangeX: Range;\n  globalRangeY: Range;\n  onRangeXChange: (detail: Range) => void;\n  onRangeYChange: (detail: Range) => void;\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that enables and handles keyboard panning gesture.\n */\nconst useKbPan = ({\n  getRangeX,\n  getRangeY,\n  globalRangeX,\n  globalRangeY,\n  onRangeXChange,\n  onRangeYChange,\n  isDisabled = false\n}: UseKbPanOptions) => {\n  const prevRangeX = useRef({ min: 0, max: 0 });\n  const prevRangeY = useRef({ min: 0, max: 0 });\n\n  const onKbPanHorizontal = (e: KbPanEvent) => {\n    const {\n      detail: { rangeRatio }\n    } = e;\n    const { newRange: newRangeX } = pan(\n      rangeRatio,\n      getRangeX(),\n      prevRangeX.current,\n      globalRangeX,\n      onRangeXChange\n    );\n    prevRangeX.current = newRangeX;\n  };\n\n  const onKbPanVertical = (e: KbPanEvent) => {\n    const {\n      detail: { rangeRatio }\n    } = e;\n    const { newRange: newRangeY } = pan(\n      rangeRatio,\n      getRangeY(),\n      prevRangeY.current,\n      globalRangeY,\n      onRangeYChange\n    );\n    prevRangeY.current = newRangeY;\n  };\n\n  return isDisabled\n    ? {}\n    : {\n        onKbPanHorizontal,\n        onKbPanVertical\n      };\n};\n\nexport { useKbPan };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { useDragPan } from '#PRIVATE_TimeComponent/hooks/useDragPan';\nimport { useWheelPan } from '#PRIVATE_TimeComponent/hooks/useWheelPan';\nimport { usePinchZoom } from '#PRIVATE_TimeComponent/hooks/usePinchZoom';\nimport { useWheelZoom } from '#PRIVATE_TimeComponent/hooks/useWheelZoom';\nimport { useKbZoom } from '#PRIVATE_TimeComponent/hooks/useKbZoom';\nimport { useGanttKbPan } from './useGanttKbPan';\nimport { getISOString } from '#PRIVATE_TimeComponent/utils/timeUtils';\nimport {\n  OnTimeComponentViewportChange,\n  TimeComponentScale,\n  TimeComponentZoomParameters\n} from '#PRIVATE_TimeComponent/timeComponent.types';\nimport { GanttRowData, GanttTaskData, OnGanttScrollPositionChange } from '../gantt.types';\nimport type { ViewportLayout } from '../utils/dataLayoutUtils';\n\ntype UsePanZoomGestureOptions<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = {\n  captureTargetRef: RefObject<HTMLDivElement>;\n  width: number;\n  height: number;\n  viewportStartTime: number;\n  viewportEndTime: number;\n  majorAxisScale?: TimeComponentScale;\n  minorAxisScale: TimeComponentScale;\n  startTime: number;\n  endTime: number;\n  zoomParameters: TimeComponentZoomParameters;\n  scrollPosition: number;\n  dataBodyHeight: number;\n  totalRowsHeight: number;\n  viewportLayout: ViewportLayout<K1, K2, D1, D2>;\n  onViewportChange?: OnTimeComponentViewportChange;\n  onScrollPositionChange?: OnGanttScrollPositionChange;\n  onCursorChange?: (detail: { cursor: 'grabbing' | 'grabbingUnset' }) => void;\n  isPanDisabled?: boolean;\n  isZoomDisabled?: boolean;\n};\n\n/**\n * Hook that handles pan/zoom related gestures on a Gantt.\n */\nconst useGanttPanZoomGestures = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  captureTargetRef,\n  width,\n  height,\n  viewportStartTime,\n  viewportEndTime,\n  majorAxisScale,\n  minorAxisScale,\n  startTime,\n  endTime,\n  zoomParameters,\n  scrollPosition,\n  dataBodyHeight,\n  totalRowsHeight,\n  viewportLayout,\n  onViewportChange,\n  onScrollPositionChange,\n  onCursorChange,\n  isPanDisabled,\n  isZoomDisabled\n}: UsePanZoomGestureOptions<K1, K2, D1, D2>) => {\n  const panOptions = {\n    captureTargetRef,\n    width,\n    height,\n    getRangeX: () => ({ min: viewportStartTime, max: viewportEndTime }),\n    getRangeY: () => ({ min: scrollPosition, max: scrollPosition + dataBodyHeight }),\n    globalRangeX: { min: startTime, max: endTime },\n    globalRangeY: { min: 0, max: totalRowsHeight },\n    onRangeXChange: (newRange: { min: number; max: number }) => {\n      onViewportChange?.({\n        viewportStart: getISOString(newRange.min),\n        viewportEnd: getISOString(newRange.max),\n        majorAxisScale,\n        minorAxisScale\n      });\n    },\n    onRangeYChange: (newRange: { min: number; max: number }) => {\n      onScrollPositionChange?.({\n        y: newRange.min\n      });\n    },\n    isDisabled: isPanDisabled\n  };\n\n  const { getZoomOrderViewDurationThresholds, ...restZoomParameters } = zoomParameters;\n  const zoomOrderViewDurationThresholds = getZoomOrderViewDurationThresholds(width);\n  const zoomOptions = {\n    captureTargetRef,\n    width,\n    ...restZoomParameters,\n    zoomOrderViewDurationThresholds,\n    onViewportChange,\n    isDisabled: isZoomDisabled\n  };\n\n  const dragPanProps = useDragPan({\n    ...panOptions,\n    onDragPanStart: () => onCursorChange?.({ cursor: 'grabbing' }),\n    onDragPanEnd: () => onCursorChange?.({ cursor: 'grabbingUnset' })\n  });\n  const wheelPanProps = useWheelPan(panOptions);\n  const kbPanProps = useGanttKbPan<K1, K2, D1, D2>({\n    ...panOptions,\n    viewportLayout,\n    dataBodyWidth: width,\n    dataBodyHeight,\n    viewportStartTime,\n    viewportEndTime,\n    scrollPosition\n  });\n  const pinchZoomProps = usePinchZoom(zoomOptions);\n  const wheelZoomProps = useWheelZoom(zoomOptions);\n  const kbZoomProps = useKbZoom(zoomOptions);\n  const gestureProps = mergeProps(\n    dragPanProps,\n    wheelPanProps,\n    kbPanProps,\n    pinchZoomProps,\n    wheelZoomProps,\n    kbZoomProps\n  );\n\n  return { gestureProps };\n};\n\nexport { useGanttPanZoomGestures };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useRef } from 'preact/hooks';\nimport { useDrag } from './useDrag';\nimport { Range, pan } from '../utils/panUtils';\nimport { useUser } from '#hooks/UNSAFE_useUser';\n\ntype UseDragPanOptions = {\n  captureTargetRef: RefObject<HTMLDivElement>;\n  width: number;\n  height: number;\n  getRangeX: () => Range;\n  getRangeY: () => Range;\n  globalRangeX: Range;\n  globalRangeY: Range;\n  onRangeXChange: (detail: Range) => void;\n  onRangeYChange: (detail: Range) => void;\n  onDragPanStart?: () => void;\n  onDragPanEnd?: () => void;\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that enables and handles drag pan gestures.\n */\nconst useDragPan = ({\n  captureTargetRef,\n  width,\n  height,\n  getRangeX,\n  getRangeY,\n  globalRangeX,\n  globalRangeY,\n  onRangeXChange,\n  onRangeYChange,\n  onDragPanStart,\n  onDragPanEnd,\n  isDisabled = false\n}: UseDragPanOptions) => {\n  const { direction } = useUser();\n  const prevRangeX = useRef({ min: 0, max: 0 });\n  const prevRangeY = useRef({ min: 0, max: 0 });\n  const initialRangeX = useRef({ min: 0, max: 0 });\n  const initialRangeY = useRef({ min: 0, max: 0 });\n  const isPanning = useRef(false);\n\n  const dragProps = useDrag({\n    captureTargetRef,\n    onDragStart: () => {\n      initialRangeX.current = getRangeX();\n      initialRangeY.current = getRangeY();\n      onDragPanStart && onDragPanStart();\n    },\n    onDragMove: ({ dx, dy }) => {\n      isPanning.current = true;\n\n      const { newRange: newRangeX } = pan(\n        ((direction === 'rtl' ? -1 : 1) * dx) / width,\n        initialRangeX.current,\n        prevRangeX.current,\n        globalRangeX,\n        onRangeXChange\n      );\n      prevRangeX.current = newRangeX;\n\n      const { newRange: newRangeY } = pan(\n        dy / height,\n        initialRangeY.current,\n        prevRangeY.current,\n        globalRangeY,\n        onRangeYChange\n      );\n      prevRangeY.current = newRangeY;\n    },\n    onDragEnd: ({ originalEvent }) => {\n      // If panning occurred, call preventDefault to prevent selection from occurring\n      if (isPanning.current) originalEvent.preventDefault();\n      isPanning.current = false;\n      onDragPanEnd && onDragPanEnd();\n    },\n    isDisabled\n  });\n\n  return isDisabled ? {} : dragProps;\n};\n\nexport { useDragPan };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useRef } from 'preact/hooks';\nimport { useWheel } from './useWheel';\nimport { Range, pan } from '../utils/panUtils';\nimport { useUser } from '#hooks/UNSAFE_useUser';\n\ntype UseWheelPanOptions = {\n  width: number;\n  height: number;\n  getRangeX: () => Range;\n  getRangeY: () => Range;\n  globalRangeX: Range;\n  globalRangeY: Range;\n  onRangeXChange: (detail: Range) => void;\n  onRangeYChange: (detail: Range) => void;\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that enables and handles wheel pan gestures.\n */\nconst useWheelPan = ({\n  width,\n  height,\n  getRangeX,\n  getRangeY,\n  globalRangeX,\n  globalRangeY,\n  onRangeXChange,\n  onRangeYChange,\n  isDisabled = false\n}: UseWheelPanOptions) => {\n  const { direction } = useUser();\n  const prevRangeX = useRef({ min: 0, max: 0 });\n  const prevRangeY = useRef({ min: 0, max: 0 });\n\n  const wheelProps = useWheel({\n    onWheel: ({ deltaX: dx, deltaY: dy, ctrlKey }) => {\n      // WheelEvent with ctrlKey means pinch/zoom gesture\n      if (ctrlKey) return;\n\n      const { newRange: newRangeX } = pan(\n        ((direction === 'rtl' ? -1 : 1) * dx) / width,\n        getRangeX(),\n        prevRangeX.current,\n        globalRangeX,\n        onRangeXChange\n      );\n      prevRangeX.current = newRangeX;\n\n      const { newRange: newRangeY } = pan(\n        dy / height,\n        getRangeY(),\n        prevRangeY.current,\n        globalRangeY,\n        onRangeYChange\n      );\n      prevRangeY.current = newRangeY;\n    },\n    isDisabled\n  });\n\n  return isDisabled ? {} : wheelProps;\n};\n\nexport { useWheelPan };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { usePinch } from './usePinch';\nimport { getGestureZoomFactor, zoomTime } from '../utils/timeZoomUtils';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { OnTimeComponentViewportChange, TimeComponentZoomParameters } from '../timeComponent.types';\nimport { getPositionTime } from '../utils/timeUtils';\n\ntype UsePinchZoomOptions = {\n  captureTargetRef: RefObject<HTMLDivElement>;\n  width: number;\n  startTime: number;\n  endTime: number;\n  viewportStartTime: number;\n  viewportEndTime: number;\n  majorAxisZoomOrder?: TimeComponentZoomParameters['majorAxisZoomOrder'];\n  majorAxisZoomOrderIndex?: TimeComponentZoomParameters['majorAxisZoomOrderIndex'];\n  minorAxisZoomOrder: TimeComponentZoomParameters['minorAxisZoomOrder'];\n  minorAxisZoomOrderIndex: TimeComponentZoomParameters['minorAxisZoomOrderIndex'];\n  zoomOrderViewDurationThresholds: ReturnType<\n    TimeComponentZoomParameters['getZoomOrderViewDurationThresholds']\n  >;\n  minZoomViewportDuration: TimeComponentZoomParameters['minZoomViewportDuration'];\n  maxZoomViewportDuration: TimeComponentZoomParameters['maxZoomViewportDuration'];\n  onViewportChange?: OnTimeComponentViewportChange;\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that enables and handles pinch zoom gestures.\n */\nconst usePinchZoom = ({\n  captureTargetRef,\n  width,\n  startTime,\n  endTime,\n  viewportStartTime,\n  viewportEndTime,\n  majorAxisZoomOrder,\n  majorAxisZoomOrderIndex,\n  minorAxisZoomOrder,\n  minorAxisZoomOrderIndex,\n  zoomOrderViewDurationThresholds,\n  minZoomViewportDuration,\n  maxZoomViewportDuration,\n  onViewportChange,\n  isDisabled = false\n}: UsePinchZoomOptions) => {\n  const { direction } = useUser();\n  const isRTL = direction === 'rtl';\n\n  const pinchProps = usePinch({\n    captureTargetRef,\n    onPinchZoomChange: ({ origin: { x }, delta }) => {\n      const time = getPositionTime(x, viewportStartTime, viewportEndTime, width, isRTL);\n      zoomTime(\n        time,\n        viewportStartTime,\n        viewportEndTime,\n        startTime,\n        endTime,\n        getGestureZoomFactor(delta),\n        minZoomViewportDuration,\n        maxZoomViewportDuration,\n        zoomOrderViewDurationThresholds,\n        minorAxisZoomOrder,\n        minorAxisZoomOrderIndex,\n        majorAxisZoomOrder,\n        majorAxisZoomOrderIndex,\n        onViewportChange\n      );\n    },\n    isDisabled\n  });\n\n  return isDisabled ? {} : pinchProps;\n};\n\nexport { usePinchZoom };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useWheel } from './useWheel';\nimport { getGestureZoomFactor, zoomTime } from '../utils/timeZoomUtils';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { OnTimeComponentViewportChange, TimeComponentZoomParameters } from '../timeComponent.types';\nimport { getPositionTime } from '../utils/timeUtils';\n\ntype UseWheelZoomOptions = {\n  width: number;\n  startTime: number;\n  endTime: number;\n  viewportStartTime: number;\n  viewportEndTime: number;\n  majorAxisZoomOrder?: TimeComponentZoomParameters['majorAxisZoomOrder'];\n  majorAxisZoomOrderIndex?: TimeComponentZoomParameters['majorAxisZoomOrderIndex'];\n  minorAxisZoomOrder: TimeComponentZoomParameters['minorAxisZoomOrder'];\n  minorAxisZoomOrderIndex: TimeComponentZoomParameters['minorAxisZoomOrderIndex'];\n  zoomOrderViewDurationThresholds: ReturnType<\n    TimeComponentZoomParameters['getZoomOrderViewDurationThresholds']\n  >;\n  minZoomViewportDuration: TimeComponentZoomParameters['minZoomViewportDuration'];\n  maxZoomViewportDuration: TimeComponentZoomParameters['maxZoomViewportDuration'];\n  onViewportChange?: OnTimeComponentViewportChange;\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that enables and handles wheen zoom gestures.\n */\nconst useWheelZoom = ({\n  width,\n  startTime,\n  endTime,\n  viewportStartTime,\n  viewportEndTime,\n  majorAxisZoomOrder,\n  majorAxisZoomOrderIndex,\n  minorAxisZoomOrder,\n  minorAxisZoomOrderIndex,\n  zoomOrderViewDurationThresholds,\n  minZoomViewportDuration,\n  maxZoomViewportDuration,\n  onViewportChange,\n  isDisabled = false\n}: UseWheelZoomOptions) => {\n  const { direction } = useUser();\n  const isRTL = direction === 'rtl';\n\n  const wheelProps = useWheel({\n    onWheel: ({ x, deltaY, ctrlKey }) => {\n      // WheelEvent with ctrlKey means pinch/zoom gesture\n      if (!ctrlKey) return;\n\n      const time = getPositionTime(x, viewportStartTime, viewportEndTime, width, isRTL);\n      zoomTime(\n        time,\n        viewportStartTime,\n        viewportEndTime,\n        startTime,\n        endTime,\n        getGestureZoomFactor(deltaY),\n        minZoomViewportDuration,\n        maxZoomViewportDuration,\n        zoomOrderViewDurationThresholds,\n        minorAxisZoomOrder,\n        minorAxisZoomOrderIndex,\n        majorAxisZoomOrder,\n        majorAxisZoomOrderIndex,\n        onViewportChange\n      );\n    },\n    isDisabled\n  });\n\n  return isDisabled ? {} : wheelProps;\n};\n\nexport { useWheelZoom };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { zoomTime } from '../utils/timeZoomUtils';\nimport { KbZoomEvent } from '../utils/keyboardUtils';\nimport { OnTimeComponentViewportChange, TimeComponentZoomParameters } from '../timeComponent.types';\n\ntype UseKbZoomOptions = {\n  startTime: number;\n  endTime: number;\n  viewportStartTime: number;\n  viewportEndTime: number;\n  majorAxisZoomOrder?: TimeComponentZoomParameters['majorAxisZoomOrder'];\n  majorAxisZoomOrderIndex?: TimeComponentZoomParameters['majorAxisZoomOrderIndex'];\n  minorAxisZoomOrder: TimeComponentZoomParameters['minorAxisZoomOrder'];\n  minorAxisZoomOrderIndex: TimeComponentZoomParameters['minorAxisZoomOrderIndex'];\n  zoomOrderViewDurationThresholds: ReturnType<\n    TimeComponentZoomParameters['getZoomOrderViewDurationThresholds']\n  >;\n  minZoomViewportDuration: TimeComponentZoomParameters['minZoomViewportDuration'];\n  maxZoomViewportDuration: TimeComponentZoomParameters['maxZoomViewportDuration'];\n  onViewportChange?: OnTimeComponentViewportChange;\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that enables and handles keyboard zooming gestures.\n */\nconst useKbZoom = ({\n  startTime,\n  endTime,\n  viewportStartTime,\n  viewportEndTime,\n  majorAxisZoomOrder,\n  majorAxisZoomOrderIndex,\n  minorAxisZoomOrder,\n  minorAxisZoomOrderIndex,\n  zoomOrderViewDurationThresholds,\n  minZoomViewportDuration,\n  maxZoomViewportDuration,\n  onViewportChange,\n  isDisabled = false\n}: UseKbZoomOptions) => {\n  const onKbZoomIn = (e: KbZoomEvent) => {\n    const viewportCenter = viewportStartTime + (viewportEndTime - viewportStartTime) / 2;\n    zoomTime(\n      viewportCenter,\n      viewportStartTime,\n      viewportEndTime,\n      startTime,\n      endTime,\n      e.detail.zoomFactor,\n      minZoomViewportDuration,\n      maxZoomViewportDuration,\n      zoomOrderViewDurationThresholds,\n      minorAxisZoomOrder,\n      minorAxisZoomOrderIndex,\n      majorAxisZoomOrder,\n      majorAxisZoomOrderIndex,\n      onViewportChange\n    );\n  };\n\n  const onKbZoomOut = (e: KbZoomEvent) => {\n    const viewportCenter = viewportStartTime + (viewportEndTime - viewportStartTime) / 2;\n    zoomTime(\n      viewportCenter,\n      viewportStartTime,\n      viewportEndTime,\n      startTime,\n      endTime,\n      e.detail.zoomFactor,\n      minZoomViewportDuration,\n      maxZoomViewportDuration,\n      zoomOrderViewDurationThresholds,\n      minorAxisZoomOrder,\n      minorAxisZoomOrderIndex,\n      majorAxisZoomOrder,\n      majorAxisZoomOrderIndex,\n      onViewportChange\n    );\n  };\n\n  return isDisabled\n    ? {}\n    : {\n        onKbZoomIn,\n        onKbZoomOut\n      };\n};\n\nexport { useKbZoom };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { RefObject } from 'preact';\nimport { useDatatip } from './useDatatip_FORK';\nimport { calculateOffset } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport type { GanttViewportTaskLayoutObj } from '../utils/dataLayoutUtils';\nimport type { GanttProps, GanttRowData, GanttTaskData } from '../gantt.types';\nimport { getDefaultDatatipRenderer, getRenderContext } from '../utils/datatipUtils';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { BundleType } from '#resources/nls/bundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\n\ntype UseGanttTaskDatatipOptions<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = {\n  targetRef: RefObject<HTMLElement>;\n  datatip?: GanttProps<K2, D1, D2>['datatip'];\n  rowData: GanttProps<K2, D1, D2>['rows'];\n  dateFormatter: (date: string) => string;\n  hoveredTaskObj?: GanttViewportTaskLayoutObj<K2>;\n  focusedTaskObj?: GanttViewportTaskLayoutObj<K2>;\n  currentTaskInteraction: 'hover' | 'focus' | 'none';\n  dataBodyRegion: { x: number; y: number; w: number; h: number };\n};\n\n/**\n * Hook that handles task datatip.\n */\nconst useGanttTaskDatatip = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  targetRef,\n  datatip,\n  rowData,\n  dateFormatter,\n  hoveredTaskObj,\n  focusedTaskObj,\n  currentTaskInteraction,\n  dataBodyRegion\n}: UseGanttTaskDatatipOptions<K1, K2, D1, D2>) => {\n  const { direction } = useUser();\n  const isRTL = direction === 'rtl';\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const config = {\n    hover: {\n      taskObj: hoveredTaskObj,\n      anchor: 'pointer' as const\n    },\n    focus: {\n      taskObj: focusedTaskObj,\n      anchor: 'element' as const\n    },\n    none: {\n      taskObj: undefined,\n      anchor: 'pointer' as const\n    }\n  };\n\n  const { anchor, taskObj: activeTaskObj } = config[currentTaskInteraction];\n\n  const datatipRenderer =\n    datatip ??\n    getDefaultDatatipRenderer<K1, K2, D1, D2>({\n      translations,\n      dateFormatter,\n      isRTL\n    });\n\n  const { content, borderColor } = activeTaskObj\n    ? datatipRenderer(getRenderContext<K1, K2, D1, D2>(rowData, activeTaskObj))\n    : { content: undefined, borderColor: undefined };\n\n  const elementBounds =\n    activeTaskObj && anchor === 'element'\n      ? {\n          x: activeTaskObj.x,\n          y: activeTaskObj.y + dataBodyRegion.y,\n          width: activeTaskObj.width,\n          height: activeTaskObj.height\n        }\n      : undefined;\n\n  return useDatatip({\n    content,\n    anchor,\n    placement: 'top-start',\n    offset: calculateOffset(isRTL, dataBodyRegion.w, elementBounds),\n    borderColor,\n    targetFocusRef: targetRef\n  });\n};\n\nexport { useGanttTaskDatatip };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { VisTabularDatatip } from '#PRIVATE_VisTabularDatatip';\nimport type { BundleType } from '#resources/nls/bundle';\nimport type { GanttDatatipContext, GanttProps, GanttRowData, GanttTaskData } from '../gantt.types';\nimport { getNormalizedStartEnd } from './dataLayoutUtils';\n\n/**\n * Gets the default datatip renderer.\n * @param options Relevant information.\n * @returns The default datatip renderer.\n */\nconst getDefaultDatatipRenderer = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(options: {\n  translations: BundleType;\n  dateFormatter: (date: string) => string;\n  isRTL: boolean;\n}): NonNullable<GanttProps<K2, D1, D2>['datatip']> => {\n  const { translations, dateFormatter } = options;\n  const defaultDatatipRenderer = ({ data, rowData }: GanttDatatipContext<D1, D2>) => {\n    if (data.accessibleLabel !== undefined) {\n      return { content: data.accessibleLabel };\n    }\n\n    const { start, end } = getNormalizedStartEnd(data);\n    const isMilestone = start === end;\n\n    const tableData = [];\n\n    if (rowData.label) {\n      tableData.push({ key: translations.gantt_labelRow(), value: rowData.label });\n    }\n    if (!isMilestone) {\n      tableData.push({ key: translations.gantt_labelStart(), value: dateFormatter(start) });\n      tableData.push({ key: translations.gantt_labelEnd(), value: dateFormatter(end) });\n    } else {\n      tableData.push({ key: translations.gantt_labelDate(), value: dateFormatter(start) });\n    }\n    if (data.label) {\n      tableData.push({ key: translations.gantt_labelLabel(), value: data.label });\n    }\n\n    const content = <VisTabularDatatip tableData={tableData} />;\n    return { content };\n  };\n  return defaultDatatipRenderer;\n};\n\n/**\n * Gets the datatip renderer context.\n * @param rows The rows data.\n * @param layoutObj The task layout object.\n * @returns\n */\nconst getRenderContext = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>(\n  rows: GanttProps<K2, D1, D2>['rows'],\n  layoutObj: { index: number; rowIndex: number }\n): GanttDatatipContext<D1, D2> => {\n  const { index, rowIndex } = layoutObj;\n  return {\n    data: rows[rowIndex].tasks[index],\n    rowData: rows[rowIndex]\n  };\n};\n\nexport { getDefaultDatatipRenderer, getRenderContext };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { RefObject, ComponentChildren } from 'preact';\nimport { useState } from 'preact/hooks';\nimport { Property } from 'csstype';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { TrackResizeContainer } from '#UNSAFE_TrackResizeContainer';\nimport { getResolvedTimeAxesLayout } from '#PRIVATE_TimeComponent/utils/timeAxisLayoutUtils';\nimport { timeAxisDataBodyStyles } from './themes/GanttStyles.css';\nimport {\n  OnTimeComponentViewportChange,\n  TimeComponentZoomParameters\n} from '#PRIVATE_TimeComponent/timeComponent.types';\nimport { getDefaultDateFormatter, getISOString } from '#PRIVATE_TimeComponent/utils/timeUtils';\nimport {\n  getEffectTaskObjs,\n  getResolvedViewportLayout,\n  type ViewportLayout,\n  type getRowDataLayout\n} from './utils/dataLayoutUtils';\nimport { useGanttPanZoomGestures } from './hooks/useGanttPanZoomGestures';\nimport type {\n  GanttCurrentTask,\n  GanttProps,\n  GanttRowData,\n  GanttSelection as GanttSelectionProps,\n  GanttTaskData,\n  GanttTaskHover,\n  OnGanttScrollPositionChange\n} from './gantt.types';\nimport { useGanttTaskPointerGestures } from './hooks/useGanttTaskPointerGestures';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { useGanttTaskDatatip } from './hooks/useGanttTaskDatatip';\n\ntype GetTimeAxesLayout = ReturnType<typeof getResolvedTimeAxesLayout>;\ntype MajorAxisLayout = Omit<\n  NonNullable<ReturnType<GetTimeAxesLayout>['majorAxis']>,\n  'gridTicksPos'\n>;\ntype MinorAxisLayout = Omit<ReturnType<GetTimeAxesLayout>['minorAxis'], 'gridTicksPos'>;\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  innerRef: RefObject<HTMLDivElement>;\n  isRTL: boolean;\n  scrollPosition: number;\n  onScrollPositionChange?: OnGanttScrollPositionChange;\n  isViewportDefined: boolean;\n  onViewportChange?: OnTimeComponentViewportChange;\n  zoomParameters?: TimeComponentZoomParameters;\n  zooming: 'on' | 'off';\n  getTimeAxesLayout: ReturnType<typeof getResolvedTimeAxesLayout>;\n  getResolvedViewportLayout: typeof getResolvedViewportLayout<K1, K2, D1, D2>;\n  rowDataLayout: ReturnType<typeof getRowDataLayout<K1, K2, D1, D2>>;\n  rowAxisSeparator: boolean;\n  datatip?: GanttProps<K2, D1, D2>['datatip'];\n  majorAxis: (layout: MajorAxisLayout) => ComponentChildren;\n  minorAxis: (layout: MinorAxisLayout) => ComponentChildren;\n  dataBody: (layout: {\n    width: number;\n    height: number;\n    viewportLayout: ViewportLayout<K1, K2, D1, D2>;\n    minorAxisLayout: MinorAxisLayout;\n    effectsLayout: ReturnType<typeof getEffectTaskObjs<K2, D2>>;\n    dateFormatter: (date: string) => string;\n    ariaActiveTask?: { dataId: K2; ariaId: string; type: 'task' };\n  }) => ComponentChildren;\n  currentTaskInteraction: 'hover' | 'focus' | 'none';\n  ariaActive?: { dataId: K2; ariaId: string; type: 'task' };\n} & GanttSelectionProps<K2, D2> &\n  GanttTaskHover<K2> &\n  GanttCurrentTask<K2>;\n\nexport function GanttTimeAxisDataBody<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  innerRef,\n  isRTL,\n  scrollPosition,\n  onScrollPositionChange,\n  isViewportDefined,\n  onViewportChange,\n  zoomParameters,\n  zooming,\n  selectedIds,\n  selectionMode,\n  onSelectionChange,\n  hoveredTaskId,\n  onTaskHoverChange,\n  currentTask,\n  onCurrentTaskChange,\n  currentTaskInteraction,\n  ariaActive,\n  getTimeAxesLayout,\n  getResolvedViewportLayout,\n  rowDataLayout,\n  rowAxisSeparator,\n  datatip,\n  majorAxis,\n  minorAxis,\n  dataBody\n}: Props<K1, K2, D1, D2>) {\n  if (!isViewportDefined) {\n    return (\n      <TrackResizeContainer width=\"100%\" height=\"100%\">\n        {(width) => {\n          const timeAxesLayout = getTimeAxesLayout(width);\n          const {\n            majorAxis: majorAxisLayout,\n            minorAxis: minorAxisLayout,\n            viewportStartTime,\n            viewportEndTime\n          } = timeAxesLayout;\n          const majorAxisScale =\n            majorAxisLayout && majorAxisLayout.zoomOrder[majorAxisLayout.zoomOrderIndex];\n          const minorAxisScale = minorAxisLayout.zoomOrder[minorAxisLayout.zoomOrderIndex];\n\n          onViewportChange?.({\n            viewportStart: getISOString(viewportStartTime),\n            viewportEnd: getISOString(viewportEndTime),\n            majorAxisScale,\n            minorAxisScale\n          });\n          return null;\n        }}\n      </TrackResizeContainer>\n    );\n  }\n  return (\n    <TrackResizeContainer width=\"100%\" height=\"100%\">\n      {function _(width, height) {\n        const timeAxesLayout = getTimeAxesLayout(width);\n        const {\n          position,\n          majorAxis: majorAxisLayout,\n          minorAxis: minorAxisLayout,\n          viewportStartTime,\n          viewportEndTime,\n          startTime,\n          endTime\n        } = timeAxesLayout;\n        const majorAxisScale =\n          majorAxisLayout && majorAxisLayout.zoomOrder[majorAxisLayout.zoomOrderIndex];\n        const minorAxisScale = minorAxisLayout.zoomOrder[minorAxisLayout.zoomOrderIndex];\n\n        const majorAxisHeight = majorAxisLayout ? majorAxisLayout.height : 0;\n        const { height: minorAxisHeight } = minorAxisLayout;\n        const dataBodyHeight = height - (majorAxisHeight + minorAxisHeight);\n\n        const viewportLayout = getResolvedViewportLayout(\n          rowDataLayout,\n          viewportStartTime,\n          viewportEndTime,\n          scrollPosition,\n          width,\n          dataBodyHeight,\n          isRTL\n        );\n        const effectsLayout = getEffectTaskObjs(\n          {\n            selectionProps: { selectedIds, selectionMode },\n            hoverProps: { hoveredTaskId },\n            currentProps: { currentTask }\n          },\n          viewportLayout.idTaskObjMap\n        );\n        const defaultDateFormatter = getDefaultDateFormatter(minorAxisScale, viewportStartTime);\n\n        const majorAxisComp = majorAxisLayout && majorAxis(majorAxisLayout);\n        const minorAxisComp = minorAxis(minorAxisLayout);\n        const dataBodyComp = dataBody({\n          width,\n          height: dataBodyHeight,\n          viewportLayout,\n          minorAxisLayout,\n          effectsLayout,\n          dateFormatter: defaultDateFormatter,\n          ariaActiveTask: ariaActive\n        });\n\n        const layout = {\n          top: {\n            components: [majorAxisComp, minorAxisComp, dataBodyComp],\n            dataBodyPos: height - dataBodyHeight\n          },\n          bottom: {\n            components: [dataBodyComp, minorAxisComp, majorAxisComp],\n            dataBodyPos: 0\n          }\n        };\n\n        // Temporary; this will be a Gantt prop when we add marquee selection support\n        const dragMode = 'pan';\n\n        // TODO: think about a better cursor management system\n        const [cursor, setCursor] = useState<Property.Cursor>();\n        const onCursorChange = (detail: {\n          cursor: 'grabbing' | 'grabbingUnset' | 'pointer' | 'pointerUnset';\n        }) =>\n          setCursor((prevCursor) => {\n            if (prevCursor === undefined) return detail.cursor;\n            if (prevCursor === 'grabbing' && detail.cursor !== 'grabbingUnset') return 'grabbing';\n            if (detail.cursor === 'grabbingUnset' || detail.cursor === 'pointerUnset')\n              return undefined;\n            return detail.cursor;\n          });\n\n        const { gestureProps: panZoomGestureProps } = useGanttPanZoomGestures({\n          captureTargetRef: innerRef,\n          width,\n          height,\n          viewportStartTime,\n          viewportEndTime,\n          majorAxisScale,\n          minorAxisScale,\n          startTime,\n          endTime,\n          zoomParameters: zoomParameters!,\n          scrollPosition,\n          dataBodyHeight,\n          totalRowsHeight: rowDataLayout.totalRowsHeight,\n          viewportLayout,\n          onViewportChange: (args) => {\n            if (onViewportChange) {\n              onViewportChange(args);\n              // TODO: Evaluate whether it's okay to clear hover behavior on pan and zoom\n              onTaskHoverChange({ id: undefined });\n            }\n          },\n          onScrollPositionChange: (args) => {\n            if (onScrollPositionChange) {\n              onScrollPositionChange(args);\n              // TODO: Evaluate whether it's okay to clear hover behavior on pan\n              onTaskHoverChange({ id: undefined });\n            }\n          },\n          onCursorChange,\n          isPanDisabled: dragMode !== 'pan',\n          isZoomDisabled: zooming === 'off'\n        });\n\n        const dataBodyRegion = {\n          x: 0,\n          y: layout[position].dataBodyPos,\n          w: width,\n          h: dataBodyHeight\n        };\n        const { gestureProps: taskGestureProps, selectionContent } = useGanttTaskPointerGestures({\n          viewportLayout,\n          viewportYOffset: scrollPosition - layout[position].dataBodyPos,\n          dataBodyRegion,\n          viewportStartTime,\n          viewportEndTime,\n          width,\n          isRTL,\n          selectionProps: { selectedIds, selectionMode, onSelectionChange },\n          hoverProps: { hoveredTaskId, onTaskHoverChange },\n          currentProps: { currentTask, onCurrentTaskChange },\n          onCursorChange\n        });\n\n        const { datatipContent, datatipProps } = useGanttTaskDatatip<K1, K2, D1, D2>({\n          datatip,\n          rowData: viewportLayout.rowData,\n          dateFormatter: defaultDateFormatter,\n          hoveredTaskObj: hoveredTaskId && viewportLayout.idTaskObjMap.get(hoveredTaskId),\n          focusedTaskObj: effectsLayout.focusedTaskObj,\n          currentTaskInteraction,\n          dataBodyRegion,\n          targetRef: innerRef\n        });\n\n        const gestureProps = mergeProps(panZoomGestureProps, taskGestureProps, datatipProps);\n\n        return (\n          <div\n            ref={innerRef}\n            {...gestureProps}\n            class={classNames([\n              timeAxisDataBodyStyles.base,\n              dragMode === 'pan' && timeAxisDataBodyStyles.pannable,\n              isRTL\n                ? rowAxisSeparator && timeAxisDataBodyStyles.withRowAxisSeparatorRight\n                : rowAxisSeparator && timeAxisDataBodyStyles.withRowAxisSeparatorLeft\n            ])}\n            style={{ cursor }}>\n            {layout[position].components}\n            {datatipContent}\n            {selectionContent}\n          </div>\n        );\n      }}\n    </TrackResizeContainer>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { getPositionTime } from '#PRIVATE_TimeComponent/utils/timeUtils';\nimport { useSelection } from '#hooks/PRIVATE_useVisSelection';\nimport type {\n  GanttCurrentTask,\n  GanttRowData,\n  GanttSelection as GanttSelectionProps,\n  GanttTaskData,\n  GanttTaskHover\n} from '../gantt.types';\nimport { type ViewportLayout, supportsSelection } from '../utils/dataLayoutUtils';\nimport { queryTasksSpatialIndex } from '../utils/spatialUtils';\n\ntype UseTaskPointerGestureOptions<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = {\n  viewportLayout: ViewportLayout<K1, K2, D1, D2>;\n  viewportYOffset: number;\n  dataBodyRegion: { x: number; y: number; w: number; h: number };\n  viewportStartTime: number;\n  viewportEndTime: number;\n  width: number;\n  isRTL: boolean;\n  selectionProps: GanttSelectionProps<K2, D2>;\n  hoverProps: GanttTaskHover<K2>;\n  currentProps: GanttCurrentTask<K2>;\n  onCursorChange?: (detail: { cursor: 'pointer' | 'pointerUnset' }) => void;\n};\n\n/**\n * Hook that handles task pointer gestures.\n */\nconst useGanttTaskPointerGestures = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  viewportLayout,\n  viewportYOffset,\n  dataBodyRegion,\n  viewportStartTime,\n  viewportEndTime,\n  width,\n  isRTL,\n  selectionProps,\n  hoverProps,\n  currentProps,\n  onCursorChange\n}: UseTaskPointerGestureOptions<K1, K2, D1, D2>) => {\n  const { x: dbx, y: dby, w: dbw, h: dbh } = dataBodyRegion;\n  const selectionSupported = supportsSelection(selectionProps.selectionMode);\n\n  const idExtracter = (event: Event) => {\n    const rowObjs = viewportLayout.allRowObjs;\n    const spatialIndex = viewportLayout.spatialIndex;\n    const { offsetX: x, offsetY: y } = event as MouseEvent;\n    const inDataBody = !(x < dbx || x > dbx + dbw || y < dby || y > dby + dbh);\n    if (!inDataBody) return;\n\n    const timePoint = {\n      time: getPositionTime(x, viewportStartTime, viewportEndTime, width, isRTL),\n      y: y + viewportYOffset\n    };\n    const targetIndices = queryTasksSpatialIndex(rowObjs, spatialIndex.tasks, timePoint);\n    if (!targetIndices) return;\n\n    const { rowIndex, taskIndex } = targetIndices;\n    return rowObjs[rowIndex].taskObjs[taskIndex].id;\n  };\n\n  const onPointerMove = (event: PointerEvent) => {\n    const id = idExtracter(event);\n    if (id !== hoverProps.hoveredTaskId) {\n      hoverProps.onTaskHoverChange({ id });\n    }\n    selectionSupported &&\n      onCursorChange?.({ cursor: id !== undefined ? 'pointer' : 'pointerUnset' });\n  };\n\n  const onPointerUp = (event: PointerEvent) => {\n    const id = idExtracter(event);\n    if (id !== undefined) {\n      selectionSupported && onCursorChange?.({ cursor: 'pointer' });\n      if (id !== currentProps?.currentTask?.id) {\n        currentProps.onCurrentTaskChange({ id, isFocused: false });\n      }\n    }\n  };\n\n  const hoverPointerGestureProps = { onPointerMove };\n  const focusPointerGestureProps = { onPointerUp };\n\n  const {\n    selectionProps: { onKeyUp, ...selectionPointerGestureProps },\n    selectionContent\n  } = useSelection<K2, D2>({\n    idExtracter,\n    selection: selectionProps.selectedIds,\n    selectionMode: selectionProps.selectionMode,\n    onChange: selectionProps.onSelectionChange,\n    getDataById: viewportLayout.getTaskDataById\n  });\n\n  const gestureProps = mergeProps(\n    hoverPointerGestureProps,\n    focusPointerGestureProps,\n    selectionPointerGestureProps\n  );\n\n  return { gestureProps, selectionContent };\n};\n\nexport { useGanttTaskPointerGestures };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { horizontalGridlinesStyles } from './themes/GanttStyles.css';\n\ntype Props = {\n  width: number;\n  height: number;\n  positions: number[];\n};\n\nexport function GanttHorizontalGridlinesLayer({ width, height, positions }: Props) {\n  const cmd = positions.map((p) => `M0,${p} H${width}`).join(' ');\n  return (\n    <svg width={width} height={height}>\n      <path class={horizontalGridlinesStyles.base} d={cmd} />\n    </svg>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { getRandomId } from '#utils/PRIVATE_visLayoutUtils';\nimport type { GanttViewportTaskLayoutObj, ViewportLayout } from './utils/dataLayoutUtils';\nimport { useMemo, useRef } from 'preact/hooks';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { BundleType } from '#resources/nls/bundle';\nimport { getTaskAriaLabel } from './utils/ariaUtils';\nimport type { GanttRowData, GanttTaskData } from './gantt.types';\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  width: number;\n  height: number;\n  rowData: ViewportLayout<K1, K2, D1, D2>['rowData'];\n  dateFormatter: (date: string) => string;\n  ariaActiveId?: string;\n  ariaActiveTaskObj?: GanttViewportTaskLayoutObj<K2>;\n};\n\nexport function GanttDesktopTaskAccContent<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  width,\n  height,\n  rowData,\n  dateFormatter,\n  ariaActiveId,\n  ariaActiveTaskObj\n}: Props<K1, K2, D1, D2>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const idIndex = useRef(0);\n  const ids = useMemo(() => {\n    const ids =\n      idIndex.current === 0 ? [ariaActiveId, getRandomId()] : [getRandomId(), ariaActiveId];\n    idIndex.current = Math.abs(idIndex.current - 1);\n    return ids;\n  }, [ariaActiveId]);\n\n  const ariaLabel =\n    ariaActiveTaskObj && getTaskAriaLabel(ariaActiveTaskObj, rowData, dateFormatter, translations);\n\n  return (\n    <div style={{ width, height }}>\n      <div role=\"img\" id={ids[0]} aria-label={ariaLabel}></div>\n      <div role=\"img\" id={ids[1]} aria-label={ariaLabel}></div>\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport type { ViewportLayout } from './utils/dataLayoutUtils';\nimport { getTaskAriaLabel } from './utils/ariaUtils';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { BundleType } from '#resources/nls/bundle';\nimport { taskMobileAccStyles } from './themes/GanttStyles.css';\nimport type { GanttRowData, GanttTaskData } from './gantt.types';\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  width: number;\n  height: number;\n  rowData: ViewportLayout<K1, K2, D1, D2>['rowData'];\n  dateFormatter: (date: string) => string;\n  layoutObjs: ViewportLayout<K1, K2, D1, D2>['rowObjs'];\n};\n\nexport function GanttMobileTaskAccContent<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({ width, height, rowData, dateFormatter, layoutObjs }: Props<K1, K2, D1, D2>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const content: ComponentChildren[] = [];\n  layoutObjs.forEach((rowObj) => {\n    rowObj.taskObjs.forEach((taskObj) => {\n      const ariaLabel = getTaskAriaLabel(taskObj, rowData, dateFormatter, translations);\n      content.push(\n        <div\n          role=\"img\"\n          aria-label={ariaLabel}\n          class={taskMobileAccStyles.content}\n          style={{\n            width: taskObj.width,\n            height: taskObj.height,\n            top: taskObj.y,\n            left: taskObj.x\n          }}></div>\n      );\n    });\n  });\n\n  return (\n    <div class={taskMobileAccStyles.base} style={{ width, height }}>\n      {content}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { supportsMobileScreenReader } from '#utils/UNSAFE_visUtils';\nimport type { GanttRowData, GanttTaskData } from './gantt.types';\nimport { GanttDesktopTaskAccContent } from './GanttDesktopTaskAccContent';\nimport { GanttMobileTaskAccContent } from './GanttMobileTaskAccContent';\nimport type { GanttViewportTaskLayoutObj, ViewportLayout } from './utils/dataLayoutUtils';\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  width: number;\n  height: number;\n  rowData: ViewportLayout<K1, K2, D1, D2>['rowData'];\n  dateFormatter: (date: string) => string;\n  ariaActiveId?: string;\n  ariaActiveTaskObj?: GanttViewportTaskLayoutObj<K2>;\n  layoutObjs: ViewportLayout<K1, K2, D1, D2>['rowObjs'];\n};\n\nexport function GanttTaskAccLayer<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  width,\n  height,\n  rowData,\n  dateFormatter,\n  ariaActiveId,\n  ariaActiveTaskObj,\n  layoutObjs\n}: Props<K1, K2, D1, D2>) {\n  return supportsMobileScreenReader ? (\n    <GanttMobileTaskAccContent\n      width={width}\n      height={height}\n      layoutObjs={layoutObjs}\n      rowData={rowData}\n      dateFormatter={dateFormatter}\n    />\n  ) : (\n    <GanttDesktopTaskAccContent\n      width={width}\n      height={height}\n      rowData={rowData}\n      dateFormatter={dateFormatter}\n      ariaActiveId={ariaActiveId}\n      ariaActiveTaskObj={ariaActiveTaskObj}\n    />\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { GanttRowData, GanttTaskData } from './gantt.types';\nimport { rowBackgroundStyles } from './themes/GanttStyles.css';\nimport type { ViewportLayout } from './utils/dataLayoutUtils';\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  width: number;\n  height: number;\n  layoutObjs: ViewportLayout<K1, K2, D1, D2>['rowObjs'];\n};\n\nexport function GanttRowBackgroundsLayer<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({ width, height, layoutObjs }: Props<K1, K2, D1, D2>) {\n  const selectedRowObjs = layoutObjs.filter((rowObj) => rowObj.isSelected);\n  const selectedRowsCmd = selectedRowObjs\n    .map(({ y, height }) => {\n      // Reduce left and right edge by 1px to ensure the rendering doesn't\n      // interfere with the row axis separator\n      return `M1,${y} H${width - 1} V${y + height} H${1} Z`;\n    })\n    .join(' ');\n\n  return selectedRowObjs.length > 0 ? (\n    <svg width={width} height={height}>\n      <path class={rowBackgroundStyles.selected} d={selectedRowsCmd} />\n    </svg>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { rectangleWithBorderRadius } from '#utils/PRIVATE_visSVGUtils';\nimport { GanttViewportTaskLayoutObj } from './dataLayoutUtils';\n\n/**\n * Draws a given task effect onto a given Canvas.\n * @param ctx The Canvas's 2D context.\n * @param effectLayout The task effect layout object.\n */\nconst drawTaskEffectRing = (\n  ctx: CanvasRenderingContext2D,\n  effectLayout: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    borderRadius: string;\n    stroke: string;\n    strokeWidth: number;\n    padding: number;\n  }\n) => {\n  const { x, y, width, height, borderRadius, stroke, strokeWidth, padding } = effectLayout;\n  const ringX = x - padding;\n  const ringY = y - padding;\n  const ringWidth = width + 2 * padding;\n  const ringHeight = height + 2 * padding;\n  const effectRingCmd = rectangleWithBorderRadius(\n    ringX,\n    ringY,\n    ringWidth,\n    ringHeight,\n    borderRadius,\n    Math.min(ringWidth, ringHeight),\n    '0'\n  );\n  const effectRingPath = new Path2D(effectRingCmd);\n  ctx.strokeStyle = stroke;\n  ctx.lineWidth = strokeWidth;\n  ctx.stroke(effectRingPath);\n};\n\n/**\n * Draws a given task effect shadow onto a given Canvas.\n * @param ctx The Canvas's 2D context.\n * @param shadow The shadow definition.\n */\nconst drawTaskEffectShadow = (\n  ctx: CanvasRenderingContext2D,\n  shadow: {\n    shadowColor: string;\n    shadowOffsetX: number;\n    shadowOffsetY: number;\n    shadowBlur: number;\n  }\n) => {\n  ctx.shadowColor = shadow.shadowColor;\n  ctx.shadowOffsetX = shadow.shadowOffsetX;\n  ctx.shadowOffsetY = shadow.shadowOffsetY;\n  ctx.shadowBlur = shadow.shadowBlur;\n};\n\n/**\n * Resets any shadow settings in the Canvas's context.\n * @param ctx The Canvas's 2D context.\n */\nconst resetShadow = (ctx: CanvasRenderingContext2D) => {\n  ctx.shadowColor = 'transparent';\n  ctx.shadowOffsetX = 0;\n  ctx.shadowOffsetY = 0;\n  ctx.shadowBlur = 0;\n};\n\n/**\n * Draws a given task onto a given Canvas.\n * @param ctx The Canvas's 2D context.\n * @param taskLayoutObj The task layout object.\n * @param state The task's state.\n */\nconst drawTask = <K2>(\n  ctx: CanvasRenderingContext2D,\n  taskLayoutObj: GanttViewportTaskLayoutObj<K2>,\n  state?: 'selected' | 'hovered' | 'focused'\n) => {\n  const drawShadow = state === 'hovered';\n  const { x, y, width, height, borderRadius, fill, stroke, strokeWidth } = taskLayoutObj;\n\n  const roundRectCmd = rectangleWithBorderRadius(\n    x,\n    y,\n    width,\n    height,\n    borderRadius,\n    Math.min(width, height),\n    '0'\n  );\n  const roundRectPath = new Path2D(roundRectCmd);\n\n  // Draw white task backdrop\n  if (drawShadow) drawTaskEffectShadow(ctx, taskLayoutObj.hoverEffect.shadow);\n  ctx.fillStyle = '#ffffff';\n  ctx.fill(roundRectPath);\n  if (drawShadow) resetShadow(ctx);\n\n  // Draw task\n  ctx.strokeStyle = stroke;\n  ctx.fillStyle = fill;\n  ctx.lineWidth = strokeWidth;\n  ctx.fill(roundRectPath);\n  ctx.stroke(roundRectPath);\n\n  switch (state) {\n    case 'selected': {\n      drawTaskEffectRing(ctx, {\n        x,\n        y,\n        width,\n        height,\n        borderRadius,\n        ...taskLayoutObj.selectionEffect\n      });\n      break;\n    }\n    case 'hovered': {\n      drawTaskEffectRing(ctx, { x, y, width, height, borderRadius, ...taskLayoutObj.hoverEffect });\n      break;\n    }\n    case 'focused': {\n      drawTaskEffectRing(ctx, { x, y, width, height, borderRadius, ...taskLayoutObj.focusEffect });\n      break;\n    }\n    case undefined: {\n      // No effect\n      break;\n    }\n    default: {\n      const _exhaustiveCheck: never = state;\n      return _exhaustiveCheck;\n    }\n  }\n};\n\nexport { drawTask };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { GanttViewportTaskLayoutObj } from './utils/dataLayoutUtils';\nimport { TimeComponentCanvas2D } from '#PRIVATE_TimeComponent';\nimport { drawTask } from './utils/canvasDrawUtils';\n\ntype Props<K2> = {\n  width: number;\n  height: number;\n  layoutObj?: GanttViewportTaskLayoutObj<K2>;\n};\n\nexport function GanttTaskFocusEffectsLayer<K2>({ width, height, layoutObj: taskObj }: Props<K2>) {\n  const draw = (ctx: CanvasRenderingContext2D) => {\n    taskObj && drawTask(ctx, taskObj, 'focused');\n  };\n  return <TimeComponentCanvas2D width={width} height={height} draw={draw} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { GanttViewportTaskLayoutObj } from './utils/dataLayoutUtils';\nimport { TimeComponentCanvas2D } from '#PRIVATE_TimeComponent';\nimport { drawTask } from './utils/canvasDrawUtils';\n\ntype Props<K2> = {\n  width: number;\n  height: number;\n  layoutObj?: GanttViewportTaskLayoutObj<K2>;\n};\n\nexport function GanttTaskHoverEffectsLayer<K2>({ width, height, layoutObj: taskObj }: Props<K2>) {\n  const draw = (ctx: CanvasRenderingContext2D) => {\n    taskObj && drawTask(ctx, taskObj, 'hovered');\n  };\n  return <TimeComponentCanvas2D width={width} height={height} draw={draw} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { GanttViewportTaskLayoutObj } from './utils/dataLayoutUtils';\nimport { TimeComponentCanvas2D } from '#PRIVATE_TimeComponent';\nimport { drawTask } from './utils/canvasDrawUtils';\n\ntype Props<K2> = {\n  width: number;\n  height: number;\n  layoutObjs: GanttViewportTaskLayoutObj<K2>[];\n};\n\nexport function GanttTaskSelectionEffectsLayer<K2>({ width, height, layoutObjs }: Props<K2>) {\n  const draw = (ctx: CanvasRenderingContext2D) => {\n    layoutObjs.forEach((taskObj) => drawTask(ctx, taskObj, 'selected'));\n  };\n  return <TimeComponentCanvas2D width={width} height={height} draw={draw} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { TimeComponentLayersStack } from '#PRIVATE_TimeComponent';\nimport { GanttTaskFocusEffectsLayer } from './GanttTaskFocusEffectsLayer';\nimport { GanttTaskHoverEffectsLayer } from './GanttTaskHoverEffectsLayer';\nimport { GanttTaskSelectionEffectsLayer } from './GanttTaskSelectionEffectsLayer';\nimport type { getEffectTaskObjs } from './utils/dataLayoutUtils';\n\ntype Props<K2, D2> = {\n  width: number;\n  height: number;\n  layoutObjs: ReturnType<typeof getEffectTaskObjs<K2, D2>>;\n};\n\nexport function GanttTaskEffectsLayer<K2, D2>({\n  width,\n  height,\n  layoutObjs: { selectedTaskObjs, hoveredTaskObj, focusedTaskObj }\n}: Props<K2, D2>) {\n  return (\n    <TimeComponentLayersStack width={`${width}px`} height={`${height}px`}>\n      <GanttTaskFocusEffectsLayer<K2> width={width} height={height} layoutObj={focusedTaskObj} />\n      <GanttTaskSelectionEffectsLayer<K2>\n        width={width}\n        height={height}\n        layoutObjs={selectedTaskObjs}\n      />\n      <GanttTaskHoverEffectsLayer<K2> width={width} height={height} layoutObj={hoveredTaskObj} />\n    </TimeComponentLayersStack>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Property } from 'csstype';\nimport { Text } from '#UNSAFE_Text';\nimport { taskLabelLayerStyles } from './themes/GanttStyles.css';\nimport { classNames } from '#utils/UNSAFE_classNames';\n\ntype Props = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  label: string;\n  isInner: boolean;\n  textAlign: 'left' | 'center' | 'right';\n  labelStyle?: {\n    color?: Property.Color;\n    fontFamily?: Property.FontFamily;\n    fontSize?: Property.FontSize;\n    fontStyle?: Property.FontStyle;\n    fontWeight?: Property.FontWeight;\n    textDecoration?: Property.TextDecoration;\n  };\n};\n\nexport function GanttTaskLabel({\n  x,\n  y,\n  width,\n  height,\n  label,\n  isInner,\n  textAlign,\n  labelStyle\n}: Props) {\n  return (\n    <div\n      aria-hidden=\"true\"\n      class={classNames([taskLabelLayerStyles.label, isInner && taskLabelLayerStyles.innerLabel])}\n      style={{\n        left: x,\n        top: y,\n        width,\n        height,\n        textAlign,\n        ...labelStyle\n      }}>\n      <Text\n        variant={labelStyle?.color ? 'inherit' : 'primary'}\n        truncation=\"ellipsis\"\n        size=\"md\"\n        weight=\"inherit\">\n        {label}\n      </Text>\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { ViewportLayout } from './utils/dataLayoutUtils';\nimport { taskLabelLayerStyles } from './themes/GanttStyles.css';\nimport { GanttTaskLabel } from './GanttTaskLabel';\nimport type { GanttRowData, GanttTaskData } from './gantt.types';\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  width: number;\n  height: number;\n  layoutObjs: ViewportLayout<K1, K2, D1, D2>['taskLabelObjs'];\n};\n\nexport function GanttTaskLabelsLayer<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({ width, height, layoutObjs }: Props<K1, K2, D1, D2>) {\n  return (\n    <div class={taskLabelLayerStyles.base} style={{ width, height }}>\n      {layoutObjs.map((labelObj) => (\n        <GanttTaskLabel {...labelObj} />\n      ))}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { ViewportLayout } from './utils/dataLayoutUtils';\nimport { TimeComponentCanvas2D } from '#PRIVATE_TimeComponent';\nimport { drawTask } from './utils/canvasDrawUtils';\nimport type { GanttRowData, GanttTaskData } from './gantt.types';\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  width: number;\n  height: number;\n  layoutObjs: ViewportLayout<K1, K2, D1, D2>['rowObjs'];\n};\n\nexport function GanttTasksLayer<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({ width, height, layoutObjs }: Props<K1, K2, D1, D2>) {\n  const draw = (ctx: CanvasRenderingContext2D) => {\n    layoutObjs.forEach((rowObj) => {\n      rowObj.taskObjs.forEach((taskObj) => drawTask(ctx, taskObj));\n    });\n  };\n\n  return <TimeComponentCanvas2D width={width} height={height} draw={draw} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport {\n  TimeComponentLayersStack,\n  TimeComponentVerticalGridlines as GanttVerticalGridlinesLayer\n} from '#PRIVATE_TimeComponent';\nimport { GanttHorizontalGridlinesLayer } from './GanttHorizontalGridlinesLayer';\nimport { GanttTaskAccLayer } from './GanttTaskAccLayer';\nimport { GanttRowBackgroundsLayer } from './GanttRowBackgroundsLayer';\nimport { GanttTaskEffectsLayer } from './GanttTaskEffectsLayer';\nimport { GanttTaskLabelsLayer } from './GanttTaskLabelsLayer';\nimport { GanttTasksLayer } from './GanttTasksLayer';\nimport type { getEffectTaskObjs, ViewportLayout } from './utils/dataLayoutUtils';\nimport type { GanttRowData, GanttTaskData } from './gantt.types';\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  width: number;\n  height: number;\n  minorAxisLayout: {\n    minorGridTicksPos: number[];\n    majorGridTicksPos?: number[];\n  };\n  viewportLayout: ViewportLayout<K1, K2, D1, D2>;\n  effectsLayout: ReturnType<typeof getEffectTaskObjs<K2, D2>>;\n  dateFormatter: (date: string) => string;\n  ariaActiveTask?: {\n    dataId: K2;\n    ariaId: string;\n  };\n};\n\nexport function GanttDataBody<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  width,\n  height,\n  minorAxisLayout: { minorGridTicksPos, majorGridTicksPos },\n  viewportLayout: {\n    gridlines,\n    rowData,\n    rowObjs,\n    taskLabelObjs,\n    horizontalGridlinesPos,\n    idTaskObjMap\n  },\n  effectsLayout,\n  dateFormatter,\n  ariaActiveTask\n}: Props<K1, K2, D1, D2>) {\n  return (\n    <TimeComponentLayersStack width={`${width}px`} height={`${height}px`}>\n      <GanttRowBackgroundsLayer width={width} height={height} layoutObjs={rowObjs} />\n      {gridlines.vertical === 'on' && (\n        <GanttVerticalGridlinesLayer\n          width={width}\n          height={height}\n          positions={minorGridTicksPos}\n          variant=\"minor\"\n        />\n      )}\n      {gridlines.vertical === 'on' && majorGridTicksPos && (\n        <GanttVerticalGridlinesLayer\n          width={width}\n          height={height}\n          positions={majorGridTicksPos}\n          variant=\"major\"\n        />\n      )}\n      {horizontalGridlinesPos && (\n        <GanttHorizontalGridlinesLayer\n          width={width}\n          height={height}\n          positions={horizontalGridlinesPos}\n        />\n      )}\n      <GanttTaskAccLayer\n        width={width}\n        height={height}\n        layoutObjs={rowObjs}\n        rowData={rowData}\n        dateFormatter={dateFormatter}\n        ariaActiveId={ariaActiveTask?.ariaId}\n        ariaActiveTaskObj={ariaActiveTask && idTaskObjMap.get(ariaActiveTask.dataId)}\n      />\n      <GanttTasksLayer width={width} height={height} layoutObjs={rowObjs} />\n      <GanttTaskEffectsLayer width={width} height={height} layoutObjs={effectsLayout} />\n      <GanttTaskLabelsLayer width={width} height={height} layoutObjs={taskLabelObjs} />\n    </TimeComponentLayersStack>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport {\n  TimeComponentPanZoomLayout,\n  TimeComponentZoomControls,\n  TimeComponentVerticalScrollbarContainer,\n  TimeComponentVerticalScrollbar,\n  TimeComponentHorizontalScrollbarContainer,\n  TimeComponentHorizontalScrollbar,\n  TimeComponentHorizontalTimeAxis\n} from '#PRIVATE_TimeComponent';\nimport type {\n  OnTimeComponentViewportChange,\n  TimeComponentZoomParameters\n} from '#PRIVATE_TimeComponent/timeComponent.types';\nimport type { getPanZoomCanvasLayout } from './utils/panZoomCanvasLayoutUtils';\nimport type { getResolvedTimeAxesLayout } from '#PRIVATE_TimeComponent/utils/timeAxisLayoutUtils';\nimport type {\n  getResolvedHorizontalScrollbarLayout,\n  getResolvedVerticalScrollbarLayout\n} from '#PRIVATE_TimeComponent/utils/scrollbarLayoutUtils';\nimport { GanttTimeAxisDataBody } from './GanttTimeAxisDataBody';\nimport { GanttDataBody } from './GanttDataBody';\nimport { getResolvedViewportLayout, type getRowDataLayout } from './utils/dataLayoutUtils';\nimport type {\n  GanttCurrentTask,\n  GanttProps,\n  GanttRowData,\n  GanttSelection as GanttSelectionProps,\n  GanttTaskData,\n  GanttTaskHover,\n  OnGanttScrollPositionChange\n} from './gantt.types';\nimport { Size } from '#utils/UNSAFE_size';\n\ntype Props<K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>> = {\n  visRef: RefObject<HTMLDivElement>;\n  overlayControlsContainerRef: RefObject<HTMLDivElement>;\n  panZoomLayout: ReturnType<typeof getPanZoomCanvasLayout>;\n  getTimeAxesLayout: ReturnType<typeof getResolvedTimeAxesLayout>;\n  getHorizontalScrollbarLayout: ReturnType<typeof getResolvedHorizontalScrollbarLayout>;\n  onHorizontalScrollChange: (newViewStartTime: number, newViewEndTime: number) => void;\n  getVerticalScrollbarLayout: ReturnType<typeof getResolvedVerticalScrollbarLayout>;\n  onVerticalScrollChange: (newScrollPosition: number) => void;\n  rowAxisSeparator?: boolean;\n  zoomParameters?: TimeComponentZoomParameters;\n  zooming?: 'on' | 'off';\n  isViewportDefined: boolean;\n  onViewportChange?: OnTimeComponentViewportChange;\n  getResolvedViewportLayout: typeof getResolvedViewportLayout;\n  datatip?: GanttProps<K2, D1, D2>['datatip'];\n  rowDataLayout: ReturnType<typeof getRowDataLayout<K1, K2, D1, D2>>;\n  isRTL: boolean;\n  scrollPosition: number;\n  onScrollPositionChange?: OnGanttScrollPositionChange;\n  width?: Size;\n  height?: Size;\n  currentTaskInteraction: 'hover' | 'focus' | 'none';\n  ariaActive?: { dataId: K2; ariaId: string; type: 'task' };\n} & GanttSelectionProps<K2, D2> &\n  GanttTaskHover<K2> &\n  GanttCurrentTask<K2>;\n\nexport function GanttView<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  visRef,\n  overlayControlsContainerRef,\n  panZoomLayout,\n  getTimeAxesLayout,\n  getHorizontalScrollbarLayout,\n  onHorizontalScrollChange,\n  getVerticalScrollbarLayout,\n  onVerticalScrollChange,\n  rowAxisSeparator = false,\n  zoomParameters,\n  zooming = 'on',\n  isViewportDefined,\n  onViewportChange,\n  getResolvedViewportLayout,\n  datatip,\n  rowDataLayout,\n  isRTL,\n  scrollPosition,\n  onScrollPositionChange,\n  selectedIds,\n  selectionMode,\n  onSelectionChange,\n  hoveredTaskId,\n  onTaskHoverChange,\n  currentTask,\n  onCurrentTaskChange,\n  currentTaskInteraction,\n  ariaActive,\n  width,\n  height\n}: Props<K1, K2, D1, D2>) {\n  return (\n    <TimeComponentPanZoomLayout\n      overlayControlsContainerRef={overlayControlsContainerRef}\n      {...panZoomLayout}\n      width={width}\n      height={height}\n      overlayControls={\n        zooming === 'on' && zoomParameters && isViewportDefined ? (\n          <TimeComponentZoomControls\n            position={panZoomLayout.overlayControlsPosition}\n            zoomParameters={zoomParameters}\n            onViewportChange={onViewportChange}\n          />\n        ) : undefined\n      }\n      verticalControl={\n        <TimeComponentVerticalScrollbarContainer\n          getLayout={getVerticalScrollbarLayout}\n          onRangeChange={onVerticalScrollChange}>\n          {(layout) => <TimeComponentVerticalScrollbar {...layout} />}\n        </TimeComponentVerticalScrollbarContainer>\n      }\n      horizontalControl={\n        <TimeComponentHorizontalScrollbarContainer\n          getLayout={getHorizontalScrollbarLayout}\n          onRangeChange={onHorizontalScrollChange}>\n          {(layout) => <TimeComponentHorizontalScrollbar {...layout} />}\n        </TimeComponentHorizontalScrollbarContainer>\n      }\n      vis={\n        <GanttTimeAxisDataBody\n          innerRef={visRef}\n          isRTL={isRTL}\n          scrollPosition={scrollPosition}\n          onScrollPositionChange={onScrollPositionChange}\n          isViewportDefined={isViewportDefined}\n          onViewportChange={onViewportChange}\n          zoomParameters={zoomParameters}\n          zooming={zooming}\n          rowAxisSeparator={rowAxisSeparator}\n          selectedIds={selectedIds}\n          selectionMode={selectionMode}\n          onSelectionChange={onSelectionChange}\n          hoveredTaskId={hoveredTaskId}\n          onTaskHoverChange={onTaskHoverChange}\n          currentTask={currentTask}\n          onCurrentTaskChange={onCurrentTaskChange}\n          currentTaskInteraction={currentTaskInteraction}\n          ariaActive={ariaActive}\n          getTimeAxesLayout={getTimeAxesLayout}\n          getResolvedViewportLayout={getResolvedViewportLayout}\n          rowDataLayout={rowDataLayout}\n          datatip={datatip}\n          majorAxis={(layout) => <TimeComponentHorizontalTimeAxis {...layout} />}\n          minorAxis={(layout) => <TimeComponentHorizontalTimeAxis {...layout} />}\n          dataBody={(layout) => <GanttDataBody {...layout} />}\n        />\n      }\n    />\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { TimeComponentTimeAxis } from '../timeComponent.types';\nimport { bridgeValues } from '../themes/TimeComponentStyles.css';\nimport { getTimePosition } from './timeUtils';\nimport type { useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\ntype GetTextDimensions = NonNullable<ReturnType<typeof useTextDimensions>['getTextDimensions']>;\ntype Font = NonNullable<Parameters<GetTextDimensions>[1]>;\n\n// TODO: Remove and replace this with the future useTextDimensions batch text measurements solution.\n// We also just need width, so maybe we can make useTextDimensions optimize for that case too\n// e.g. use canvas backend for width only measurements, etc.\n/**\n * Gets the text dimensions of the given array of texts.\n * @param getTextDimensions The measurement function.\n * @param texts An array of texts.\n * @param font The font of the texts.\n * @returns An array of text dimensions.\n */\nconst getBatchTextDimensions = (\n  getTextDimensions: GetTextDimensions,\n  texts: string[],\n  font?: Font\n) => texts.map((text) => getTextDimensions(text, font));\n\n/**\n * Gets the (unresolved) time axis height.\n * @param axisProps The axis props.\n * @returns The (unresolved) height.\n */\nconst getUnresolvedTimeAxisHeight = (axisProps?: TimeComponentTimeAxis) => {\n  return axisProps === undefined\n    ? '0px'\n    : axisProps.height !== undefined\n    ? `${axisProps.height}px`\n    : bridgeValues.horizontalTimeAxisHeight;\n};\n\n/**\n * Gets the unresolved time axis layout.\n * @param axisPosition The axis position.\n * @param minorAxis The minor axis props.\n * @param majorAxis The major axis props.\n * @returns The unresovled time axis layout.\n */\nconst getUnresolvedTimeAxesLayout = (\n  axisPosition: 'top' | 'bottom',\n  minorAxis?: TimeComponentTimeAxis,\n  majorAxis?: TimeComponentTimeAxis\n) => {\n  const minorAxisHeight = getUnresolvedTimeAxisHeight(minorAxis);\n  const majorAxisHeight = getUnresolvedTimeAxisHeight(majorAxis);\n  const totalHeight = `calc(${majorAxisHeight} + ${minorAxisHeight})`;\n  return {\n    position: axisPosition,\n    height: totalHeight\n  };\n};\n\n/**\n * Gets the resolved time axis height.\n * @param defaultHeight The default time axis height.\n * @param axisProps The axis props.\n * @returns The time axis height in pixels.\n */\nconst getResolvedTimeAxisHeight = (defaultHeight: number, axisProps?: TimeComponentTimeAxis) => {\n  return axisProps === undefined\n    ? 0\n    : axisProps.height !== undefined\n    ? axisProps.height\n    : defaultHeight;\n};\n\n/**\n * Gets the resolved time axis props.\n * @param defaultHeight The default time axis height.\n * @param axisProps The axis props.\n * @returns The resolved axis props.\n */\nconst getResolvedTimeAxisProps = (defaultHeight: number, axisProps: TimeComponentTimeAxis) => {\n  const height = getResolvedTimeAxisHeight(defaultHeight, axisProps);\n  const { scale, zoomOrder = [axisProps.scale] } = axisProps;\n  return {\n    height,\n    zoomOrder,\n    zoomOrderIndex: zoomOrder.indexOf(scale)\n  };\n};\n\n/**\n * Gets the interval start time relative to the given time according to the given scale.\n * @param scale The time scale.\n * @param time The query time.\n * @returns The interval start time.\n */\nconst getPreviousTime = (scale: TimeComponentTimeAxis['scale'], time: number) => {\n  return Date.parse(scale.getPreviousDate(new Date(time).toISOString()));\n};\n\n/**\n * Gets the interval end time relative to the given time according to the given scale.\n * @param scale The time scale.\n * @param time The query time.\n * @returns The interval end time.\n */\nconst getNextTime = (scale: TimeComponentTimeAxis['scale'], time: number) => {\n  return Date.parse(scale.getNextDate(new Date(time).toISOString()));\n};\n\n/**\n * Gets the time axis ticks in the given viewport.\n * @param scale The time scale.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @returns The ticks (in time).\n */\nconst getViewportTicks = (\n  scale: TimeComponentTimeAxis['scale'],\n  viewportStartTime: number,\n  viewportEndTime: number\n) => {\n  const times = [getPreviousTime(scale, viewportStartTime)];\n  while (times[times.length - 1] < viewportEndTime) {\n    times.push(getNextTime(scale, times[times.length - 1]));\n  }\n  return times;\n};\n\n/**\n * Returns a set of date intervals sampled using the following procedure:\n * 1. Divide up the time range into numSections sections\n * 2. For each section, take the first numIntervalsPerSection intervals from the start,\n *    plus the last interval of the section.\n * 3. Consolidate all of them and return\n * @param scale\n * @param startTime\n * @param endTime\n * @param numSections\n * @param numIntervalsPerSection\n * @returns The unique intervals retrieved (as a Map of <start time, end time>)\n */\nconst sampleIntervals = (\n  scale: TimeComponentTimeAxis['scale'],\n  startTime: number,\n  endTime: number,\n  numSections: number,\n  numIntervalsPerSection: number\n) => {\n  // key: interval start time, value: interval end time\n  // Use Map to prevent duplicate intervals\n  const intervals = new Map<number, number>();\n\n  const sectionInterval = Math.floor((endTime - startTime) / numSections);\n  for (let i = 0; i < numSections; i++) {\n    const sectionStartTime = startTime + sectionInterval * i;\n    const sectionEndTime = Math.min(startTime + sectionInterval * (i + 1), endTime);\n\n    let prevTime = getPreviousTime(scale, sectionStartTime);\n    for (let j = 0; j < numIntervalsPerSection; j++) {\n      if (prevTime >= sectionEndTime) {\n        break;\n      }\n      const currTime = getNextTime(scale, prevTime);\n      intervals.set(prevTime, currTime);\n      prevTime = currTime;\n    }\n\n    // Also consider last label at the end of the section\n    prevTime = getPreviousTime(scale, sectionEndTime - 1);\n    intervals.set(prevTime, getNextTime(scale, prevTime));\n  }\n\n  return intervals;\n};\n\n/**\n * Gets (a representative set of) the time intervals in the given time scale.\n * @param scale The time scale.\n * @param samplingStrategy The sampling strategy to use.\n *  The 'exact' type would retrieve ALL intervals in the given range and scale.\n *  'approximate' would retrieve only a representative subset of intervals.\n * @returns (A representative set of) the time intervals in the given time scale.\n */\nconst getTimeAxisIntervals = (\n  scale: TimeComponentTimeAxis['scale'],\n  samplingStrategy:\n    | {\n        type: 'exact';\n        params: { startTime: number; endTime: number };\n      }\n    | {\n        type: 'approximate';\n        params: {\n          numSections: number;\n          numIntervalsPerSection: number;\n          startTime: number;\n          endTime: number;\n        };\n      }\n) => {\n  const { type, params } = samplingStrategy;\n  switch (type) {\n    case 'exact': {\n      const intervals = new Map<number, number>();\n      const viewportTimes = getViewportTicks(scale, params.startTime, params.endTime);\n      for (let i = 0; i < viewportTimes.length - 1; i++) {\n        intervals.set(viewportTimes[i], viewportTimes[i + 1]);\n      }\n      return { intervals, numIntervals: intervals.size };\n    }\n    case 'approximate': {\n      // Rather than computing all dates (and labels) to obtain exact dimensions,\n      // heuristically sample a subset of dates for better performance.\n      // Assumption is that in many usecases, label widths have small variance.\n      // Even if our estimation is off and cause a label trunction, users can manually zoom in to see the full label.\n      const { startTime, endTime, numSections, numIntervalsPerSection } = params;\n      const intervals = sampleIntervals(\n        scale,\n        startTime,\n        endTime,\n        numSections,\n        numIntervalsPerSection\n      );\n      // Estimate real number of intervals\n      const intervalStartTimes = [...intervals.keys()];\n      const avgTimePerInterval =\n        intervalStartTimes.reduce((sum, prevTime) => {\n          return sum + (intervals.get(prevTime)! - Number(prevTime));\n        }, 0) / intervalStartTimes.length;\n      const estNumIntervals = (endTime - startTime) / avgTimePerInterval;\n      return { intervals, numIntervals: estNumIntervals };\n    }\n    default: {\n      const _exhaustiveCheck: never = type;\n      return _exhaustiveCheck;\n    }\n  }\n};\n\n/**\n * Gets the zoom order characteristics based on the given time intervals, and widths of those intervals.\n * @param getTextDimensions The text measurement function.\n * @param intervalPaddingStart The interval padding start.\n * @param intervalPaddingEnd The interval padding end.\n * @param minIntervalWidth The minimum interval width.\n * @param axisFont The font.\n * @param zoomOrder The zoom order.\n * @param samplingStrategy The sampling strategy to use to retrieve intervals.\n * @returns The min length factor for each scale in the zoom order, and (an estimate of) the max number of intervals in the time axis across all scales in the zoom order.\n */\nconst getZoomOrderCharacteristics = (\n  getTextDimensions: GetTextDimensions,\n  intervalPaddingStart: number,\n  intervalPaddingEnd: number,\n  minIntervalWidth: number,\n  axisFont: Font,\n  zoomOrder: NonNullable<TimeComponentTimeAxis['zoomOrder']>,\n  samplingStrategy: Parameters<typeof getTimeAxisIntervals>[1]\n) => {\n  const intervalPadding = intervalPaddingStart + intervalPaddingEnd;\n  const zoomLevelIntervals = zoomOrder.map((scale) =>\n    getTimeAxisIntervals(scale, samplingStrategy)\n  );\n  const maxNumIntervals = Math.max(...zoomLevelIntervals.map(({ numIntervals }) => numIntervals));\n  const zoomOrderMinLengthFactor = zoomLevelIntervals.map(({ intervals }, i) => {\n    const scale = zoomOrder[i];\n    const prevTimes = [...intervals.keys()];\n    const labels = prevTimes.map((prevTime) => getTimeLabel(scale, intervals.get(prevTime)!));\n    const intervalDurations = prevTimes.map((prevTime) => intervals.get(prevTime)! - prevTime);\n    const intervalLabelDimensions = getBatchTextDimensions(getTextDimensions, labels, axisFont);\n    const minLengthFactor = Math.min(\n      ...intervalDurations.map((duration, i) => {\n        const contentWidth = Math.max(\n          minIntervalWidth,\n          intervalLabelDimensions[i].width + intervalPadding\n        );\n        return duration / contentWidth;\n      })\n    );\n    return minLengthFactor;\n  });\n\n  return {\n    zoomOrderMinLengthFactor,\n    maxNumIntervals\n  };\n};\n\n/**\n * Gets the resolved viewport range given the range constraints.\n * @param viewportDuration The viewport duration.\n * @param startTime The start time.\n * @param endTime The end time.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @returns The resolved viewport range.\n */\nconst getResolvedViewport = (\n  viewportDuration: number,\n  startTime: number,\n  endTime: number,\n  viewportStartTime?: number,\n  viewportEndTime?: number\n) => {\n  if (viewportStartTime !== undefined && viewportEndTime !== undefined) {\n    return { viewportStartTime, viewportEndTime };\n  }\n  if (viewportStartTime !== undefined && viewportEndTime === undefined) {\n    return {\n      viewportStartTime,\n      viewportEndTime: Math.min(endTime, viewportStartTime + viewportDuration)\n    };\n  }\n  if (viewportStartTime === undefined && viewportEndTime !== undefined) {\n    return {\n      viewportStartTime: Math.max(startTime, viewportEndTime - viewportDuration),\n      viewportEndTime\n    };\n  }\n  return {\n    viewportStartTime: startTime,\n    viewportEndTime: Math.min(endTime, startTime + viewportDuration)\n  };\n};\n\n/**\n * Gets the formatted string for the given time in the given scale.\n * This is used for the time axis interval labels.\n * @param scale The time scale.\n * @param time The time.\n * @returns The formatted string.\n */\nconst getTimeLabel = (scale: TimeComponentTimeAxis['scale'], time: number) =>\n  scale.formatter(new Date(time).toISOString());\n\n/**\n * Gets the viewport axis ticks and labels for the given scale.\n * @param scale The time scale.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @returns The ticks and labels.\n */\nconst getViewportLabelsTicks = (\n  scale: TimeComponentTimeAxis['scale'],\n  viewportStartTime: number,\n  viewportEndTime: number\n) => {\n  // ticks.length >= 2 always, because there's always the first and last tick.\n  const ticks = getViewportTicks(scale, viewportStartTime, viewportEndTime);\n\n  // We don't need the label of the last tick.\n  const labels = ticks.slice(0, ticks.length - 1).map((t) => getTimeLabel(scale, t));\n\n  return { ticks, labels };\n};\n\n/**\n * Gets the time axis layout.\n * @param getTextDimensions The text measurement function.\n * @param labelPaddingStart The interval label padding start.\n * @param labelPaddingEnd The interval label padding end.\n * @param font The font.\n * @param labelPosition The label position.\n * @param ticks The ticks (in time).\n * @param gridTicks The subset of visible ticks that mark the vertical tick lines (in time).\n * @param labels The interval labels.\n * @param startTime The start time.\n * @param endTime The end time.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @param width The viewport width.\n * @param isRTL Whether the reading direction is rtl.\n * @returns The time axis layout.\n */\nconst getTimeAxisLayout = (\n  getTextDimensions: GetTextDimensions,\n  labelPaddingStart: number,\n  labelPaddingEnd: number,\n  font: Font,\n  labelPosition: TimeComponentTimeAxis['scale']['labelPosition'] = 'start',\n  ticks: number[],\n  gridTicks: number[],\n  labels: string[],\n  startTime: number,\n  endTime: number,\n  viewportStartTime: number,\n  viewportEndTime: number,\n  width: number,\n  isRTL: boolean\n) => {\n  const intervalPadding = labelPaddingStart + labelPaddingEnd;\n  const vs = viewportStartTime;\n  const ve = viewportEndTime;\n  const labelTicks = ticks.slice(0, ticks.length - 1);\n  const gridTicksPos = gridTicks.map((t) => getTimePosition(t, vs, ve, width, isRTL));\n  const ticksPos = ticks.map((t) => getTimePosition(t, vs, ve, width, isRTL));\n  const intervalWidths = ticksPos\n    .slice(1)\n    .map((p, i) => (isRTL ? ticksPos[i] - p : p - ticksPos[i]));\n  // Labels that start before the startTime or ends after the endTime need to be truncated\n  const isIntervalStartTruncated = ticks[0] < startTime;\n  if (isIntervalStartTruncated) {\n    ticksPos[0] = 0;\n    intervalWidths[0] = ticksPos[1];\n  }\n  if (ticks[ticks.length - 1] > endTime) {\n    ticksPos[ticksPos.length - 1] = isRTL ? 0 : width;\n    intervalWidths[intervalWidths.length - 1] = isRTL\n      ? ticksPos[ticksPos.length - 2] - ticksPos[ticksPos.length - 1]\n      : ticksPos[ticksPos.length - 1] - ticksPos[ticksPos.length - 2];\n  }\n  const labelPositions = ticksPos\n    .slice(0, ticksPos.length - 1)\n    .map((p, i) => (isRTL ? p - intervalWidths[i] : p));\n  const isLabelTruncated = getBatchTextDimensions(getTextDimensions, labels, font).map(\n    ({ width }, i) => Math.floor(width) - Math.floor(intervalWidths[i] - intervalPadding) > 0\n  );\n\n  return {\n    font,\n    labelPosition,\n    labels,\n    labelTicks,\n    labelPositions,\n    isLabelTruncated,\n    isIntervalStartTruncated,\n    intervalWidths,\n    gridTicksPos,\n    isRTL\n  };\n};\n\n/**\n * Gets the time axes layout for the viewport.\n * @param getTextDimensions The text measurement function.\n * @param labelPaddingStart The interval label padding start.\n * @param labelPaddingEnd The interval label padding end.\n * @param majorAxisFont The major axis font.\n * @param minorAxisFont The minor axis font.\n * @param startTime The start time.\n * @param endTime The end time.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @param width The viewport width.\n * @param isRTL Whether the reading direction is rtl.\n * @param minorAxisScale The minor axis scale.\n * @param majorAxisScale The major axis scale.\n * @returns The time axes layout for the viewport.\n */\nconst getTimeAxesViewportLayout = (\n  getTextDimensions: GetTextDimensions,\n  labelPaddingStart: number,\n  labelPaddingEnd: number,\n  majorAxisFont: Font,\n  minorAxisFont: Font,\n  startTime: number,\n  endTime: number,\n  viewportStartTime: number,\n  viewportEndTime: number,\n  width: number,\n  isRTL: boolean,\n  minorAxisScale: TimeComponentTimeAxis['scale'],\n  majorAxisScale?: TimeComponentTimeAxis['scale']\n) => {\n  const majorAxisLabelsTicks = majorAxisScale\n    ? getViewportLabelsTicks(majorAxisScale, viewportStartTime, viewportEndTime)\n    : { ticks: [], labels: [] };\n\n  const minorAxisLabelsTicks = getViewportLabelsTicks(\n    minorAxisScale,\n    viewportStartTime,\n    viewportEndTime\n  );\n\n  // Determine whether to render secondary major gridlines\n  // If major dates is a subset of minor dates, then the two grids line up.\n  // Don't render the minor dates at overlap\n  // (due to opacity, minor line would show through major line otherwise).\n  // Otherwise the major and minor axis do not \"line up\"\n  // (e.g. months and weeks scale together). Render minor lines only.\n  const { ticks: majorTicks, labels: majorLabels } = majorAxisLabelsTicks;\n  const { ticks: minorTicks, labels: minorLabels } = minorAxisLabelsTicks;\n  const majorTicksSet = new Set(majorTicks);\n  const minorTicksSet = new Set(minorTicks);\n  // only consider major dates that are in range (e.g. first and/or last ticks may be out of range)\n  const showMajorTicks =\n    majorTicks.filter((t) => t > viewportStartTime && t < viewportEndTime && !minorTicksSet.has(t))\n      .length === 0;\n  const minorGridTicks = showMajorTicks\n    ? minorTicks.filter((t) => !majorTicksSet.has(t))\n    : minorTicks;\n\n  const majorAxisLayout =\n    majorAxisScale &&\n    getTimeAxisLayout(\n      getTextDimensions,\n      labelPaddingStart,\n      labelPaddingEnd,\n      majorAxisFont,\n      majorAxisScale.labelPosition,\n      majorTicks,\n      majorTicks,\n      majorLabels,\n      startTime,\n      endTime,\n      viewportStartTime,\n      viewportEndTime,\n      width,\n      isRTL\n    );\n\n  const minorAxisLayout = getTimeAxisLayout(\n    getTextDimensions,\n    labelPaddingStart,\n    labelPaddingEnd,\n    minorAxisFont,\n    minorAxisScale.labelPosition,\n    minorTicks,\n    minorGridTicks,\n    minorLabels,\n    startTime,\n    endTime,\n    viewportStartTime,\n    viewportEndTime,\n    width,\n    isRTL\n  );\n\n  return {\n    minorAxisLayout: {\n      majorGridTicksPos:\n        showMajorTicks && majorAxisLayout ? majorAxisLayout.gridTicksPos : undefined,\n      minorGridTicksPos: minorAxisLayout.gridTicksPos,\n      variant: 'minor' as const,\n      ...minorAxisLayout\n    },\n    majorAxisLayout: majorAxisLayout && {\n      majorGridTicksPos: majorAxisLayout.gridTicksPos,\n      minorGridTicksPos: undefined,\n      variant: 'major' as const,\n      ...majorAxisLayout\n    }\n  };\n};\n\n/**\n * Gets the time axes zoom parameters.\n * @param getTextDimensions The text measurement function.\n * @param labelPaddingStart The interval label padding start.\n * @param labelPaddingEnd The interval label padding end.\n * @param labelMinWidth The interval label min width.\n * @param minorAxisFont The minor axis font.\n * @param startTime The start time.\n * @param endTime The end time.\n * @param minorAxisZoomOrder The minor axis zoom order.\n * @returns The time axes zoom parameters.\n */\nconst getTimeAxesZoomParameters = (\n  getTextDimensions: GetTextDimensions,\n  labelPaddingStart: number,\n  labelPaddingEnd: number,\n  labelMinWidth: number,\n  minorAxisFont: Font,\n  startTime: number,\n  endTime: number,\n  minorAxisZoomOrder: NonNullable<TimeComponentTimeAxis['zoomOrder']>\n) => {\n  const { zoomOrderMinLengthFactor, maxNumIntervals } = getZoomOrderCharacteristics(\n    getTextDimensions,\n    labelPaddingStart,\n    labelPaddingEnd,\n    labelMinWidth,\n    minorAxisFont,\n    minorAxisZoomOrder,\n    // 4 sections and 10 interval sections is arbitrary, which samples some labels at every quarter.\n    // This is more than enough for the current default scales and labels because they're very equally spaced.\n    // but this may not work well with weird custom scales such as reptitions of e.g. [3 weeks, 7 days, 2 months]\n    // for a span of 1 year, in which case we may only see weeks and months in our sample, but not days,\n    // and we underestimate the content lengths.\n    // But even then, users may still be able to zoom in sufficiently to see everything they need.\n    // If it turns out this doesn't work well for some common cases, we can bump these params up\n    // to cover more intervals in the future.\n    {\n      type: 'approximate',\n      params: { numSections: 4, numIntervalsPerSection: 10, startTime, endTime }\n    }\n  );\n\n  const getZoomOrderViewDurationThresholds = (width: number) =>\n    zoomOrderMinLengthFactor.map((l) => width * l);\n  const minZoomViewportDuration = (endTime - startTime) / maxNumIntervals;\n  const maxZoomViewportDuration = endTime - startTime;\n\n  return {\n    getZoomOrderViewDurationThresholds,\n    minorAxisZoomOrder,\n    minZoomViewportDuration,\n    maxZoomViewportDuration,\n    startTime,\n    endTime\n  };\n};\n\n/**\n * Returns a function that given the viewport width, returns the resolved time axes layout for the given viewport.\n * @param getTextDimensions The text measurement function.\n * @param labelPaddingStart The interval label padding start.\n * @param labelPaddingEnd The interval label padding end.\n * @param majorAxisFont The major axis font.\n * @param minorAxisFont The minor axis font.\n * @param getZoomOrderViewDurationThresholds A function that given the viewport width, returns the zoom order viewport duration thresholds.\n * @param axisPosition The axis position.\n * @param startTime The start time.\n * @param endTime The end time.\n * @param isRTL Whether the reading direction is rtl.\n * @param resolvedMinorAxisProps The resolved minor axis props.\n * @param resolvedMajorAxisProps The resolved major axis props.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @returns A function that given the viewport width, returns the resolved time axes layout for the given viewport.\n */\nconst getResolvedTimeAxesLayout = (\n  getTextDimensions: GetTextDimensions,\n  labelPaddingStart: number,\n  labelPaddingEnd: number,\n  majorAxisFont: Font,\n  minorAxisFont: Font,\n  getZoomOrderViewDurationThresholds: (width: number) => number[],\n  axisPosition: 'top' | 'bottom',\n  startTime: number,\n  endTime: number,\n  isRTL: boolean,\n  resolvedMinorAxisProps: ReturnType<typeof getResolvedTimeAxisProps>,\n  resolvedMajorAxisProps?: ReturnType<typeof getResolvedTimeAxisProps>,\n  viewportStartTime?: number,\n  viewportEndTime?: number\n) => {\n  return (width: number) => {\n    const { zoomOrder, zoomOrderIndex } = resolvedMinorAxisProps;\n    const zoomOrderViewDurationThresholds = getZoomOrderViewDurationThresholds(width);\n\n    const {\n      viewportStartTime: resolvedViewportStartTime,\n      viewportEndTime: resolvedViewportEndTime\n    } = getResolvedViewport(\n      zoomOrderViewDurationThresholds[zoomOrderIndex],\n      startTime,\n      endTime,\n      viewportStartTime,\n      viewportEndTime\n    );\n\n    const { majorAxisLayout, minorAxisLayout } = getTimeAxesViewportLayout(\n      getTextDimensions,\n      labelPaddingStart,\n      labelPaddingEnd,\n      majorAxisFont,\n      minorAxisFont,\n      startTime,\n      endTime,\n      resolvedViewportStartTime,\n      resolvedViewportEndTime,\n      width,\n      isRTL,\n      zoomOrder[zoomOrderIndex],\n      resolvedMajorAxisProps &&\n        resolvedMajorAxisProps.zoomOrder[resolvedMajorAxisProps.zoomOrderIndex]\n    );\n\n    return {\n      position: axisPosition,\n      startTime,\n      endTime,\n      viewportStartTime: resolvedViewportStartTime,\n      viewportEndTime: resolvedViewportEndTime,\n      width,\n      majorAxis: majorAxisLayout && { width, ...resolvedMajorAxisProps!, ...majorAxisLayout },\n      minorAxis: { width, ...resolvedMinorAxisProps, ...minorAxisLayout }\n    };\n  };\n};\n\nexport {\n  getResolvedTimeAxisProps,\n  getUnresolvedTimeAxesLayout,\n  getResolvedTimeAxesLayout,\n  getTimeAxesZoomParameters\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { useCssVars } from '#hooks/PRIVATE_useCssVars';\nimport { bridgeValues } from '../themes/TimeComponentStyles.css';\nimport { typographyVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\nimport { xUnits } from '#UNSAFE_Theme/utils';\n\nconst timeComponentUnresolvedVars: Parameters<typeof useCssVars>[0] = [\n  {\n    tokenVar: bridgeValues.horizontalTimeAxisHeight,\n    key: 'defaultTimeAxisHeight',\n    cssProp: 'height'\n  },\n  {\n    tokenVar: bridgeValues.horizontalTimeAxisLabelPaddingInlineStart,\n    key: 'timeAxisLabelPaddingInlineStart',\n    cssProp: 'margin-inline-start'\n  },\n  {\n    tokenVar: bridgeValues.horizontalTimeAxisLabelPaddingInlineEnd,\n    key: 'timeAxisLabelPaddingInlineEnd',\n    cssProp: 'margin-inline-end'\n  },\n  {\n    tokenVar: xUnits(12.5),\n    key: 'timeAxisLabelMinWidth',\n    cssProp: 'min-width'\n  },\n  {\n    tokenVar: typographyVars.body.md.fontSize,\n    key: 'majorAxisFontSize',\n    cssProp: 'font-size'\n  },\n  {\n    tokenVar: typographyVars.body.sm.fontSize,\n    key: 'minorAxisFontSize',\n    cssProp: 'margin-block-start'\n  },\n  {\n    tokenVar: typographyVars.body.md.fontWeight.semibold,\n    key: 'majorAxisFontWeight'\n  },\n  {\n    tokenVar: typographyVars.body.sm.fontWeight.regular,\n    key: 'minorAxisFontWeight'\n  }\n];\n\n/**\n * Gets the resolved time axis related CSS vars.\n * @param resolvedVars The resolved CSS vars.\n * @returns The resolved values.\n */\nconst getResolvedTimeAxisVars = (resolvedVars: ReturnType<typeof useCssVars>['resolvedVars']) => ({\n  defaultTimeAxisHeight: pxToNumber(resolvedVars['defaultTimeAxisHeight']),\n  timeAxisLabelPaddingInlineStart: pxToNumber(resolvedVars['timeAxisLabelPaddingInlineStart']),\n  timeAxisLabelPaddingInlineEnd: pxToNumber(resolvedVars['timeAxisLabelPaddingInlineEnd']),\n  timeAxisLabelMinWidth: pxToNumber(resolvedVars['timeAxisLabelMinWidth']),\n  majorAxisFont: {\n    fontSize: resolvedVars['majorAxisFontSize'],\n    fontWeight: resolvedVars['majorAxisFontWeight']\n  },\n  minorAxisFont: {\n    fontSize: resolvedVars['minorAxisFontSize'],\n    fontWeight: resolvedVars['minorAxisFontWeight']\n  }\n});\n\n// TODO: Export this from useCssVars? Or make useCssVars output number for px strings?\n/**\n * Parses the number from a pixel string.\n * @param length The pixel string.\n * @returns The number.\n */\nconst pxToNumber = (length: string) =>\n  length === '0' ? 0 : Number(length.substring(0, length.length - 2));\n\nexport { timeComponentUnresolvedVars, getResolvedTimeAxisVars, pxToNumber };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { useCssVars } from '#hooks/PRIVATE_useCssVars';\nimport { baseVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\nimport { xUnits } from '#UNSAFE_Theme/utils';\nimport { pxToNumber } from '#PRIVATE_TimeComponent/utils/timeComponentStyleUtils';\nimport { bridgeValues } from '../themes/GanttStyles.css';\n\nconst ganttUnresolvedVars: Parameters<typeof useCssVars>[0] = [\n  {\n    tokenVar: bridgeValues.rowLabelPaddingInlineStart,\n    key: 'rowLabelPaddingInlineStart',\n    cssProp: 'padding-inline-start'\n  },\n  {\n    tokenVar: bridgeValues.rowLabelPaddingInlineStart,\n    key: 'rowLabelPaddingInlineEnd',\n    cssProp: 'padding-inline-end'\n  },\n  {\n    tokenVar: xUnits(3),\n    key: 'rowPaddingTop',\n    cssProp: 'padding-top'\n  },\n  {\n    tokenVar: xUnits(3),\n    key: 'rowPaddingBottom',\n    cssProp: 'padding-bottom'\n  },\n  {\n    tokenVar: xUnits(6),\n    key: 'taskHeight',\n    cssProp: 'min-height'\n  },\n  {\n    tokenVar: xUnits(1),\n    key: 'taskBorderRadius',\n    cssProp: 'border-radius'\n  },\n  {\n    tokenVar: bridgeValues.taskBgColor,\n    key: 'taskBgColor',\n    cssProp: 'background-color'\n  },\n  {\n    tokenVar: bridgeValues.taskBorderColor,\n    key: 'taskBorderColor',\n    cssProp: 'border-color'\n  },\n  {\n    tokenVar: bridgeValues.taskEffectBorderColor,\n    key: 'taskEffectBorderColor',\n    cssProp: 'outline-color'\n  },\n  {\n    tokenVar: baseVars.boxShadow.md,\n    key: 'taskEffectBoxShadow',\n    cssProp: 'box-shadow'\n  }\n];\n\n/**\n * Parses a CSS box-shadow string.\n * @param boxShadow A CSS box-shadow string, of the form \"color offsetX offsetY blur spread\".\n * @returns The components of the box-shadow.\n */\nconst parseBoxShadow = (boxShadow: string) => {\n  // boxShadow: \"color offsetX offsetY blur spread\"\n  // color may have spaces e.g. rgb(0, 0, 0, 0.2)\n  const [_, shadowBlur, shadowOffsetY, shadowOffsetX, ...rest] = boxShadow.split(' ').reverse();\n  const shadowColor = rest.reverse().join(' ');\n  return {\n    shadowColor,\n    shadowOffsetX: pxToNumber(shadowOffsetX ?? '0'),\n    shadowOffsetY: pxToNumber(shadowOffsetY ?? '0'),\n    shadowBlur: pxToNumber(shadowBlur ?? '0')\n  };\n};\n\n/**\n * Gets the resolved row axis related CSS vars.\n * @param resolvedVars The resolved CSS vars.\n * @returns The resolved values.\n */\nconst getResolvedRowAxisVars = (resolvedVars: ReturnType<typeof useCssVars>['resolvedVars']) => ({\n  rowLabelPaddingInlineStart: pxToNumber(resolvedVars['rowLabelPaddingInlineStart']),\n  rowLabelPaddingInlineEnd: pxToNumber(resolvedVars['rowLabelPaddingInlineEnd'])\n});\n\n/**\n * Gets the resolved row related CSS vars.\n * @param resolvedVars The resolved CSS vars.\n * @returns The resolved values.\n */\nconst getResolvedRowVars = (resolvedVars: ReturnType<typeof useCssVars>['resolvedVars']) => ({\n  rowPaddingTop: pxToNumber(resolvedVars['rowPaddingTop']),\n  rowPaddingBottom: pxToNumber(resolvedVars['rowPaddingBottom'])\n});\n\n/**\n * Gets the resolved task related CSS vars.\n * @param resolvedVars The resolved CSS vars.\n * @returns The resolved values.\n */\nconst getResolvedTaskVars = (resolvedVars: ReturnType<typeof useCssVars>['resolvedVars']) => ({\n  taskHeight: pxToNumber(resolvedVars['taskHeight']),\n  taskBorderRadius: resolvedVars['taskBorderRadius'] as string,\n  taskBgColor: resolvedVars['taskBgColor'] as string,\n  taskBorderColor: resolvedVars['taskBorderColor'] as string,\n  taskEffectBorderColor: resolvedVars['taskEffectBorderColor'] as string,\n  taskEffectBoxShadow: parseBoxShadow(resolvedVars['taskEffectBoxShadow'])\n});\n\nexport { ganttUnresolvedVars, getResolvedRowAxisVars, getResolvedRowVars, getResolvedTaskVars };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { GanttRowAxisProps } from '../gantt.types';\nimport { getUnresolvedTimeAxesLayout } from '#PRIVATE_TimeComponent/utils/timeAxisLayoutUtils';\nimport { bridgeValues as timeCompBridgeValues } from '#PRIVATE_TimeComponent/themes/TimeComponentStyles.css';\nimport { xUnits } from '#UNSAFE_Theme';\n\ntype RowAxisWidth<D1> = NonNullable<GanttRowAxisProps<D1>['width']>;\ntype RowAxisMaxWidth<D1> = NonNullable<GanttRowAxisProps<D1>['maxWidth']>;\ntype RowAxisLabel<D1> = NonNullable<GanttRowAxisProps<D1>['labelRenderer']>;\n\n/**\n * Gets the row axis layout.\n * @param timeAxesLayout The time axes layout.\n * @param rowAxisProps The row axis props.\n * @returns\n */\nconst getWithRowAxisLayout = <D1>(\n  timeAxesLayout: ReturnType<typeof getUnresolvedTimeAxesLayout>,\n  rowAxisProps: {\n    width: RowAxisWidth<D1>;\n    maxWidth: RowAxisMaxWidth<D1>;\n    label: RowAxisLabel<D1>;\n  }\n) => {\n  const horiScrollbarHeight = `${xUnits(1)} + ${timeCompBridgeValues.horizontalScrollbarHeight}`;\n  const generalLayout = {\n    top: {\n      rowAxisTopGap: timeAxesLayout.height,\n      rowAxisBottomGap: `calc(${horiScrollbarHeight})`\n    },\n    bottom: {\n      rowAxisTopGap: '0',\n      rowAxisBottomGap: `calc(${timeAxesLayout.height} + ${horiScrollbarHeight})`\n    }\n  };\n\n  const resolvedWidth = getResolvedLength(rowAxisProps.width);\n  const resolvedMaxWidth = getResolvedLength(rowAxisProps.maxWidth);\n\n  return {\n    ...generalLayout[timeAxesLayout.position],\n    resolvedRowAxisWidth: resolvedWidth,\n    resolvedRowAxisMaxWidth: resolvedMaxWidth,\n    label: rowAxisProps.label\n  };\n};\n\n/**\n * Gets the parsed length given the values that the row axis accepts.\n * @param length The length values that the row axis accepts.\n * @returns The parsed length.\n */\nconst getResolvedLength = <D1>(length: RowAxisWidth<D1> | RowAxisMaxWidth<D1>) => {\n  if (length.endsWith('px')) {\n    return {\n      value: Number(length.substring(0, length.length - 2)),\n      suffix: 'px' as const\n    };\n  }\n  if (length.endsWith('%')) {\n    return {\n      value: Number(length.substring(0, length.length - 1)),\n      suffix: '%' as const\n    };\n  }\n  // length is 'max-content' for width and 'none' for max-width\n  return {\n    value: Infinity,\n    suffix: undefined\n  };\n};\n\nexport { getWithRowAxisLayout };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { GanttProps, GanttRowData, GanttTaskData } from '../gantt.types';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useCssVars } from '#hooks/PRIVATE_useCssVars';\nimport { useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport {\n  getResolvedTimeAxisProps,\n  getUnresolvedTimeAxesLayout,\n  getResolvedTimeAxesLayout,\n  getTimeAxesZoomParameters\n} from '#PRIVATE_TimeComponent/utils/timeAxisLayoutUtils';\nimport { getParsedTimeAxisParams } from '#PRIVATE_TimeComponent/utils/validationUtils';\nimport { getISOString } from '#PRIVATE_TimeComponent/utils/timeUtils';\nimport {\n  ganttUnresolvedVars,\n  getResolvedRowAxisVars,\n  getResolvedRowVars,\n  getResolvedTaskVars\n} from '../utils/ganttStyleUtils';\nimport {\n  timeComponentUnresolvedVars,\n  getResolvedTimeAxisVars\n} from '#PRIVATE_TimeComponent/utils/timeComponentStyleUtils';\nimport { getPanZoomCanvasLayout } from '../utils/panZoomCanvasLayoutUtils';\nimport { getWithRowAxisLayout } from '../utils/rowAxisLayoutUtils';\nimport { getResolvedViewportLayout, getRowDataLayout } from '../utils/dataLayoutUtils';\nimport {\n  getResolvedHorizontalScrollbarLayout,\n  getResolvedVerticalScrollbarLayout\n} from '#PRIVATE_TimeComponent/utils/scrollbarLayoutUtils';\nimport { defaultRowAxisLabelRender } from '../utils/rowAxisUtils';\n\nconst cssVars = timeComponentUnresolvedVars.concat(ganttUnresolvedVars);\n\n/**\n * Hook that computes layout related information for the Gantt.\n */\nconst useGanttLayout = <K1, K2, D1 extends GanttRowData<K1, D1, D2>, D2 extends GanttTaskData<K2>>({\n  rowAxis: rowAxisProps,\n  gridlines: { horizontal: gridlinesHorizontal = 'off', vertical: gridlinesVertical = 'on' } = {\n    horizontal: 'off',\n    vertical: 'on'\n  },\n  axisPosition = 'top',\n  minorAxis,\n  majorAxis,\n  start,\n  end,\n  viewportStart,\n  viewportEnd,\n  onViewportChange,\n  scrollPosition: { y: scrollPosition = 0 } = { y: 0 },\n  onScrollPositionChange,\n  rows,\n  selectedIds,\n  selectionMode = 'none'\n}: Omit<GanttProps<K2, D1, D2>, 'width' | 'height'>) => {\n  const { direction } = useUser();\n  const { resolvedVars, cssContent } = useCssVars(cssVars);\n  const { textMeasureContent, getTextDimensions } = useTextDimensions();\n\n  const isRTL = direction === 'rtl';\n  const layoutContent = (\n    <>\n      {textMeasureContent}\n      {cssContent}\n    </>\n  );\n\n  const {\n    startTime,\n    endTime,\n    viewportStartTime,\n    viewportEndTime,\n    isValidTimeConfig: isValidConfig\n  } = getParsedTimeAxisParams(start, end, viewportStart, viewportEnd);\n\n  // TODO: take a look a useCssVars and see if we can tighten the types more and make the following check nicer.\n  if (!getTextDimensions || Object.keys(resolvedVars).length === 0) {\n    return { isRTL, layoutContent, isValidConfig, isReady: false };\n  }\n\n  if (!isValidConfig) {\n    return { isRTL, layoutContent, isValidConfig, isReady: true };\n  }\n\n  // Resolve row axis props\n  const rowAxisRendered = rowAxisProps === undefined ? 'off' : 'on';\n  const rowAxis = rowAxisProps === 'on' ? {} : rowAxisProps;\n  const rowAxisWidth = rowAxis?.width ?? 'max-content';\n  const rowAxisMaxWidth = rowAxis?.maxWidth ?? 'none';\n  const rowAxisLabelRender = rowAxis?.labelRenderer ?? defaultRowAxisLabelRender;\n\n  // General layout\n  const unresolvedTimeAxesLayout = getUnresolvedTimeAxesLayout(axisPosition, minorAxis, majorAxis);\n  const panZoomLayout = getPanZoomCanvasLayout(unresolvedTimeAxesLayout);\n  const withRowAxisLayout =\n    rowAxisRendered === 'on'\n      ? getWithRowAxisLayout<D1>(unresolvedTimeAxesLayout, {\n          width: rowAxisWidth,\n          maxWidth: rowAxisMaxWidth,\n          label: rowAxisLabelRender\n        })\n      : undefined;\n\n  // Time axes layout and Zoom parameters\n  const timeAxisResolvedVars = getResolvedTimeAxisVars(resolvedVars);\n  const resolvedMajorAxisProps =\n    majorAxis && getResolvedTimeAxisProps(timeAxisResolvedVars.defaultTimeAxisHeight, majorAxis);\n  const resolvedMinorAxisProps = getResolvedTimeAxisProps(\n    timeAxisResolvedVars.defaultTimeAxisHeight,\n    minorAxis\n  );\n  // TODO: see if we need to useMemo this\n  const zoomParameters = getTimeAxesZoomParameters(\n    getTextDimensions,\n    timeAxisResolvedVars.timeAxisLabelPaddingInlineStart,\n    timeAxisResolvedVars.timeAxisLabelPaddingInlineEnd,\n    timeAxisResolvedVars.timeAxisLabelMinWidth,\n    timeAxisResolvedVars.minorAxisFont,\n    startTime,\n    endTime,\n    resolvedMinorAxisProps.zoomOrder\n  );\n  const getTimeAxesLayout = getResolvedTimeAxesLayout(\n    getTextDimensions,\n    timeAxisResolvedVars.timeAxisLabelPaddingInlineStart,\n    timeAxisResolvedVars.timeAxisLabelPaddingInlineEnd,\n    timeAxisResolvedVars.majorAxisFont,\n    timeAxisResolvedVars.minorAxisFont,\n    zoomParameters.getZoomOrderViewDurationThresholds,\n    axisPosition,\n    startTime,\n    endTime,\n    isRTL,\n    resolvedMinorAxisProps,\n    resolvedMajorAxisProps,\n    viewportStartTime,\n    viewportEndTime\n  );\n\n  // Row data layout\n  const rowResolvedVars = getResolvedRowVars(resolvedVars);\n  const taskResolvedVars = getResolvedTaskVars(resolvedVars);\n  const gridlines = { horizontal: gridlinesHorizontal, vertical: gridlinesVertical };\n  const rowDataLayout = getRowDataLayout<K1, K2, D1, D2>(\n    rows,\n    { ...rowResolvedVars, ...taskResolvedVars },\n    gridlines,\n    { selectedIds, selectionMode }\n  );\n\n  // Row axis layout\n  const rowAxisResolvedVars = getResolvedRowAxisVars(resolvedVars);\n  const rowAxisLayout = {\n    labelPaddingInlineStart: rowAxisResolvedVars.rowLabelPaddingInlineStart,\n    labelPaddingInlineEnd: rowAxisResolvedVars.rowLabelPaddingInlineEnd,\n    rowData: rowDataLayout.rowData,\n    rowObjs: rowDataLayout.rowObjs,\n    idRowObjMap: rowDataLayout.idRowObjMap,\n    isHorizontalGridlinesVisible: gridlinesHorizontal === 'on'\n  };\n\n  // Horizontal scrollbar layout\n  const getHorizontalScrollbarLayout = getResolvedHorizontalScrollbarLayout(\n    viewportStartTime ?? startTime,\n    viewportEndTime ?? endTime,\n    startTime,\n    endTime,\n    isRTL\n  );\n\n  const onHorizontalScrollChange = (newViewStartTime: number, newViewEndTime: number) => {\n    onViewportChange?.({\n      viewportStart: getISOString(newViewStartTime),\n      viewportEnd: getISOString(newViewEndTime),\n      majorAxisScale: majorAxis?.scale,\n      minorAxisScale: minorAxis.scale\n    });\n  };\n\n  // Vertical scrollbar layout\n  const getVerticalScrollbarLayout = getResolvedVerticalScrollbarLayout(\n    scrollPosition,\n    undefined,\n    0,\n    rowDataLayout.totalRowsHeight\n  );\n\n  const onVerticalScrollChange = (newScrollPosition: number) => {\n    onScrollPositionChange?.({ y: newScrollPosition });\n  };\n\n  return {\n    scrollPosition,\n    panZoomLayout,\n    withRowAxisLayout,\n    getTimeAxesLayout,\n    zoomParameters:\n      viewportStartTime !== undefined && viewportEndTime !== undefined\n        ? {\n            viewportStartTime,\n            viewportEndTime,\n            minorAxisZoomOrderIndex: resolvedMinorAxisProps.zoomOrderIndex,\n            majorAxisZoomOrder: resolvedMajorAxisProps?.zoomOrder,\n            majorAxisZoomOrderIndex: resolvedMajorAxisProps?.zoomOrderIndex,\n            ...zoomParameters\n          }\n        : undefined,\n    rowDataLayout,\n    rowAxisLayout,\n    getResolvedViewportLayout,\n    getHorizontalScrollbarLayout,\n    onHorizontalScrollChange,\n    getVerticalScrollbarLayout,\n    onVerticalScrollChange,\n    isRTL,\n    layoutContent,\n    isValidConfig,\n    isReady: true\n  };\n};\n\nexport { useGanttLayout };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { parseDate } from './timeUtils';\n\n/**\n * Returns whether the given configration is valid.\n * @param startTime The start time.\n * @param endTime The end time.\n * @param viewportStartTime The viewport start time.\n * @param viewportEndTime The viewport end time.\n * @returns Whether the given configuration is valid.\n */\nconst hasValidTimeConfig = (\n  startTime: number,\n  endTime: number,\n  viewportStartTime?: number,\n  viewportEndTime?: number\n) => {\n  const hasValidStartAndEnd = endTime > startTime;\n  const hasValidViewport =\n    viewportStartTime !== undefined && viewportEndTime !== undefined\n      ? viewportEndTime > viewportStartTime\n      : true;\n  const hasValidViewportStart =\n    viewportStartTime !== undefined\n      ? viewportStartTime >= startTime && viewportStartTime < endTime\n      : true;\n  const hasValidViewportEnd =\n    viewportEndTime !== undefined\n      ? viewportEndTime > startTime && viewportEndTime <= endTime\n      : true;\n  return hasValidStartAndEnd && hasValidViewport && hasValidViewportStart && hasValidViewportEnd;\n};\n\n/**\n * Gets the parsed time axis params.\n * @param start The start date string.\n * @param end The end date string.\n * @param viewportStart The viewport start date string.\n * @param viewportEnd The viewport end date string.\n * @returns The parsed params.\n */\nconst getParsedTimeAxisParams = (\n  start: string,\n  end: string,\n  viewportStart?: string,\n  viewportEnd?: string\n) => {\n  const startTime = parseDate(start);\n  const endTime = parseDate(end);\n  const viewportStartTime = viewportStart ? parseDate(viewportStart) : undefined;\n  const viewportEndTime = viewportEnd ? parseDate(viewportEnd) : undefined;\n  const isValidTimeConfig = hasValidTimeConfig(\n    startTime,\n    endTime,\n    viewportStartTime,\n    viewportEndTime\n  );\n  return { startTime, endTime, viewportStartTime, viewportEndTime, isValidTimeConfig };\n};\n\nexport { hasValidTimeConfig, getParsedTimeAxisParams };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { getUnresolvedTimeAxesLayout } from '#PRIVATE_TimeComponent/utils/timeAxisLayoutUtils';\n\n/**\n * Gets the pan zoom canvas layout given the time axes layout.\n * @param timeAxesLayout The time axes layout.\n * @returns The pan zoom canvas layout.\n */\nconst getPanZoomCanvasLayout = (timeAxesLayout: ReturnType<typeof getUnresolvedTimeAxesLayout>) => {\n  const layout = {\n    top: {\n      overlayControlsPosition: 'topEnd' as const,\n      verticalControlTopGap: timeAxesLayout.height,\n      verticalControlBottomGap: '0'\n    },\n    bottom: {\n      overlayControlsPosition: 'bottomEnd' as const,\n      verticalControlTopGap: '0',\n      verticalControlBottomGap: timeAxesLayout.height\n    }\n  };\n  return layout[timeAxesLayout.position];\n};\n\nexport { getPanZoomCanvasLayout };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n/**\n * Gets the resolved horizontal scrollbar layout.\n * @param min The range min.\n * @param max The range max.\n * @param globalMin The global min.\n * @param globalMax The global max.\n * @param isRTL Whether the reading direction is rtl.\n * @returns The resolved horizontal scrollbar layout.\n */\nconst getResolvedHorizontalScrollbarLayout = (\n  min: number,\n  max: number,\n  globalMin: number,\n  globalMax: number,\n  isRTL: boolean\n) => {\n  return (width: number) => {\n    const localRange = max - min;\n    const globalRange = globalMax - globalMin;\n    const thumbWidth = (width * localRange) / globalRange;\n    const thumbStartOffset = (width * (min - globalMin)) / globalRange;\n    const logicalThumbLeft = isRTL ? width - thumbStartOffset - thumbWidth : thumbStartOffset;\n    const thumbLeft = isRTL ? undefined : thumbStartOffset;\n    const thumbRight = isRTL ? thumbStartOffset : undefined;\n\n    const draggableRegion = {\n      xMin: logicalThumbLeft,\n      xMax: logicalThumbLeft + thumbWidth,\n      yMin: -Infinity,\n      yMax: Infinity\n    };\n\n    const getNewRange = (newThumbLeft: number) => {\n      const p = isRTL ? Math.max(0, width - newThumbLeft - thumbWidth) : newThumbLeft;\n      const newMin = Math.min(globalMin + (p / width) * globalRange, globalMax - localRange);\n      const newMax = newMin + localRange;\n      return { newMin, newMax };\n    };\n\n    return {\n      thumbWidth,\n      thumbLeft,\n      thumbRight,\n      draggableRegion,\n      getNewRange\n    };\n  };\n};\n\n/**\n * Gets the resolved vertical scrollbar layout.\n * @param min The range min.\n * @param max The range max (if any).\n * @param globalMin The global min.\n * @param globalMax The global max.\n * @returns The resolved vertical scrollbar layout.\n */\nconst getResolvedVerticalScrollbarLayout = (\n  min: number,\n  max: number | undefined,\n  globalMin: number,\n  globalMax: number\n) => {\n  return (height: number) => {\n    // It's possible for globalRange to be smaller than localRange\n    // due to the component being taller than the height the data occupies\n    // e.g. tall Gantt with 1 row\n    // So throughout this code we make sure to clamp thumb dimensions and ranges\n    const localRange = (max ?? height + min) - min;\n    const globalRange = globalMax - globalMin;\n    const thumbHeight = Math.min(height, (height * localRange) / globalRange);\n    const thumbTop = Math.max(0, (height * (min - globalMin)) / globalRange);\n\n    const draggableRegion = {\n      xMin: -Infinity,\n      xMax: Infinity,\n      yMin: thumbTop,\n      yMax: thumbTop + thumbHeight\n    };\n\n    const getNewRange = (newThumbTop: number) => {\n      const newMin = Math.max(\n        0,\n        Math.min(globalMin + (newThumbTop / height) * globalRange, globalMax - localRange)\n      );\n      const newMax = newMin + localRange;\n      return { newMin, newMax };\n    };\n\n    return {\n      thumbHeight,\n      thumbTop,\n      draggableRegion,\n      getNewRange\n    };\n  };\n};\n\nexport { getResolvedHorizontalScrollbarLayout, getResolvedVerticalScrollbarLayout };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { cancelEvent } from '#utils/UNSAFE_visUtils';\nimport {\n  createKbPanDownEvent,\n  createKbPanEndEvent,\n  createKbPanStartEvent,\n  createKbPanUpEvent,\n  createKbZoomInEvent,\n  createKbZoomOutEvent\n} from '../utils/keyboardUtils';\n\ntype UseTimeComponentKeyboardOptions = {\n  visRef: RefObject<HTMLDivElement>;\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that handles various Time Component keyboard gestures.\n */\nconst useTimeComponentKeyboard = ({\n  visRef,\n  isDisabled = false\n}: UseTimeComponentKeyboardOptions) => {\n  const onKeyDown = (event: KeyboardEvent) => {\n    const key = event.key;\n    switch (key) {\n      case '=':\n      case '+': {\n        const e = createKbZoomInEvent();\n        visRef.current?.dispatchEvent(e);\n        cancelEvent(event);\n        break;\n      }\n      case '-':\n      case '_': {\n        const e = createKbZoomOutEvent();\n        visRef.current?.dispatchEvent(e);\n        cancelEvent(event);\n        break;\n      }\n      case 'PageUp': {\n        const e = event.shiftKey ? createKbPanStartEvent() : createKbPanUpEvent();\n        visRef.current?.dispatchEvent(e);\n        cancelEvent(event);\n        break;\n      }\n      case 'PageDown': {\n        const e = event.shiftKey ? createKbPanEndEvent() : createKbPanDownEvent();\n        visRef.current?.dispatchEvent(e);\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  return isDisabled ? {} : { onKeyDown };\n};\n\nexport { useTimeComponentKeyboard };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { DEFAULT_ZOOM_IN_FACTOR, DEFAULT_ZOOM_OUT_FACTOR } from './timeZoomUtils';\n\nconst DEFAULT_PAN_UP_RANGE_RATIO = 0.25;\nconst DEFAULT_PAN_DOWN_RANGE_RATIO = -0.25;\nconst DEFAULT_PAN_START_RANGE_RATIO = 0.25;\nconst DEFAULT_PAN_END_RANGE_RATIO = -0.25;\n\ntype KbPanEvent = CustomEvent<{ rangeRatio: number }>;\ntype KbZoomEvent = CustomEvent<{ zoomFactor: number }>;\n\nconst createKbPanUpEvent = () =>\n  new CustomEvent('KbPanVertical', { detail: { rangeRatio: DEFAULT_PAN_UP_RANGE_RATIO } });\n\nconst createKbPanDownEvent = () =>\n  new CustomEvent('KbPanVertical', { detail: { rangeRatio: DEFAULT_PAN_DOWN_RANGE_RATIO } });\n\nconst createKbPanStartEvent = () =>\n  new CustomEvent('KbPanHorizontal', { detail: { rangeRatio: DEFAULT_PAN_START_RANGE_RATIO } });\n\nconst createKbPanEndEvent = () =>\n  new CustomEvent('KbPanHorizontal', { detail: { rangeRatio: DEFAULT_PAN_END_RANGE_RATIO } });\n\nconst createKbZoomInEvent = () =>\n  new CustomEvent('KbZoomIn', { detail: { zoomFactor: DEFAULT_ZOOM_IN_FACTOR } });\n\nconst createKbZoomOutEvent = () =>\n  new CustomEvent('KbZoomIn', { detail: { zoomFactor: DEFAULT_ZOOM_OUT_FACTOR } });\n\nexport {\n  type KbPanEvent,\n  createKbPanUpEvent,\n  createKbPanDownEvent,\n  createKbPanStartEvent,\n  createKbPanEndEvent,\n  type KbZoomEvent,\n  createKbZoomInEvent,\n  createKbZoomOutEvent\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { cancelEvent } from '#utils/UNSAFE_visUtils';\nimport type { GanttCurrentTask, GanttRowData, GanttTaskData } from '../gantt.types';\nimport type { getRowDataLayout } from '../utils/dataLayoutUtils';\nimport {\n  getAboveTaskNavigable,\n  getBelowTaskNavigable,\n  getNextTaskNavigable,\n  getPrevTaskNavigable\n} from '../utils/navigationUtils';\n\ntype UseGanttTaskNavigationOptions<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = {\n  rowDataLayout: ReturnType<typeof getRowDataLayout<K1, K2, D1, D2>>;\n  currentTask: GanttCurrentTask<K2>['currentTask'];\n  onCurrentTaskChange: GanttCurrentTask<K2>['onCurrentTaskChange'];\n  isRTL: boolean;\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that handles row labels keyboard navigation.\n */\nconst useGanttTaskNavigation = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  rowDataLayout,\n  currentTask,\n  onCurrentTaskChange,\n  isRTL,\n  isDisabled = false\n}: UseGanttTaskNavigationOptions<K1, K2, D1, D2>) => {\n  const onKeyDown = (event: KeyboardEvent) => {\n    const key = event.key;\n    switch (key) {\n      case 'ArrowRight': {\n        const nextTaskId =\n          currentTask &&\n          (!isRTL\n            ? getNextTaskNavigable(currentTask.id, rowDataLayout)\n            : getPrevTaskNavigable(currentTask.id, rowDataLayout));\n        if (nextTaskId !== undefined) {\n          onCurrentTaskChange({ id: nextTaskId, isFocused: true });\n        }\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowLeft': {\n        const prevTaskId =\n          currentTask &&\n          (!isRTL\n            ? getPrevTaskNavigable(currentTask.id, rowDataLayout)\n            : getNextTaskNavigable(currentTask.id, rowDataLayout));\n        if (prevTaskId !== undefined) {\n          onCurrentTaskChange({ id: prevTaskId, isFocused: true });\n        }\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowUp': {\n        const aboveTaskId = currentTask && getAboveTaskNavigable(currentTask.id, rowDataLayout);\n        if (aboveTaskId !== undefined) {\n          onCurrentTaskChange({ id: aboveTaskId, isFocused: true });\n        }\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowDown': {\n        const belowTaskId = currentTask && getBelowTaskNavigable(currentTask.id, rowDataLayout);\n        if (belowTaskId !== undefined) {\n          onCurrentTaskChange({ id: belowTaskId, isFocused: true });\n        }\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  return isDisabled ? {} : { onKeyDown };\n};\n\nexport { useGanttTaskNavigation };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { cancelEvent } from '#utils/UNSAFE_visUtils';\nimport type { GanttCurrentRowLabel, GanttRowData, GanttTaskData } from '../gantt.types';\nimport type { getRowDataLayout } from '../utils/dataLayoutUtils';\nimport { getAboveRowLabelNavigable, getBelowRowLabelNavigable } from '../utils/navigationUtils';\n\ntype UseGanttRowLabelNavigationOptions<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = {\n  rowDataLayout: ReturnType<typeof getRowDataLayout<K1, K2, D1, D2>>;\n  currentRowLabel: GanttCurrentRowLabel<K1>['currentRowLabel'];\n  onCurrentRowLabelChange: GanttCurrentRowLabel<K1>['onCurrentRowLabelChange'];\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that handles row labels keyboard navigation.\n */\nconst useGanttRowLabelNavigation = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  rowDataLayout,\n  currentRowLabel,\n  onCurrentRowLabelChange,\n  isDisabled = false\n}: UseGanttRowLabelNavigationOptions<K1, K2, D1, D2>) => {\n  const onKeyDown = (event: KeyboardEvent) => {\n    const key = event.key;\n    switch (key) {\n      case 'ArrowUp': {\n        const aboveRowId =\n          currentRowLabel && getAboveRowLabelNavigable(currentRowLabel.id, rowDataLayout);\n        if (aboveRowId !== undefined) {\n          onCurrentRowLabelChange({ id: aboveRowId, isFocused: true });\n        }\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowDown': {\n        const belowRowId =\n          currentRowLabel && getBelowRowLabelNavigable(currentRowLabel.id, rowDataLayout);\n        if (belowRowId !== undefined) {\n          onCurrentRowLabelChange({ id: belowRowId, isFocused: true });\n        }\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  return isDisabled ? {} : { onKeyDown };\n};\n\nexport { useGanttRowLabelNavigation };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useRef } from 'preact/hooks';\nimport { cancelEvent } from '#utils/UNSAFE_visUtils';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { useTimeComponentKeyboard } from '#PRIVATE_TimeComponent/hooks/useTimeComponentKeyboard';\nimport { useSelection } from '#hooks/PRIVATE_useVisSelection';\nimport type {\n  GanttCurrentRowLabel,\n  GanttCurrentTask,\n  GanttRowData,\n  GanttSelection as GanttSelectionProps,\n  GanttTaskData\n} from '../gantt.types';\nimport type { getRowDataLayout } from '../utils/dataLayoutUtils';\nimport {\n  getDefaultInitialFocusTask,\n  getRowLabelNavigableFromTask,\n  getTaskNavigableFromRowLabel\n} from '../utils/navigationUtils';\nimport { useGanttTaskNavigation } from './useGanttTaskNavigation';\nimport { useGanttRowLabelNavigation } from './useGanttRowLabelNavigation';\n\n/**\n * Hook that handles keyboard gestures on a Gantt.\n */\ntype UseGanttKeyboardOptions<\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n> = {\n  visRef: RefObject<HTMLDivElement>;\n  rowAxisRef: RefObject<HTMLDivElement>;\n  rowDataLayout: ReturnType<typeof getRowDataLayout<K1, K2, D1, D2>>;\n  navigationModes: {\n    tasks: {\n      currentItem: GanttCurrentTask<K2>['currentTask'];\n      onCurrentItemChange: GanttCurrentTask<K2>['onCurrentTaskChange'];\n    };\n    rowLabels: {\n      currentItem: GanttCurrentRowLabel<K1>['currentRowLabel'];\n      onCurrentItemChange: GanttCurrentRowLabel<K1>['onCurrentRowLabelChange'];\n    };\n  };\n  selectionProps: GanttSelectionProps<K2, D2>;\n  isRTL: boolean;\n  isDisabled?: boolean;\n};\n\nconst useGanttKeyboard = <\n  K1,\n  K2,\n  D1 extends GanttRowData<K1, D1, D2>,\n  D2 extends GanttTaskData<K2>\n>({\n  visRef,\n  rowAxisRef,\n  rowDataLayout,\n  navigationModes,\n  selectionProps,\n  isRTL,\n  isDisabled = false\n}: UseGanttKeyboardOptions<K1, K2, D1, D2>) => {\n  const currentNavMode = useRef<keyof typeof navigationModes>('tasks');\n\n  const idExtracter = (event: Event) => {\n    if (currentNavMode.current !== 'tasks' || event.type !== 'keyup') return;\n    return navigationModes.tasks.currentItem?.id;\n  };\n\n  const { onKeyUp: selectionKeyup } = useSelection<K2, D2>({\n    idExtracter,\n    selection: selectionProps.selectedIds,\n    selectionMode: selectionProps.selectionMode,\n    onChange: selectionProps.onSelectionChange,\n    // TODO: rowDataLayout is undefined when isDisabled is true. Let's reevalute the lifecycle when we work on JET-62889\n    getDataById: rowDataLayout?.getTaskDataById || (() => undefined)\n  }).selectionProps;\n  const selectionKeyboardProps =\n    currentNavMode.current === 'tasks' ? { onKeyUp: selectionKeyup } : {};\n\n  const keyboardProps = useTimeComponentKeyboard({\n    visRef,\n    isDisabled\n  });\n\n  const taskNavProps = useGanttTaskNavigation({\n    rowDataLayout,\n    currentTask: navigationModes.tasks.currentItem,\n    onCurrentTaskChange: navigationModes.tasks.onCurrentItemChange,\n    isRTL\n  });\n\n  const rowLabelNavProps = useGanttRowLabelNavigation({\n    rowDataLayout,\n    currentRowLabel: navigationModes.rowLabels.currentItem,\n    onCurrentRowLabelChange: navigationModes.rowLabels.onCurrentItemChange\n  });\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    let stopImmediatePropagation = false;\n    const applyFocus = (item: { id: K1; type: 'rowLabels' } | { id: K2; type: 'tasks' }) => {\n      const { onCurrentItemChange } = navigationModes[item.type];\n      onCurrentItemChange({ id: item.id as any, isFocused: true });\n    };\n    const removeFocus = (navType: keyof typeof navigationModes) => {\n      const { currentItem, onCurrentItemChange } = navigationModes[navType];\n      currentItem && onCurrentItemChange({ id: currentItem.id as any, isFocused: false });\n    };\n    const enterRowLabelsNavigation = () => {\n      const id = getRowLabelNavigableFromTask(navigationModes.tasks.currentItem!.id, rowDataLayout);\n      applyFocus({ id, type: 'rowLabels' });\n      removeFocus('tasks');\n      currentNavMode.current = 'rowLabels';\n      stopImmediatePropagation = true;\n      cancelEvent(event);\n    };\n    const enterTasksNavigation = () => {\n      const id = getTaskNavigableFromRowLabel(\n        navigationModes.rowLabels.currentItem!.id,\n        rowDataLayout,\n        navigationModes.tasks.currentItem?.id\n      );\n      id !== undefined && applyFocus({ id, type: 'tasks' });\n      removeFocus('rowLabels');\n      currentNavMode.current = 'tasks';\n      stopImmediatePropagation = true;\n      cancelEvent(event);\n    };\n\n    const key = event.key;\n    switch (key) {\n      case 'Tab': {\n        // Tab OUT of component\n        // Remove focus visuals\n        removeFocus(currentNavMode.current);\n        break;\n      }\n      case 'ArrowLeft': {\n        if (event.altKey) {\n          if (!isRTL && currentNavMode.current === 'tasks') {\n            enterRowLabelsNavigation();\n          } else if (isRTL && currentNavMode.current === 'rowLabels') {\n            enterTasksNavigation();\n          }\n        }\n        break;\n      }\n      case 'ArrowRight': {\n        if (event.altKey) {\n          if (!isRTL && currentNavMode.current === 'rowLabels') {\n            enterTasksNavigation();\n          } else if (isRTL && currentNavMode.current === 'tasks') {\n            enterRowLabelsNavigation();\n          }\n        }\n        break;\n      }\n    }\n\n    if (!stopImmediatePropagation) {\n      switch (currentNavMode.current) {\n        case 'tasks':\n          taskNavProps.onKeyDown?.(event);\n          break;\n        case 'rowLabels':\n          rowLabelNavProps.onKeyDown?.(event);\n          break;\n        default: {\n          const _exhaustiveCheck: never = currentNavMode.current;\n          return _exhaustiveCheck;\n        }\n      }\n    }\n  };\n\n  const onKeyUp = (event: KeyboardEvent) => {\n    const key = event.key;\n    switch (key) {\n      case 'Tab': {\n        // Tab INTO component\n        const { currentItem, onCurrentItemChange } = navigationModes[currentNavMode.current];\n        // currentItem should only ever be undefined on first Tab\n        const itemToFocus = currentItem ? currentItem : getDefaultInitialFocusTask(rowDataLayout);\n        itemToFocus && onCurrentItemChange({ id: itemToFocus.id as any, isFocused: true });\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n\n  // TODO: JET-62887: Avoid this temporary hack to get keyboard datatip to work (until we find a way to get rid of all these dispatchEvents)\n  const focusDatatipProps = {\n    onFocus: () => {\n      const e = new Event('ShowFocusDatatip');\n      visRef.current?.dispatchEvent(e);\n      rowAxisRef.current?.dispatchEvent(e);\n    }\n  };\n\n  return isDisabled\n    ? {}\n    : mergeProps(keyboardProps, focusDatatipProps, { onKeyDown, onKeyUp }, selectionKeyboardProps);\n};\n\nexport { useGanttKeyboard };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useRef, useState } from 'preact/hooks';\nimport type {\n  GanttCurrentRowLabel,\n  GanttCurrentTask,\n  GanttProps,\n  GanttRowData,\n  GanttTaskData\n} from './gantt.types';\nimport { GanttContainer } from './GanttContainer';\nimport { GanttWithRowAxisLayout } from './GanttWithRowAxisLayout';\nimport { GanttRowAxis } from './GanttRowAxis';\nimport { GanttView } from './GanttView';\nimport { useGanttLayout } from './hooks/useGanttLayout';\nimport { useTimeComponentEvents } from '#PRIVATE_TimeComponent/hooks/useTimeComponentEvents';\nimport { useGanttKeyboard } from './hooks/useGanttKeyboard';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { getRandomId } from '#utils/PRIVATE_visLayoutUtils';\n\n/**\n * A gantt displays scheduling information graphically, making it easier to plan, coordinate, and track various tasks and resources.\n */\nexport function Gantt<\n  K1 extends string | number,\n  D1 extends GanttRowData<K1, D1, D2>,\n  K2 extends string | number,\n  D2 extends GanttTaskData<K2>\n>({ width, height, testId, ...props }: GanttProps<K2, D1, D2>) {\n  const ref = useRef<HTMLDivElement>(null);\n  const {\n    scrollPosition,\n    panZoomLayout,\n    withRowAxisLayout,\n    getTimeAxesLayout,\n    zoomParameters,\n    rowDataLayout,\n    rowAxisLayout,\n    getResolvedViewportLayout,\n    getHorizontalScrollbarLayout,\n    onHorizontalScrollChange,\n    getVerticalScrollbarLayout,\n    onVerticalScrollChange,\n    isRTL,\n    layoutContent,\n    isValidConfig,\n    isReady\n  } = useGanttLayout<K1, K2, D1, D2>(props);\n\n  const ariaProps = {\n    'aria-label': props['aria-label'],\n    'aria-describedby': props['aria-describedby'],\n    'aria-labelledby': props['aria-labelledby'],\n    role: 'application' as const\n  };\n\n  const isViewportDefined = props.viewportStart !== undefined && props.viewportEnd !== undefined;\n\n  const [ariaActive, setAriaActive] = useState<\n    { dataId: K2; ariaId: string; type: 'task' } | { dataId: K1; ariaId: string; type: 'rowLabel' }\n  >();\n  const [currentTaskInteraction, setCurrentTaskInteraction] = useState<'hover' | 'focus' | 'none'>(\n    'none'\n  );\n  const [hoveredTaskId, setHoveredTaskId] = useState<K2>();\n  const onTaskHoverChange = (detail: { id?: K2 }) => {\n    detail.id !== undefined &&\n      setAriaActive({ dataId: detail.id, ariaId: getRandomId(), type: 'task' });\n    setCurrentTaskInteraction(detail.id !== undefined ? 'hover' : 'none');\n    setHoveredTaskId(detail.id);\n  };\n  const [currentRowLabelInteraction, setCurrentRowLabelInteraction] = useState<\n    'hover' | 'focus' | 'none'\n  >('none');\n  const [hoveredRowLabelId, setHoveredRowLabelId] = useState<K1>();\n  const onRowLabelHoverChange = (detail: { id?: K1 }) => {\n    detail.id !== undefined &&\n      setAriaActive({ dataId: detail.id, ariaId: getRandomId(), type: 'rowLabel' });\n    setCurrentRowLabelInteraction(detail.id !== undefined ? 'hover' : 'none');\n    setHoveredRowLabelId(detail.id);\n  };\n  const [currentTask, setCurrentTask] = useState<GanttCurrentTask<K2>['currentTask']>();\n  const onCurrentTaskChange = (detail: { id: K2; isFocused: boolean }) => {\n    if (detail.isFocused) {\n      const e = new CustomEvent('KbPanTaskIntoView', { detail: { id: detail.id } });\n      visRef.current?.dispatchEvent(e);\n      setAriaActive({ dataId: detail.id, ariaId: getRandomId(), type: 'task' });\n      setCurrentTaskInteraction('focus');\n    }\n    setCurrentTask(detail);\n  };\n  const [currentRowLabel, setCurrentRowLabel] =\n    useState<GanttCurrentRowLabel<K1>['currentRowLabel']>();\n  const onCurrentRowLabelChange = (detail: { id: K1; isFocused: boolean }) => {\n    if (detail.isFocused) {\n      const e = new CustomEvent('KbPanRowIntoView', { detail: { id: detail.id } });\n      visRef.current?.dispatchEvent(e);\n      setAriaActive({ dataId: detail.id, ariaId: getRandomId(), type: 'rowLabel' });\n      setCurrentRowLabelInteraction('focus');\n    }\n    setCurrentRowLabel(detail);\n  };\n\n  const visRef = useRef<HTMLDivElement>(null);\n  const rowAxisRef = useRef<HTMLDivElement>(null);\n  const overlayControlsContainerRef = useRef<HTMLDivElement>(null);\n  const eventProps = useTimeComponentEvents({\n    rootRef: ref,\n    overlayControlsContainerRef,\n    isDisabled: !isViewportDefined\n  });\n  const keyboardProps = useGanttKeyboard({\n    visRef,\n    rowAxisRef,\n    navigationModes: {\n      tasks: { currentItem: currentTask, onCurrentItemChange: onCurrentTaskChange },\n      rowLabels: { currentItem: currentRowLabel, onCurrentItemChange: onCurrentRowLabelChange }\n    },\n    rowDataLayout: rowDataLayout!,\n    selectionProps: {\n      selectedIds: props.selectedIds,\n      selectionMode: props.selectionMode,\n      onSelectionChange: props.onSelectionChange\n    },\n    isRTL,\n    isDisabled: !isViewportDefined\n  });\n\n  // TODO: Move check to util and call in corepack to decide whether to render invalid data state?\n  if (!isReady || !isValidConfig) {\n    return (\n      <GanttContainer innerRef={ref} width={width} height={height} {...ariaProps}>\n        {layoutContent}\n      </GanttContainer>\n    );\n  }\n\n  const ganttView = (\n    <GanttView\n      visRef={visRef}\n      overlayControlsContainerRef={overlayControlsContainerRef}\n      isRTL={isRTL}\n      isViewportDefined={isViewportDefined}\n      scrollPosition={scrollPosition!}\n      onScrollPositionChange={props.onScrollPositionChange}\n      onViewportChange={props.onViewportChange}\n      rowAxisSeparator={!!withRowAxisLayout}\n      zoomParameters={zoomParameters}\n      zooming={props.zooming}\n      panZoomLayout={panZoomLayout!}\n      getTimeAxesLayout={getTimeAxesLayout!}\n      getHorizontalScrollbarLayout={getHorizontalScrollbarLayout!}\n      onHorizontalScrollChange={onHorizontalScrollChange!}\n      getVerticalScrollbarLayout={getVerticalScrollbarLayout!}\n      onVerticalScrollChange={onVerticalScrollChange!}\n      getResolvedViewportLayout={getResolvedViewportLayout!}\n      rowDataLayout={rowDataLayout!}\n      datatip={props.datatip}\n      selectedIds={props.selectedIds}\n      selectionMode={props.selectionMode}\n      onSelectionChange={props.onSelectionChange}\n      hoveredTaskId={hoveredTaskId}\n      onTaskHoverChange={onTaskHoverChange}\n      currentTask={currentTask}\n      onCurrentTaskChange={onCurrentTaskChange}\n      currentTaskInteraction={currentTaskInteraction}\n      ariaActive={ariaActive?.type === 'task' ? ariaActive : undefined}\n    />\n  );\n\n  const ganttViewWithRowAxis = withRowAxisLayout && (\n    <GanttWithRowAxisLayout\n      {...withRowAxisLayout}\n      rowAxis={(resolvedWidth, resolvedMaxWidth) => (\n        <GanttRowAxis\n          innerRef={rowAxisRef}\n          resolvedWidth={resolvedWidth}\n          resolvedMaxWidth={resolvedMaxWidth}\n          currentRowLabel={currentRowLabel}\n          hoveredRowLabelId={hoveredRowLabelId}\n          onRowLabelHoverChange={onRowLabelHoverChange}\n          currentRowLabelInteraction={currentRowLabelInteraction}\n          ariaActive={ariaActive?.type === 'rowLabel' ? ariaActive : undefined}\n          layoutObj={rowAxisLayout}\n          scrollPosition={scrollPosition}>\n          {withRowAxisLayout.label}\n        </GanttRowAxis>\n      )}\n      ganttView={ganttView}\n    />\n  );\n\n  return (\n    <GanttContainer\n      innerRef={ref}\n      width={width}\n      height={height}\n      testId={testId}\n      {...ariaProps}\n      {...mergeProps(keyboardProps, eventProps)}\n      aria-activedescendant={ariaActive?.ariaId}>\n      {ganttViewWithRowAxis || ganttView}\n      {layoutContent}\n    </GanttContainer>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useRef } from 'preact/hooks';\n\ntype UseTimeComponentEventsOptions = {\n  rootRef: RefObject<HTMLDivElement>;\n  overlayControlsContainerRef: RefObject<HTMLDivElement>;\n  isDisabled?: boolean;\n};\n\n/**\n * Hook that handles various Time Component gestures.\n */\nconst useTimeComponentEvents = ({\n  rootRef,\n  overlayControlsContainerRef,\n  isDisabled = false\n}: UseTimeComponentEventsOptions) => {\n  const isFocused = useRef(false);\n\n  const dispatchControlsShow = () => {\n    const e = new Event('ControlsShow');\n    overlayControlsContainerRef.current?.dispatchEvent(e);\n  };\n\n  const dispatchControlsHide = () => {\n    const e = new Event('ControlsHide');\n    overlayControlsContainerRef.current?.dispatchEvent(e);\n  };\n\n  const onFocus = () => {\n    isFocused.current = true;\n    dispatchControlsShow();\n  };\n\n  const onBlur = (e: FocusEvent) => {\n    if (!e.relatedTarget || !rootRef.current?.contains(e.relatedTarget as Node)) {\n      isFocused.current = false;\n      dispatchControlsHide();\n    }\n  };\n\n  const onPointerDown = (e: PointerEvent) => {\n    if (e.pointerType !== 'mouse') {\n      // Ensure component is focused upon interaction\n      // e.g. on touch devices, if the component is not initially focused\n      // then one tries to drag pan the component, the component is still\n      // not focused. This is not a problem with mouse devices.\n      rootRef.current?.focus();\n    }\n  };\n\n  const onPointerOver = (e: PointerEvent) => {\n    if (e.pointerType === 'mouse') {\n      dispatchControlsShow();\n    }\n  };\n\n  const onPointerOut = (e: PointerEvent) => {\n    if (e.pointerType === 'mouse') {\n      if (!isFocused.current) dispatchControlsHide();\n    }\n  };\n\n  return isDisabled\n    ? {}\n    : {\n        onFocus,\n        onBlur,\n        onPointerDown,\n        onPointerOver,\n        onPointerOut\n      };\n};\n\nexport { useTimeComponentEvents };\n"],"names":["GanttContainer","innerRef","width","height","testId","children","otherProps","testIdProps","useTestId","_jsx","ref","tabIndex","class","classNames","timeComponentStyles","baseStyle","ganttStyles","styles","style","sizeToCSS","GanttWithRowAxisLayout","rowAxisTopGap","rowAxisBottomGap","resolvedRowAxisWidth","resolvedRowAxisMaxWidth","rowAxis","ganttView","isRelativeWidth","suffix","isRelativeMaxWidth","jsx","TrackResizeContainer","_","_jsxs","jsxs","rowAxisLayoutStyles","base","gridTemplateRows","value","defaultRowAxisLabelRender","maxWidth","maxHeight","data","label","labelStyle","undefined","display","alignItems","Text","size","variant","color","truncation","getRenderContext","layoutObj","rowData","index","FlatQueue","constructor","this","ids","values","length","clear","push","id","pos","parent","parentValue","pop","top","halfLength","left","right","bestIndex","bestValue","rightValue","peek","peekValue","shrink","ARRAY_TYPES","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","Flatbush","from","byteLength","buffer","Error","magic","versionAndType","version","ArrayType","nodeSize","numItems","ArrayBufferType","ArrayBuffer","isNaN","Math","min","max","n","numNodes","_levelBounds","ceil","IndexArrayType","arrayTypeIndex","indexOf","nodesByteSize","BYTES_PER_ELEMENT","_boxes","_indices","_pos","minX","minY","maxX","maxY","Infinity","set","_queue","add","boxes","finish","hilbertValues","i","x","floor","y","hilbert","sort","end","nodeIndex","nodeMinX","nodeMinY","nodeMaxX","nodeMaxY","j","search","filterFn","queue","results","upperBound","neighbors","maxResults","maxDistance","q","maxDistSquared","outer","dx","axisDist","dy","dist","k","arr","m","indices","pivot","swap","temp","a","b","c","d","e","A","B","C","D","i0","i1","getTasksSpatialIndex","rowObjs","numTasks","map","r","taskObjs","reduce","forEach","overallStartTime","overallEndTime","isIntervalOverlap","s1","e1","s2","e2","isClosedComparison","isOverlap","taskObj1","taskObj2","findRowIndRange","rowYs","yMin","yMax","minRowInd","array","target","approximateMode","L","R","binarySearchLeftMost","maxRowInd","getNormalizedStartEnd","task","start","supportsSelection","selectionMode","getRowDataLayout","resolvedVars","gridlines","selectionProps","selectionEnabled","selectedIds","Set","rowY","row","tasks","startTime","parseDate","endTime","renderIndex","rowIndex","rowLevel","taskHeight","borderRadius","toString","taskBorderRadius","fill","taskBgColor","stroke","taskBorderColor","strokeWidth","isSelectable","isSelected","has","selectionEffect","taskEffectBorderColor","padding","hoverEffect","shadow","taskEffectBoxShadow","focusEffect","t","resolvedRowHeight","rowHeight","rowPaddingTop","rowPaddingBottom","getEmptyRowHeight","overlapChains","rowLevelRecentTaskObjs","taskObj","overlapBehavior","previousTaskObj","previousAdjacentTaskObj","promote","nextAdjacentTaskObj","rowLevelHeights","rowLevelCumHeightsWithPadding","rowLevelHeight","acc","curr","overlapChainHeights","chain","chainHeight","chainTaskObj","distanceFromBottomToRowTop","minTaskY","Number","MAX_VALUE","offsetFromRowCenter","calcRowTaskVerticalLayout","labelText","labelObj","isInner","position","calcTaskLabelLayout","rowObj","some","horizontalLineHeightOffset","horizontal","lastRowLayoutObj","totalRowsHeight","idTaskObjMap","Map","idRowObjMap","spatialIndex","getSpatialIndex","rowPadding","getTaskDataById","get","getResolvedTaskObj","viewportStartTime","viewportEndTime","viewportWidth","scrollPosition","isRTL","startPos","getTimePosition","endPos","getResolvedViewportLayout","rowDataLayout","viewportHeight","viewportYMin","viewportYMax","viewportRowsLayout","resolvedViewportTaskObjs","filter","resolvedViewportRowObjs","viewportTaskLabelsLayout","labelLayout","textAlign","getResolvedTaskLabelLayout","horizontalGridlinesPos","allRowObjs","allIdTaskObjMap","allIdRowObjMap","taskLabelObjs","getTaskAriaLabel","dateFormatter","translations","accessibleLabel","isMilestone","desc","rowDesc","vis_labelAndValue","LABEL","gantt_labelRow","VALUE","dateDesc","gantt_labelDate","startDesc","gantt_labelStart","endDesc","gantt_labelEnd","labelDesc","gantt_labelLabel","join","getDefaultTaskAccessibleLabel","generateAriaLabel","GanttRowLabelContainer","isRowSelected","isFocused","isHorizontalGridlinesVisible","ariaActive","ariaLabel","getRowLabelAriaLabel","dataId","ariaId","role","rowAxisStyles","labelContainer","rowBackgroundStyles","selected","labelContainerFocused","withLabelSeparatorBottom","useDatatip","content","placement","offset","borderColor","anchor","targetFocusRef","uniqueIdRef","useRef","useId","coords","setCoords","useState","offsetValue","mainAxis","DATATIP_OFFSET","crossAxis","targetRef","anchorRef","current","datatipContent","Layer","Floating","flipOptions","shiftOptions","className","visDatatipStyle","datatipProps","onPointerEnter","event","eventPhase","Event","AT_TARGET","BUBBLING_PHASE","currentTarget","onPointerLeave","onPointerMove","clientX","clientY","onFocus","onShowFocusDatatip","useGanttRowLabelPointerGestures","hoverProps","elements","document","elementsFromPoint","dataRowIndex","dataset","idExtracter","hoveredRowLabelId","onRowLabelHoverChange","GanttRowAxis","resolvedWidth","resolvedMaxWidth","currentRowLabel","currentRowLabelInteraction","labelPaddingInlineStart","labelPaddingInlineEnd","availableWidth","contextMaxWidth","gestureProps","hoveredRowObj","focusedRowObj","rowAxisRegion","direction","useUser","config","hover","focus","none","activeRowObj","elementBounds","w","calculateOffset","useGanttRowLabelDatatip","h","mergeProps","withSeparatorTop","contentContainer","pan","rangeRatio","initialRange","prevRange","globalRange","onRangeChange","newRange","dRangeMin","dRangeMax","dRange","dRangeClamped","getNewRange","prevMin","prevMax","isRangeChanged","getDefaultInitialFocusTask","getAdjacentTaskNavigable","currentTask","currentTaskObj","indexOffset","adjTaskObj","adjRowObj","getVerticalTaskNavigable","rowIndexOffset","getNextTaskNavigable","getPrevTaskNavigable","getAdjacentRowLabelNavigable","currentRowObj","getPanIntoViewValues","region","viewportRegion","xPriority","yPriority","overShoot","deltaXLeftVisible","deltaXRightVisible","deltaXStartVisible","deltaXEndVisible","deltaX","deltaYTopVisible","deltaYBottomVisible","deltaY","useGanttKbPan","viewportLayout","dataBodyWidth","dataBodyHeight","panOptions","kbPanProps","getRangeX","getRangeY","globalRangeX","globalRangeY","onRangeXChange","onRangeYChange","isDisabled","prevRangeX","prevRangeY","onKbPanHorizontal","detail","newRangeX","onKbPanVertical","newRangeY","useKbPan","panBy","onKbPanTaskIntoView","unresolvedTaskObj","onKbPanRowIntoView","useGanttPanZoomGestures","captureTargetRef","majorAxisScale","minorAxisScale","zoomParameters","onViewportChange","onScrollPositionChange","onCursorChange","isPanDisabled","isZoomDisabled","viewportStart","getISOString","viewportEnd","getZoomOrderViewDurationThresholds","restZoomParameters","zoomOptions","zoomOrderViewDurationThresholds","dragPanProps","onDragPanStart","onDragPanEnd","initialRangeX","initialRangeY","isPanning","dragProps","useDrag","onDragStart","onDragMove","onDragEnd","originalEvent","preventDefault","useDragPan","cursor","wheelPanProps","wheelProps","useWheel","onWheel","ctrlKey","useWheelPan","pinchZoomProps","majorAxisZoomOrder","majorAxisZoomOrderIndex","minorAxisZoomOrder","minorAxisZoomOrderIndex","minZoomViewportDuration","maxZoomViewportDuration","pinchProps","usePinch","onPinchZoomChange","origin","delta","time","getPositionTime","zoomTime","getGestureZoomFactor","usePinchZoom","wheelZoomProps","useWheelZoom","kbZoomProps","onKbZoomIn","viewportCenter","zoomFactor","onKbZoomOut","useKbZoom","useGanttTaskDatatip","datatip","hoveredTaskObj","focusedTaskObj","currentTaskInteraction","dataBodyRegion","useTranslationBundle","activeTaskObj","datatipRenderer","options","tableData","key","VisTabularDatatip","getDefaultDatatipRenderer","rows","GanttTimeAxisDataBody","isViewportDefined","zooming","onSelectionChange","hoveredTaskId","onTaskHoverChange","onCurrentTaskChange","getTimeAxesLayout","rowAxisSeparator","majorAxis","minorAxis","dataBody","timeAxesLayout","majorAxisLayout","minorAxisLayout","zoomOrder","zoomOrderIndex","majorAxisHeight","minorAxisHeight","effectsLayout","effectProps","selectedTaskObjs","selectedTaskObj","hoveredId","currentProps","isTaskFocused","currentTaskId","getEffectTaskObjs","defaultDateFormatter","getDefaultDateFormatter","majorAxisComp","minorAxisComp","dataBodyComp","ariaActiveTask","layout","components","dataBodyPos","bottom","setCursor","prevCursor","panZoomGestureProps","args","dragMode","taskGestureProps","selectionContent","viewportYOffset","dbx","dby","dbw","dbh","selectionSupported","offsetX","offsetY","timePoint","targetIndices","found","flatIndex","taskIndex","queryTasksSpatialIndex","hoverPointerGestureProps","focusPointerGestureProps","onPointerUp","onKeyUp","selectionPointerGestureProps","useSelection","selection","onChange","getDataById","useGanttTaskPointerGestures","timeAxisDataBodyStyles","pannable","withRowAxisSeparatorRight","withRowAxisSeparatorLeft","GanttHorizontalGridlinesLayer","positions","cmd","p","horizontalGridlinesStyles","GanttDesktopTaskAccContent","ariaActiveId","ariaActiveTaskObj","idIndex","useMemo","getRandomId","abs","GanttMobileTaskAccContent","layoutObjs","taskMobileAccStyles","GanttTaskAccLayer","supportsMobileScreenReader","GanttRowBackgroundsLayer","selectedRowObjs","selectedRowsCmd","drawTaskEffectRing","ctx","effectLayout","ringX","ringY","ringWidth","ringHeight","effectRingCmd","rectangleWithBorderRadius","effectRingPath","Path2D","strokeStyle","lineWidth","drawTask","taskLayoutObj","state","drawShadow","roundRectCmd","roundRectPath","shadowColor","shadowOffsetX","shadowOffsetY","shadowBlur","drawTaskEffectShadow","fillStyle","resetShadow","GanttTaskFocusEffectsLayer","TimeComponentCanvas2D","draw","GanttTaskHoverEffectsLayer","GanttTaskSelectionEffectsLayer","GanttTaskEffectsLayer","TimeComponentLayersStack","GanttTaskLabel","taskLabelLayerStyles","innerLabel","weight","GanttTaskLabelsLayer","GanttTasksLayer","GanttDataBody","minorGridTicksPos","majorGridTicksPos","vertical","GanttVerticalGridlinesLayer","GanttView","visRef","overlayControlsContainerRef","panZoomLayout","getHorizontalScrollbarLayout","onHorizontalScrollChange","getVerticalScrollbarLayout","onVerticalScrollChange","TimeComponentPanZoomLayout","overlayControls","TimeComponentZoomControls","overlayControlsPosition","verticalControl","TimeComponentVerticalScrollbarContainer","getLayout","TimeComponentVerticalScrollbar","horizontalControl","TimeComponentHorizontalScrollbarContainer","TimeComponentHorizontalScrollbar","vis","TimeComponentHorizontalTimeAxis","getBatchTextDimensions","getTextDimensions","texts","font","text","getUnresolvedTimeAxisHeight","axisProps","bridgeValues","horizontalTimeAxisHeight","getResolvedTimeAxisProps","defaultHeight","getResolvedTimeAxisHeight","scale","getPreviousTime","Date","parse","getPreviousDate","toISOString","getNextTime","getNextDate","getViewportTicks","times","getTimeAxisIntervals","samplingStrategy","type","params","intervals","viewportTimes","numIntervals","numSections","numIntervalsPerSection","sectionInterval","sectionStartTime","sectionEndTime","prevTime","currTime","sampleIntervals","intervalStartTimes","keys","avgTimePerInterval","sum","getTimeLabel","formatter","getViewportLabelsTicks","ticks","labels","slice","getTimeAxisLayout","labelPaddingStart","labelPaddingEnd","labelPosition","gridTicks","intervalPadding","vs","ve","labelTicks","gridTicksPos","ticksPos","intervalWidths","isIntervalStartTruncated","labelPositions","isLabelTruncated","getTimeAxesZoomParameters","labelMinWidth","minorAxisFont","zoomOrderMinLengthFactor","maxNumIntervals","intervalPaddingStart","intervalPaddingEnd","minIntervalWidth","axisFont","zoomLevelIntervals","prevTimes","intervalDurations","intervalLabelDimensions","minLengthFactor","duration","getZoomOrderCharacteristics","l","getResolvedTimeAxesLayout","majorAxisFont","axisPosition","resolvedMinorAxisProps","resolvedMajorAxisProps","resolvedViewportStartTime","resolvedViewportEndTime","viewportDuration","getResolvedViewport","majorAxisLabelsTicks","minorAxisLabelsTicks","majorTicks","majorLabels","minorTicks","minorLabels","majorTicksSet","minorTicksSet","showMajorTicks","minorGridTicks","getTimeAxesViewportLayout","timeComponentUnresolvedVars","tokenVar","cssProp","horizontalTimeAxisLabelPaddingInlineStart","horizontalTimeAxisLabelPaddingInlineEnd","xUnits","typographyVars","body","md","fontSize","sm","fontWeight","semibold","regular","pxToNumber","substring","ganttUnresolvedVars","rowLabelPaddingInlineStart","baseVars","boxShadow","parseBoxShadow","rest","split","reverse","getResolvedLength","endsWith","cssVars","concat","useGanttLayout","rowAxisProps","gridlinesHorizontal","gridlinesVertical","cssContent","useCssVars","textMeasureContent","useTextDimensions","layoutContent","_Fragment","isValidTimeConfig","isValidConfig","hasValidTimeConfig","getParsedTimeAxisParams","Object","isReady","rowAxisRendered","rowAxisWidth","rowAxisMaxWidth","rowAxisLabelRender","labelRenderer","unresolvedTimeAxesLayout","getUnresolvedTimeAxesLayout","verticalControlTopGap","verticalControlBottomGap","withRowAxisLayout","horiScrollbarHeight","timeCompBridgeValues","horizontalScrollbarHeight","generalLayout","getWithRowAxisLayout","timeAxisResolvedVars","defaultTimeAxisHeight","timeAxisLabelPaddingInlineStart","timeAxisLabelPaddingInlineEnd","timeAxisLabelMinWidth","getResolvedTimeAxisVars","rowResolvedVars","getResolvedRowVars","taskResolvedVars","getResolvedTaskVars","rowAxisResolvedVars","rowLabelPaddingInlineEnd","getResolvedRowAxisVars","rowAxisLayout","globalMin","globalMax","localRange","thumbWidth","thumbStartOffset","logicalThumbLeft","thumbLeft","thumbRight","draggableRegion","xMin","xMax","newThumbLeft","newMin","newMax","getResolvedHorizontalScrollbarLayout","thumbHeight","thumbTop","newThumbTop","newViewStartTime","newViewEndTime","newScrollPosition","useTimeComponentKeyboard","onKeyDown","CustomEvent","DEFAULT_ZOOM_IN_FACTOR","dispatchEvent","cancelEvent","DEFAULT_ZOOM_OUT_FACTOR","shiftKey","useGanttTaskNavigation","nextTaskId","prevTaskId","aboveTaskId","getAboveTaskNavigable","belowTaskId","getBelowTaskNavigable","useGanttRowLabelNavigation","onCurrentRowLabelChange","aboveRowId","getAboveRowLabelNavigable","belowRowId","getBelowRowLabelNavigable","useGanttKeyboard","rowAxisRef","navigationModes","currentNavMode","selectionKeyup","currentItem","selectionKeyboardProps","keyboardProps","taskNavProps","onCurrentItemChange","rowLabelNavProps","rowLabels","focusDatatipProps","stopImmediatePropagation","applyFocus","item","removeFocus","navType","enterRowLabelsNavigation","getRowLabelNavigableFromTask","enterTasksNavigation","firstTaskObj","defaultTask","getTaskNavigableFromRowLabel","altKey","itemToFocus","props","ariaProps","setAriaActive","setCurrentTaskInteraction","setHoveredTaskId","setCurrentRowLabelInteraction","setHoveredRowLabelId","setCurrentTask","setCurrentRowLabel","eventProps","rootRef","dispatchControlsShow","dispatchControlsHide","onBlur","relatedTarget","contains","onPointerDown","pointerType","onPointerOver","onPointerOut","useTimeComponentEvents","ganttViewWithRowAxis"],"mappings":"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"}