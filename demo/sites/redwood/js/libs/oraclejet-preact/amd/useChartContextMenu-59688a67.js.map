{"version":3,"file":"useChartContextMenu-59688a67.js","sources":["../../src/hooks/PRIVATE_useChartContextMenu/useChartContextMenu.ts","../../src/hooks/PRIVATE_useChartContextMenu/contextMenuUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { BarSeriesData } from '#UNSAFE_BarChart/barChart.types';\nimport type { LineAreaSeriesData } from '#UNSAFE_LineAreaChart/lineAreaChart.types';\nimport type { RefObject } from 'preact';\nimport type {\n  ChartContextMenuContext,\n  ChartContextMenuConfig,\n  Info\n} from '#utils/UNSAFE_visTypes/chart';\nimport { type gestureTypes, useContextMenu } from '#hooks/PRIVATE_useVisContextMenu';\nimport { getChartContextMenuContext } from './contextMenuUtils';\nimport { calculateOffset } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { GroupLevelItem } from '#PRIVATE_Axis/groupAxis/hierarchicalUtils';\n\ntype Props<K, D> = {\n  series: (BarSeriesData<K, D> | LineAreaSeriesData<K, D>)[];\n  levelsArray: GroupLevelItem[][];\n  isRtl: boolean;\n  width: number;\n  height: number;\n  getDataItemPosition: (seriesIndex: number, groupIndex: number) => Dimension | undefined;\n  getDataItem: (seriesIndex: number, groupIndex: number, groupPath: number[]) => D | undefined;\n  focusedItemInfo: Info;\n  focusedGroupInfo: Info;\n  rootRef: RefObject<HTMLDivElement>;\n  xAxisTitle?: string;\n  yAxisTitle?: string;\n  contextMenuConfig?: ChartContextMenuConfig<K, D>;\n  onContextMenuDismissed?: (gesture: gestureTypes) => void;\n};\n\nexport const useChartContextMenu = <K extends string | number, D>({\n  isRtl,\n  width,\n  getDataItemPosition,\n  getDataItem,\n  focusedItemInfo,\n  focusedGroupInfo,\n  series,\n  levelsArray,\n  rootRef,\n  xAxisTitle,\n  yAxisTitle,\n  contextMenuConfig,\n  onContextMenuDismissed\n}: Props<K, D>) => {\n  const { contextMenuProps, contextMenuContent } = useContextMenu<ChartContextMenuContext<K, D>>({\n    onContextMenuHandler: ({ gesture, target }) => {\n      const { context } = getChartContextMenuContext<K, D>(\n        focusedItemInfo,\n        focusedGroupInfo,\n        gesture,\n        target as HTMLElement,\n        series,\n        levelsArray,\n        rootRef,\n        xAxisTitle,\n        yAxisTitle,\n        getDataItem\n      );\n      if (gesture === 'keyboard' && context.type === 'item') {\n        const elementBounds = focusedItemInfo?.isCurrent\n          ? getDataItemPosition(focusedItemInfo.seriesIndex!, focusedItemInfo.groupIndex!)\n          : undefined;\n        const offsetValue = calculateOffset(isRtl, width, elementBounds);\n        return {\n          type: 'offset',\n          context,\n          offsetValue,\n          isRtl,\n          width\n        };\n      }\n      return { type: 'pointer', context };\n    },\n    contextMenuOptions: {\n      isDisabled: !contextMenuConfig //If there is not a context menu renderer we disable the hook\n    },\n    rootRef,\n    contextMenuConfig,\n    onContextMenuDismissed\n  });\n\n  return { contextMenuContent, contextMenuProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { GroupLevelItem } from '#PRIVATE_Axis/groupAxis/hierarchicalUtils';\nimport type { ChartSeriesData, Info, ChartContextMenuContext } from '#utils/UNSAFE_visTypes/chart';\nimport { getInfo } from '#utils/UNSAFE_visUtils';\nimport type { RefObject } from 'preact';\n\nexport function getChartContextMenuContext<K, D>(\n  focusedItemInfo: Info,\n  focusedGroupInfo: Info,\n  gesture: 'mouse' | 'touch' | 'keyboard',\n  target: HTMLElement,\n  series: ChartSeriesData<K, D>[],\n  levelsArray: GroupLevelItem[][],\n  rootRef: RefObject<HTMLElement>,\n  xAxisTitle?: string,\n  yAxisTitle?: string,\n  getDataItem?: (seriesIndex: number, groupIndex: number, groupPath: number[]) => D | undefined\n) {\n  let seriesIndex;\n  let groupIndex;\n  let levelIndex;\n  if (gesture === 'keyboard') {\n    //We find the element where the position of the menu is going to be based of\n    groupIndex = focusedItemInfo.groupIndex;\n    seriesIndex = focusedItemInfo.seriesIndex;\n    levelIndex = focusedGroupInfo.levelIndex;\n  } else {\n    //We search for the key using the target of the event\n    const info = getInfo(rootRef, target);\n    seriesIndex = info ? info.seriesIndex : undefined;\n    groupIndex = info ? info.groupIndex : undefined;\n    levelIndex = info ? info.levelIndex : undefined;\n  }\n  let context;\n  if (seriesIndex !== undefined && groupIndex !== undefined && getDataItem) {\n    const groupPath = levelsArray[levelsArray.length - 1]?.[groupIndex]?.path;\n    const data = getDataItem(seriesIndex, groupIndex, groupPath);\n    context = {\n      data,\n      groupIndex,\n      seriesIndex,\n      type: 'item'\n    };\n  } else if (seriesIndex !== undefined) {\n    context = {\n      data: series[seriesIndex],\n      type: 'series'\n    };\n  } else if (groupIndex !== undefined && levelIndex != undefined) {\n    context = {\n      data: levelsArray[levelIndex]?.[groupIndex],\n      type: 'xAxisTickLabel'\n    };\n  } else {\n    const target = event?.target as HTMLElement;\n    const text = target?.textContent;\n    if ((text && gesture !== 'keyboard' && text === xAxisTitle) || text === yAxisTitle) {\n      context = {\n        type: 'axisTitle',\n        axis: text === xAxisTitle ? 'x' : 'y'\n      };\n    } else {\n      context = {\n        type: 'background'\n      };\n    }\n  }\n  return {\n    context: context as ChartContextMenuContext<K, D>\n  };\n}\n"],"names":["isRtl","width","getDataItemPosition","getDataItem","focusedItemInfo","focusedGroupInfo","series","levelsArray","rootRef","xAxisTitle","yAxisTitle","contextMenuConfig","onContextMenuDismissed","contextMenuProps","contextMenuContent","useContextMenu","onContextMenuHandler","gesture","target","context","seriesIndex","groupIndex","levelIndex","info","getInfo","undefined","groupPath","length","path","data","type","event","text","textContent","axis","getChartContextMenuContext","elementBounds","isCurrent","offsetValue","calculateOffset","contextMenuOptions","isDisabled"],"mappings":"u4BAsCmC,EACjCA,QACAC,QACAC,sBACAC,cACAC,kBACAC,mBACAC,SACAC,cACAC,UACAC,aACAC,aACAC,oBACAC,6BAEA,MAAMC,iBAAEA,EAAgBC,mBAAEA,GAAuBC,iBAA8C,CAC7FC,qBAAsB,EAAGC,UAASC,aAChC,MAAMC,QAAEA,GC1CR,SACJf,EACAC,EACAY,EACAC,EACAZ,EACAC,EACAC,EACAC,EACAC,EACAP,GAEA,IAAIiB,EACAC,EACAC,EAaAH,EAZJ,GAAgB,aAAZF,EAEFI,EAAajB,EAAgBiB,WAC7BD,EAAchB,EAAgBgB,YAC9BE,EAAajB,EAAiBiB,eACzB,CAEL,MAAMC,EAAOC,EAAAA,QAAQhB,EAASU,GAC9BE,EAAcG,EAAOA,EAAKH,iBAAcK,EACxCJ,EAAaE,EAAOA,EAAKF,gBAAaI,EACtCH,EAAaC,EAAOA,EAAKD,gBAAaG,CACvC,CAED,QAAoBA,IAAhBL,QAA4CK,IAAfJ,GAA4BlB,EAAa,CACxE,MAAMuB,EAAYnB,EAAYA,EAAYoB,OAAS,KAAKN,IAAaO,KAErET,EAAU,CACRU,KAFW1B,EAAYiB,EAAaC,EAAYK,GAGhDL,aACAD,cACAU,KAAM,OAET,MAAM,QAAoBL,IAAhBL,EACTD,EAAU,CACRU,KAAMvB,EAAOc,GACbU,KAAM,eAEH,QAAmBL,IAAfJ,GAA0CI,MAAdH,EACrCH,EAAU,CACRU,KAAMtB,EAAYe,KAAcD,GAChCS,KAAM,sBAEH,CACL,MAAMZ,EAASa,OAAOb,OAChBc,EAAOd,GAAQe,YAEnBd,EADGa,GAAoB,aAAZf,GAA0Be,IAASvB,GAAeuB,IAAStB,EAC5D,CACRoB,KAAM,YACNI,KAAMF,IAASvB,EAAa,IAAM,KAG1B,CACRqB,KAAM,aAGX,CACD,MAAO,CACLX,QAASA,EAEb,CDtB0BgB,CAClB/B,EACAC,EACAY,EACAC,EACAZ,EACAC,EACAC,EACAC,EACAC,EACAP,GAEF,GAAgB,aAAZc,GAA2C,SAAjBE,EAAQW,KAAiB,CACrD,MAAMM,EAAgBhC,GAAiBiC,UACnCnC,EAAoBE,EAAgBgB,YAAchB,EAAgBiB,iBAClEI,EAEJ,MAAO,CACLK,KAAM,SACNX,UACAmB,YAJkBC,EAAeA,gBAACvC,EAAOC,EAAOmC,GAKhDpC,QACAC,QAEH,CACD,MAAO,CAAE6B,KAAM,UAAWX,UAAS,EAErCqB,mBAAoB,CAClBC,YAAa9B,GAEfH,UACAG,oBACAC,2BAGF,MAAO,CAAEE,qBAAoBD,mBAAkB"}