{"version":3,"file":"useNavigation-a6a2218f.js","sources":["../../src/hooks/PRIVATE_useListCommon/useCurrentItemOverride.ts","../../src/PRIVATE_List/ListUtils.ts","../../src/hooks/PRIVATE_useListCommon/useNavigation.ts"],"sourcesContent":["import { useRef, useMemo, useState, useEffect } from 'preact/hooks';\nimport { CurrentItemProps, CurrentKeyDetail, Item } from '#UNSAFE_Collection';\nimport { useReorderableContext } from '#hooks/PRIVATE_useReorderable/useReorderableContext';\n\n/**\n * This hook converts the new API (i.e. currentItemOverride and onPersistCurrentItem) back to\n * the old API (i.e. currentKey and onCurrentKeyChange), keeps the internal current item, and\n * also triggers an update when a new currentItemOverride is passed by the app\n *\n * @param currentItemOverride\n * @param onPersistCurrentItem\n */\nexport const useCurrentItemOverride = <K extends string | number>(\n  currentItemOverride: CurrentItemProps<K>['currentItemOverride'],\n  onPersistCurrentItem: CurrentItemProps<K>['onPersistCurrentItem']\n) => {\n  // the internal state of current item\n  const [currentItem, setCurrentItem] = useState<Item<K>>();\n  // track the currentItemOverride props\n  const currentItemOverrideRef = useRef<Item<K>>();\n  // whether the current item is overridden by the app\n  const isCurrentItemOverridden = useRef(false);\n\n  // if reorder is enabled, need to update the context here when current item is changed\n  const reorderContext = useReorderableContext();\n\n  // intercept onPersistCurrentItem calls to ensure internal state is updated appropriately\n  const handleCurrentItemChanged = useMemo(() => {\n    return (detail: CurrentKeyDetail<K>) => {\n      const rowKey = detail.value;\n      setCurrentItem({ rowKey });\n      onPersistCurrentItem?.(detail);\n      if (reorderContext?.currentItemKey != null) {\n        reorderContext.currentItemKey.current = rowKey;\n      }\n    };\n  }, [onPersistCurrentItem, reorderContext?.currentItemKey]);\n\n  // ensure any new currentItemOverride settings are applied only on that render\n  // (same as how Table handles the changes)\n  if (currentItemOverrideRef.current !== currentItemOverride) {\n    currentItemOverrideRef.current = currentItemOverride;\n    if (currentItem?.rowKey !== currentItemOverride?.rowKey) {\n      isCurrentItemOverridden.current = true;\n      handleCurrentItemChanged({ value: currentItemOverride?.rowKey as K });\n    }\n  }\n\n  useEffect(() => {\n    isCurrentItemOverridden.current = false;\n  });\n\n  return {\n    currentKey: currentItem?.rowKey,\n    onCurrentKeyChange: handleCurrentItemChanged,\n    isCurrentItemOverridden: isCurrentItemOverridden.current\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { FlattenedDataState } from '../UNSAFE_Collection';\nimport { Keys } from '../utils/UNSAFE_keys';\nimport { ListProps } from '../UNSAFE_ListView/List.types';\n\n/**\n * Helper function to only include keys of leaf items.\n */\nexport const excludeGroup = <K, D>(data: FlattenedDataState<K, D>, keys: Keys<K>) => {\n  if (!keys.all) {\n    const groups = data.data\n      .filter((dataMetadata) => {\n        return !dataMetadata.metadata.isLeaf;\n      })\n      .map((dataMetadata) => {\n        return dataMetadata.metadata.key;\n      });\n    const leafOnly = Array.from(keys.keys.values()).filter((key: K) => {\n      return !groups.includes(key);\n    });\n    return { ...keys, keys: new Set(leafOnly) };\n  }\n  return keys;\n};\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nexport const scrollToVisible = (elem: Element, scroller: Element, offset: number) => {\n  if (elem && scroller) {\n    if ((elem as any).scrollIntoViewIfNeeded) {\n      // for Safari, we'll need the non-standard scrollIntoViewIfNeeded\n      (elem as any).scrollIntoViewIfNeeded();\n    } else {\n      elem.scrollIntoView({ block: 'nearest' });\n    }\n    if (offset > 0) {\n      const scrollerBounds = scroller.getBoundingClientRect();\n      const elemBounds = elem.getBoundingClientRect();\n      const diff = scrollerBounds.top + offset - elemBounds.top;\n      if (diff > 0) {\n        scroller.scrollTop = scroller.scrollTop - diff;\n      }\n    }\n  }\n};\n\n/**\n * Helper method to determine whether the selection mode is multiple or multipleToggle\n */\nexport const isMultipleSelection = (selectionMode: ListProps<any, any>['selectionMode']) => {\n  return selectionMode === 'multiple' || selectionMode === 'multipleToggle';\n};\n","import type { RefObject } from 'preact';\nimport { useEffect, useCallback, useRef } from 'preact/hooks';\nimport { ListProps as CommonProps } from '#UNSAFE_ListView/List.types';\nimport { scrollToVisible } from '#PRIVATE_List/ListUtils';\nimport { useCurrentKey } from '#hooks/PRIVATE_useCurrentKey';\nimport { useCurrentItemOverride } from './useCurrentItemOverride';\nimport { useCollectionFocusRing } from '#hooks/PRIVATE_useCollectionFocusRing';\nimport { useTabbableModeSet } from '#hooks/PRIVATE_useTabbableModeSet';\nimport {\n  getFirstVisibleKey,\n  keyExtractor,\n  findElementByKey,\n  ITEM_SELECTOR\n} from '#utils/PRIVATE_collectionUtils';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { isKeyDefined } from '#utils/UNSAFE_keys';\n\ntype ArrowKeyHandler<K> = (key?: K) => () => K | null;\ntype ArrowKeyAndHandlers<K> = {\n  ArrowUp: ArrowKeyHandler<K>;\n  ArrowDown: ArrowKeyHandler<K>;\n  ArrowLeft?: ArrowKeyHandler<K>;\n  ArrowRight?: ArrowKeyHandler<K>;\n};\n\n/**\n * A hook to set up the currentKey, focus ring and F2 mode.\n *\n * The current key setup includes convert the currentItemOverride to currentKey syntax, set initial currentKey,\n * scroll current item into view, update aria-activedescendant when currentKey changed.\n *\n * This hook can be shared across ListView, CardView, TreeView\n */\nexport const useNavigation = <K extends string | number, D>(\n  data: any | null,\n  rootRef: RefObject<HTMLDivElement>,\n  idExtractor: (elem: Element) => string,\n  arrowKeyAndHandlers: ArrowKeyAndHandlers<K>,\n  currentItemOverride: CommonProps<K, D>['currentItemOverride'],\n  onPersistCurrentItem: CommonProps<K, D>['onPersistCurrentItem'],\n  viewportConfig: CommonProps<K, D>['viewportConfig'],\n  scrollToVisibleOffset: CommonProps<K, D>['scrollToVisibleOffset'],\n  allowShiftKey: boolean,\n  allowTabbableMode?: boolean,\n  allowActiveDescendant?: boolean,\n  isEmbedded?: boolean,\n  allowEnterKey?: boolean\n) => {\n  // tracking pending current key in pointer down event\n  const pendingCurrentKey = useRef<K>();\n  // ensure current item scroll into view when treeview regains focus\n  // unless pendingCurrentKey gets updated to something different than currentKey\n  const focusAndScrollIntoView = useRef(true);\n\n  const { currentKey, onCurrentKeyChange, isCurrentItemOverridden } = useCurrentItemOverride(\n    currentItemOverride,\n    onPersistCurrentItem\n  );\n\n  const { currentKeyProps } = useCurrentKey(\n    (element) => keyExtractor(element, ITEM_SELECTOR),\n    allowShiftKey,\n    arrowKeyAndHandlers.ArrowUp(currentKey),\n    arrowKeyAndHandlers.ArrowDown(currentKey),\n    arrowKeyAndHandlers.ArrowLeft?.(currentKey),\n    arrowKeyAndHandlers.ArrowRight?.(currentKey),\n    currentKey,\n    onCurrentKeyChange\n  );\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(\n    rootRef,\n    Object.keys(arrowKeyAndHandlers)\n  );\n\n  const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(\n    rootRef,\n    (element) => {\n      // we don't want the component to go into Tabbable mode when user clicks on expander\n      return isExpander(element) ? null : (keyExtractor(element, ITEM_SELECTOR) as K);\n    },\n    currentKey,\n    onCurrentKeyChange,\n    undefined,\n    undefined,\n    allowEnterKey\n  );\n\n  // need to track pointer down element to set currentKey when initial focus happens\n  const handlePointerDown = useCallback(\n    (event: PointerEvent) => {\n      const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n      if (isKeyDefined(key)) {\n        pendingCurrentKey.current = key as K;\n        if (key !== currentKey) {\n          focusAndScrollIntoView.current = false;\n        }\n      }\n    },\n    [currentKey]\n  );\n\n  // handle undefined currentKey at the initial focus or invalid currentKey that doesn't exist\n  const handleInvalidCurrentKey = useCallback(() => {\n    if (rootRef.current && (!allowTabbableMode || isCurrentTabbableKey(undefined))) {\n      const firstKey =\n        pendingCurrentKey.current || (getFirstVisibleKey(rootRef.current, ITEM_SELECTOR) as K);\n      if (isKeyDefined(firstKey)) {\n        onCurrentKeyChange({ value: firstKey });\n      }\n    }\n  }, [rootRef, currentKey, onCurrentKeyChange, allowTabbableMode, isCurrentTabbableKey]);\n\n  // handle currenKey and scroll into view during focus\n  const handleFocus = useCallback(\n    (event: FocusEvent) => {\n      // avoid the focus get trapped in the expander\n      if (isExpander(event.target as HTMLElement)) {\n        rootRef.current?.focus({ preventScroll: true });\n        return;\n      }\n      if (rootRef.current) {\n        if (!isKeyDefined(currentKey)) {\n          handleInvalidCurrentKey();\n        } else {\n          const elem = findElementByKey(rootRef.current, currentKey!, ITEM_SELECTOR);\n          if (elem) {\n            // if currentKey is defined, make sure scroll the current item into view only when the component regains focus,\n            // unless pendingCurrentKey gets updated to something different than currentKey\n            if (focusAndScrollIntoView.current) {\n              scrollIntoView(elem, rootRef, viewportConfig, scrollToVisibleOffset);\n            }\n            focusAndScrollIntoView.current = true;\n          } else {\n            // if elem is not found, meaning the currentKey is not valid,\n            // we should pick the first item as current item\n            handleInvalidCurrentKey();\n          }\n        }\n      }\n    },\n    [rootRef, currentKey, handleInvalidCurrentKey, viewportConfig, scrollToVisibleOffset]\n  );\n\n  // update aria-activedescendant for screen reader\n  useEffect(() => {\n    if (allowActiveDescendant && rootRef.current && isKeyDefined(currentKey)) {\n      const elem = findElementByKey(rootRef.current, currentKey!, ITEM_SELECTOR);\n      if (elem) {\n        const id = idExtractor(elem);\n        const activeDescendant = rootRef.current.getAttribute('aria-activedescendant');\n        if (id !== '' && activeDescendant !== id) {\n          rootRef.current.setAttribute('aria-activedescendant', id);\n          // scroll the current item into view only when:\n          // 1. the current item is updated internally and listview has focus\n          // 2. the current item is updated by the app when the collection gesture is 'embedded'\n          const hasFocus = rootRef.current?.contains(document.activeElement as HTMLElement);\n          if ((!isCurrentItemOverridden && hasFocus) || isEmbedded) {\n            scrollIntoView(elem, rootRef, viewportConfig, scrollToVisibleOffset);\n          }\n        }\n      }\n    }\n    // listen to data because the current item would re-render when data is updated, i.e. the id\n    // of current item would be updated, so the currentKey itself couldn't guarantee the root has\n    // the latest aria-activedescendant\n  }, [\n    data,\n    rootRef,\n    currentKey,\n    idExtractor,\n    viewportConfig,\n    scrollToVisibleOffset,\n    isCurrentItemOverridden,\n    allowActiveDescendant,\n    isEmbedded\n  ]);\n\n  return {\n    navigationProps: mergeProps(\n      currentKeyProps,\n      focusRingProps,\n      allowTabbableMode ? tabbableModeProps : {},\n      {\n        onFocus: handleFocus,\n        onPointerDown: handlePointerDown\n      }\n    ),\n    currentKey,\n    onCurrentKeyChange,\n    isCurrentItemOverridden,\n    showFocusRing,\n    isCurrentTabbableKey\n  };\n};\n\n/**\n * A private helper function to handle scroll into view\n */\nconst scrollIntoView = <K, D>(\n  elem: Element,\n  rootRef: RefObject<HTMLDivElement>,\n  viewportConfig: CommonProps<K, D>['viewportConfig'],\n  scrollToVisibleOffset: CommonProps<K, D>['scrollToVisibleOffset']\n) => {\n  if (rootRef.current) {\n    const scroller = viewportConfig?.scroller();\n    const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;\n    scrollToVisible(elem, scroller || rootRef.current, offset);\n  }\n};\n\n// TODO: should update the class 'oj-listview-expander' to something more general\n// when we add treeview or expander components\nconst isExpander = (elem: HTMLElement) => {\n  if (elem.parentElement && elem.parentElement.classList.contains('oj-listview-expander')) {\n    return true;\n  }\n  return false;\n};\n"],"names":["useCurrentItemOverride","currentItemOverride","onPersistCurrentItem","currentItem","setCurrentItem","useState","currentItemOverrideRef","useRef","isCurrentItemOverridden","reorderContext","useReorderableContext","handleCurrentItemChanged","useMemo","detail","rowKey","value","currentItemKey","current","useEffect","currentKey","onCurrentKeyChange","scrollToVisible","elem","scroller","offset","scrollIntoViewIfNeeded","scrollIntoView","block","scrollerBounds","getBoundingClientRect","elemBounds","diff","top","scrollTop","rootRef","viewportConfig","scrollToVisibleOffset","isExpander","parentElement","classList","contains","data","keys","all","groups","filter","dataMetadata","metadata","isLeaf","map","key","leafOnly","Array","from","values","includes","Set","selectionMode","idExtractor","arrowKeyAndHandlers","allowShiftKey","allowTabbableMode","allowActiveDescendant","isEmbedded","allowEnterKey","pendingCurrentKey","focusAndScrollIntoView","currentKeyProps","useCurrentKey","element","keyExtractor","ITEM_SELECTOR","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","showFocusRing","focusRingProps","useCollectionFocusRing","Object","isCurrentTabbableKey","tabbableModeProps","useTabbableModeSet","undefined","handlePointerDown","useCallback","event","target","isKeyDefined","handleInvalidCurrentKey","firstKey","getFirstVisibleKey","handleFocus","focus","preventScroll","findElementByKey","id","activeDescendant","getAttribute","setAttribute","hasFocus","document","activeElement","navigationProps","mergeProps","onFocus","onPointerDown"],"mappings":"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"}