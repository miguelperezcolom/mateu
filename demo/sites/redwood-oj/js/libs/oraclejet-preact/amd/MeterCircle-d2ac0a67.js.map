{"version":3,"file":"MeterCircle-d2ac0a67.js","sources":["../../src/UNSAFE_MeterCircle/circleMeterUtils.ts","../../src/UNSAFE_MeterCircle/layoutUtils.ts","../../src/UNSAFE_MeterCircle/CircularReferenceLine.tsx","../../src/UNSAFE_MeterCircle/refLineUtils.ts","../../src/UNSAFE_MeterCircle/FitMeterCircle.tsx","../../src/UNSAFE_MeterCircle/SizedMeterCircle.tsx","../../src/UNSAFE_MeterCircle/MeterCircle.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport {\n  getPositiveAngle,\n  convertToPolar,\n  getCenterCoord,\n  Sector\n} from '#utils/PRIVATE_meterUtils';\n\nimport { CenterContext } from './meterCircle.types';\n\ntype Dimensions = {\n  width: number;\n  height: number;\n  innerRadius: number;\n  outerRadius: number;\n};\n\n/**\n * Returns the true dimensions of the meter circle after initial render. All dimensions are 0 for initial render.\n * @param element The HTML element that wraps the track and indicator div.\n * @param section The section in which the meter circle lies.\n * @returns The dimensions of the meter circle.\n */\nexport function getDimensions(element: HTMLElement | null, section: Sector): Dimensions {\n  if (!element) {\n    return {\n      width: 0,\n      height: 0,\n      innerRadius: 0,\n      outerRadius: 0\n    };\n  }\n\n  const circleTrack = element.children[0] as HTMLElement;\n  const rect = circleTrack.getBoundingClientRect();\n\n  return {\n    width: Math.round(rect.width),\n    height: Math.round(rect.height),\n    ...getInnerAndOuterRadius(circleTrack, rect, section)\n  };\n}\n\n/**\n * Returns the inner and outer radius of the meter circle.\n * @param element The HTML element that wraps the track and indicator div.\n * @param rect The bounding rect of the wrapper HTML element.\n * @param section The section in which the meter circle lies.\n * @returns The inner and outer radius of the meter circle.\n */\nfunction getInnerAndOuterRadius(\n  element: HTMLElement,\n  rect: { width: number; height: number },\n  section: string\n): {\n  innerRadius: number;\n  outerRadius: number;\n} {\n  const width = element.clientWidth;\n  const height = element.clientHeight;\n\n  if (section === 'bottom' || section === 'top') {\n    return { outerRadius: rect.width / 2, innerRadius: height };\n  } else if (section === 'left' || section === 'right') {\n    return { outerRadius: rect.height / 2, innerRadius: width };\n  }\n  return { innerRadius: width / 2, outerRadius: rect.width / 2 };\n}\n\n/**\n * Returns the value corresponding to clicked point in the meter circle. Returns undefined if the clicked point is\n * outside the track of the meter circle.\n * @param pageX The pageX of the click event\n * @param pageY The pageY of the click event\n * @param max The max value of the meter circle.\n * @param min The min value of the meter circle.\n * @param step The step of the metercircle.\n * @param dimensionsRef The ref that stores dimensions reference of meter circle.\n * @param startAngle The startAngle of the meter circle.\n * @param angleExtent The angleExtent of the meter circle\n * @returns {number} The value corresponding to clicked point in the meter circle.\n */\nexport function getValue(\n  event: PointerEvent,\n  min: number,\n  max: number,\n  step: number,\n  dimensionsRef: RefObject<Dimensions>,\n  startAngle: number,\n  angleExtent: number,\n  section: Sector,\n  isRtl: boolean\n): number | undefined {\n  const dims = dimensionsRef.current;\n  if (!dims) {\n    return undefined;\n  }\n\n  const center = getCenterCoord(section);\n  const { angle } = convertToPolar(\n    dims.width * center.x,\n    dims.height * center.y,\n    event.offsetX,\n    event.offsetY\n  );\n\n  const positiveAngle = getPositiveAngle(angle);\n\n  let val;\n  if (isRtl && startAngle + angleExtent > positiveAngle) {\n    val = (getPositiveAngle(angle - startAngle) / angleExtent) * (max - min);\n  }\n\n  if (!isRtl) {\n    const clockwiseArc = getPositiveAngle(startAngle - positiveAngle);\n    if (clockwiseArc <= angleExtent) {\n      val = (clockwiseArc * (max - min)) / angleExtent;\n    }\n  }\n\n  if (val != undefined) {\n    val = Math.round(val / step) * step;\n    val = Math.max(Math.min(max, val), min);\n  }\n  return val;\n}\n\n/**\n * Returns the fraction of angle extent for given delta.\n * @param delta The delta of metric values.\n * @param min The minimum value of the meter circle.\n * @param max The maximum value of the meter circle.\n * @param angleExtent The angle extent of the meter circle.\n * @returns The angle extent corresponding to delta in metric value.\n */\nexport function getAngleExtentFromDelta(\n  delta: number,\n  min: number,\n  max: number,\n  angleExtent: number\n): number {\n  return (delta * angleExtent) / (max - min);\n}\n\n/**\n * Returns the start angle for given metric value.\n * @param value The metric value\n * @param min The minimum value of the meter circle.\n * @param max The maximum value of the meter circle.\n * @param startAngle The startAngle of the meter circle.\n * @param angleExtent The angleExtent of the meter circle.\n * @param isRtl Whether the reading mode is 'rtl'\n * @returns The startAngle for the metric value.\n */\nexport function getStartAngleForValue(\n  value: number,\n  min: number,\n  max: number,\n  startAngle: number,\n  angleExtent: number,\n  isRtl: boolean\n): number {\n  const extent = getAngleExtentFromDelta(value - min, min, max, angleExtent);\n  return startAngle + (isRtl ? 1 : -1) * extent;\n}\n\n/**\n * Returns the center context of for the meter circle.\n */\nexport function getCenterContext(\n  dimensionsRef: RefObject<Dimensions>,\n  section: 'top' | 'bottom' | 'left' | 'right' | 'full'\n): CenterContext | undefined {\n  const dims = dimensionsRef.current;\n\n  if (!dims) {\n    return;\n  }\n\n  const center = getCenterCoord(section);\n  const cx = center.x * dims.width;\n  const cy = center.y * dims.height;\n\n  const isHoriz = section === 'top' || section === 'bottom';\n\n  let innerX, innerY, innerW, innerH;\n  let outerX, outerY, outerW, outerH;\n\n  if (isHoriz || section === 'full') {\n    outerW = 2 * dims.innerRadius;\n    outerH = section === 'full' ? 2 * dims.innerRadius : dims.innerRadius;\n    outerX = cx - dims.innerRadius;\n    outerY = section === 'bottom' ? 0 : cy - dims.innerRadius;\n\n    innerW = Math.sqrt(2) * dims.innerRadius;\n    innerH = section === 'full' ? innerW : dims.innerRadius / Math.sqrt(2);\n    innerX = cx - dims.innerRadius / Math.sqrt(2);\n    innerY = section === 'bottom' ? 0 : cy - dims.innerRadius / Math.sqrt(2);\n  } else {\n    outerH = 2 * dims.innerRadius;\n    outerW = dims.innerRadius;\n    outerX = section === 'left' ? cx - dims.innerRadius : 0;\n    outerY = cy - dims.innerRadius;\n\n    innerH = Math.sqrt(2) * dims.innerRadius;\n    innerW = dims.innerRadius / Math.sqrt(2);\n    innerX = section === 'left' ? cx - dims.innerRadius / Math.sqrt(2) : 0;\n    innerY = cy - dims.innerRadius / Math.sqrt(2);\n  }\n\n  return {\n    outerBounds: {\n      x: outerX,\n      y: outerY,\n      width: outerW,\n      height: outerH\n    },\n    innerBounds: {\n      x: innerX,\n      y: innerY,\n      width: innerW,\n      height: innerH\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  Threshold,\n  MeterSize,\n  ThresholdDisplay,\n  getVisThresholdColor\n} from '#utils/UNSAFE_meterUtils';\nimport { getClipPath, getPositiveAngle, Sector } from '#utils/PRIVATE_meterUtils';\nimport { getAngleExtentFromDelta, getStartAngleForValue } from './circleMeterUtils';\nimport { MeterProps } from './meterCircle.types';\nimport { ColorProps } from '#utils/UNSAFE_interpolations/colors';\nimport { meterCircleVars } from './themes/MeterCircleContract.css';\nimport { colorSchemeVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\nimport { xUnits } from '#UNSAFE_Theme/utils';\nexport type MeterInfo = Required<\n  Pick<MeterProps, 'min' | 'max' | 'value' | 'size' | 'startAngle' | 'angleExtent'>\n> & {\n  section: Sector;\n  isRtl: boolean;\n  innerRadius: number;\n};\n\n// reduce the max width of text by 8px. There were some inconsistency on exact\n// truncation width between browsers, viewport, container width, which led to some ellipses\n// bleeding out. Reducing the max width provides a buffer so that labels are truncated\n// slightly before reaching the exact max width.\nconst TRUCATION_THRESHOLD = xUnits(2);\n\n//max left (right) offset for right (left) half circle for sized meter circle\nexport const SIZED_HALF_METER_HORIZ_OFFSET = xUnits(7.5);\n\n// max ref line protrusion\n\nconst MAX_PROTUSION = 16;\n\n/**\n * Returns the css variable corresponding to the default size of the meter circle.\n * @param size The size of the meter circle.\n * @returns The css variable corresponding to the default size of the meter circle.\n */\nfunction getSizeVar(size: MeterSize, diameter?: number): string {\n  return size\n    ? size === 'fit'\n      ? `${diameter}px`\n      : meterCircleVars.sizes[size]\n    : meterCircleVars.size;\n}\n\n/**\n * Returns the css variable corresponding to the default track size of the meter circle.\n * @param size The size of the meter circle.\n * @returns The css variable corresponding to the default track size of the meter circle.\n */\nfunction getTrackSizeVar(size: MeterSize): string {\n  return size ? meterCircleVars.trackSizes[size] : meterCircleVars.trackSize;\n}\n\n/**\n * Returns the calculated css variable string for the inner radius when given size and innerRadius of meter circle.\n * @param size The size of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns {string} CSS varible string for the calculated inner radius of the meter circle.\n */\nexport function getInnerRadius(size: MeterSize, innerRadius?: number, diameter?: number): string {\n  if (innerRadius != undefined) {\n    return `(${getSizeVar(size, diameter)} * ${innerRadius / 2})`;\n  }\n  return `(${getSizeVar(size, diameter)} * 0.5 - ${getTrackSizeVar(size)})`;\n}\n\n/**\n * Returns the calculated css variable string for meter circle track for a given size and innerRadius of meter circle.\n * @param size The size of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns {string} CSS variable for the calculated track size of the meter circle.\n */\nexport function getTrackSize(size: MeterSize, innerRadius?: number, diameter?: number): string {\n  if (innerRadius != undefined) {\n    return `(${getSizeVar(size, diameter)} * ${1 - innerRadius} / 2)`;\n  }\n  return getTrackSizeVar(size);\n}\n\n/**\n * Returns the array of calculated props for InnerCircle representing each threshold.\n * @param meterInfo MeterInfo object containing info about given meter circle.\n * @param thresholds thresholds array of the meter circle.\n * @param isTrackRendered Whether track is rendered.\n * @param trackColor The track color of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns Array of calculated props object for InnerCircle representing each threshold.\n */\nexport function getThresholdsProps(\n  meterInfo: MeterInfo,\n  thresholds: Threshold[],\n  isTrackRendered: boolean,\n  trackColor?: ColorProps['color'],\n  innerRadius?: number,\n  diameter?: number\n): Array<{\n  clipPath: string;\n  color?: ColorProps['color'];\n  section: Sector;\n  size: string;\n}> {\n  const {\n    min,\n    max,\n    startAngle,\n    angleExtent,\n    size,\n    section,\n    isRtl,\n    innerRadius: innerDim\n  } = meterInfo;\n  const trackSize = `calc(${getTrackSize(size, innerRadius, diameter)})`;\n  const thresholdProps = [];\n  const validThresholds = thresholds\n    .filter((threshold: Threshold) => threshold.max > min && threshold.max <= max)\n    .sort((a, b) => a.max - b.max);\n  const numOfThreshold = validThresholds.length;\n  for (let i = 0; i < numOfThreshold; i++) {\n    const threshold = validThresholds[i];\n    const startValue = i === 0 ? min : validThresholds[i - 1].max;\n    const diff = i === 0 ? threshold.max : threshold.max - validThresholds[i - 1].max;\n\n    let thresholdStart = getStartAngleForValue(\n      startValue,\n      min,\n      max,\n      startAngle,\n      angleExtent,\n      isRtl\n    );\n    let thresholdExtent = getAngleExtentFromDelta(diff, min, max, angleExtent);\n\n    const { startOffset, extentOffset } = getThresholdsBuffer(\n      innerDim,\n      angleExtent,\n      i === 0,\n      threshold.max === max,\n      isRtl\n    );\n    const clipPath = getClipPath(\n      thresholdStart + startOffset,\n      thresholdExtent + extentOffset,\n      isRtl,\n      section\n    );\n\n    thresholdProps.push({\n      clipPath,\n      color: getVisThresholdColor(threshold.color),\n      size: trackSize,\n      section\n    });\n\n    if (i === numOfThreshold - 1 && threshold.max < max && isTrackRendered) {\n      thresholdStart = thresholdStart + (isRtl ? 1 : -1) * thresholdExtent;\n      thresholdExtent = getAngleExtentFromDelta(max - threshold.max, min, max, angleExtent);\n      const { startOffset, extentOffset } = getThresholdsBuffer(\n        innerDim,\n        angleExtent,\n        false,\n        true,\n        isRtl\n      );\n      thresholdProps.push({\n        clipPath: getClipPath(\n          thresholdStart + startOffset,\n          thresholdExtent + extentOffset,\n          isRtl,\n          section\n        ),\n        color: trackColor,\n        size: trackSize,\n        section\n      });\n    }\n  }\n  return thresholdProps;\n}\n\n/**\n * Returns the calculated props for InnerCircle representing the track.\n * @param meterInfo MeterInfo object containing info about the meter circle.\n * @param trackColor The color of the track.\n * @param istrackRendered Whether the track is rendered.\n * @param thresholdDisplay Specifies whether the current threshold is displayed in the track, on the indicator, or if all thresholds are displayed in the track.\n * @param innerRadius The innerRadius of the meter circle.\n * @param thresholds thresholds array of the meter circle.\n * @returns An object with calculated props for InnerCircle that represents the track.\n */\nexport function getTrackProps(\n  meterInfo: MeterInfo,\n  isTrackRendered: boolean,\n  thresholdDisplay: ThresholdDisplay,\n  trackColor?: ColorProps['color'],\n  innerRadius?: number,\n  thresholds?: Threshold[],\n  diameter?: number\n): {\n  section: Sector;\n  color?: ColorProps['color'];\n  clipPath: string;\n  size: string;\n} {\n  const { startAngle, angleExtent, size, section, isRtl } = meterInfo;\n  const color = !isTrackRendered\n    ? 'transparent'\n    : thresholdDisplay === 'all' && thresholds\n    ? `${colorSchemeVars.dvt.contrastLine}`\n    : trackColor;\n  return {\n    section,\n    color,\n    clipPath: getClipPath(startAngle, angleExtent, isRtl, section),\n    size: `calc(${getTrackSize(size, innerRadius, diameter)})`\n  };\n}\n\n/**\n * Returns the calculated props for InnerCircle representing the indicator.\n * @param meterInfo MeterInfo object containing info about the meter circle.\n * @param indicatorSize Relative thickness of the indicator to the track.\n * @param innerRadius The innerRadius of the meter circle.\n * @returns An object with calculated props for InnerCircle that represents the indicator.\n */\nexport function getIndicatorProps(\n  meterInfo: MeterInfo,\n  indicatorSize: number,\n  innerRadius?: number,\n  fitDiameter?: number\n) {\n  const { value, min, max, startAngle, angleExtent, size, section, isRtl } = meterInfo;\n  const valueExtent = ((value - min) * angleExtent) / (max - min);\n  const validIndicatorSize = Math.min(Math.max(0, indicatorSize), 1);\n  const isHoriz = section === 'left' || section === 'right';\n  const isVert = section === 'top' || section === 'bottom';\n  const valueTrackSize = `calc(${getTrackSize(\n    size,\n    innerRadius,\n    fitDiameter\n  )} * ${validIndicatorSize})`;\n  const diameter = `${getSizeVar(\n    size,\n    fitDiameter\n  )} - ((1 - ${validIndicatorSize}) * ${getTrackSize(size, innerRadius, fitDiameter)})`;\n  const radius = `(${diameter}) / 2`;\n  return {\n    section,\n    width: isHoriz ? `calc(${radius})` : `calc(${diameter})`,\n    height: isVert ? `calc(${radius})` : `calc(${diameter})`,\n    size: valueTrackSize,\n    clipPath: getClipPath(startAngle, valueExtent, isRtl, section)\n  };\n}\n\n/**\n * Returns the threshold offsets to create the whitespace between the thresholds.\n * @param innerRadius The innerRadius of the meter circle.\n * @param angleExtent The angleExtent of the meter circle.\n * @param firstThreshold Whether the current threshold is the first threshold.\n * @param lastThreshold  Whether the current threshold is the last threshold.\n * @param isRtl Whether the document reading mode is 'rtl'\n * @returns The offsets (startOffset and extentOffset) to add to calculated threshold startAngle and threhsold extent.\n */\nfunction getThresholdsBuffer(\n  innerRadius: number,\n  angleExtent: number,\n  firstThreshold: boolean,\n  lastThreshold: boolean,\n  isRtl: boolean\n): {\n  startOffset: number;\n  extentOffset: number;\n} {\n  if (!innerRadius) {\n    return { startOffset: 0, extentOffset: 0 };\n  }\n  const offset = 360 / (2 * Math.PI * innerRadius);\n  let startOffset = (offset / 2) * (isRtl ? 1 : -1);\n  let extentOffset = -1 * offset;\n\n  if (firstThreshold && angleExtent < 360) {\n    startOffset = 0;\n    extentOffset = -0.5 * offset;\n  }\n\n  if (lastThreshold && angleExtent < 360) {\n    extentOffset = -0.5 * offset;\n  }\n  return { startOffset, extentOffset };\n}\n\nexport function getWidthAndHeight(width: number, height: number, section: Sector) {\n  if (section === 'top' || section === 'bottom') {\n    return {\n      height: Math.min(height, width / 2),\n      width: Math.min(height, width / 2) * 2\n    };\n  } else if (section === 'left' || section === 'right') {\n    return {\n      width: Math.min(width, height / 2),\n      height: Math.min(width, height / 2) * 2\n    };\n  } else {\n    return {\n      width: Math.min(width, height),\n      height: Math.min(width, height)\n    };\n  }\n}\n\n/**\n * Returns the x and y offset for absolute position of reference line.\n */\nexport function getReferenceLineXYOffset(\n  centerCoord: { x: number; y: number },\n  angle: number,\n  radius: string\n) {\n  const yOffset = `calc(${centerCoord.y * 100}% - ((${Math.sin(\n    (angle * 2 * Math.PI) / 360\n  )} * ${radius} )))`;\n  const xOffset = `calc(${centerCoord.x * 100}%  + ((${Math.cos(\n    (angle * 2 * Math.PI) / 360\n  )} * ${radius} )))`;\n  return { xOffset, yOffset };\n}\n\n/**\n * Returns the translation offset for the reference line label.\n */\nexport function getLabelTranslateOffset(\n  ag: number,\n  section: Sector,\n  halfMeterOffset: string | number\n) {\n  let horizTranslate = '-50%';\n  const angle = getPositiveAngle(ag);\n\n  if (angle === 90 || angle === 270) {\n    halfMeterOffset =\n      typeof halfMeterOffset === 'string' ? halfMeterOffset : `${Math.abs(halfMeterOffset)}px`;\n    if (section === 'left') {\n      horizTranslate = `min(-50%, calc(-100% + ${halfMeterOffset}))`;\n    } else if (section === 'right') {\n      horizTranslate = `max(-50%, calc(-1 *  ${halfMeterOffset}))`;\n    }\n  }\n\n  // these numbers are from the meter circle spec.\n\n  if (angle <= 72 || angle >= 288) {\n    return `0 -50%`;\n  } else if (angle >= 108 && angle <= 252) {\n    return `-100% -50%`;\n  } else if (angle <= 108 && angle >= 72) {\n    return `${horizTranslate} -100%`;\n  } else {\n    return `${horizTranslate} 0`;\n  }\n}\n\n/**\n * The maxiumum width of for the reference line label in meter circle.\n */\nexport function getMaxWidth(sizeVar: string, angle: number, radius: string) {\n  angle = getPositiveAngle(angle);\n  if ((angle < 108 && angle > 72) || (angle < 288 && angle > 252)) {\n    return `calc(${sizeVar} * 1.4)`;\n  }\n\n  return `calc( (${sizeVar} * 0.7 ) - (${Math.abs(\n    Math.cos((angle * 2 * Math.PI) / 360)\n  )} * ${radius} ))`;\n}\n\n/**\n * Returns the maximum width of label for a given angled reference line.\n */\nexport function getFitMaxWidth(sector: Sector, width: number, angle: number, radius: number) {\n  angle = getPositiveAngle(angle);\n  if (sector === 'full' || sector === 'bottom' || sector === 'top') {\n    if ((angle < 108 && angle > 72) || (angle < 288 && angle > 252)) {\n      return `calc(${width}px - ${TRUCATION_THRESHOLD})`;\n    }\n\n    return `calc(${\n      width / 2 - Math.abs(Math.cos((angle * 2 * Math.PI) / 360)) * radius\n    }px - ${TRUCATION_THRESHOLD})`;\n  } else {\n    if (angle === 90 || angle === 270) {\n      return `calc(${width}px - ${TRUCATION_THRESHOLD})`;\n    }\n\n    return `calc(${\n      width / 2 + radius / 2 - radius * Math.abs(Math.cos((angle * 2 * Math.PI) / 360))\n    }px - ${TRUCATION_THRESHOLD})`;\n  }\n}\n\n/**\n * Returns the margin needed to accomodate reference line and label in a sized meter circle.\n */\nexport function getSizedMargin(\n  size: string,\n  sector: Sector,\n  hasReferenceLine: boolean,\n  hasReferenceLineLabel: boolean,\n  maxRefLabelDims: { width: number; height: number }\n) {\n  let marginValue = '';\n\n  if (!hasReferenceLine && !hasReferenceLine) {\n    return '';\n  }\n\n  if (hasReferenceLineLabel) {\n    marginValue = `calc(${meterCircleVars.size} / ${size === 'lg' || size === 'md' ? 3 : 2} )`;\n  } else if (hasReferenceLine) {\n    if (size === 'sm') {\n      marginValue = xUnits(4);\n    } else if (size === 'md') {\n      marginValue = xUnits(3);\n    } else if (size === 'lg') {\n      marginValue = xUnits(2);\n    }\n  }\n\n  if (sector === 'bottom') {\n    return `${maxRefLabelDims.height / 2}px ${marginValue} ${marginValue} ${marginValue}`;\n  } else if (sector === 'top') {\n    return `${marginValue} ${marginValue} ${maxRefLabelDims.height / 2}px ${marginValue}`;\n  } else if (sector === 'left') {\n    return `${marginValue} ${SIZED_HALF_METER_HORIZ_OFFSET} ${marginValue} ${marginValue}`;\n  } else if (sector === 'right') {\n    return `${marginValue} ${marginValue} ${marginValue} ${SIZED_HALF_METER_HORIZ_OFFSET}`;\n  } else {\n    return marginValue;\n  }\n}\n/**\n * Returns the breakpoint for a given width of the meter circle.\n */\nexport function getBreakPoint(width: number) {\n  // these numbers are from the meter circle spec.\n  if (width < 200) {\n    return 'min';\n  } else if (width < 320) {\n    return 'xs';\n  } else if (width < 360) {\n    return 'sm';\n  } else {\n    return 'md';\n  }\n}\n\n/**\n * Returns the translation needed to center the meter bar when\n * reference line and label is present.\n */\nexport function getCenterOffsets(section: Sector, overHang: number, isRtl: boolean) {\n  const overHangOffset = section === 'full' ? overHang / 2 : overHang;\n  if (section === 'top') {\n    return isRtl ? '50% -50%' : '-50%, -50%';\n  }\n  return isRtl\n    ? `calc(50% + ${overHangOffset}px), calc(-50% - ${overHangOffset}px)`\n    : `calc(-50% - ${overHangOffset}px), calc(-50% - ${overHangOffset}px)`;\n}\n\n/**\n * Returns the horizontal offset for left and right half circle for fit meter circle.\n */\nexport function getFitHalfCircleOffset(\n  width: number,\n  radius: number,\n  section: Sector,\n  isRtl: boolean\n) {\n  const factor = (!isRtl && section === 'right') || (isRtl && section === 'left') ? -0.5 : 0.5;\n  return (width - radius) / 2 + factor * MAX_PROTUSION;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getCenterCoord } from '#utils/PRIVATE_meterUtils';\nimport { ColorProps } from '#utils/UNSAFE_interpolations/colors';\nimport { VisThresholdsColors, getVisThresholdColor } from '#utils/UNSAFE_meterUtils';\nimport { styles } from './themes/MeterCircleStyles.css';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { CSSProperties } from 'preact/compat';\nimport { getLabelTranslateOffset, getReferenceLineXYOffset } from './layoutUtils';\n\ntype getCenterCoordParamType = Parameters<typeof getCenterCoord>;\n\nexport type CircularReferenceLineProps = {\n  color?: ColorProps['color'] | VisThresholdsColors;\n  angle: number;\n  radius: string;\n  length: string;\n  section: getCenterCoordParamType[0];\n  label?: string;\n  labelMaxWidth: string;\n  labelOffset: number;\n  labelStyle?: CSSProperties;\n  halfMeterOffset: string | number;\n};\n\nexport function CircularReferenceLine({\n  color,\n  angle,\n  radius,\n  length,\n  section = 'full',\n  label,\n  labelMaxWidth,\n  labelOffset,\n  labelStyle,\n  halfMeterOffset\n}: CircularReferenceLineProps) {\n  const centerCoord = getCenterCoord(section);\n  const { xOffset: refXOffset, yOffset: refYOffset } = getReferenceLineXYOffset(\n    centerCoord,\n    angle,\n    radius\n  );\n  const { xOffset: labelXOffset, yOffset: labelYOffset } = getReferenceLineXYOffset(\n    centerCoord,\n    angle,\n    `calc(${length} + ${radius} + ${labelOffset}px)`\n  );\n  return (\n    <>\n      <div\n        class={classNames([\n          styles.referenceBaseLineStyle,\n          color ? undefined : styles.referenceBorderStyle\n        ])}\n        style={{\n          left: refXOffset,\n          top: refYOffset,\n          width: `calc(${length})`,\n          transform: `translate(0, -1px) rotate(${360 - angle}deg)`,\n          backgroundColor: color ? getVisThresholdColor(color) : undefined\n        }}></div>\n\n      {label && (\n        <div\n          className={styles.referenceLineLabelContainerStyle}\n          style={{\n            left: labelXOffset,\n            top: labelYOffset,\n            maxWidth: labelMaxWidth,\n            translate: getLabelTranslateOffset(angle, section, halfMeterOffset),\n            ...labelStyle\n          }}>\n          {label}\n        </div>\n      )}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { typographyVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\nimport { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { xUnits } from '#UNSAFE_Theme';\nimport {\n  getDefaultReferenceLineLabelFontSize,\n  hasLabelledReferenceLine\n} from '#utils/PRIVATE_meterUtils/meterUtils';\nimport { ColorProps } from '#utils/UNSAFE_interpolations/colors';\nimport { MeterSize, ReferenceLine } from '#utils/UNSAFE_meterUtils';\nimport { getStartAngleForValue } from './circleMeterUtils';\nimport { getInnerRadius, getTrackSize, MeterInfo } from './layoutUtils';\n\nconst LABEL_GAP = 4;\n\nimport { CircularRefLine } from './meterCircle.types';\n\n/**\n * Returns the calculated length of reference line for given size and inner radius of meter circle.\n * The length of reference line runs from the inner radius to slight outside the outer radius.\n * The length outside the outer radius depends on size of the meter circle.\n * @param size The size of the meter circle.\n * @param innerRadius The inner radius of the meter circle.\n * @returns The calculated CSS var for the length of reference line.\n */\nexport function getReferenceLineLength(\n  size: MeterSize,\n  innerRadius?: number,\n  isMin?: boolean,\n  diameter?: number\n): string {\n  return `${getTrackSize(size, innerRadius, diameter)} +  ${xUnits(\n    size === 'fit' && !isMin ? 4 : 2\n  )}`;\n}\n\n/**\n * Returns the calculated props for CircularReferenceLine.\n * @param meterInfo MeterInfo object containing info about the meter circle.\n * @param refLine The CircularRefLine object\n * @param innerRadius The innerRadius of the meter circle.\n * @returns An bject with calculated props for CircularReferenceLine.\n */\nexport function getReferenceLinesProps(\n  meterInfo: MeterInfo,\n  refLine: CircularRefLine,\n  innerRadius?: number,\n  isMin?: boolean,\n  diameter?: number\n): {\n  radius: string;\n  length: string;\n  angle: number;\n  color?: ColorProps['color'];\n} {\n  const { min, max, startAngle, angleExtent, size, isRtl } = meterInfo;\n  return {\n    radius: getInnerRadius(size, innerRadius, diameter),\n    length: getReferenceLineLength(size, innerRadius, isMin, diameter),\n    angle: getStartAngleForValue(refLine.value, min, max, startAngle, angleExtent, isRtl),\n    color: refLine.color\n  };\n}\n\n/**\n * Returns the width and height of the fit meter circle when reference line\n * and reference line label is present.\n * @returns\n */\nexport function getWidthAndHeightWithReferenceLine(\n  _width: number,\n  _height: number,\n  hasReferenceLine: boolean,\n  breakPoint: 'min' | 'xs' | 'sm' | 'md',\n  hasReferenceLineLabel: boolean,\n  maxRefLabelDims: { width: number; height: number }\n) {\n  if (!hasReferenceLine) {\n    return { width: _width, height: _height, overHang: 0 };\n  }\n  const overHang = getReferenceLineOverHang(breakPoint);\n  const labelOffset = getReferenceLineLabelGap(breakPoint);\n  return {\n    width: _width * (hasReferenceLineLabel ? 0.6 : 1) - 2 * overHang,\n    height: _height - 2 * overHang - 2 * (maxRefLabelDims.height + labelOffset),\n    overHang\n  };\n}\n\n/**\n * Returns the maximum dimensions of reference lines labels.\n */\nexport function getMaxReferenceLineLabelDims(\n  breakPoint: 'min' | 'xs' | 'sm' | 'md',\n  refLines?: ReferenceLine[],\n  getTextDimensions?: GetTextDimensionsType\n) {\n  if (!hasLabelledReferenceLine(refLines) || !getTextDimensions || !refLines) {\n    return { width: 0, height: 0 };\n  }\n  return refLines\n    .map((line) => {\n      const { label, labelStyle } = line;\n      const dims = label\n        ? getTextDimensions(label, {\n            fontSize: getDefaultReferenceLineLabelFontSize(breakPoint),\n            lineHeight: typographyVars.body.md.lineHeight,\n            ...labelStyle\n          })\n        : { width: 0, height: 0 };\n      return dims;\n    })\n    .reduce(\n      (acc, cur) => {\n        return {\n          width: Math.max(cur.width, acc.width),\n          height: Math.max(cur.height, acc.height)\n        };\n      },\n      { width: 0, height: 0 }\n    );\n}\n\n/**\n * Returns the gap for the reference line label.\n */\nexport function getReferenceLineLabelGap(breakPoint: 'min' | 'xs' | 'sm' | 'md', angle?: number) {\n  const isMin = breakPoint === 'min' || breakPoint === 'xs';\n\n  // vertical gap\n  if (angle != null && ((angle < 108 && angle > 72) || (angle < 288 && angle > 252))) {\n    return isMin ? 0 : LABEL_GAP;\n  }\n\n  // horizontal gap\n\n  if (angle != null && (!(angle < 108 && angle > 72) || (angle < 288 && angle > 252))) {\n    return 1.5 * LABEL_GAP;\n  }\n\n  return isMin ? LABEL_GAP / 2 : LABEL_GAP;\n}\n\n/**\n * Returns the length of reference line outside the diameter of the meter circle.\n */\nexport function getReferenceLineOverHang(breakPoint: 'min' | 'xs' | 'sm' | 'md') {\n  // these numbers are from the meter circle spec.\n  return breakPoint === 'min' || breakPoint === 'xs' ? LABEL_GAP * 2 : LABEL_GAP * 4;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { CircleWrapper, CircleInner } from '#PRIVATE_Meter';\nimport { CircularReferenceLine } from './CircularReferenceLine';\nimport { TrackResizeContainer } from '#UNSAFE_TrackResizeContainer';\n\nimport {\n  validateRange,\n  getTrackAndIndicatorColor,\n  getMeterAriaProps,\n  getCircleSection,\n  getPositiveAngle\n} from '#utils/PRIVATE_meterUtils';\n\nimport { getDimensions, getValue, getCenterContext } from './circleMeterUtils';\n\nimport {\n  getIndicatorProps,\n  getTrackProps,\n  getThresholdsProps,\n  MeterInfo,\n  getWidthAndHeight,\n  getFitMaxWidth,\n  getBreakPoint,\n  getCenterOffsets,\n  getFitHalfCircleOffset\n} from './layoutUtils';\n\nimport {\n  usePointerEvents,\n  useKeyboardEvents,\n  useMeterDatatip\n} from '#hooks/PRIVATE_useVisMeterEvents';\n\nimport { MeterProps, CircularRefLine } from './meterCircle.types';\nimport { useTabbableMode } from '#hooks/UNSAFE_useTabbableMode';\nimport { useComponentTheme } from '#hooks/UNSAFE_useComponentTheme';\nimport { MeterCircleStyles, MeterCircleVariantOptions } from './themes/MeterCircleStyles.css';\nimport { MeterCircleRedwoodTheme } from './themes/redwood/MeterCircleTheme';\nimport { useTestId } from '#hooks/UNSAFE_useTestId';\nimport {\n  getReferenceLineLabelGap,\n  getReferenceLinesProps,\n  getWidthAndHeightWithReferenceLine\n} from './refLineUtils';\nimport { useCssVars } from '#hooks/PRIVATE_useCssVars';\nimport {\n  getDefaultReferenceLineLabelFontSize,\n  getMaxRefLabelDims,\n  hasLabelledReferenceLine\n} from '#utils/PRIVATE_meterUtils/meterUtils';\nimport { useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { typographyVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\n\nconst FIT_INNERRADIUS = 0.8;\nconst FIT_BUFFER = 8;\n\n/**\n * A Meter circle displays information graphically in a circular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.\n */\nexport function FitMeterCircle({\n  max = 100,\n  min = 0,\n  value = 0,\n  step = 1,\n  size = 'fit',\n  startAngle = 90,\n  angleExtent = 360,\n  isTrackRendered = true,\n  thresholdDisplay = 'all',\n  indicatorSize = 1,\n  testId,\n  isReadonly,\n  ...props\n}: MeterProps) {\n  const testIdProps = useTestId(testId);\n  validateRange(min, max, value, step, isReadonly);\n  const isInteractive = props.onCommit || props.onInput;\n  const { classes, styles } = useComponentTheme<MeterCircleVariantOptions, MeterCircleStyles>(\n    MeterCircleRedwoodTheme,\n    {\n      size,\n      interaction: isInteractive ? 'isInteractive' : undefined\n    }\n  );\n\n  return (\n    <TrackResizeContainer\n      class={classNames([classes, styles.textAlignCenter])}\n      width={'100%'}\n      height={'100%'}>\n      {function _(_width, _height) {\n        _width -= FIT_BUFFER;\n        _height -= FIT_BUFFER;\n\n        const hasReferenceLabel = hasLabelledReferenceLine(props.referenceLines);\n\n        const { textMeasureContent, getTextDimensions } = useTextDimensions();\n        const { direction } = useUser();\n        const isRtl = direction === 'rtl';\n\n        let sAngle = startAngle;\n        if (isRtl) {\n          sAngle = getPositiveAngle(180 - sAngle);\n        }\n\n        const section = getCircleSection(sAngle, angleExtent, isRtl);\n\n        const { width: _w, height: _h } = getWidthAndHeight(_width, _height, section);\n        const breakPoint = getBreakPoint(Math.max(_w, _h));\n\n        const fontSize = getDefaultReferenceLineLabelFontSize(breakPoint);\n\n        const circleVars = useMemo(\n          () => [\n            {\n              tokenVar: fontSize,\n              key: 'labelFontSize',\n              cssProp: 'font-size'\n            },\n            {\n              tokenVar: typographyVars.body.md.lineHeight,\n              key: 'lineHeight',\n              cssProp: 'line-height'\n            }\n          ],\n          [fontSize]\n        );\n\n        const { resolvedVars, cssContent } = useCssVars(circleVars);\n\n        const { maxRefLabelDims } = getMaxRefLabelDims(\n          resolvedVars['fontSize'],\n          resolvedVars['lineHeight'],\n          props.referenceLines,\n          getTextDimensions\n        );\n\n        const isMin = breakPoint === 'xs' || breakPoint === 'min';\n        const innerR = props.innerRadius ?? FIT_INNERRADIUS;\n\n        const {\n          width: w,\n          height: h,\n          overHang\n        } = getWidthAndHeightWithReferenceLine(\n          _width,\n          _height,\n          !!props.referenceLines?.length,\n          breakPoint,\n          hasReferenceLabel,\n          maxRefLabelDims\n        );\n\n        const { width, height } = getWidthAndHeight(w, h, section);\n\n        const radius = section === 'full' ? Math.min(width, height) / 2 : Math.min(width, height);\n        const diameter = radius * 2;\n\n        const currentInputRef = useRef<number>();\n\n        const dimensionsRef = useRef(getDimensions(null, section));\n        const circleWrapperRef = useRef<HTMLDivElement>(null);\n        const [isDimsReady, setDimsReady] = useState<boolean>(false);\n\n        useEffect(() => {\n          if (props.onCommit || props.onInput || props.children) {\n            dimensionsRef.current = getDimensions(circleWrapperRef.current, section);\n            setDimsReady(true);\n          }\n        }, [section]);\n\n        const getValueFromEvent = (event: PointerEvent) => {\n          const circleContainer = circleWrapperRef.current;\n          if (event.target == circleContainer) {\n            return getValue(\n              event,\n              min,\n              max,\n              step,\n              dimensionsRef,\n              sAngle,\n              angleExtent,\n              section,\n              isRtl\n            );\n          }\n          return;\n        };\n\n        const isPointerActiveRef = useRef(false);\n\n        const pointerEventsProps = usePointerEvents(\n          value,\n          getValueFromEvent,\n          circleWrapperRef,\n          currentInputRef,\n          isPointerActiveRef,\n          props.onCommit,\n          props.onInput\n        );\n\n        const keyboardEventsProps = useKeyboardEvents(\n          value,\n          min,\n          max,\n          step,\n          currentInputRef,\n          props.onCommit,\n          props.onInput\n        );\n\n        const { datatipContent, datatipProps } = useMeterDatatip(\n          value,\n          isPointerActiveRef,\n          props.datatip,\n          props['aria-describedby']\n        );\n\n        const ariaProps = getMeterAriaProps(\n          value,\n          min,\n          max,\n          props['aria-label'],\n          props['aria-labelledby'],\n          props.thresholds,\n          isReadonly\n        );\n        const mergedProps = mergeProps(\n          pointerEventsProps,\n          keyboardEventsProps,\n          datatipProps,\n          ariaProps\n        );\n\n        const { trackColor, indicatorColor } = getTrackAndIndicatorColor(\n          value,\n          thresholdDisplay,\n          props.trackColor,\n          props.indicatorColor,\n          props.thresholds\n        );\n\n        const meterInfo = {\n          min,\n          max,\n          value,\n          startAngle: sAngle,\n          angleExtent,\n          size,\n          section,\n          isRtl,\n          innerRadius: dimensionsRef.current.innerRadius\n        } as MeterInfo;\n\n        const { isTabbable } = useTabbableMode();\n        const centerContext = getCenterContext(dimensionsRef, section);\n        return (\n          <>\n            <div\n              class={classNames([\n                classes,\n                section === 'full' ? styles.meterCircleFullSizeStyle : '',\n                styles.textAlignInitial\n              ])}\n              style={{\n                width: _width,\n                height: _height\n              }}\n              tabIndex={!isTabbable ? -1 : 0}\n              {...testIdProps}\n              {...mergedProps}>\n              <CircleWrapper\n                wrapperRef={circleWrapperRef}\n                class={classNames([\n                  styles.circleWrapperBaseStyle,\n                  isInteractive ? styles.interactiveStyle : '',\n                  props.referenceLines && props.referenceLines.length > 0\n                    ? size && styles[`${section}Fit${isMin ? 'Sm' : 'Lg'}Style`]\n                    : '',\n                  isRtl ? styles.centerDivRtl : styles.centerDivLtr\n                ])}\n                style={{\n                  width: `${width}px`,\n                  height: `${height}px`,\n                  // correction for margin\n                  transform: `translate(${getCenterOffsets(section, overHang, isRtl)})`\n                }}>\n                <CircleInner\n                  width={`${width}px`}\n                  height={`${height}px`}\n                  class={classNames([styles.circleTrackBaseStyle, styles[`${section}Style`]])}\n                  {...getTrackProps(\n                    meterInfo,\n                    isTrackRendered,\n                    thresholdDisplay,\n                    trackColor,\n                    innerR,\n                    props.thresholds,\n                    diameter\n                  )}\n                />\n                {thresholdDisplay === 'all' &&\n                  props.thresholds &&\n                  getThresholdsProps(\n                    meterInfo,\n                    props.thresholds,\n                    isTrackRendered,\n                    trackColor,\n                    innerR,\n                    diameter\n                  ).map((threshold) => {\n                    return (\n                      <CircleInner\n                        class={classNames([styles.circleTrackBaseStyle, styles[`${section}Style`]])}\n                        {...threshold}\n                        width={`${width}px`}\n                        height={`${height}px`}\n                      />\n                    );\n                  })}\n                <CircleInner\n                  color={indicatorColor}\n                  class={classNames([\n                    styles.circleValueBaseStyle,\n                    styles[`circleValue${section}Style`],\n                    styles[`${section}Style`]\n                  ])}\n                  {...getIndicatorProps(meterInfo, indicatorSize, innerR, 2 * radius)}\n                />\n                {props.referenceLines?.map((refLine: CircularRefLine) => {\n                  const { radius, length, angle, color } = getReferenceLinesProps(\n                    meterInfo,\n                    refLine,\n                    innerR,\n                    isMin,\n                    diameter\n                  );\n                  const labelMaxWidth = getFitMaxWidth(\n                    section,\n                    _width,\n                    angle,\n                    diameter / 2 + overHang + getReferenceLineLabelGap(breakPoint, angle)\n                  );\n                  return (\n                    <CircularReferenceLine\n                      label={refLine.label}\n                      labelStyle={{\n                        fontSize: resolvedVars['labelFontSize'],\n                        lineHeight: typographyVars.body.md.lineHeight,\n                        ...refLine.labelStyle\n                      }}\n                      labelMaxWidth={labelMaxWidth}\n                      radius={radius}\n                      length={length}\n                      angle={angle}\n                      labelOffset={getReferenceLineLabelGap(breakPoint, angle)}\n                      color={color}\n                      section={section}\n                      halfMeterOffset={getFitHalfCircleOffset(_width, diameter / 2, section, isRtl)}\n                    />\n                  );\n                })}\n                {isDimsReady && props.children && centerContext && (\n                  <div class={classNames([styles.meterCircleCenterContent])}>\n                    {props.children(centerContext)}\n                  </div>\n                )}\n              </CircleWrapper>\n            </div>\n            {datatipContent}\n            {textMeasureContent}\n            {cssContent}\n          </>\n        );\n      }}\n    </TrackResizeContainer>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { CircleWrapper, CircleInner } from '#PRIVATE_Meter';\nimport { CircularReferenceLine } from './CircularReferenceLine';\n\nimport {\n  validateRange,\n  getTrackAndIndicatorColor,\n  getMeterAriaProps,\n  getCircleSection,\n  getPositiveAngle\n} from '#utils/PRIVATE_meterUtils';\n\nimport { getDimensions, getValue, getCenterContext } from './circleMeterUtils';\n\nimport {\n  getIndicatorProps,\n  getTrackProps,\n  getThresholdsProps,\n  MeterInfo,\n  getMaxWidth,\n  getSizedMargin,\n  SIZED_HALF_METER_HORIZ_OFFSET\n} from './layoutUtils';\n\nimport {\n  usePointerEvents,\n  useKeyboardEvents,\n  useMeterDatatip\n} from '#hooks/PRIVATE_useVisMeterEvents';\n\nimport { MeterProps, CircularRefLine } from './meterCircle.types';\nimport { useTabbableMode } from '#hooks/UNSAFE_useTabbableMode';\nimport { useComponentTheme } from '#hooks/UNSAFE_useComponentTheme';\nimport { MeterCircleStyles, MeterCircleVariantOptions } from './themes/MeterCircleStyles.css';\nimport { MeterCircleRedwoodTheme } from './themes/redwood/MeterCircleTheme';\nimport { useTestId } from '#hooks/UNSAFE_useTestId';\nimport {\n  getDefaultReferenceLineLabelFontSize,\n  getMaxRefLabelDims,\n  hasLabelledReferenceLine\n} from '#utils/PRIVATE_meterUtils/meterUtils';\nimport { meterCircleVars } from './themes/MeterCircleContract.css';\nimport { useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { getReferenceLineLabelGap, getReferenceLinesProps } from './refLineUtils';\nimport { useCssVars } from '#hooks/PRIVATE_useCssVars';\nimport { typographyVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\n\ntype SizedMeterProps = MeterProps & { size?: 'sm' | 'md' | 'lg' };\n\n/**\n * A Meter circle displays information graphically in a circular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.\n */\nexport function SizedMeterCircle({\n  max = 100,\n  min = 0,\n  value = 0,\n  step = 1,\n  size = 'lg',\n  startAngle = 90,\n  angleExtent = 360,\n  isTrackRendered = true,\n  thresholdDisplay = 'all',\n  indicatorSize = 1,\n  testId,\n  isReadonly,\n  ...props\n}: SizedMeterProps) {\n  const testIdProps = useTestId(testId);\n\n  validateRange(min, max, value, step, isReadonly);\n  const currentInputRef = useRef<number>();\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  let sAngle = startAngle;\n  if (isRtl) {\n    sAngle = getPositiveAngle(180 - sAngle);\n  }\n\n  const section = getCircleSection(sAngle, angleExtent, isRtl);\n  const dimensionsRef = useRef(getDimensions(null, section));\n  const circleWrapperRef = useRef<HTMLDivElement>(null);\n  const [isDimsReady, setDimsReady] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (props.onCommit || props.onInput || props.children) {\n      dimensionsRef.current = getDimensions(circleWrapperRef.current, section);\n      setDimsReady(true);\n    }\n  }, [size, section, props.onCommit, props.onInput, props.children]);\n\n  const { textMeasureContent, getTextDimensions } = useTextDimensions();\n\n  const getValueFromEvent = (event: PointerEvent) => {\n    const circleContainer = circleWrapperRef.current;\n    if (event.target == circleContainer) {\n      return getValue(event, min, max, step, dimensionsRef, sAngle, angleExtent, section, isRtl);\n    }\n    return;\n  };\n\n  const isPointerActiveRef = useRef(false);\n\n  const pointerEventsProps = usePointerEvents(\n    value,\n    getValueFromEvent,\n    circleWrapperRef,\n    currentInputRef,\n    isPointerActiveRef,\n    props.onCommit,\n    props.onInput\n  );\n\n  const keyboardEventsProps = useKeyboardEvents(\n    value,\n    min,\n    max,\n    step,\n    currentInputRef,\n    props.onCommit,\n    props.onInput\n  );\n\n  const { datatipContent, datatipProps } = useMeterDatatip(\n    value,\n    isPointerActiveRef,\n    props.datatip,\n    props['aria-describedby']\n  );\n\n  const ariaProps = getMeterAriaProps(\n    value,\n    min,\n    max,\n    props['aria-label'],\n    props['aria-labelledby'],\n    props.thresholds,\n    isReadonly\n  );\n  const mergedProps = mergeProps(pointerEventsProps, keyboardEventsProps, datatipProps, ariaProps);\n\n  const { trackColor, indicatorColor } = getTrackAndIndicatorColor(\n    value,\n    thresholdDisplay,\n    props.trackColor,\n    props.indicatorColor,\n    props.thresholds\n  );\n\n  const orientation =\n    section === 'bottom' || section === 'top'\n      ? 'Horizontal'\n      : section === 'left' || section === 'right'\n      ? 'Vertical'\n      : 'Full';\n\n  const meterInfo = {\n    min,\n    max,\n    value,\n    startAngle: sAngle,\n    angleExtent,\n    size,\n    section,\n    isRtl,\n    innerRadius: dimensionsRef.current.innerRadius\n  } as MeterInfo;\n  const isInteractive = props.onCommit || props.onInput;\n\n  const { classes, styles } = useComponentTheme<MeterCircleVariantOptions, MeterCircleStyles>(\n    MeterCircleRedwoodTheme,\n    {\n      size,\n      interaction: isInteractive ? 'isInteractive' : undefined\n    }\n  );\n\n  const { isTabbable } = useTabbableMode();\n  const centerContext = getCenterContext(dimensionsRef, section);\n  const indicatorProps = getIndicatorProps(meterInfo, indicatorSize, props.innerRadius);\n\n  const hasReferenceLabel = hasLabelledReferenceLine(props.referenceLines);\n\n  const breakPoint = size === 'lg' ? 'sm' : 'min';\n\n  const fontSize = getDefaultReferenceLineLabelFontSize(breakPoint);\n  const circleVars = useMemo(\n    () => [\n      {\n        tokenVar: fontSize,\n        key: 'labelFontSize',\n        cssProp: 'font-size'\n      },\n      {\n        tokenVar: typographyVars.body.md.lineHeight,\n        key: 'lineHeight',\n        cssProp: 'line-height'\n      }\n    ],\n    [fontSize]\n  );\n\n  const { resolvedVars, cssContent } = useCssVars(circleVars);\n  const { maxRefLabelDims } = getMaxRefLabelDims(\n    resolvedVars['fontSize'],\n    resolvedVars['lineHeight'],\n    props.referenceLines,\n    getTextDimensions\n  );\n\n  const trackProps = getTrackProps(\n    meterInfo,\n    isTrackRendered,\n    thresholdDisplay,\n    trackColor,\n    props.innerRadius,\n    props.thresholds\n  );\n\n  return (\n    <>\n      <div\n        class={classNames([classes])}\n        tabIndex={!isTabbable ? -1 : 0}\n        {...testIdProps}\n        {...mergedProps}>\n        <CircleWrapper\n          wrapperRef={circleWrapperRef}\n          class={classNames([\n            styles.circleWrapperBaseStyle,\n            isInteractive ? styles.interactiveStyle : '',\n            styles[`meterCircle${orientation}SizeStyle`]\n          ])}\n          style={{\n            margin: getSizedMargin(\n              size,\n              section,\n              !!props.referenceLines?.length,\n              hasReferenceLabel,\n              maxRefLabelDims\n            )\n          }}>\n          <CircleInner\n            class={classNames([styles.circleTrackBaseStyle, styles[`${section}Style`]])}\n            {...trackProps}\n          />\n          {thresholdDisplay === 'all' &&\n            props.thresholds &&\n            getThresholdsProps(\n              meterInfo,\n              props.thresholds,\n              isTrackRendered,\n              trackColor,\n              props.innerRadius\n            ).map((threshold) => {\n              return (\n                <CircleInner\n                  class={classNames([styles.circleTrackBaseStyle, styles[`${section}Style`]])}\n                  {...threshold}\n                />\n              );\n            })}\n\n          <CircleInner\n            color={indicatorColor}\n            class={classNames([\n              styles.circleValueBaseStyle,\n              styles[`circleValue${section}Style`],\n              styles[`${section}Style`]\n            ])}\n            {...indicatorProps}\n          />\n          {props.referenceLines?.map((refLine: CircularRefLine) => {\n            const { radius, length, angle, color } = getReferenceLinesProps(\n              meterInfo,\n              refLine,\n              props.innerRadius\n            );\n            return (\n              <CircularReferenceLine\n                label={refLine.label}\n                labelStyle={{\n                  fontSize: resolvedVars['labelFontSize'],\n                  ...refLine.labelStyle\n                }}\n                labelMaxWidth={getMaxWidth(\n                  meterCircleVars['size'],\n                  angle,\n                  `calc( ${radius} + ${length} - ${trackProps.size} + ${getReferenceLineLabelGap(\n                    breakPoint,\n                    angle\n                  )}px)`\n                )}\n                radius={radius}\n                labelOffset={getReferenceLineLabelGap(breakPoint, angle)}\n                length={length}\n                angle={angle}\n                color={color}\n                halfMeterOffset={SIZED_HALF_METER_HORIZ_OFFSET}\n                section={section}\n              />\n            );\n          })}\n          {isDimsReady && props.children && centerContext && (\n            <div class={classNames([styles.meterCircleCenterContent])}>\n              {props.children(centerContext)}\n            </div>\n          )}\n        </CircleWrapper>\n      </div>\n      {datatipContent}\n      {textMeasureContent}\n      {cssContent}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { FitMeterCircle } from './FitMeterCircle';\nimport { SizedMeterCircle } from './SizedMeterCircle';\nimport { MeterProps } from './meterCircle.types';\n\n/**\n * A Meter circle displays information graphically in a circular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.\n */\nexport function MeterCircle({\n  size,\n  max = 100,\n  min = 0,\n  value = 0,\n  step = 1,\n  startAngle = 90,\n  angleExtent = 360,\n  isTrackRendered = true,\n  thresholdDisplay = 'all',\n  indicatorSize = 1,\n  isReadonly,\n  ...props\n}: MeterProps) {\n  if (size === 'fit') {\n    return (\n      <FitMeterCircle\n        isReadonly={isReadonly}\n        min={min}\n        value={value}\n        max={max}\n        step={step}\n        startAngle={startAngle}\n        angleExtent={angleExtent}\n        isTrackRendered={isTrackRendered}\n        thresholdDisplay={thresholdDisplay}\n        indicatorSize={indicatorSize}\n        {...props}\n      />\n    );\n  }\n  return (\n    <SizedMeterCircle\n      isReadonly={isReadonly}\n      size={size || 'lg'}\n      min={min}\n      value={value}\n      max={max}\n      step={step}\n      startAngle={startAngle}\n      angleExtent={angleExtent}\n      isTrackRendered={isTrackRendered}\n      thresholdDisplay={thresholdDisplay}\n      indicatorSize={indicatorSize}\n      {...props}\n    />\n  );\n}\n"],"names":["getDimensions","element","section","width","height","innerRadius","outerRadius","circleTrack","children","rect","getBoundingClientRect","Math","round","getInnerAndOuterRadius","clientWidth","clientHeight","getValue","event","min","max","step","dimensionsRef","startAngle","angleExtent","isRtl","dims","current","center","getCenterCoord","angle","convertToPolar","x","y","offsetX","offsetY","positiveAngle","getPositiveAngle","val","clockwiseArc","undefined","getAngleExtentFromDelta","delta","getStartAngleForValue","value","getCenterContext","cx","cy","innerX","innerY","innerW","innerH","outerX","outerY","outerW","outerH","sqrt","outerBounds","innerBounds","TRUCATION_THRESHOLD","xUnits","SIZED_HALF_METER_HORIZ_OFFSET","getSizeVar","size","diameter","meterCircleVars","sizes","getTrackSizeVar","trackSizes","trackSize","getInnerRadius","getTrackSize","getThresholdsProps","meterInfo","thresholds","isTrackRendered","trackColor","innerDim","thresholdProps","validThresholds","filter","threshold","sort","a","b","numOfThreshold","length","i","startValue","diff","thresholdStart","thresholdExtent","startOffset","extentOffset","getThresholdsBuffer","clipPath","getClipPath","push","color","getVisThresholdColor","getTrackProps","thresholdDisplay","colorSchemeVars","dvt","contrastLine","getIndicatorProps","indicatorSize","fitDiameter","valueExtent","validIndicatorSize","isHoriz","isVert","valueTrackSize","radius","firstThreshold","lastThreshold","offset","PI","getWidthAndHeight","getReferenceLineXYOffset","centerCoord","yOffset","sin","xOffset","cos","getLabelTranslateOffset","ag","halfMeterOffset","horizTranslate","abs","getMaxWidth","sizeVar","getSizedMargin","sector","hasReferenceLine","hasReferenceLineLabel","maxRefLabelDims","marginValue","getCenterOffsets","overHang","overHangOffset","getFitHalfCircleOffset","CircularReferenceLine","label","labelMaxWidth","labelOffset","labelStyle","refXOffset","refYOffset","labelXOffset","labelYOffset","_jsxs","jsxs","_Fragment","Fragment","_jsx","class","classNames","styles","referenceBaseLineStyle","referenceBorderStyle","style","left","top","transform","backgroundColor","className","referenceLineLabelContainerStyle","maxWidth","translate","getReferenceLineLength","isMin","getReferenceLinesProps","refLine","getWidthAndHeightWithReferenceLine","_width","_height","breakPoint","LABEL_GAP","getReferenceLineOverHang","getReferenceLineLabelGap","FitMeterCircle","testId","isReadonly","props","testIdProps","useTestId","validateRange","isInteractive","onCommit","onInput","classes","useComponentTheme","MeterCircleRedwoodTheme","interaction","TrackResizeContainer","textAlignCenter","hasReferenceLabel","hasLabelledReferenceLine","referenceLines","textMeasureContent","getTextDimensions","useTextDimensions","direction","useUser","sAngle","getCircleSection","_w","_h","getBreakPoint","fontSize","getDefaultReferenceLineLabelFontSize","circleVars","useMemo","tokenVar","key","cssProp","typographyVars","body","md","lineHeight","resolvedVars","cssContent","useCssVars","getMaxRefLabelDims","innerR","w","h","currentInputRef","useRef","circleWrapperRef","isDimsReady","setDimsReady","useState","useEffect","isPointerActiveRef","pointerEventsProps","usePointerEvents","circleContainer","target","keyboardEventsProps","useKeyboardEvents","datatipContent","datatipProps","useMeterDatatip","datatip","ariaProps","getMeterAriaProps","mergedProps","mergeProps","indicatorColor","getTrackAndIndicatorColor","isTabbable","useTabbableMode","centerContext","meterCircleFullSizeStyle","textAlignInitial","tabIndex","CircleWrapper","wrapperRef","circleWrapperBaseStyle","interactiveStyle","centerDivRtl","centerDivLtr","CircleInner","circleTrackBaseStyle","map","jsx","circleValueBaseStyle","getFitMaxWidth","meterCircleCenterContent","SizedMeterCircle","orientation","indicatorProps","trackProps","margin"],"mappings":"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"}