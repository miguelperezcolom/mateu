{"version":3,"file":"Resizable-dc482666.js","sources":["../../src/PRIVATE_Resizable/Resizable.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useCallback, useRef } from 'preact/hooks';\nimport type { RefObject } from 'preact';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { baseStyle, styles } from './themes/ResizableStyles.css';\nimport { getContainingBlockElem } from '../utils/PRIVATE_floatingUtils';\nimport { Rect } from '../utils/UNSAFE_flexibleComponentUtils';\n\ntype Point = {\n  x: number;\n  y: number;\n};\n\nenum ResizeEdge {\n  NONE,\n  N,\n  NE,\n  E,\n  SE,\n  S,\n  SW,\n  W,\n  NW\n}\n\nexport type ResizableConstraints = {\n  minWidth?: number;\n  maxWidth?: number;\n  minHeight?: number;\n  maxHeight?: number;\n};\n\ntype ResizableProps = {\n  onResizeStart?: (rect: Rect) => void;\n  onResize?: (rect: Rect) => void;\n  onResizeEnd?: (rect: Rect) => void;\n  containerRef?: RefObject<HTMLElement>;\n  constraints?: ResizableConstraints;\n};\n\n/**\n * A component that adds resize capability to a component. Fires the onResize event whenever\n * a potential resize gesture is detected. It is up to the consuming component to update its\n * position and dimensions when appropriate.\n */\nexport function Resizable({\n  onResize,\n  onResizeStart,\n  onResizeEnd,\n  containerRef,\n  constraints\n}: ResizableProps) {\n  const isResizing = useRef<boolean>(false);\n  const resizingEdge = useRef<ResizeEdge>(ResizeEdge.NONE);\n\n  const startPosition = useRef<Point>();\n  const initialParentClientRect = useRef<Rect>({ x: 0, y: 0, width: 0, height: 0 });\n  const initialMousePosition = useRef<Point>({ x: 0, y: 0 });\n\n  const findPos = (element: Element) => {\n    let elem = element as HTMLElement;\n    let curLeft = 0;\n    let curTop = 0;\n    if (elem.offsetParent) {\n      do {\n        curLeft += elem.offsetLeft;\n        curTop += elem.offsetTop;\n      } while ((elem = elem.offsetParent as HTMLElement));\n    }\n\n    return { left: curLeft, top: curTop };\n  };\n\n  /**\n   * Constrains rect to the current containing block\n   */\n  const constrainRect = useCallback(\n    (srcRect: Rect): Rect => {\n      const elem = containerRef?.current;\n\n      const result = {\n        x: srcRect.x,\n        y: srcRect.y,\n        width: srcRect.width,\n        height: srcRect.height\n      };\n\n      if (!elem) return result;\n\n      const containingBlock = getContainingBlockElem(elem);\n\n      const boundingRect = containingBlock?.getBoundingClientRect();\n      const dialogRect = elem.getBoundingClientRect();\n\n      const limitLeft = boundingRect ? boundingRect.left : 0;\n      const limitTop = boundingRect ? boundingRect.top : 0;\n      const limitRight = boundingRect ? boundingRect.right : window.innerWidth;\n      const limitBottom = boundingRect ? boundingRect.bottom : window.innerHeight;\n\n      // make sure the new rectangle fits in the min/max constraints and viewport limits\n\n      if (\n        (constraints?.minHeight && result.height < constraints.minHeight) ||\n        (constraints?.maxHeight && result.height > constraints.maxHeight)\n      ) {\n        result.y = dialogRect.y;\n        result.height = dialogRect.height;\n      } else {\n        if (result.y < limitTop) {\n          result.y = limitTop;\n          result.height = dialogRect.height;\n        }\n        if (result.y + result.height > limitBottom) {\n          result.height = dialogRect.height;\n        }\n      }\n\n      if (\n        (constraints?.minWidth && result.width < constraints.minWidth) ||\n        (constraints?.maxWidth && result.width > constraints.maxWidth)\n      ) {\n        result.x = dialogRect.x;\n        result.width = dialogRect.width;\n      } else {\n        if (result.x < limitLeft) {\n          result.x = limitLeft;\n          result.width = dialogRect.width;\n        }\n        if (result.x + result.width > limitRight) {\n          result.width = dialogRect.width;\n        }\n      }\n\n      return result;\n    },\n    [containerRef, constraints]\n  );\n\n  /**\n   * Calculates the new rect coordinates for a given mouse event\n   */\n  const getNewRect = useCallback(\n    (event: MouseEvent) => {\n      let left = 0;\n      let width = 0;\n      let top = 0;\n      let height = 0;\n\n      switch (resizingEdge.current) {\n        case ResizeEdge.N:\n          top = event.pageY - initialMousePosition.current.y;\n          height = initialMousePosition.current.y - event.pageY;\n          break;\n\n        case ResizeEdge.E:\n          width = event.pageX - initialMousePosition.current.x;\n          break;\n\n        case ResizeEdge.S:\n          height = event.pageY - initialMousePosition.current.y;\n          break;\n\n        case ResizeEdge.W:\n          left = event.pageX - initialMousePosition.current.x;\n          width = initialMousePosition.current.x - event.pageX;\n          break;\n\n        case ResizeEdge.NE:\n          top = event.pageY - initialMousePosition.current.y;\n          width = event.pageX - initialMousePosition.current.x;\n          height = initialMousePosition.current.y - event.pageY;\n          break;\n\n        case ResizeEdge.SE:\n          width = event.pageX - initialMousePosition.current.x;\n          height = event.pageY - initialMousePosition.current.y;\n          break;\n\n        case ResizeEdge.SW:\n          left = event.pageX - initialMousePosition.current.x;\n          width = initialMousePosition.current.x - event.pageX;\n          height = event.pageY - initialMousePosition.current.y;\n          break;\n\n        case ResizeEdge.NW:\n          left = event.pageX - initialMousePosition.current.x;\n          top = event.pageY - initialMousePosition.current.y;\n          width = initialMousePosition.current.x - event.pageX;\n          height = initialMousePosition.current.y - event.pageY;\n          break;\n      }\n\n      const newRect = {\n        x: initialParentClientRect.current.x + left,\n        y: initialParentClientRect.current.y + top,\n        width: initialParentClientRect.current.width + width,\n        height: initialParentClientRect.current.height + height\n      };\n\n      const newConstrainedRect = constrainRect(newRect);\n\n      return newConstrainedRect;\n    },\n    [constrainRect]\n  );\n\n  /**\n   * Handles mousedown events while the 'resize' mode is active.\n   */\n  const handleResize = useCallback(\n    (event: MouseEvent) => {\n      if (!isResizing.current) return;\n\n      if (!startPosition.current) return;\n\n      const newRect = getNewRect(event);\n      onResize?.(newRect);\n\n      event.stopPropagation();\n      event.preventDefault();\n    },\n    [onResize, getNewRect]\n  );\n\n  /**\n   * Handles mouseup event to exit the 'resize' mode.\n   */\n  const endResize = useCallback(\n    (event: MouseEvent) => {\n      isResizing.current = false;\n\n      document.removeEventListener('mousemove', handleResize, true);\n      document.removeEventListener('mouseup', endResize, true);\n\n      const newRect = getNewRect(event);\n      onResizeEnd?.(newRect);\n\n      resizingEdge.current = ResizeEdge.NONE;\n\n      event.preventDefault();\n      event.stopPropagation();\n    },\n    [getNewRect, onResizeEnd, handleResize]\n  );\n\n  /**\n   * Handles mousedown event to enter the 'resize mode.\n   */\n  const startResize = useCallback(\n    (event: MouseEvent) => {\n      const elem = event.currentTarget as HTMLElement;\n\n      if (!elem || !elem.parentElement) return;\n\n      const pos = findPos(elem.parentElement);\n\n      isResizing.current = true;\n\n      document.addEventListener('mousemove', handleResize, true);\n      document.addEventListener('mouseup', endResize, true);\n\n      initialParentClientRect.current = elem.parentElement.getBoundingClientRect();\n\n      startPosition.current = { x: pos.left, y: pos.top };\n      initialMousePosition.current = { x: event.pageX, y: event.pageY };\n\n      const newRect = getNewRect(event);\n      onResizeStart?.(newRect);\n    },\n    [getNewRect, onResizeStart, handleResize, endResize]\n  );\n\n  const startResizeN = (event: MouseEvent) => {\n    startResize(event);\n    if (isResizing.current) {\n      resizingEdge.current = ResizeEdge.N;\n    }\n  };\n\n  const startResizeE = (event: MouseEvent) => {\n    startResize(event);\n    if (isResizing.current) {\n      resizingEdge.current = ResizeEdge.E;\n    }\n  };\n\n  const startResizeS = (event: MouseEvent) => {\n    startResize(event);\n    if (isResizing.current) {\n      resizingEdge.current = ResizeEdge.S;\n    }\n  };\n\n  const startResizeW = (event: MouseEvent) => {\n    startResize(event);\n    if (isResizing.current) {\n      resizingEdge.current = ResizeEdge.W;\n    }\n  };\n\n  const startResizeNE = (event: MouseEvent) => {\n    startResize(event);\n    if (isResizing.current) {\n      resizingEdge.current = ResizeEdge.NE;\n    }\n  };\n\n  const startResizeSE = (event: MouseEvent) => {\n    startResize(event);\n    if (isResizing.current) {\n      resizingEdge.current = ResizeEdge.SE;\n    }\n  };\n\n  const startResizeSW = (event: MouseEvent) => {\n    startResize(event);\n    if (isResizing.current) {\n      resizingEdge.current = ResizeEdge.SW;\n    }\n  };\n\n  const startResizeNW = (event: MouseEvent) => {\n    startResize(event);\n    if (isResizing.current) {\n      resizingEdge.current = ResizeEdge.NW;\n    }\n  };\n\n  return (\n    <>\n      <div class={classNames([baseStyle, styles.handleN])} onMouseDown={startResizeN} />\n      <div class={classNames([baseStyle, styles.handleE])} onMouseDown={startResizeE} />\n      <div class={classNames([baseStyle, styles.handleS])} onMouseDown={startResizeS} />\n      <div class={classNames([baseStyle, styles.handleW])} onMouseDown={startResizeW} />\n      <div class={classNames([baseStyle, styles.handleNE])} onMouseDown={startResizeNE} />\n      <div class={classNames([baseStyle, styles.handleSE])} onMouseDown={startResizeSE} />\n      <div class={classNames([baseStyle, styles.handleSW])} onMouseDown={startResizeSW} />\n      <div class={classNames([baseStyle, styles.handleNW])} onMouseDown={startResizeNW} />\n    </>\n  );\n}\n"],"names":["ResizeEdge","onResize","onResizeStart","onResizeEnd","containerRef","constraints","isResizing","useRef","resizingEdge","NONE","startPosition","initialParentClientRect","x","y","width","height","initialMousePosition","constrainRect","useCallback","srcRect","elem","current","result","containingBlock","getContainingBlockElem","boundingRect","getBoundingClientRect","dialogRect","limitLeft","left","limitTop","top","limitRight","right","window","innerWidth","limitBottom","bottom","innerHeight","minHeight","maxHeight","minWidth","maxWidth","getNewRect","event","N","pageY","E","pageX","S","W","NE","SE","SW","NW","newRect","handleResize","stopPropagation","preventDefault","endResize","document","removeEventListener","startResize","currentTarget","parentElement","pos","element","curLeft","curTop","offsetParent","offsetLeft","offsetTop","findPos","addEventListener","_jsxs","_Fragment","children","_jsx","class","classNames","baseStyle","styles","handleN","onMouseDown","handleE","handleS","handleW","jsx","handleNE","handleSE","handleSW","handleNW"],"mappings":"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"}