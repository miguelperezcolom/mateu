{"version":3,"file":"PRIVATE_ListCardCommon.js","sources":["../../src/PRIVATE_ListCardCommon/useCurrentItemOverride.ts"],"sourcesContent":["import { useRef, useMemo, useState, useEffect } from 'preact/hooks';\nimport { CurrentItemProps, CurrentKeyDetail, Item } from '../UNSAFE_Collection';\nimport { useReorderableContext } from '../hooks/PRIVATE_useReorderable/useReorderableContext';\n\n/**\n * This hook converts the new API (i.e. currentItemOverride and onPersistCurrentItem) back to\n * the old API (i.e. currentKey and onCurrentKeyChange), keeps the internal current item, and\n * also triggers an update when a new currentItemOverride is passed by the app\n *\n * @param currentItemOverride\n * @param onPersistCurrentItem\n */\nexport const useCurrentItemOverride = <K extends string | number>(\n  currentItemOverride: CurrentItemProps<K>['currentItemOverride'],\n  onPersistCurrentItem: CurrentItemProps<K>['onPersistCurrentItem']\n) => {\n  // the internal state of current item\n  const [currentItem, setCurrentItem] = useState<Item<K>>();\n  // track the currentItemOverride props\n  const currentItemOverrideRef = useRef<Item<K>>();\n  // whether the current item is overridden by the app\n  const isCurrentItemOverridden = useRef(false);\n\n  // if reorder is enabled, need to update the context here when current item is changed\n  const reorderContext = useReorderableContext();\n\n  // intercept onPersistCurrentItem calls to ensure internal state is updated appropriately\n  const handleCurrentItemChanged = useMemo(() => {\n    return (detail: CurrentKeyDetail<K>) => {\n      const rowKey = detail.value;\n      setCurrentItem({ rowKey });\n      onPersistCurrentItem?.(detail);\n      if (reorderContext?.currentItemKey != null) {\n        reorderContext.currentItemKey.current = rowKey;\n      }\n    };\n  }, [onPersistCurrentItem, reorderContext?.currentItemKey]);\n\n  // ensure any new currentItemOverride settings are applied only on that render\n  // (same as how Table handles the changes)\n  if (currentItemOverrideRef.current !== currentItemOverride) {\n    currentItemOverrideRef.current = currentItemOverride;\n    if (currentItem?.rowKey !== currentItemOverride?.rowKey) {\n      isCurrentItemOverridden.current = true;\n      handleCurrentItemChanged({ value: currentItemOverride?.rowKey as K });\n    }\n  }\n\n  useEffect(() => {\n    isCurrentItemOverridden.current = false;\n  });\n\n  return {\n    currentKey: currentItem?.rowKey,\n    onCurrentKeyChange: handleCurrentItemChanged,\n    isCurrentItemOverridden: isCurrentItemOverridden.current\n  };\n};\n"],"names":["currentItemOverride","onPersistCurrentItem","currentItem","setCurrentItem","useState","currentItemOverrideRef","useRef","isCurrentItemOverridden","reorderContext","useReorderableContext","handleCurrentItemChanged","useMemo","detail","rowKey","value","currentItemKey","current","useEffect","currentKey","onCurrentKeyChange"],"mappings":"yKAYsC,CACpCA,EACAC,KAGA,MAAOC,EAAaC,GAAkBC,EAAQA,WAExCC,EAAyBC,EAAAA,SAEzBC,EAA0BD,UAAO,GAGjCE,EAAiBC,EAAAA,wBAGjBC,EAA2BC,EAAAA,SAAQ,IAC/BC,IACN,MAAMC,EAASD,EAAOE,MACtBX,EAAe,CAAEU,WACjBZ,IAAuBW,GACe,MAAlCJ,GAAgBO,iBAClBP,EAAeO,eAAeC,QAAUH,EACzC,GAEF,CAACZ,EAAsBO,GAAgBO,iBAgB1C,OAZIV,EAAuBW,UAAYhB,IACrCK,EAAuBW,QAAUhB,EAC7BE,GAAaW,SAAWb,GAAqBa,SAC/CN,EAAwBS,SAAU,EAClCN,EAAyB,CAAEI,MAAOd,GAAqBa,WAI3DI,EAAAA,WAAU,KACRV,EAAwBS,SAAU,CAAK,IAGlC,CACLE,WAAYhB,GAAaW,OACzBM,mBAAoBT,EACpBH,wBAAyBA,EAAwBS,QAClD"}