{"version":3,"file":"useCurrentKey-2f1ca19e.js","sources":["../../src/hooks/PRIVATE_useCurrentKey/useCurrentKey.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback } from 'preact/hooks';\nimport { isKeyDefined } from '../../utils/UNSAFE_keys';\nimport { CurrentKeyDetail } from '../../UNSAFE_Collection';\nimport { useUser } from '../UNSAFE_useUser';\n\n/**\n * Hook for handling current key update due to user interaction including keyboard navigation.\n * This can be reuse by all Collection components.\n *\n * @param keyExtractor function to extract the key based on the provided element\n * @param allowShiftKey if set to false, then pressing arrow key while shift key is down will not change the current key\n * @param getVerticalPrevKey function to get the previous key in the vertical direction based on the current key\n * @param getVerticalNextKey function to get the next key in the vertical direction based on the current key\n * @param getHorizontalPrevKey function to get the previous key in the horizontal direction based on the current key\n * @param getHorizontalNextKey function to get the next key based on the current key\n * @param currentKey the current key\n * @param onCurrentChange function to invoke if the current key has changed\n * @param keyComparator an optional function to compare keys, otherwise === is used\n * @returns\n */\nexport function useCurrentKey<K>(\n  keyExtractor: (element: HTMLElement) => K | null,\n  allowShiftKey: boolean,\n  getVerticalPrevKey?: () => K | null,\n  getVerticalNextKey?: () => K | null,\n  getHorizontalPrevKey?: () => K | null,\n  getHorizontalNextKey?: () => K | null,\n  currentKey?: K,\n  onChange?: (detail: CurrentKeyDetail<K>) => void,\n  keyComparator?: (key1: K, key2: K) => boolean\n) {\n  const { direction } = useUser();\n\n  const keyEquals = useCallback(\n    (key1: K, key2: K) => {\n      if (keyComparator) {\n        return keyComparator(key1, key2);\n      }\n      return key1 === key2;\n    },\n    [keyComparator]\n  );\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (onChange && isKeyDefined(currentKey)) {\n        const isRtl = direction === 'rtl';\n        const keyHandlers: Record<string, (() => K | null) | undefined> = {\n          ArrowUp: getVerticalPrevKey,\n          ArrowDown: getVerticalNextKey,\n          ArrowLeft: isRtl ? getHorizontalNextKey : getHorizontalPrevKey,\n          ArrowRight: isRtl ? getHorizontalPrevKey : getHorizontalNextKey\n        };\n\n        // should not update currentKey during keyboard reordering\n        if (\n          Object.keys(keyHandlers).includes(event.key) &&\n          (allowShiftKey || !event.shiftKey) &&\n          !event.metaKey &&\n          !event.ctrlKey\n        ) {\n          const newKey = keyHandlers[event.key]?.();\n          if (isKeyDefined(newKey) && !keyEquals(currentKey as K, newKey as K)) {\n            onChange({ value: newKey as K });\n          }\n          event.preventDefault();\n        }\n      }\n    },\n    [\n      currentKey,\n      onChange,\n      getVerticalPrevKey,\n      getVerticalNextKey,\n      getHorizontalPrevKey,\n      getHorizontalNextKey,\n      keyEquals,\n      allowShiftKey,\n      direction\n    ]\n  );\n\n  const onClickCapture = useCallback(\n    (event: MouseEvent) => {\n      if (onChange && (allowShiftKey || !event.shiftKey)) {\n        const nextKey = keyExtractor(event.target as HTMLElement);\n        if (isKeyDefined(nextKey) && !keyEquals(currentKey as K, nextKey as K)) {\n          onChange({ value: nextKey as K });\n        }\n      }\n    },\n    [currentKey, allowShiftKey, keyExtractor, onChange, keyEquals]\n  );\n\n  const currentKeyProps = onChange == null ? {} : { onClickCapture, onKeyDown };\n  return { currentKeyProps };\n}\n"],"names":["keyExtractor","allowShiftKey","getVerticalPrevKey","getVerticalNextKey","getHorizontalPrevKey","getHorizontalNextKey","currentKey","onChange","keyComparator","direction","useUser","keyEquals","useCallback","key1","key2","onKeyDown","event","isKeyDefined","isRtl","keyHandlers","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Object","keys","includes","key","shiftKey","metaKey","ctrlKey","newKey","value","preventDefault","onClickCapture","nextKey","target","currentKeyProps"],"mappings":"kIA4BEA,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMC,UAAEA,GAAcC,EAAAA,UAEhBC,EAAYC,EAAAA,aAChB,CAACC,EAASC,IACJN,EACKA,EAAcK,EAAMC,GAEtBD,IAASC,GAElB,CAACN,IAGGO,EAAYH,eACfI,IACC,GAAIT,GAAYU,eAAaX,GAAa,CACxC,MAAMY,EAAsB,QAAdT,EACRU,EAA4D,CAChEC,QAASlB,EACTmB,UAAWlB,EACXmB,UAAWJ,EAAQb,EAAuBD,EAC1CmB,WAAYL,EAAQd,EAAuBC,GAI7C,GACEmB,OAAOC,KAAKN,GAAaO,SAASV,EAAMW,OACvC1B,IAAkBe,EAAMY,YACxBZ,EAAMa,UACNb,EAAMc,QACP,CACA,MAAMC,EAASZ,EAAYH,EAAMW,SAC7BV,EAAAA,aAAac,KAAYpB,EAAUL,EAAiByB,IACtDxB,EAAS,CAAEyB,MAAOD,IAEpBf,EAAMiB,gBACP,CACF,IAEH,CACE3B,EACAC,EACAL,EACAC,EACAC,EACAC,EACAM,EACAV,EACAQ,IAIEyB,EAAiBtB,eACpBI,IACC,GAAIT,IAAaN,IAAkBe,EAAMY,UAAW,CAClD,MAAMO,EAAUnC,EAAagB,EAAMoB,QAC/BnB,EAAAA,aAAakB,KAAaxB,EAAUL,EAAiB6B,IACvD5B,EAAS,CAAEyB,MAAOG,GAErB,IAEH,CAAC7B,EAAYL,EAAeD,EAAcO,EAAUI,IAItD,MAAO,CAAE0B,gBAD2B,MAAZ9B,EAAmB,CAAE,EAAG,CAAE2B,iBAAgBnB,aAEpE"}