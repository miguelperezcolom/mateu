{"version":3,"file":"useFocusWithin-5a504fca.js","sources":["../../src/hooks/UNSAFE_useFocusWithin/useFocusWithin.ts"],"sourcesContent":["import { useCallback, useRef, useState } from 'preact/hooks';\n\ntype FocusEvents = {\n  onBlurWithin?: (e: FocusEvent) => void;\n  onFocusWithin?: (e: FocusEvent) => void;\n};\n\ntype UseFocusWithinProps = FocusEvents & {\n  isDisabled?: boolean;\n};\n\nexport function useFocusWithin({\n  isDisabled,\n  onBlurWithin,\n  onFocusWithin\n}: UseFocusWithinProps = {}) {\n  const [isFocused, setIsFocused] = useState(false);\n  // Maintain a ref for whether we're focused so that we can update it synchronously and check\n  // it in the listeners.  It's possible for an element to receive and lose focus before\n  // the next render happens, in which case the isFocused state hasn't been updated yet for\n  // the focusin event.  The focusout listener would not do anything based on that stale state,\n  // which would result in the isFocused state incorrectly remaining true.\n  // We still need the isFocused state because that state change will trigger a rerender,\n  // whereas updating the ref will not.\n  const isFocusedRef = useRef(false);\n  const onFocusIn = useCallback(\n    (event: FocusEvent) => {\n      if (!isFocusedRef.current) {\n        onFocusWithin?.(event);\n        setIsFocused(true);\n        isFocusedRef.current = true;\n      }\n    },\n    [onFocusWithin]\n  );\n  const onFocusOut = useCallback(\n    (event: FocusEvent) => {\n      // Trigger focus event changes only when the focus goes outside of the current\n      // target. Ignore focus changes within the current target\n      if (\n        isFocusedRef.current &&\n        (event.relatedTarget == null ||\n          !(event.currentTarget as HTMLElement).contains(event.relatedTarget as HTMLElement))\n      ) {\n        onBlurWithin?.(event);\n        setIsFocused(false);\n        isFocusedRef.current = false;\n      }\n    },\n    [onBlurWithin]\n  );\n\n  return isDisabled\n    ? {\n        isFocused: false,\n        focusProps: {}\n      }\n    : {\n        isFocused,\n        focusProps: {\n          onFocusIn,\n          onFocusOut\n        }\n      };\n}\n"],"names":["isDisabled","onBlurWithin","onFocusWithin","isFocused","setIsFocused","useState","isFocusedRef","useRef","onFocusIn","useCallback","event","current","onFocusOut","relatedTarget","currentTarget","contains","focusProps"],"mappings":"+EAWM,UAAyBA,WAC7BA,EAAUC,aACVA,EAAYC,cACZA,GACuB,CAAA,GACvB,MAAOC,EAAWC,GAAgBC,EAAQA,UAAC,GAQrCC,EAAeC,UAAO,GACtBC,EAAYC,eACfC,IACMJ,EAAaK,UAChBT,IAAgBQ,GAChBN,GAAa,GACbE,EAAaK,SAAU,EACxB,GAEH,CAACT,IAEGU,EAAaH,eAChBC,KAIGJ,EAAaK,SACW,MAAvBD,EAAMG,eACHH,EAAMI,cAA8BC,SAASL,EAAMG,iBAEvDZ,IAAeS,GACfN,GAAa,GACbE,EAAaK,SAAU,EACxB,GAEH,CAACV,IAGH,OAAOD,EACH,CACEG,WAAW,EACXa,WAAY,CAAE,GAEhB,CACEb,YACAa,WAAY,CACVR,YACAI,cAGV"}