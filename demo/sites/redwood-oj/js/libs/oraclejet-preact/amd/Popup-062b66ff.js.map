{"version":3,"file":"Popup-062b66ff.js","sources":["../../src/UNSAFE_Popup/PopupSkipLink.tsx","../../src/UNSAFE_Popup/Popup.tsx"],"sourcesContent":["import { JSX } from 'preact';\nimport { useRef } from 'preact/hooks';\nimport { HiddenAccessible } from '../UNSAFE_HiddenAccessible';\n\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\n\ntype SkipLinkProps = IntrinsicProps & {\n  message?: string;\n  callback?: () => void;\n};\n\nexport function PopupSkipLink({ message, callback }: SkipLinkProps) {\n  const hiddenAccessibleRef = useRef<HTMLDivElement | null>(null);\n\n  const handleKey = (event: KeyboardEvent) => {\n    // Prevent click generated from an \"enter\" key press by eating the event.\n    // This could only happen in some kind of simulator as this skip link is only used on the iOS platform.\n    if (event.code === 'Enter') {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  };\n\n  return (\n    <div ref={hiddenAccessibleRef}>\n      <HiddenAccessible>\n        <a\n          onClick={callback}\n          tabIndex={-1}\n          href=\"#\"\n          role=\"button\"\n          onKeyDown={handleKey}\n          onKeyUp={handleKey}\n          onKeyPress={handleKey}>\n          {message}\n        </a>\n      </HiddenAccessible>\n    </div>\n  );\n}\n","import type { JSX, RefObject } from 'preact';\nimport { useState, useEffect, useLayoutEffect, useMemo, useRef, useCallback } from 'preact/hooks';\nimport { Floating, Offset, Placement, Coords, FlipOptions, ShiftOptions } from '../UNSAFE_Floating';\nimport {\n  FocusableElement,\n  focusOn,\n  focusWithin,\n  getActiveElement\n} from '../utils/PRIVATE_tabbableUtils';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { Layer } from '../UNSAFE_Layer';\nimport { Modal } from '../UNSAFE_Modal';\nimport { WindowOverlay, WindowOverlayPlacement } from '../UNSAFE_WindowOverlay';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\nimport { usePopupAnimation } from './usePopupAnimation';\nimport { AnimationStatus } from '../hooks/PRIVATE_useAnimationStatus';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { LiveRegion } from '../UNSAFE_LiveRegion';\nimport { PopupSkipLink } from './PopupSkipLink';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '../resources/nls/bundle';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { popupVars } from './themes/PopupContract.css';\nimport { getVarName } from '@oracle/oraclejet-internal-utilities/stringUtils';\nimport { Property } from 'csstype';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { PopupRedwoodTheme } from './themes/redwood/PopupTheme';\nimport { dimensionInterpolations, DimensionProps } from '../utils/UNSAFE_interpolations/dimensions';\nimport { colorInterpolations, ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\n\nimport type { UnsafeDomHandle } from '#utils/UNSAFE_unsafeDomAccess';\nimport { UNSAFE_DOM_ACCESS } from '#utils/UNSAFE_unsafeDomAccess';\n\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\n\nexport type PopupPlacement = Placement | WindowOverlayPlacement;\nexport type OnCloseDetail = {\n  reason: 'escapeKey' | 'closeSkipLink';\n};\nexport type InitialFocus = 'auto' | 'none' | 'popup' | 'firstFocusable';\nexport type Tail = 'none' | 'simple';\nexport type Modality = 'modal' | 'modeless';\nexport type Variant = 'standard' | 'unstyled';\n\ntype Props = IntrinsicProps &\n  Pick<ColorProps, 'backgroundColor'> &\n  DimensionProps &\n  TestIdProps & {\n    /**\n     * Specifies whether the Popup is open.\n     */\n    isOpen: boolean;\n    /**\n     * Specifies Popup's anchor. Popup is placed relatively to its anchor.\n     */\n    anchorRef?: RefObject<Element | Coords | UnsafeDomHandle<Element>>;\n    /**\n     * Specifies Popup's launcher. After Popup closes, it returns focus to the launcher.\n     */\n    launcherRef?: RefObject<HTMLElement>;\n    /**\n     * Specifies placement of the Popup relative to the anchor.\n     */\n    placement?: PopupPlacement;\n    /**\n     * Specifies displacement of the Popup from the anchor element along the specified axes.\n     * The offset object consists of mainAxis and crossAxis properties. The direction in which these properties\n     * are applied depends on the current value of the position property.\n     *\n     * The <code>mainAxis</code> property represents the distance between the Popup and the anchor.\n     * The <code>crossAxis</code> property represents the deviation in the opposite axis to the main axis - the skidding between the Popup and the anchor.\n     */\n    offset?: Offset;\n    /**\n     * Specifies modality of the Popup.\n     */\n    modality?: Modality;\n    /**\n     * Specifies whether a floating Popup changes placement to the opposite side to be kept in view when a collision is detected.\n     *\n     * The flipOptions object consists of mainAxis and crossAxis properties.\n     * The <code>mainAxis</code> runs along the side of the Popup element.\n     * The <code>crossAxis</code> runs along the alignment of the Popup element.\n     */\n    flipOptions?: FlipOptions;\n    /**\n     * Specifies whether a floating Popup shifts along axis to be kept in view when a collision is detected.\n     * Note that if both 'flip' and 'shift' are enabled on respective axis, the flip will take precedence.\n     *\n     * The shiftOptions object consists of mainAxis and crossAxis properties.\n     * The <code>mainAxis</code> runs along the side of the Popup element.\n     * The <code>crossAxis</code> runs along the alignment of the Popup element.\n     */\n    shiftOptions?: ShiftOptions;\n    /**\n     * Specifies if the Popup sets focus to its content when initially open.\n     * A value of none prevents the popup from setting focus when open.\n     *\n     * <code>auto</code> in modeless mode resolves to none.\n     * <code>none</code> prevents the popup from setting focus when open.\n     * <code>popup</code> sets focus to the root popup container (good choice for touch platforms).\n     * <code>firstFocusable</code> defines that a popup should set focus to the first focusable element within the popup's content.\n     */\n    initialFocus?: InitialFocus;\n    /**\n     * Specifies callback triggered when a user clicks outside Popup.\n     */\n    onClickOutside?: (event: MouseEvent) => void;\n    /**\n     * Specifies callback triggered when a user tries to close a Popup through UI interaction.\n     * The parent should listen to this event and close the Popup. If the parent fails to remove\n     * the Popup, then no change will be done in the UI by the component.\n     */\n    onClose?: (detail: OnCloseDetail) => void;\n    /**\n     * Specifies callback triggered when initial focus is set or when Popup receives it via F6 key.\n     */\n    onFocusSet?: () => void;\n    /**\n     * Specifies Popup's tail. Simple tail is an arrow pointing to Popup's anchor.\n     */\n    tail?: Tail;\n    /**\n     * Specifies callback triggered after the animation ends.\n     */\n    onTransitionEnd?: (value: boolean) => void;\n    /**\n     * Specifies styling variant. If <code>unstyled</code> is set, standard styles are not applied.\n     */\n    variant?: Variant;\n    /**\n     * Specifies the ARIA role type.\n     */\n    role?: UnpackSignals<JSX.HTMLAttributes['role']>;\n    /**\n     * Specifies guidance for screen readers.\n     */\n    'aria-label'?: string;\n    /**\n     * Specifies ID of an element used for guidance for screen readers.\n     */\n    'aria-labelledby'?: string;\n    /**\n     * Specifies ID of an element (or space separated IDs of multiple elements) that\n     * describes the Drawer.\n     */\n    'aria-describedby'?: string;\n  };\n\n/**\n * A popup temporarily 'pops up' content in the foreground.\n */\nexport const Popup = forwardRef(\n  (\n    {\n      anchorRef,\n      launcherRef,\n      children,\n      isOpen = false,\n      modality = 'modeless',\n      offset = { mainAxis: 0, crossAxis: 0 },\n      flipOptions = { mainAxis: true, crossAxis: true },\n      shiftOptions = { mainAxis: false, crossAxis: false },\n      onClickOutside,\n      onClose,\n      initialFocus = 'auto',\n      placement = anchorRef ? 'top' : 'center',\n      tail = 'none',\n      onTransitionEnd,\n      onFocusSet,\n      variant = 'standard',\n      role = 'dialog',\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      testId,\n      ...props\n    }: Props,\n    ref: ForwardedRef<HTMLElement | null>\n  ) => {\n    const localLauncherRef = useRef<HTMLElement | null>(null);\n    const [popupBgColor, setPopupBgColor] = useState<Property.BackgroundColor>();\n\n    const contentWrapperRef = useRef<HTMLDivElement | null>(null);\n\n    const prevStatusRef = useRef<AnimationStatus>('unmounted');\n\n    // testId support\n    const testIdProps = useTestId(testId);\n\n    const insideRefs: RefObject<HTMLElement>[] = [contentWrapperRef];\n    // launcher should be considered an \"inside\" element\n    if (localLauncherRef.current && localLauncherRef.current !== document.body) {\n      insideRefs.push(localLauncherRef);\n    }\n\n    const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n    const isModal = useCallback(() => {\n      return modality === 'modal';\n    }, [modality]);\n\n    // We can not merge outsideClick to onClose event with {reason: 'outsideClick'} payload\n    // The reason is that we allow outsideClick/autodismiss in modeless mode and\n    // we need to detect outsideClick which is\n    useOutsideClick({\n      isDisabled: !(isOpen && contentWrapperRef.current),\n      ref: insideRefs,\n      handler: (event) => {\n        onClickOutside?.(event);\n      }\n    });\n\n    const launcherKeyDownCallback = useCallback(\n      (event: KeyboardEvent): void => {\n        if (localLauncherRef.current === getActiveElement() && event.code === 'F6' && !isModal()) {\n          // Prevent default F6 handlers.\n          // F6 is a standard Chrome address bar shortcut on Windows.\n          event.preventDefault();\n          event.stopPropagation();\n\n          focusWithin(contentWrapperRef.current as HTMLElement);\n          onFocusSet?.();\n        }\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [isModal]\n    );\n\n    const _onTransitionEnd = (isOpen: boolean) => {\n      if (isOpen) {\n        setInitialFocus();\n        onTransitionEnd?.(true);\n      } else {\n        onTransitionEnd?.(false);\n      }\n    };\n\n    // Animation\n    const { setAnimationElementRef, status, onPosition } = usePopupAnimation({\n      isOpen,\n      isAnimatedOnMount: true,\n      onTransitionEnd: _onTransitionEnd,\n      placement: placement\n    });\n\n    const stableRef = useMemo(() => mergeRefs(contentWrapperRef, ref), [contentWrapperRef, ref]);\n\n    const returnFocus = useCallback((): void => {\n      // Try to return focus to 1.launcher or 2.anchor\n      const launcherEl = localLauncherRef.current;\n      const anchor = anchorRef?.current;\n\n      if (launcherEl) {\n        focusOn(launcherEl);\n      } else if (anchor) {\n        let anchorElement: FocusableElement | null = null;\n\n        // Checking instanceof to avoid Coords type that can not be focused\n        if (anchor instanceof Element) {\n          anchorElement = anchor as FocusableElement;\n        } else if ((anchor as UnsafeDomHandle)[UNSAFE_DOM_ACCESS]) {\n          anchorElement = (anchor as UnsafeDomHandle)[UNSAFE_DOM_ACCESS];\n        }\n\n        if (anchorElement) {\n          focusOn(anchorElement);\n        }\n      }\n    }, [localLauncherRef, anchorRef]);\n\n    useEffect(() => {\n      // Init closing\n      if (!isOpen && status === 'opening' && !isModal()) {\n        // Only actively return focus to the launcher or anchor if the popup contained focus.\n        // Otherwise, focus is already elsewhere on the page and should not be forced back\n        // because that could reopen the popup again, which essentially prevents the user from\n        // moving focus out of the launcher.\n        if (contentWrapperRef.current?.contains(getActiveElement())) {\n          returnFocus();\n        }\n      }\n      // JET-71010 - for modal popups, the focus cannot be moved until the modal overlay is gone\n      else if (!isOpen && status === 'unmounted' && isModal()) {\n        // avoid returning focus on initial render\n        if (status !== prevStatusRef.current) {\n          returnFocus();\n        }\n      }\n      return () => {\n        prevStatusRef.current = status;\n      };\n    }, [isOpen, status, returnFocus, isModal]);\n\n    // Initialize launcher\n    useEffect(() => {\n      if (isOpen) {\n        if (!launcherRef?.current) {\n          // 1. If launcher is not defined, most frequent scenario is,\n          // that element, that has focus before opening a popup is considered launcher\n          localLauncherRef.current = getActiveElement() as HTMLElement;\n        } else if (launcherRef.current instanceof Element) {\n          // 2. launcherRef element was provided.\n          // Verify, if it exists in DOM, otherwise use the last active element\n          localLauncherRef.current = document.body.contains(launcherRef.current)\n            ? launcherRef.current\n            : (getActiveElement() as HTMLElement);\n        } else {\n          localLauncherRef.current = getActiveElement() as HTMLElement;\n        }\n        // Register F6 key handler to enter the Popup\n        localLauncherRef.current?.addEventListener('keydown', launcherKeyDownCallback);\n      }\n      return () => {\n        // Deregister F6 key handler\n        localLauncherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);\n      };\n    }, [isOpen, launcherRef, launcherKeyDownCallback]);\n    // Note: unlike oj-c-popup we do not default anchorRef to launcherRef in Preact Popup\n    // If anchorRef is undefined, we use WindowOverlay as anchor\n\n    const setInitialFocus = () => {\n      let derivedInitialFocus = initialFocus;\n      if (initialFocus === 'auto') {\n        if (isModal()) {\n          // modal mode - set focus to first focusable\n          derivedInitialFocus = 'firstFocusable';\n        } else {\n          // modeless mode - do not steal focus by default\n          derivedInitialFocus = 'none';\n        }\n      }\n\n      // Case: 'popup'\n      // Focus on Popup container\n      if (derivedInitialFocus === 'popup') {\n        focusOn(contentWrapperRef.current as HTMLElement);\n        onFocusSet?.();\n      }\n\n      // Case: 'firstFocusable'\n      // Focus on first tabbable in the Popup container or container itself if there is none\n      if (derivedInitialFocus === 'firstFocusable') {\n        focusWithin(contentWrapperRef.current as HTMLElement);\n        onFocusSet?.();\n      }\n    };\n\n    const getMainAxisOffset = (offset?: Offset) => {\n      let calcOffset = 0;\n      if (offset) {\n        // @ts-ignore as OffsetFunction is going to be removed\n        // Property 'mainAxis' does not exist on type 'OffsetFunction'.\n        calcOffset = typeof offset === 'number' ? offset : offset.mainAxis || 0;\n        if (tail === 'simple') {\n          calcOffset += 5;\n        }\n      }\n      return calcOffset;\n    };\n\n    const getCrossAxisOffset = (offset?: Offset) => {\n      if (!offset) {\n        return 0;\n      } else {\n        // @ts-ignore as OffsetFunction is going to be removed\n        // Property 'crossAxis' does not exist on type 'OffsetFunction'.\n        return typeof offset === 'number' ? 0 : offset.crossAxis || 0;\n      }\n    };\n\n    const finalOffset = {\n      mainAxis: getMainAxisOffset(offset),\n      crossAxis: getCrossAxisOffset(offset)\n    };\n\n    const handlePopupKeyDown = (event: KeyboardEvent) => {\n      const currentlyFocusedEl = getActiveElement();\n      const wrapperEl = contentWrapperRef.current;\n      const launcherEl = localLauncherRef.current;\n      if (wrapperEl === currentlyFocusedEl || wrapperEl?.contains(currentlyFocusedEl)) {\n        switch (event.code) {\n          case 'Escape': {\n            // Trigger onClose event with outside click detail\n            onClose?.({ reason: 'escapeKey' });\n            break;\n          }\n          case 'F6':\n            // Prevent default F6 handlers.\n            // F6 is a standard Chrome address bar shortcut on Windows.\n            event.preventDefault();\n            event.stopPropagation();\n\n            // Focus launcher\n            if (launcherEl && !isModal()) {\n              focusOn(launcherEl);\n            }\n            break;\n        }\n      }\n    };\n\n    useLayoutEffect(() => {\n      if (\n        status === 'unmounted' ||\n        contentWrapperRef.current == null ||\n        popupBgColor != null ||\n        tail === 'none'\n      )\n        return;\n\n      const backgroundColorVar = getVarName(popupVars.backgroundColor);\n      const computedStyle = getComputedStyle(contentWrapperRef.current!);\n      setPopupBgColor(props.backgroundColor || computedStyle.getPropertyValue(backgroundColorVar));\n    }, [status, contentWrapperRef, popupBgColor, tail, props.backgroundColor]);\n\n    const clientHints = getClientHints();\n    const isVOSupported = ['ios', 'android'].indexOf(clientHints.platform) > -1;\n    // Note: Popup does not have 'open' status. It is 'opening' even when open.\n    const renderVOSupport = status === 'opening';\n\n    // Styles\n    const { baseTheme, classes } = useComponentTheme(PopupRedwoodTheme);\n    const isMounted = status !== 'unmounted';\n\n    const interpolations = [\n      ...Object.values(dimensionInterpolations),\n      ...Object.values(colorInterpolations)\n    ];\n    const styleInterpolations = mergeInterpolations<DimensionProps & ColorProps>(interpolations);\n    const { ...styles } = styleInterpolations(props);\n\n    const closeSkipLinkCallback = () => {\n      // Trigger onClose event with outside click detail\n      onClose?.({ reason: 'closeSkipLink' });\n    };\n\n    const renderPopup = () => {\n      return (\n        <>\n          <FocusTrap restoreFocusRef={false}>\n            {/*Setting restoreFocusRef to false because otherwise FocusTrap is stealing the focus back when :*/}\n            {/*we click outside of modeless Popup (that keeps being open).*/}\n            <div\n              ref={stableRef}\n              tabIndex={-1}\n              role={role}\n              className={classNames([baseTheme, variant === 'unstyled' ? null : classes])}\n              style={styles}\n              onKeyDown={handlePopupKeyDown}\n              aria-label={ariaLabel}\n              aria-labelledby={ariaLabelledBy}\n              aria-describedby={ariaDescribedBy}\n              {...testIdProps}>\n              {/* Acc: Close SkipLink */}\n              {!isModal() && isVOSupported && renderVOSupport && (\n                <PopupSkipLink\n                  callback={closeSkipLinkCallback}\n                  message={`${translations.popup_close_skipLink}`}></PopupSkipLink>\n              )}\n              {children}\n            </div>\n          </FocusTrap>\n\n          {/* Acc: LiveRegion */}\n          {!isModal() &&\n            // Render on non-mobile only.\n            !isVOSupported && (\n              <LiveRegion>\n                {`${\n                  ['auto', 'none'].indexOf(initialFocus) != -1\n                    ? translations.popup_liveRegion_F6_initial_focus_none\n                    : translations.popup_liveRegion_F6_initial_focus_firstFocusable\n                }`}\n              </LiveRegion>\n            )}\n        </>\n      );\n    };\n\n    const renderFloatingOrOverlayPopup = () => {\n      if (!anchorRef || !anchorRef.current) {\n        return (\n          <WindowOverlay placement={placement as WindowOverlayPlacement} offset={finalOffset}>\n            <div ref={setAnimationElementRef}>{renderPopup()}</div>\n          </WindowOverlay>\n        );\n      } else {\n        return (\n          <Floating\n            ref={setAnimationElementRef}\n            backgroundColor={popupBgColor}\n            anchorRef={anchorRef}\n            placement={placement as Placement}\n            offsetValue={finalOffset}\n            flipOptions={flipOptions}\n            shiftOptions={shiftOptions}\n            tail={tail}\n            onPosition={onPosition}>\n            {renderPopup()}\n          </Floating>\n        );\n      }\n    };\n\n    if (isMounted) {\n      if (isModal()) {\n        return <Modal isOpen={isMounted}>{renderFloatingOrOverlayPopup()}</Modal>;\n      } else {\n        return <Layer>{renderFloatingOrOverlayPopup()}</Layer>;\n      }\n    } else return null;\n  }\n);\n"],"names":["PopupSkipLink","message","callback","hiddenAccessibleRef","useRef","handleKey","event","code","stopPropagation","preventDefault","_jsx","ref","children","jsx","HiddenAccessible","onClick","tabIndex","href","role","onKeyDown","onKeyUp","onKeyPress","Popup","forwardRef","anchorRef","launcherRef","isOpen","modality","offset","mainAxis","crossAxis","flipOptions","shiftOptions","onClickOutside","onClose","initialFocus","placement","tail","onTransitionEnd","onFocusSet","variant","ariaLabel","ariaLabelledBy","ariaDescribedBy","testId","props","localLauncherRef","popupBgColor","setPopupBgColor","useState","contentWrapperRef","prevStatusRef","testIdProps","useTestId","insideRefs","current","document","body","push","translations","useTranslationBundle","isModal","useCallback","useOutsideClick","isDisabled","handler","launcherKeyDownCallback","getActiveElement","focusWithin","setAnimationElementRef","status","onPosition","usePopupAnimation","isAnimatedOnMount","setInitialFocus","stableRef","useMemo","mergeRefs","returnFocus","launcherEl","anchor","focusOn","anchorElement","Element","UNSAFE_DOM_ACCESS","useEffect","contains","addEventListener","removeEventListener","derivedInitialFocus","finalOffset","calcOffset","getMainAxisOffset","getCrossAxisOffset","handlePopupKeyDown","currentlyFocusedEl","wrapperEl","reason","useLayoutEffect","backgroundColorVar","getVarName","popupVars","backgroundColor","computedStyle","getComputedStyle","getPropertyValue","clientHints","getClientHints","isVOSupported","indexOf","platform","renderVOSupport","baseTheme","classes","useComponentTheme","PopupRedwoodTheme","isMounted","interpolations","Object","values","dimensionInterpolations","colorInterpolations","styleInterpolations","mergeInterpolations","styles","closeSkipLinkCallback","renderPopup","_jsxs","FocusTrap","restoreFocusRef","className","classNames","style","popup_close_skipLink","LiveRegion","popup_liveRegion_F6_initial_focus_none","popup_liveRegion_F6_initial_focus_firstFocusable","renderFloatingOrOverlayPopup","Floating","offsetValue","WindowOverlay","Modal","Layer"],"mappings":"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"}