;
define("corepackbundle", function(){});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/UNSAFE_vizUtils/TemplateHandler',["require", "exports", "preact/compat"], function (require, exports, compat_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.processTemplate = exports.processNodeTemplate = void 0;
    const PRIVATE_VALUE_KEY = '__oj_private_do_not_use_value';
    const PRIVATE_CHECKED_KEY = '__oj_private_do_not_use_checked';
    /**
     * Utility method used by resolveVDomTemplateProps() on TemplateEngine to resolve
     * properties for DVT component templates. The method converts both name and value
     * of private props ('value' and 'checked') into its original form.
     * @param prop
     * @param value
     * @returns
     */
    const convertPrivatePropFromPreact = (prop, value) => {
        // TODO: clean up as part of JET-67994
        if (prop === PRIVATE_VALUE_KEY) {
            return { prop: 'value', value: typeof value !== 'symbol' ? value : undefined }; // if a symbol do undefined.
            // check if in preact we are are getting symbol for null values
        }
        if (prop === PRIVATE_CHECKED_KEY) {
            return { prop: 'checked', value: typeof value !== 'symbol' ? value : undefined };
        }
        return { prop, value };
    };
    /**
     * Convert the prop key to camel case.
     * @param prop The prop of the resolved template.
     * Could be in following formats : BORDER-COLOR, DRILLING, borderColor, drilling
     * @returns
     */
    const getValidProp = (prop) => {
        return prop[0].toLowerCase() !== prop[0]
            ? prop.toLowerCase().replace(/-./g, (c) => c[1].toUpperCase())
            : prop;
    };
    /**
     * Resolve the props of the vnode.
     * @param props
     * @returns
     */
    const resolveProps = (props) => {
        return Object.keys(props).reduce((resolvedProps, origProp) => {
            if (origProp === 'children')
                return resolvedProps;
            const { prop, value } = convertPrivatePropFromPreact(origProp, props[origProp]); // TODO: clean up as part of JET-67994
            resolvedProps[getValidProp(prop)] = value;
            return resolvedProps;
        }, {});
    };
    /**
     * @param datum The datum from data provider.
     * @param template The template slot.
     * @param getContext The function that returns template context.
     * @param templateName The name of the template element.
     * @returns
     */
    const processNodeTemplate = (datum, template, context, templateName) => {
        const children = template(context);
        const node = compat_1.Children.toArray(children).find((child) => {
            if (!child || !child.props) {
                return;
            }
            return (child.props?.children?.type || child.type) === templateName;
        });
        // The computed template node structure varies between cookbook and storybook. We are handling
        // both case here.  TODO: consult with framework team about separate node structure as it feels
        // like we should always get same nodes structure.
        const props = node?.type === templateName ? node.props : (node?.props?.children).props;
        const key = datum.key || datum.metadata?.key; // TODO: we should probably move this logic to processTemplate so this function just does node processing
        return props
            ? { ...resolveProps(props), key, id: key, _itemData: datum.data }
            : { key, id: key, _itemData: datum.data };
    };
    exports.processNodeTemplate = processNodeTemplate;
    /**
     * @param data The array of data from data provider.
     * @param template The template slot.
     * @param getContext The function that returns template context.
     * @param templateName The name of the template element.
     * @returns
     */
    const processTemplate = (data, template, getContext, templateName) => {
        return data.map((datum, index) => (0, exports.processNodeTemplate)(datum, template, getContext(datum, index), templateName));
    };
    exports.processTemplate = processTemplate;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/PRIVATE_chartUtils/lineAreaUtils',["require", "exports", "@oracle/oraclejet-preact/utils/UNSAFE_visUtils"], function (require, exports, UNSAFE_visUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformItem = transformItem;
    exports.transformSeries = transformSeries;
    exports.transformGroup = transformGroup;
    exports.transformValueFormats = transformValueFormats;
    const colorRamp = (0, UNSAFE_visUtils_1.getColorRamp)();
    /**
     * Transforms the corepack area-chart item to preact area-chart item.
     */
    function transformItem(item, series) {
        return {
            markerColor: item.color || series.markerColor,
            accessibleLabel: item.shortDesc,
            value: item.value,
            label: item.label,
            id: item.id,
            drilling: item.drilling || series.drilling,
            isMarkerDisplayed: (item.markerDisplayed && item.markerDisplayed !== 'off') ||
                (series.markerDisplayed && series.markerDisplayed !== 'off'),
            markerType: (item.markerShape !== 'auto' && item.markerShape) ||
                (series.markerShape !== 'auto' && series.markerShape),
            markerSize: (item.markerSize !== undefined && item.markerSize) || series.markerSize
        };
    }
    function transformSeries(series, seriesIndex) {
        return {
            lineColor: series.color || colorRamp[seriesIndex % colorRamp.length],
            areaColor: series.areaColor || series.color || colorRamp[seriesIndex % colorRamp.length], // TODO: this will need to consider chart type
            accessibleLabel: series.shortDesc,
            drilling: series.drilling,
            lineStyle: series.lineStyle,
            lineType: series.lineType,
            lineWidth: series.lineWidth,
            markerShape: series.markerShape,
            markerColor: series.markerColor || colorRamp[seriesIndex % colorRamp.length],
            markerDisplayed: series.markerDisplayed,
            markerSize: series.markerSize,
            id: series.id,
            name: series.name,
            items: series.items,
            associatedYAxis: series.assignedToY2 === 'on' ? 'y2' : 'y'
        };
    }
    function transformGroup(group) {
        return {
            drilling: group.drilling,
            name: group.name,
            id: group.id,
            accessibleLabel: group.shortDesc
        };
    }
    /**
     * Transforms the corepack area-chart item to preact area-chart item.
     */
    function transformValueFormats(valueFormats) {
        if (!valueFormats)
            return;
        const formats = {};
        if (valueFormats.value) {
            formats.value = {
                isDisplayed: valueFormats.value?.tooltipDisplay !== 'off',
                label: valueFormats.value?.tooltipLabel,
                format: valueFormats.value?.converter?.format
            };
        }
        if (valueFormats.series) {
            formats.series = {
                isDisplayed: valueFormats.series?.tooltipDisplay !== 'off',
                label: valueFormats.series?.tooltipLabel
            };
        }
        if (valueFormats.group) {
            formats.group = {
                isDisplayed: valueFormats.group?.tooltipDisplay !== 'off',
                label: valueFormats.group?.tooltipLabel
            };
        }
        return formats;
    }
});

/**
 * @license
 * Copyright (c) 2018 %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/hooks/UNSAFE_useChartData/dataUtil',["require", "exports", "ojs/ojlogger", "../../utils/UNSAFE_vizUtils/TemplateHandler", "../../utils/PRIVATE_chartUtils/lineAreaUtils"], function (require, exports, Logger, TemplateHandler_1, lineAreaUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createGroupsAndSeries = void 0;
    /**
     * Takes the dataProvider and templates and returns the series, group and getDataItem needed by preact charts
     */
    const createGroupsAndSeries = (data, itemTemplate, seriesTemplate, groupTemplate, itemElementName, seriesElementName, groupElementName, seriesComparator, groupComparator) => {
        const getItemContext = (context, index) => {
            return {
                data: context.data,
                key: context.key,
                index
            };
        };
        const items = itemTemplate && itemElementName
            ? (0, TemplateHandler_1.processTemplate)(data, itemTemplate, getItemContext, itemElementName)
            : data.map((item) => {
                return { id: item.key, _itemData: item.data, ...item.data };
            });
        const groupMap = new Map();
        // Map for each group Symbol containing indices of belonging items
        // Only populated if groupTemplate or groupComparator is specified
        const groupItemMap = groupTemplate || groupComparator ? new Map() : null;
        const seriesMap = new Map();
        const addGroup = (groupId) => {
            let currentMap = groupMap;
            const symbols = [];
            for (let i = 0; i < groupId?.length; i++) {
                const gid = groupId[i];
                let group = currentMap.get(gid);
                if (!group) {
                    // gid isn't necessarily globally unique, but still helpful for debugging
                    group = { value: Symbol(gid) };
                    if (i !== groupId?.length - 1) {
                        group.groups = new Map();
                    }
                    currentMap.set(gid, group);
                }
                if (group.value)
                    symbols.push(group.value);
                if (group.groups)
                    currentMap = group.groups;
            }
            return symbols;
        };
        const addItemIfUnique = (seriesId, groupSymbols, itemIndex) => {
            let itemMap = seriesMap.get(seriesId);
            if (!itemMap) {
                itemMap = new Map();
                seriesMap.set(seriesId, itemMap);
            }
            const leafSymbol = groupSymbols[groupSymbols?.length - 1];
            if (itemMap.get(leafSymbol) === undefined) {
                itemMap.set(leafSymbol, itemIndex);
                // add the itemIndex to all groups if the groupItemMap was passed
                if (groupItemMap) {
                    groupSymbols.forEach((groupSymbol) => {
                        let groupItems = groupItemMap.get(groupSymbol);
                        if (!groupItems) {
                            groupItems = [];
                            groupItemMap.set(groupSymbol, groupItems);
                        }
                        groupItems.push(itemIndex);
                    });
                }
            }
        };
        const processItems = () => {
            items.forEach((item, index) => {
                const groupSymbols = addGroup(item['groupId']);
                addItemIfUnique(item['seriesId'], groupSymbols, index);
            });
        };
        const createGroupContext = (groupSymbol, groupIds, index) => {
            const context = {
                ids: groupIds,
                depth: groupIds?.length,
                index: index
            };
            Object.defineProperty(context, 'items', {
                get: () => {
                    return groupItemMap?.get(groupSymbol).map((itemIndex) => {
                        const item = items[itemIndex];
                        return {
                            data: item._itemData,
                            key: item.id,
                            index: itemIndex
                        };
                    });
                }
            });
            return context;
        };
        const createGroupLevel = (mapLevel, prefix) => {
            const gids = [...mapLevel.keys()];
            const groupContexts = new Map();
            const groups = gids.map((gid, index) => {
                let group;
                const value = mapLevel.get(gid);
                const groupSymbol = value?.value;
                const subGroups = value?.groups;
                let groupContext;
                if ((groupTemplate || groupComparator) && groupSymbol) {
                    groupContext = createGroupContext(groupSymbol, [...prefix, gid], index);
                    groupContexts.set(gid, groupContext);
                }
                if (groupTemplate && groupElementName) {
                    group = (0, TemplateHandler_1.processNodeTemplate)({ key: groupSymbol }, groupTemplate, groupContext, groupElementName);
                }
                else {
                    group = {};
                }
                group['id'] = gid;
                group['name'] = group['name'] == null ? gid : group['name'];
                if (subGroups) {
                    group['groups'] = createGroupLevel(subGroups, [...prefix, gid]);
                }
                else {
                    group = (0, lineAreaUtils_1.transformGroup)(group);
                    Object.defineProperty(group, 'symbol', {
                        value: groupSymbol,
                        enumerable: false
                    });
                }
                return group;
            });
            if (groupComparator) {
                groups.sort((a, b) => groupComparator(groupContexts.get(a['id']), groupContexts.get(b['id'])));
            }
            return groups;
        };
        const createGroups = () => {
            try {
                return createGroupLevel(groupMap, []);
            }
            catch (error) {
                Logger.error(error);
                return [];
            }
        };
        const createSeriesContext = (seriesId, index, groupSymbols, itemMap) => {
            const context = {
                id: seriesId,
                index: index
            };
            Object.defineProperty(context, 'items', {
                get: () => {
                    const itemContexts = [];
                    groupSymbols.forEach((symbol) => {
                        const itemIndex = itemMap.get(symbol);
                        if (itemIndex != null) {
                            const item = items[itemIndex];
                            itemContexts.push({
                                data: item._itemData,
                                key: item.id,
                                index: itemIndex
                            });
                        }
                        return undefined;
                    });
                    return itemContexts;
                }
            });
            return context;
        };
        const getGroupSymbols = (groups) => {
            const symbols = [];
            groups.forEach((group) => {
                if (group.groups) {
                    symbols.push(...getGroupSymbols(group.groups));
                }
                else if (group.symbol) {
                    symbols.push(group.symbol);
                }
            });
            return symbols;
        };
        const createSeries = (groups) => {
            let arSeries;
            try {
                const seriesContexts = new Map();
                const groupSymbols = getGroupSymbols(groups);
                const sids = [...seriesMap.keys()];
                arSeries = sids.map((sid, index) => {
                    const itemMap = seriesMap.get(sid);
                    let seriesContext;
                    if ((seriesTemplate || seriesComparator) && itemMap) {
                        seriesContext = createSeriesContext(sid, index, groupSymbols, itemMap);
                        seriesContexts.set(sid, seriesContext);
                    }
                    let series;
                    if (seriesTemplate && seriesContext && seriesElementName) {
                        series = (0, TemplateHandler_1.processNodeTemplate)({ key: sid }, seriesTemplate, seriesContext, seriesElementName);
                    }
                    else {
                        series = { id: sid };
                    }
                    series['name'] = series['name'] == null ? String(sid) : series['name'];
                    series['items'] = groupSymbols.map((symbol) => {
                        let item = null;
                        if (itemMap) {
                            const itemIndex = itemMap.get(symbol);
                            if (itemIndex != null) {
                                item = items[itemIndex];
                            }
                        }
                        return item;
                    });
                    return series;
                });
                // first sort before transforming the series and items.
                if (seriesComparator) {
                    arSeries.sort((a, b) => seriesComparator(seriesContexts.get(a['id']), seriesContexts.get(b['id'])));
                }
                // apply default color if needed in the sorted series.
                return arSeries.map((series, index) => {
                    series['items'] = series['items'].map((item) => {
                        return (0, lineAreaUtils_1.transformItem)(item, series);
                    });
                    return (0, lineAreaUtils_1.transformSeries)(series, index);
                });
            }
            catch (error) {
                Logger.error(error);
                arSeries = [];
            }
            return arSeries;
        };
        processItems();
        const groups = createGroups();
        const series = createSeries(groups);
        return { groups, series, createGroupContext };
    };
    exports.createGroupsAndSeries = createGroupsAndSeries;
});

/**
 * @license
 * Copyright (c) %FIRSTYEAR% %CURRENTYEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/hooks/UNSAFE_useDataProvider/utils',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUpdatedItemsFromMutationDetail = getUpdatedItemsFromMutationDetail;
    /**
     * Constructs a new array with updates applied to the copy of the current data array.
     * A dataProvider can be passed which will be used to fetch
     * data, in case the data is not available in the mutation event detail.
     *
     * @param detail The mutation detail object
     * @param currentData The current data array
     * @param dataProvider The dataprovider instance
     * @returns The updated data array
     */
    async function getUpdatedItemsFromMutationDetail(detail, currentData, dataProvider) {
        const { add, remove, update } = detail ?? {};
        const keyIndexMap = new Map();
        // Build the keyIndex map for the current, so that future ops will be cheap
        for (const [index, item] of currentData.entries()) {
            keyIndexMap.set(item.key, index);
        }
        let mutatedData = [...currentData];
        // First remove the items
        if (remove) {
            mutatedData = removeItemsFromDetail(remove, mutatedData, keyIndexMap);
        }
        // Now add the new items
        if (add) {
            mutatedData = await addItemsFromDetail(add, mutatedData, keyIndexMap, dataProvider);
        }
        // Finally perform updates
        if (update) {
            mutatedData = await updateItemsFromDetail(update, mutatedData, keyIndexMap, dataProvider);
        }
        return mutatedData;
    }
    ////////////////////////////
    // Private Helper Methods //
    ////////////////////////////
    /**
     * Adds items to the original array at the end
     *
     * @param itemsToAdd The new items to be added
     * @param itemMetadataToAdd The new itemMetaData to be added
     * @param items The original array of items
     * @returns The mutated items array
     */
    function addItemsAtEnd(itemsToAdd, itemMetadataToAdd, items) {
        // adding at end means just addItems at index -1
        // so, create an indices array filled with -1, and delegate to addItemsAtIndices
        const indices = new Array(itemsToAdd.length).fill(-1);
        return addItemsAtIndices(indices, itemsToAdd, itemMetadataToAdd, items);
    }
    /**
     * Adds items to the original array at the specified indices with the corresponding
     * data
     *
     * @param indices The indices at which the new items are to be added
     * @param itemsToAdd The new items to be added
     * @param itemMetadataToAdd The new metadata corresponding to the items
     * @param items The original array of items
     * @returns The mutated items array
     */
    function addItemsAtIndices(indices, itemsToAdd, itemMetadataToAdd, items) {
        // make a shallow copy of the data array to mutate
        const returnItems = [...items];
        indices.forEach((addAtIndex, index) => {
            const addItem = {
                data: itemsToAdd[index],
                key: itemMetadataToAdd[index]?.key,
                metadata: itemMetadataToAdd[index]
            };
            // For all positive indices, add at the index
            if (addAtIndex >= 0) {
                returnItems.splice(addAtIndex, 0, addItem);
            }
            else {
                // id index is negative, then add the item to the end
                returnItems.push(addItem);
            }
        });
        return returnItems;
    }
    /**
     * Adds items to the original array at before the items with the specified keys
     * with the corresponding data
     *
     * @param beforeKeys The keys before which the new data should be added
     * @param itemsToAdd The new items to be added
     * @param items The original array of items
     * @param keyIndexMap A map containing key-index mapping
     * @returns The mutated items array
     */
    function addItemsBeforeKeys(beforeKeys, itemsToAdd, items, keyIndexMap) {
        const addIndices = [];
        const itemMetadataToAdd = [];
        beforeKeys.forEach((key) => {
            addIndices.push(getIndexByKey(keyIndexMap, key));
            itemMetadataToAdd.push({ key });
        });
        return addItemsAtIndices(addIndices, itemsToAdd, itemMetadataToAdd, items);
    }
    /**
     * Adds items to the array from the add operation detail
     *
     * @param detail The add operation detail
     * @param items The current items array
     * @param keyIndexMap A map containing key-index mapping
     * @param dataProvider The instance of DataProvider for fetching data
     * @returns Promise that resolves to the new items array
     */
    async function addItemsFromDetail(detail, items, keyIndexMap, dataProvider) {
        const { addBeforeKeys, data, indexes, keys, metadata } = detail;
        let mutatedData = [...items];
        let treatedData = data || [];
        let treatedMetaData = metadata || [];
        // Check if keys are available but the data is not, then fetch the data from the DP
        if (treatedData.length === 0 && keys?.size) {
            const fetchResults = (await fetchDataByKeys(dataProvider, keys)) ?? [];
            treatedData = fetchResults.map((itemContext) => itemContext.data);
            treatedMetaData = fetchResults.map((itemContext) => itemContext.metadata);
        }
        // Check if metadata is empty and keys are available, populate metadata from key
        if (treatedMetaData.length === 0 && keys?.size) {
            treatedMetaData = [...keys].map((key) => ({ key }));
        }
        // Perform the addition only if the data is available
        if (treatedData.length) {
            // Check in the following order of where the items need to be inserted
            // - indexes
            // - addBeforeKeys
            // - afterKeys
            // if none of them are available, just append to the end of the data
            if (indexes?.length) {
                mutatedData = addItemsAtIndices(indexes, treatedData, treatedMetaData, mutatedData);
            }
            else if (addBeforeKeys?.length) {
                mutatedData = addItemsBeforeKeys(addBeforeKeys, treatedData, mutatedData, keyIndexMap);
            }
            else {
                mutatedData = addItemsAtEnd(treatedData, treatedMetaData, mutatedData);
            }
        }
        return mutatedData;
    }
    /**
     * Fetches the data from the dataprovider for the keys specified and returns the fetched data
     *
     * @param dataProvider The dataProvider instance for fetching the data
     * @param keys The set of keys whose data needs to be fetched
     * @returns A promise that resolves with the fetched data
     */
    async function fetchDataByKeys(dataProvider, keys) {
        const fetchedData = [];
        const results = (await dataProvider.fetchByKeys({ keys })).results;
        for (const key of keys) {
            if (results.has(key)) {
                const result = results.get(key);
                fetchedData.push({ ...result, key });
            }
        }
        return fetchedData;
    }
    /**
     * Fetches the index of the item with the corresponding key
     *
     * @param keyIndexMap A map containing key-index mapping
     * @param key The key whose index has to be found
     * @returns The index of the item with the provided key
     */
    function getIndexByKey(keyIndexMap, key) {
        if (keyIndexMap.has(key)) {
            return keyIndexMap.get(key);
        }
        // If key is not in the data return -1
        return -1;
    }
    /**
     * Removes items from the original items array with the corresponding indices
     *
     * @param indices An array of indices to be removed
     * @param items The original items array
     * @returns The mutated items array
     */
    function removeItemsAtIndices(indices, items) {
        // make a shallow copy of the data array to mutate
        const returnItems = [...items];
        // sort the indices in desc order so the items can be removed from
        // the end
        indices.sort((a, b) => b - a);
        // iterate through indices and remove items
        indices.forEach((index) => {
            if (index < returnItems.length) {
                returnItems.splice(index, 1);
            }
        });
        return returnItems;
    }
    /**
     * Removes items from the original items array with the corresponding keys
     *
     * @param keys A set of keys whose corresponding data has to be removed
     * @param items The original items array
     * @param keyIndexMap A map containing key-index mapping
     * @returns The mutated items array
     */
    function removeItemsAtKeys(keys, items, keyIndexMap) {
        const indicesToRemove = [];
        keys.forEach((key) => {
            const index = getIndexByKey(keyIndexMap, key);
            if (index !== -1) {
                indicesToRemove.push(index);
            }
        });
        return removeItemsAtIndices(indicesToRemove, items);
    }
    /**
     * Removes items from the array using the remove operation detail
     *
     * @param detail The remove operation detail
     * @param items The current items array
     * @param keyIndexMap A map containing key-index mapping
     * @returns Promise that resolves to the new items array
     */
    function removeItemsFromDetail(detail, items, keyIndexMap) {
        const { indexes, keys } = detail;
        let mutatedData = [...items];
        // Check for list of indices first
        if (indexes?.length) {
            mutatedData = removeItemsAtIndices(indexes, mutatedData);
        }
        else if (keys?.size) {
            mutatedData = removeItemsAtKeys(keys, mutatedData, keyIndexMap);
        }
        return mutatedData;
    }
    /**
     * Updates items in the original array at the specified indices with the corresponding
     * data
     *
     * @param indices The indices at which the items are to be updated
     * @param itemsToUpdate The new items with updated data
     * @param itemMetadataToUpdate The new metadata corresponding to the items
     * @param items The original array of items
     * @returns The mutated items array
     */
    function updateItemsAtIndices(indices, itemsToUpdate, itemMetadataToUpdate, items) {
        // make a shallow copy of the data array to mutate
        const returnItems = [...items];
        indices.forEach((updateAtIndex, index) => {
            // Update values only for existing items
            if (returnItems[updateAtIndex]) {
                const addItem = {
                    data: itemsToUpdate[index],
                    key: itemMetadataToUpdate[index]?.key,
                    metadata: itemMetadataToUpdate[index]
                };
                returnItems.splice(updateAtIndex, 1, addItem);
            }
        });
        return returnItems;
    }
    /**
     * Updates items in the original array at the specified indices with the corresponding
     * data
     *
     * @param keys The keys at which the items are to be updated
     * @param itemsToUpdate The new items with updated data
     * @param itemMetadataToUpdate The new metadata corresponding to the items
     * @param items The original array of items
     * @param keyIndexMap A map containing key-index mapping
     * @returns The mutated items array
     */
    function updateItemsAtKeys(keys, itemsToUpdate, itemMetadataToUpdate, items, keyIndexMap) {
        // make a shallow copy of the data array to mutate
        const returnItems = [...items];
        keys.forEach((key) => {
            const index = getIndexByKey(keyIndexMap, key);
            const addItem = {
                data: itemsToUpdate[index],
                key: itemMetadataToUpdate[index]?.key,
                metadata: itemMetadataToUpdate[index]
            };
            // Update only if item exists in the current data
            if (index >= 0) {
                returnItems.splice(index, 1, addItem);
            }
        });
        return returnItems;
    }
    /**
     * Updates items in the array using the update operation detail
     *
     * @param detail The update operation detail
     * @param items The current items array
     * @param keyIndexMap A map containing key-index mapping
     * @param dataProvider The instance of DataProvider for fetching data
     * @returns Promise that resolves to the new items array
     */
    async function updateItemsFromDetail(detail, items, keyIndexMap, dataProvider) {
        const { data, indexes, keys, metadata } = detail;
        let mutatedData = [...items];
        let treatedData = data || [];
        let treatedMetaData = metadata || [];
        // Check if keys are available but the data is not, then fetch the data from the DP
        if (treatedData.length === 0 && keys?.size) {
            const fetchResults = (await fetchDataByKeys(dataProvider, keys)) ?? [];
            treatedData = fetchResults.map((itemContext) => itemContext.data);
            treatedMetaData = fetchResults.map((itemContext) => itemContext.metadata);
        }
        // Check if metadata is empty and keys are available, populate metadata from key
        if (treatedMetaData.length === 0 && keys?.size) {
            treatedMetaData = [...keys].map((key) => ({ key }));
        }
        // Perform the update only if the data is available
        if (treatedData.length) {
            // Check in the following order for updating data
            // - indexes
            // - keys
            if (indexes?.length) {
                mutatedData = updateItemsAtIndices(indexes, treatedData, treatedMetaData, mutatedData);
            }
            else if (keys?.size) {
                mutatedData = updateItemsAtKeys(keys, treatedData, treatedMetaData, mutatedData, keyIndexMap);
            }
        }
        return mutatedData;
    }
});

define('oj-c/hooks/UNSAFE_useDataProvider/DataProviderHandler',["require", "exports", "./utils"], function (require, exports, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataProviderHandler = void 0;
    /**
     * @classdesc
     * This class handles DataProvider mechanisms for the preact components
     * @ignore
     */
    class DataProviderHandler {
        ///////////////////////////
        // Handler functions end //
        ///////////////////////////
        /**
         * Instantiates the DataProviderHandler.
         *
         * @param dataProvider The data provider instance that is being used by the component
         * @param addBusyState A function reference that set busy state in the component
         * @param callback A callback that will be invoked whenever data changes
         */
        constructor(dataProvider, addBusyState, callback) {
            ////////////////////////////////////////////////////////////////////////
            // Handler functions are created as members to have them 'this' bound //
            ////////////////////////////////////////////////////////////////////////
            /**
             * Handles the mutation event triggered by the dataprovider and calls corresponding
             * callbacks.
             *
             * @param event DP mutation event object containing details relevant to the event
             */
            this.handleMutateEvent = async (event) => {
                const { detail } = event;
                // Add busy state while updating the data
                const resolver = this.addBusyState('updating data from mutation event');
                const updatedData = await (0, utils_1.getUpdatedItemsFromMutationDetail)(detail, this.currentData, this.dataProvider);
                // Resolve the busy state
                resolver?.();
                // store the newly created data and notify the consumer with the new data
                this.currentData = updatedData;
                this.callback?.onDataUpdated?.(updatedData);
            };
            /**
             * Handles the refresh event triggered by the dataprovider and calls corresponding
             * callbacks.
             */
            this.handleRefreshEvent = () => {
                this._fetchDataAndNotify();
            };
            this.addBusyState = addBusyState;
            this.callback = callback;
            this.dataProvider = dataProvider;
            this.currentData = [];
            // Subscribe to the data provider events
            dataProvider.addEventListener('refresh', this.handleRefreshEvent);
            dataProvider.addEventListener('mutate', this.handleMutateEvent);
            // Initialize a fetch
            this._fetchDataAndNotify();
        }
        ////////////////////
        // Public Methods //
        ////////////////////
        /**
         * Destroys all resources un-registers all events
         */
        destroy() {
            // Clean up callbacks so that existing fetches will not update the component
            this.callback = undefined;
            // empty the store data
            this.currentData = [];
            // Clean up data provider
            this.dataProvider.removeEventListener('refresh', this.handleRefreshEvent);
            this.dataProvider.removeEventListener('mutate', this.handleMutateEvent);
        }
        ////////////////////////
        // Public Methods End //
        ////////////////////////
        ////////////////////////////
        // Private Helper Methods //
        ////////////////////////////
        /**
         * Fetches the data from the dataprovider and returns the fetched data
         *
         * @returns A promise that resolves with the fetched data
         */
        async _fetchData() {
            const fetchedData = [];
            const asyncIterable = this.dataProvider.fetchFirst({ size: -1 });
            for await (const results of asyncIterable) {
                const contextArray = results.data.map((item, index) => {
                    return {
                        data: item,
                        key: results.metadata[index].key,
                        metadata: results.metadata[index]
                    };
                });
                fetchedData.push(...contextArray);
            }
            // Store a copy of data before returning.
            // When receiving a mutation event this data will be used along with the
            // mutation event detail to construct the new data.
            this.currentData = fetchedData.slice();
            return fetchedData;
        }
        /**
         * Fetches the data from the dataprovider and calls the corresponding
         * callback with the fetched data.
         */
        async _fetchDataAndNotify() {
            // Set the busy state
            const resolver = this.addBusyState('fetching data');
            const fetchedData = await this._fetchData();
            this.callback?.onDataUpdated?.(fetchedData);
            // Now that the data is fetched, clear the busy state
            resolver();
        }
    }
    exports.DataProviderHandler = DataProviderHandler;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/hooks/UNSAFE_useDataProvider/useDataProvider',["require", "exports", "preact/hooks", "./DataProviderHandler"], function (require, exports, hooks_1, DataProviderHandler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useDataProvider = useDataProvider;
    /**
     * Consumes a DP and converts the data into an array. This also attaches event listeners
     * to the DP and updates the array accordingly.
     *
     * @param param0 The props for the hook
     * @returns The data converted into an array
     */
    function useDataProvider({ addBusyState, data }) {
        const [fetchedData, setFetchedData] = (0, hooks_1.useState)([]);
        const dataProviderHandler = (0, hooks_1.useRef)();
        (0, hooks_1.useEffect)(() => {
            if (data !== undefined) {
                dataProviderHandler.current = new DataProviderHandler_1.DataProviderHandler(data, addBusyState, {
                    onDataUpdated: setFetchedData
                });
            }
            return () => {
                dataProviderHandler.current?.destroy();
                dataProviderHandler.current = undefined;
            };
        }, [data, addBusyState]);
        return {
            data: fetchedData
        };
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/hooks/PRIVATE_useVisData/useVisData',["require", "exports", "preact/hooks", "../UNSAFE_useDataProvider/useDataProvider"], function (require, exports, hooks_1, useDataProvider_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useVisData = useVisData;
    const STATE_GRAPH = {
        initial: {
            setDP: 'fetching',
            setNoDP: 'fetched'
        },
        fetching: {
            setDP: 'fetching',
            setData: 'fetched',
            setNoDP: 'fetched'
        },
        fetched: {
            setDP: 'fetching',
            setNoDP: 'fetched'
        }
    };
    const reducer = (state, action) => {
        const nextState = STATE_GRAPH[state][action];
        return nextState || state;
    };
    function useVisData({ addBusyState, dataProvider }) {
        const [state, send] = (0, hooks_1.useReducer)(reducer, 'initial');
        const { data } = (0, useDataProvider_1.useDataProvider)({
            data: dataProvider,
            addBusyState
        });
        (0, hooks_1.useEffect)(() => {
            if (state === 'initial')
                return;
            send('setData');
        }, [data]);
        (0, hooks_1.useEffect)(() => {
            send(dataProvider ? 'setDP' : 'setNoDP');
        }, [dataProvider]);
        return {
            data,
            isLoading: state !== 'fetched'
        };
    }
});

define('oj-c/hooks/UNSAFE_useChartData/useChartData',["require", "exports", "./dataUtil", "../PRIVATE_useVisData/useVisData", "preact/hooks"], function (require, exports, dataUtil_1, useVisData_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useChartData = useChartData;
    /**
     * Hook that returns the processed sectional legend data.
     * TODO: JET-59089 replace with proper useTreeDataProvider
     * @returns
     */
    function useChartData(dataProvider, addBusyState, itemTemplate, seriesTemplate, groupTemplate, itemElementName, seriesElementName, groupElementName, seriesComparator, groupComparator) {
        const { data, isLoading } = (0, useVisData_1.useVisData)({
            dataProvider,
            addBusyState
        });
        const { series, groups, createGroupContext } = (0, hooks_1.useMemo)(() => (0, dataUtil_1.createGroupsAndSeries)(data, itemTemplate, seriesTemplate, groupTemplate, itemElementName, seriesElementName, groupElementName, seriesComparator, groupComparator), [
            data,
            itemTemplate,
            seriesTemplate,
            groupTemplate,
            itemElementName,
            seriesElementName,
            groupElementName,
            seriesComparator,
            groupComparator
        ]);
        const idToDPItemMap = new Map(data.map((item) => [item.key, item.data]));
        const getDataItem = (seriesIndex, groupIndex) => {
            const seriesItems = series[seriesIndex]['items'];
            return seriesItems[groupIndex];
        };
        return { series, groups, getDataItem, isLoading, idToDPItemMap, createGroupContext };
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/PRIVATE_chartUtils/events',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getChartEventsHandler = void 0;
    exports.getIdFromDetail = getIdFromDetail;
    const getItemDrillDetail = (series, groups, detail) => {
        const data = series[detail.seriesIndex];
        const group = [];
        const groupData = [];
        const isHierarchical = groups.some((g) => g.groups && g.groups.length > 0);
        let currentGroup;
        detail.groupPath.forEach((value) => {
            currentGroup = groups[value];
            group.push(currentGroup.id);
            groupData.push(currentGroup);
        });
        const itemData = series[detail.seriesIndex]['items'];
        const seriesId = series[detail.seriesIndex]['id'];
        const seriesData = series[detail.seriesIndex];
        const itemObj = {
            data,
            group: isHierarchical ? group : group[0],
            groupData,
            id: detail.id,
            itemData,
            seriesId,
            seriesData
        };
        return itemObj;
    };
    const getGroupDrillDetail = (groups, detail, createGroupContext) => {
        const group = [];
        const groupData = [];
        const isHierarchical = groups.some((g) => g.groups && g.groups.length > 0);
        let currentGroup;
        detail.groupPath.forEach((value) => {
            currentGroup = groups[value];
            group.push(currentGroup.id);
            groupData.push(currentGroup);
        });
        // @ts-ignore
        const items = createGroupContext?.(detail.group.symbol, group, detail.groupIndex).items;
        const groupObj = { group: isHierarchical ? group : group[0], groupData, id: detail.id, items };
        return groupObj;
    };
    const getSeriesDrillDetail = (series, detail) => {
        const { itemIndex } = detail;
        return {
            id: series[itemIndex]['id'],
            items: series[itemIndex]['items'],
            series: series[itemIndex]['id'],
            seriesData: series
        };
    };
    /**
     * Returns the id fo the item from events detail
     * @param detail
     * @param getDataItem
     * @returns
     */
    function getIdFromDetail(detail, series, getDataItem) {
        const { seriesIndex, groupIndex } = detail;
        if (seriesIndex === undefined) {
            return;
        }
        if (groupIndex === undefined) {
            return series[seriesIndex]['id'];
        }
        return getDataItem(seriesIndex, groupIndex).id;
    }
    const getChartEventsHandler = (series, groups, drilling, onOjItemDrill, onOjGroupDrill, onOjSeriesDrill, createGroupContext) => {
        const itemDrillHandler = (detail) => {
            if (drilling === 'on') {
                onOjItemDrill?.(getItemDrillDetail(series, groups, detail));
            }
        };
        const groupDrillHandler = (detail) => {
            if (drilling === 'on' || drilling === 'groupsOnly') {
                onOjGroupDrill?.(getGroupDrillDetail(groups, detail, createGroupContext));
            }
        };
        const seriesDrillHandler = (detail) => {
            if (drilling === 'seriesOnly' || drilling === 'on') {
                onOjSeriesDrill?.(getSeriesDrillDetail(series, detail));
            }
        };
        return {
            itemDrillHandler,
            groupDrillHandler,
            seriesDrillHandler
        };
    };
    exports.getChartEventsHandler = getChartEventsHandler;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/PRIVATE_chartUtils/legendUtils',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LEGENDMAXSIZE = exports.LegendDefaults = void 0;
    exports.getLegendData = getLegendData;
    exports.getBLACCategoriesItems = getBLACCategoriesItems;
    exports.shouldRenderLegend = shouldRenderLegend;
    exports.getLegendPosition = getLegendPosition;
    exports.getLegendGap = getLegendGap;
    exports.getPreactChartDimensions = getPreactChartDimensions;
    exports.LegendDefaults = {
        rendered: 'off',
        position: 'auto'
    };
    exports.LEGENDMAXSIZE = 0.3; // 30% of the chart width or height
    /**
     * Returns the legend data for the chart.
     */
    function getLegendData(series) {
        return series.map((chartSeries) => {
            return {
                markerColor: chartSeries.color || chartSeries.areaColor,
                markerShape: chartSeries.markerShape != 'auto' ? chartSeries.markerShape : 'square',
                text: chartSeries.name || chartSeries.id,
                id: chartSeries.id
            };
        });
    }
    /**
     * Returns the categories data to use by the useVisCategories hook. Hover categories data
     * and
     * @param series
     * @param groups
     * @param getDataItem
     * @param hoverBehavior
     * @param hideAndShowBehavior
     * @returns
     */
    function getBLACCategoriesItems(series, groups, getDataItem, hoverBehavior, hideAndShowBehavior) {
        const categoriesItem = [];
        if (hoverBehavior === 'none' && hideAndShowBehavior === 'none') {
            return categoriesItem;
        }
        series.forEach((serie, seriesIndex) => {
            groups.forEach((_, groupIndex) => {
                const data = getDataItem(seriesIndex, groupIndex);
                categoriesItem.push({
                    id: data.id,
                    categories: data.categories || serie['categories'] || [serie['id']]
                });
            });
            categoriesItem.push({
                id: serie['id'],
                categories: serie['categories'] || [serie['id']]
            });
        });
        return categoriesItem;
    }
    function shouldRenderLegend(numSeries, rendered) {
        if (rendered === 'on') {
            return true;
        }
        else if (rendered === 'off' || numSeries === 0) {
            return false;
        }
        else {
            // auto
            return numSeries < 100;
        }
    }
    function getLegendPosition(legendPos, chartWidth, chartHeight) {
        return legendPos !== 'auto' ? legendPos : chartWidth > chartHeight ? 'end' : 'bottom';
    }
    function getLegendGap(_width, _height) {
        // legacy legend gap values
        // These values are used to calculate the legend gap based on the chart width and height.
        const legendGapHeight = 10;
        const legendGapWidth = 15;
        const width = Math.ceil(legendGapWidth * Math.min(_width / 400, 1));
        const height = Math.ceil(legendGapHeight * Math.min(_height / 300, 1));
        return {
            width,
            height
        };
    }
    function getPreactChartDimensions(_width, _height, legendPosition, legendPreferredSize) {
        const legendGap = getLegendGap(_width, _height);
        const width = legendPreferredSize
            ? legendPosition === 'start' || legendPosition === 'end'
                ? `${_width - legendPreferredSize.width - legendGap.width}px`
                : `${_width}px`
            : undefined;
        const height = legendPreferredSize
            ? legendPosition === 'top' || legendPosition === 'bottom'
                ? `${_height - legendPreferredSize.height - legendGap.height}px`
                : `${_height}px`
            : undefined;
        return { width: width, height: height };
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/hooks/UNSAFE_useVizCategories/useVizCategories',["require", "exports", "@oracle/oraclejet-preact/hooks/UNSAFE_useCategories"], function (require, exports, UNSAFE_useCategories_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useVizCategories = useVizCategories;
    function useVizCategories(categoriesItem, getCategories, hiddenCategories, highlightedCategories, hiddenMatch = 'any', highlightMatch = 'all', onHiddenCategoriesChanged, onHighlightedCategoriesChanged) {
        const { ids: hiddenIds, updateCategories: updateHidden } = (0, UNSAFE_useCategories_1.useCategories)({
            items: categoriesItem,
            getCategoriesFromItem: getCategories,
            initialCategories: hiddenCategories,
            matchCriteria: hiddenMatch,
            replace: false,
            onCategoriesChange: onHiddenCategoriesChanged
        });
        const { ids: highlightedIds, updateCategories: updateHighlighted } = (0, UNSAFE_useCategories_1.useCategories)({
            items: categoriesItem,
            getCategoriesFromItem: getCategories,
            initialCategories: highlightedCategories,
            matchCriteria: highlightMatch,
            replace: true,
            onCategoriesChange: onHighlightedCategoriesChanged
        });
        return {
            hiddenIds,
            updateHidden,
            highlightedIds,
            updateHighlighted
        };
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/PRIVATE_chartUtils/plotAreaUtils',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPlotArea = getPlotArea;
    function getPlotArea(plotArea, yMajorTick, yMinorTick, xMajorTick, y2MajorTick, y2MinorTick) {
        return {
            color: plotArea?.backgroundColor,
            yMajorTick: yMajorTick?.rendered
                ? { isRendered: yMajorTick?.rendered !== 'off', ...yMajorTick }
                : yMajorTick,
            yMinorTick: yMinorTick?.rendered
                ? { isRendered: yMinorTick?.rendered && yMinorTick?.rendered !== 'off', ...yMinorTick }
                : yMinorTick,
            y2MajorTick: y2MajorTick?.rendered
                ? { isRendered: y2MajorTick?.rendered !== 'off', ...y2MajorTick }
                : y2MajorTick,
            y2MinorTick: y2MinorTick?.rendered
                ? { isRendered: y2MinorTick?.rendered && y2MinorTick?.rendered !== 'off', ...y2MinorTick }
                : y2MinorTick,
            xMajorTick: xMajorTick?.rendered
                ? { isRendered: xMajorTick?.rendered && xMajorTick?.rendered !== 'off', ...xMajorTick }
                : xMajorTick
        };
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/PRIVATE_chartUtils/axisUtils',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPreactAxisProps = void 0;
    const getPreactAxisProps = (axisProps, styleDefaults) => {
        const newProps = {};
        const { tickLabel, ...rest } = axisProps;
        if (tickLabel?.converter) {
            if (Array.isArray(tickLabel.converter)) {
                newProps['format'] = [
                    (value) => tickLabel.converter[0]?.format?.(new Date(value).toISOString()),
                    (value) => tickLabel.converter[1]?.format?.(new Date(value).toISOString())
                ];
            }
            else {
                newProps['format'] = (value) => tickLabel.converter?.format?.(axisProps['timeAxisType'] ? new Date(value).toISOString() : value);
            }
        }
        newProps['isRendered'] = tickLabel?.rendered != 'off';
        newProps['style'] = tickLabel?.style;
        newProps['rotation'] = tickLabel?.rotation != 'none' ? 'autoRotate' : 'none';
        const isGroupSepRendered = styleDefaults?.['groupSeparators'].rendered !== 'off';
        return {
            tickLabel: newProps,
            ...rest,
            groupSeparators: {
                isRendered: isGroupSepRendered,
                color: styleDefaults?.['groupSeparators'].color
            }
        };
    };
    exports.getPreactAxisProps = getPreactAxisProps;
});

define('oj-c/utils/PRIVATE_ItemsMenu/menu-item-icon',["require", "exports", "preact/jsx-runtime"], function (require, exports, jsx_runtime_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemIcon = MenuItemIcon;
    function MenuItemIcon(props) {
        if (props.icon.type === 'img') {
            return (0, jsx_runtime_1.jsx)("img", { src: props.icon.src });
        }
        else {
            return (0, jsx_runtime_1.jsx)("span", { class: props.icon.class });
        }
    }
});

define('oj-c/utils/PRIVATE_ItemsMenu/menu-select-items',["require", "exports", "preact/jsx-runtime", "./menu-item-icon", "@oracle/oraclejet-preact/UNSAFE_Menu"], function (require, exports, jsx_runtime_1, menu_item_icon_1, UNSAFE_Menu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuSelectItems = MenuSelectItems;
    function MenuSelectItems(props) {
        return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: props.items.map((item) => {
                return (item && ((0, jsx_runtime_1.jsx)(UNSAFE_Menu_1.SelectMenuItem, { label: item.label, isDisabled: item.disabled, endIcon: item.endIcon ? (0, jsx_runtime_1.jsx)(menu_item_icon_1.MenuItemIcon, { icon: item.endIcon }) : undefined, value: item.value })));
            }) }));
    }
});

define('oj-c/utils/PRIVATE_ItemsMenu/items-menu',["require", "exports", "preact/jsx-runtime", "./menu-item-icon", "./menu-select-items", "@oracle/oraclejet-preact/UNSAFE_Menu"], function (require, exports, jsx_runtime_1, menu_item_icon_1, menu_select_items_1, UNSAFE_Menu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemsMenu = void 0;
    /**
     * @classdesc
     * <h3 id="MenuButtonOverview-section">
     *   JET Items Menu
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonOverview-section"></a>
     * </h3>
     *
     * <p>Description: A component that takes an items property containing a description of
     * menu items and converts to a collection of menu items suitable for a menu container,
     * such as a menu button.
     *
     * @ojmetadata description "An items to menu items converter"
     * @ojmetadata displayName "Items Menu"
     * @ojmetadata help "oj-c.ItemsMenu.html"
     * @ojmetadata main "oj-c/items-menu"
     * @ojmetadata since "16.0.0"
     */
    const ItemsMenu = ({ items = [], selection = {}, onSelectionChanged, defaultItemsRenderer, onOjMenuAction, isSplitMenu = false, onOjMenuSelection }) => {
        /*  Return the value to provide to the menu selection groups from this menu buttons selection object. */
        const getSingleGroupSelection = (key) => {
            const item = selection[key];
            return item && typeof item == 'string' ? item : undefined;
        };
        const getMultipleGroupSelection = (key) => {
            const item = selection[key];
            return Array.isArray(item) ? item : [];
        };
        const setSelectionValue = (selection, key, value) => {
            const updatedSelection = { ...selection };
            if (Array.isArray(value) && value.length === 0) {
                delete updatedSelection[key];
            }
            else {
                updatedSelection[key] = value;
            }
            return updatedSelection;
        };
        const getItemActionHandler = (key, onAction) => {
            return () => {
                onAction?.();
                onOjMenuAction?.({ key });
            };
        };
        // selection is exposed to user to permit initial values, and to update to any selected values
        // onSelectionChanged is fired when a menu item is selected
        function getCommit(key, selection, onSelection) {
            return (detail) => {
                onSelection?.({ value: detail.value, menuSelectionGroupKey: key });
                onOjMenuSelection?.({ value: detail.value, menuSelectionGroupKey: key });
                onSelectionChanged?.(setSelectionValue(selection, key, detail.value));
            };
        }
        return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: items.map((item) => {
                if (typeof item === 'string') {
                    const defaultMenuItem = defaultItemsRenderer?.[item]?.();
                    if (defaultMenuItem != undefined) {
                        return defaultMenuItem;
                    }
                    return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, {});
                }
                else {
                    switch (item.type) {
                        // For legacy support of split menu button, keep divider
                        case 'divider':
                        case 'separator':
                            // Menu is changing divider name to separator in 16+
                            // For now, we use future name separator and map to divider
                            // When Menu merges change, it can fix this.
                            return (0, jsx_runtime_1.jsx)(UNSAFE_Menu_1.MenuSeparator, {});
                        case 'submenu':
                            if (item.items && item.label && !isSplitMenu) {
                                return ((0, jsx_runtime_1.jsx)(UNSAFE_Menu_1.Submenu, { label: item.label, itemKey: item.key, children: (0, jsx_runtime_1.jsx)(exports.ItemsMenu, { items: item.items, selection: selection, onSelectionChanged: onSelectionChanged, onOjMenuSelection: onOjMenuSelection, onOjMenuAction: onOjMenuAction, defaultItemsRenderer: defaultItemsRenderer }) }));
                            }
                            return;
                        case 'selectsingle':
                            if (item.items && item.key && !isSplitMenu) {
                                return ((0, jsx_runtime_1.jsx)(UNSAFE_Menu_1.SelectSingleMenuGroup, { groupKey: item.key, value: item.selection || getSingleGroupSelection(item.key), onCommit: getCommit(item.key, selection, item.onSelection), children: (0, jsx_runtime_1.jsx)(menu_select_items_1.MenuSelectItems, { items: item.items }) }));
                            }
                            return;
                        case 'selectmultiple':
                            if (item.items && item.key && !isSplitMenu) {
                                return ((0, jsx_runtime_1.jsx)(UNSAFE_Menu_1.SelectMultipleMenuGroup, { groupKey: item.key, value: item.selection || getMultipleGroupSelection(item.key), onCommit: getCommit(item.key, selection, item.onSelection), children: (0, jsx_runtime_1.jsx)(menu_select_items_1.MenuSelectItems, { items: item.items }) }));
                            }
                            return;
                        case undefined:
                        case 'item':
                            if (item.label) {
                                return ((0, jsx_runtime_1.jsx)(UNSAFE_Menu_1.MenuItem, { itemKey: item.key, label: item.label, isDisabled: item.disabled, variant: !isSplitMenu ? item.variant : undefined, startIcon: !isSplitMenu &&
                                        item.startIcon && (0, jsx_runtime_1.jsx)(menu_item_icon_1.MenuItemIcon, { icon: item.startIcon }), endIcon: !isSplitMenu &&
                                        item.endIcon && (0, jsx_runtime_1.jsx)(menu_item_icon_1.MenuItemIcon, { icon: item.endIcon }), onAction: getItemActionHandler(item.key, item.onAction) }));
                            }
                            return;
                        default:
                            return;
                    }
                }
            }) }));
    };
    exports.ItemsMenu = ItemsMenu;
});

define('oj-c/hooks/PRIVATE_useVisContextMenu/useVisContextMenu',["require", "exports", "preact/jsx-runtime", "preact/hooks", "../../utils/PRIVATE_ItemsMenu/items-menu"], function (require, exports, jsx_runtime_1, hooks_1, items_menu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useVisContextMenu = useVisContextMenu;
    function useVisContextMenu(idToDPItemMap, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, transformContext) {
        const itemsRenderer = (0, hooks_1.useCallback)((context) => {
            let itemDetail = transformContext ? transformContext(context) : context;
            if (!transformContext && context.type === 'item') {
                const preactItemId = context.data?.id;
                const itemData = idToDPItemMap.get(preactItemId);
                itemDetail = { ...context, itemData };
            }
            const items = contextMenuConfig?.items(itemDetail);
            return ((0, jsx_runtime_1.jsx)(items_menu_1.ItemsMenu, { items: items, onOjMenuAction: ({ key }) => {
                    onOjContextMenuAction?.({
                        menuItemKey: key,
                        contextMenuContext: itemDetail
                    });
                }, onOjMenuSelection: ({ value, menuSelectionGroupKey }) => {
                    onOjContextMenuSelection?.({
                        value,
                        contextMenuContext: itemDetail,
                        menuSelectionGroupKey
                    });
                } }));
        }, [
            contextMenuConfig?.items,
            onOjContextMenuAction,
            onOjContextMenuSelection,
            idToDPItemMap,
            transformContext
        ]);
        const preactContextMenuConfig = (0, hooks_1.useMemo)(() => {
            return {
                itemsRenderer,
                accessibleLabel: contextMenuConfig?.accessibleLabel
            };
        }, [contextMenuConfig?.accessibleLabel, itemsRenderer]);
        return { preactContextMenuConfig };
    }
});


define('oj-c/area-chart/area-chart',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/hooks", "@oracle/oraclejet-preact/UNSAFE_VisProgressiveLoader", "@oracle/oraclejet-preact/UNSAFE_LineAreaChart", "@oracle/oraclejet-preact/UNSAFE_VisStatusMessage", "@oracle/oraclejet-preact/UNSAFE_Legend", "@oracle/oraclejet-preact/UNSAFE_ChartWithLegend", "@oracle/oraclejet-preact/hooks/UNSAFE_useBusyStateContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useLegendPreferredSize", "@oracle/oraclejet-preact/UNSAFE_TrackResizeContainer", "@oracle/oraclejet-preact/hooks/UNSAFE_useUser", "ojs/ojvcomponent", "../hooks/UNSAFE_useChartData/useChartData", "../utils/PRIVATE_chartUtils/events", "../utils/PRIVATE_chartUtils/legendUtils", "../hooks/UNSAFE_useVizCategories/useVizCategories", "../utils/PRIVATE_chartUtils/lineAreaUtils", "../utils/PRIVATE_chartUtils/plotAreaUtils", "../utils/PRIVATE_chartUtils/axisUtils", "oj-c/hooks/PRIVATE_useVisContextMenu/useVisContextMenu", "css!oj-c/area-chart/area-chart-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, hooks_1, UNSAFE_VisProgressiveLoader_1, UNSAFE_LineAreaChart_1, UNSAFE_VisStatusMessage_1, UNSAFE_Legend_1, UNSAFE_ChartWithLegend_1, UNSAFE_useBusyStateContext_1, UNSAFE_useLegendPreferredSize_1, UNSAFE_TrackResizeContainer_1, UNSAFE_useUser_1, ojvcomponent_1, useChartData_1, events_1, legendUtils_1, useVizCategories_1, lineAreaUtils_1, plotAreaUtils_1, axisUtils_1, useVisContextMenu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AreaChart = void 0;
    const HIGHLIGHTED_DEFAULT = [];
    const SELECTION_DEFAULT = [];
    const HIDDEN_DEFAULT = [];
    const LEGEND_DEFAULT = { rendered: 'on', position: 'auto' };
    /**
     * @classdesc
     * <h3 id="areaChartOverview-section">
     *   JET Area Chart
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#areaChartOverview-section"></a>
     * </h3>
     * <p>An area chart displays information graphically using lines and filled areas, making relationships among the data easier to understand.</p>
     *
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-area-chart
     *   data="[[dataProvider]]">
     * &lt;/oj-c-area-chart>
     * </code>
     * </pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * To make your component accessible, the application is required to include contextual information for screender readers using one or more the following methods as appropriate:
     *  <ul>
     *   <li>aria-describedby</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-label</li>
     *   <li>short-desc property of your items</li>
     *  </ul>
     * <p>
     *  If your application has custom keyboard and touch shortcuts implemented for the component, these shortcuts can conflict with those of the component. It is the application's responsibility to disclose these custom shortcuts, possibly via a datatip or help popup.
     * </p>
     * <p>
     *  When setting color, applications are responsible for making sure that the color meets the <a target="_blank" href="https://www.w3.org/TR/WCAG21/#contrast-minimum">minimum contrast requirements</a>.
     * </p>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Move focus to next element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>Move focus to previous element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Move focus and selection to previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Move focus and selection to next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Move focus and selection to previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Move focus and selection to next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + UpArrow</kbd></td>
     *       <td>Move focus and multi-select previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + DownArrow</kbd></td>
     *       <td>Move focus and multi-select next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + LeftArrow</kbd></td>
     *       <td>Move focus and multi-select previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + RightArrow</kbd></td>
     *       <td>Move focus and multi-select next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + UpArrow</kbd></td>
     *       <td>Move focus to previous data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + DownArrow</kbd></td>
     *       <td>Move focus to next data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + LeftArrow</kbd></td>
     *       <td>Move focus to previous data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + RightArrow</kbd></td>
     *       <td>Move focus to next data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + Spacebar</kbd></td>
     *       <td>Multi-select data item with focus.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>= or +</kbd></td>
     *       <td>Zoom in one level if zooming is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>- or _</kbd></td>
     *       <td>Zoom out one level if zooming is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>PageUp or Shift + PageUp</kbd></td>
     *       <td>Pan left in left-to-right locales. Pan right in right-to-left locales.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>PageDown or Shift + PageDown</kbd></td>
     *       <td>Pan right in left-to-right locales. Pan left in right-to-left locales.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Drill on data item, categorical axis label, or legend item when <code class="prettyprint">drilling</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+F10</kbd></td>
     *       <td>Launch the context menu if there is one associated with the current item.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <h4>Data Set Size</h4>
     * <p>As a rule of thumb, it's recommended that applications only set usable data densities on the chart. For example,
     *    it's not recommended to show more than 500 area series on a 500 pixel wide chart, since the areas will be unusably thin.
     *    While there are several optimizations within the chart to deal with large data sets, it's always more efficient to
     *    reduce the data set size as early as possible. Future optimizations will focus on improving end user experience as
     *    well as developer productivity for common use cases.
     * </p>
     *
     * <h4>Styling</h4>
     * <p>Use the highest level property available. For example, consider setting styling properties on
     *    <code class="prettyprint">styleDefaults</code> or <code class="prettyprint">series</code>, instead of styling properties
     *    on the individual data items. The chart can take advantage of these higher level properties to apply the style properties on
     *    containers, saving expensive DOM calls.
     * </p>
     *
     *
     * <h3 id="touch-section">
     * Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="5">Data Item</td>
     *       <td rowspan="2"><kbd>Tap</kbd></td>
     *       <td>Select when <code class="prettyprint">selectionMode</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td>Drill when <code class="prettyprint">drilling</code> is enabled and <code class="prettyprint">selectionMode</code> is <code class="prettyprint">none</code>.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Double Tap</kbd></td>
     *       <td>Drill when <code class="prettyprint">drilling</code> is enabled and <code class="prettyprint">selectionMode</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2"><kbd>Press & Hold</kbd></td>
     *       <td>Display tooltip.</td>
     *     </tr>
     *     <tr>
     *       <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2">Categorical Axis Item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Drill when <code class="prettyprint">drilling</code> is enabled.</td>
     *     </tr>
     *      <tr>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2">Legend Item</td>
     *       <td rowspan="2"><kbd>Tap</kbd></td>
     *       <td>Drill when <code class="prettyprint">drilling</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td>Filter when <code class="prettyprint">hideAndShowBehavior</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="5">Plot Area</td>
     *       <td rowspan="2"><kbd>Drag</kbd></td>
     *       <td>Pan when panning is enabled and toggled into that mode.</td>
     *     </tr>
     *     <tr>
     *       <td>Marquee select when <code class="prettyprint">selectionMode</code> is <code class="prettyprint">multiple</code> and toggled into that mode.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Pinch-close</kbd></td>
     *       <td>Zoom out when zooming is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Spread-open</kbd></td>
     *       <td>Zoom in when zooming is enabled.</td>
     *     </tr>
     *     <tr>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *        <td>Series Area</td>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *        <td>Axis Title</td>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojmetadata description "An area chart displays information graphically using lines and filled areas, making relationships among the data easier to understand."
     * @ojmetadata displayName "Area Chart"
     * @ojmetadata main "oj-c/area-chart"
     * @ojmetadata help "oj-c.AreaChart.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/area-chart",
     *       "defaultColumns": 6,
     *         "minColumns": 1
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-area-chart",
     *     "uxSpecs": [
     *       "area-chart"
     *     ]
     *   }
     * }
     *
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *        "orientation",
     *        "legend.position",
     *        "legend.rendered",
     *        "stack",
     *        "xAxis.title",
     *        "yAxis.title",
     *        "style"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data"
     *     ]
     *   }
     * ]
     * @ojmetadata since "16.0.0"
     *
     * @ojmetadata requirements [
     *   {
     *     type: "anyOf",
     *     label: "accessibility",
     *     properties: ["aria-label", "aria-labelledby", "aria-describedby"]
     *   }
     * ]
     *
     */
    function AreaChartComp({ data, hideAndShowBehavior = 'none', orientation = 'vertical', xAxis, yAxis, y2Axis, hoverBehavior = 'none', valueFormats, plotArea, zoomAndScroll, itemTemplate, seriesTemplate, groupTemplate, seriesComparator, groupComparator, drilling = 'off', hiddenCategories = HIDDEN_DEFAULT, highlightedCategories = HIGHLIGHTED_DEFAULT, highlightMatch = 'any', selection = SELECTION_DEFAULT, selectionMode = 'none', timeAxisType, stack = 'off', legend = LEGEND_DEFAULT, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, onSelectionChanged, splitterPosition = 0.5, splitDualY = 'off', ...props }) {
        const rootRef = (0, hooks_1.useRef)(null);
        const { direction } = (0, UNSAFE_useUser_1.useUser)();
        const isRtl = direction === 'rtl';
        const busyStateContext = (0, hooks_1.useContext)(UNSAFE_useBusyStateContext_1.BusyStateContext);
        const { series, groups, getDataItem, isLoading, idToDPItemMap, createGroupContext } = (0, useChartData_1.useChartData)(data, busyStateContext.addBusyState, itemTemplate, seriesTemplate, groupTemplate, 'oj-c-area-chart-item', 'oj-c-area-chart-series', 'oj-c-area-chart-group', seriesComparator, groupComparator);
        const { majorTick: xMajorTick, ...xAxisRest } = xAxis ?? {};
        const { majorTick: yMajorTick, minorTick: yMinorTick, ...yAxisRest } = yAxis ?? {};
        const { majorTick: y2MajorTick, minorTick: y2MinorTick, ...y2AxisRest } = y2Axis ?? {};
        const { itemDrillHandler, groupDrillHandler, seriesDrillHandler } = (0, events_1.getChartEventsHandler)(series, groups, drilling, props.onOjItemDrill, props.onOjGroupDrill, props.onOjSeriesDrill, createGroupContext);
        const selectionChangeHandler = (0, hooks_1.useCallback)((detail) => {
            onSelectionChanged?.(detail.ids);
        }, [onSelectionChanged]);
        const categoriesItems = (0, legendUtils_1.getBLACCategoriesItems)(series, groups, getDataItem, hoverBehavior, hideAndShowBehavior);
        const { hiddenIds, updateHidden, highlightedIds, updateHighlighted } = (0, useVizCategories_1.useVizCategories)(categoriesItems, (item) => item.categories, hiddenCategories, highlightedCategories, 'any', highlightMatch, props.onHiddenCategoriesChanged, props.onHighlightedCategoriesChanged);
        const onItemInput = (0, hooks_1.useCallback)((detail) => {
            if (hoverBehavior === 'none')
                return;
            const id = (0, events_1.getIdFromDetail)(detail, series, getDataItem);
            updateHighlighted(id);
        }, [hoverBehavior, updateHighlighted, series, getDataItem]);
        const legendData = (0, legendUtils_1.getLegendData)(series);
        const isLegendInteractive = hideAndShowBehavior != 'none' || hoverBehavior != 'none' || drilling === 'on';
        const legendItemActionHandler = (0, hooks_1.useCallback)((detail) => {
            if (hideAndShowBehavior != 'none') {
                updateHidden(detail.itemId);
                return;
            }
            seriesDrillHandler(detail);
        }, [hideAndShowBehavior, updateHidden, seriesDrillHandler]);
        const legendItemInputHandler = (0, hooks_1.useCallback)((detail) => {
            if (hoverBehavior != 'none') {
                updateHighlighted(detail.itemId);
            }
        }, [hoverBehavior, updateHighlighted]);
        const { preactContextMenuConfig } = (0, useVisContextMenu_1.useVisContextMenu)(idToDPItemMap, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection);
        const renderLegend = (0, legendUtils_1.shouldRenderLegend)(series.length, legend.rendered);
        const legendSizeRef = (0, hooks_1.useRef)(null);
        const [isGetPreferredSizeReady, setIsGetPreferredSizeReady] = (0, hooks_1.useState)(false);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, children: (0, jsx_runtime_1.jsx)(UNSAFE_TrackResizeContainer_1.TrackResizeContainer, { width: "100%", height: "100%", children: (_width, _height) => {
                    const legendPreferredSize = isGetPreferredSizeReady
                        ? legendSizeRef.current._getPreferredSize(_width, _height)
                        : undefined;
                    const legendPosition = (0, legendUtils_1.getLegendPosition)(legend.position, _width, _height);
                    const isLegendDimsResolved = !renderLegend || (renderLegend && legendPreferredSize);
                    const legendGap = (0, legendUtils_1.getLegendGap)(_width, _height);
                    const { width: preactChartWidth, height: preactChartHeight } = (0, legendUtils_1.getPreactChartDimensions)(_width, _height, legendPosition, legendPreferredSize);
                    const chart = series.length > 0 && groups.length > 0 && isLegendDimsResolved ? ((0, jsx_runtime_1.jsx)(UNSAFE_LineAreaChart_1.LineAreaChart, { type: "area", width: preactChartWidth, height: preactChartHeight, series: series, groups: groups, getDataItem: getDataItem, onItemHover: onItemInput, onItemFocus: onItemInput, drilling: drilling, dragMode: props.dragMode, onItemDrill: itemDrillHandler, onGroupDrill: groupDrillHandler, onSelectionChange: selectionChangeHandler, selectionMode: selectionMode, selectedIds: selectionMode === 'none' ? undefined : selection, orientation: orientation, xAxis: (0, axisUtils_1.getPreactAxisProps)({ ...xAxisRest, timeAxisType }, props.styleDefaults), yAxis: (0, axisUtils_1.getPreactAxisProps)(yAxisRest), y2Axis: {
                            ...(0, axisUtils_1.getPreactAxisProps)(y2AxisRest),
                            split: splitDualY === 'on' ? 1 - splitterPosition : 'off'
                        }, highlightedIds: highlightedIds.length === 0 ? undefined : highlightedIds, hiddenIds: hiddenIds, plotArea: (0, plotAreaUtils_1.getPlotArea)(plotArea, yMajorTick, yMinorTick, xMajorTick, y2MajorTick, y2MinorTick), hideAndShowBehavior: hideAndShowBehavior, hoverBehavior: hoverBehavior, isStacked: stack === 'on', valueFormats: (0, lineAreaUtils_1.transformValueFormats)(valueFormats), "aria-label": props['aria-label'], "aria-describedBy": props['aria-describedby'], "aria-labelledBy": props['aria-labelledby'], 
                        //@ts-ignore
                        contextMenuConfig: contextMenuConfig ? preactContextMenuConfig : undefined })) : (!isLoading && ((0, jsx_runtime_1.jsx)(UNSAFE_VisStatusMessage_1.VisNoData, { "aria-label": props['aria-label'], "aria-describedby": props['aria-describedby'], "aria-labelledby": props['aria-labelledby'] })));
                    const legendMaxWidth = legendPosition === 'start' || legendPosition === 'end'
                        ? (legendPreferredSize?.width || _width * legendUtils_1.LEGENDMAXSIZE) + legendGap.width
                        : _width;
                    const legendMaxHeight = legendPosition === 'top' || legendPosition === 'bottom'
                        ? (legendPreferredSize?.height || _height * legendUtils_1.LEGENDMAXSIZE) + legendGap.height
                        : _height;
                    const chartLegend = renderLegend && legendData.length > 0 ? (
                    // TODO: replace with sectional legend when implementing
                    // reference line. Currently sectional legend does not render properly
                    // for top and bottom legend position.
                    (0, jsx_runtime_1.jsx)(UNSAFE_useLegendPreferredSize_1.LegendRenderedContext.Provider, { value: {
                            isGetPreferredSizeReady: !isGetPreferredSizeReady
                                ? setIsGetPreferredSizeReady
                                : undefined,
                            width: legendMaxWidth,
                            height: legendMaxHeight
                        }, children: (0, jsx_runtime_1.jsx)(UNSAFE_Legend_1.Legend, { items: legendData, ref: legendSizeRef, orientation: legendPosition === 'start' || legendPosition === 'end'
                                ? 'vertical'
                                : 'horizontal', halign: "center", valign: "center", hideAndShowBehavior: hideAndShowBehavior === 'none' ? 'off' : 'on', hoverBehavior: hoverBehavior, isReadOnly: !isLegendInteractive, highlightedIds: highlightedIds.length === 0 ? undefined : highlightedIds, hiddenIds: hiddenIds.length === 0 ? undefined : hiddenIds, symbolHeight: legend.symbolHeight, symbolWidth: legend.symbolWidth, onItemAction: legendItemActionHandler, onItemHover: legendItemInputHandler, onItemFocus: legendItemInputHandler }) })) : undefined;
                    return ((0, jsx_runtime_1.jsx)(UNSAFE_VisProgressiveLoader_1.VisProgressiveLoader, { isLoading: isLoading, type: "area", "aria-label": props['aria-label'], "aria-describedBy": props['aria-describedby'], "aria-labelledBy": props['aria-labelledby'], children: (0, jsx_runtime_1.jsx)(UNSAFE_ChartWithLegend_1.ChartWithLegend, { chart: chart, position: legendPosition, isRtl: isRtl, legend: chartLegend }) }));
                } }) }));
    }
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const AreaChartWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-area-chart', AreaChartComp, "AreaChart", { "properties": { "data": { "type": "DataProvider|null" }, "seriesComparator": { "type": "function" }, "groupComparator": { "type": "function" }, "stack": { "type": "string", "enumValues": ["off", "on"] }, "drilling": { "type": "string", "enumValues": ["off", "on"] }, "orientation": { "type": "string", "enumValues": ["horizontal", "vertical"] }, "timeAxisType": { "type": "string", "enumValues": ["enabled", "mixedFrequency", "skipGaps"] }, "yAxis": { "type": "object", "properties": { "dataMax": { "type": "number" }, "dataMin": { "type": "number" }, "max": { "type": "number" }, "min": { "type": "number" }, "majorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "minorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "tickLabel": { "type": "object", "properties": { "converter": { "type": "object" }, "rendered": { "type": "string", "enumValues": ["off", "on"] }, "style": { "type": "object" } } }, "viewportMin": { "type": "number" }, "viewportMax": { "type": "number" }, "step": { "type": "number" }, "size": { "type": "number" }, "scale": { "type": "string", "enumValues": ["linear", "log"] }, "title": { "type": "string" }, "titleStyle": { "type": "object" } } }, "y2Axis": { "type": "object", "properties": { "dataMax": { "type": "number" }, "dataMin": { "type": "number" }, "max": { "type": "number" }, "min": { "type": "number" }, "majorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "minorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "tickLabel": { "type": "object", "properties": { "converter": { "type": "object" }, "rendered": { "type": "string", "enumValues": ["off", "on"] }, "style": { "type": "object" } } }, "viewportMin": { "type": "number" }, "viewportMax": { "type": "number" }, "step": { "type": "number" }, "size": { "type": "number" }, "scale": { "type": "string", "enumValues": ["linear", "log"] }, "title": { "type": "string" }, "titleStyle": { "type": "object" } } }, "splitDualY": { "type": "string", "enumValues": ["off", "on"] }, "splitterPosition": { "type": "number" }, "xAxis": { "type": "object", "properties": { "majorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "minorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "tickLabel": { "type": "object", "properties": { "converter": { "type": "object|Array<object>" }, "rendered": { "type": "string", "enumValues": ["off", "on"] }, "rotation": { "type": "string", "enumValues": ["auto", "none"] }, "style": { "type": "object" } } }, "viewportMin": { "type": "number" }, "viewportMax": { "type": "number" }, "step": { "type": "number" }, "size": { "type": "number" }, "scale": { "type": "string", "enumValues": ["linear", "log"] }, "title": { "type": "string" }, "titleStyle": { "type": "object" } } }, "plotArea": { "type": "object", "properties": { "backgroundColor": { "type": "string" } } }, "zoomAndScroll": { "type": "string", "enumValues": ["off", "live"] }, "valueFormats": { "type": "object", "properties": { "group": { "type": "object", "properties": { "tooltipLabel": { "type": "string" }, "tooltipDisplay": { "type": "string", "enumValues": ["auto", "off"] } } }, "series": { "type": "object", "properties": { "tooltipLabel": { "type": "string" }, "tooltipDisplay": { "type": "string", "enumValues": ["auto", "off"] } } }, "value": { "type": "object", "properties": { "converter": { "type": "object" }, "tooltipLabel": { "type": "string" }, "tooltipDisplay": { "type": "string", "enumValues": ["auto", "off"] } } } } }, "styleDefaults": { "type": "object", "properties": { "groupSeparators": { "type": "object", "properties": { "rendered": { "type": "string", "enumValues": ["auto", "off"] }, "color": { "type": "string" } } } } }, "selectionMode": { "type": "string", "enumValues": ["none", "multiple", "single"] }, "selection": { "type": "Array<string|number>", "writeback": true }, "hiddenCategories": { "type": "Array<string>", "writeback": true }, "dragMode": { "type": "string", "enumValues": ["pan", "zoom", "select", "off", "user"] }, "highlightedCategories": { "type": "Array<string>", "writeback": true }, "hideAndShowBehavior": { "type": "string", "enumValues": ["none", "withoutRescale", "withRescale"] }, "hoverBehavior": { "type": "string", "enumValues": ["none", "dim"] }, "highlightMatch": { "type": "string", "enumValues": ["all", "any"] }, "legend": { "type": "object", "properties": { "position": { "type": "string", "enumValues": ["auto", "end", "start", "top", "bottom"] }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] }, "maxSize": { "type": "number|string" }, "size": { "type": "number|string" }, "symbolHeight": { "type": "number" }, "symbolWidth": { "type": "number" } } }, "contextMenuConfig": { "type": "object", "properties": { "accessibleLabel": { "type": "string" }, "items": { "type": "function" } } } }, "slots": { "itemTemplate": { "data": {} }, "seriesTemplate": { "data": {} }, "groupTemplate": { "data": {} } }, "events": { "ojViewportChange": {}, "ojItemDrill": {}, "ojGroupDrill": {}, "ojSeriesDrill": {}, "ojContextMenuAction": { "bubbles": true }, "ojContextMenuSelection": { "bubbles": true } }, "extension": { "_WRITEBACK_PROPS": ["selection", "hiddenCategories", "highlightedCategories"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-describedby", "aria-labelledby"] } }, { "hideAndShowBehavior": "none", "orientation": "vertical", "hoverBehavior": "none", "drilling": "off", "hiddenCategories": [], "highlightedCategories": [], "highlightMatch": "any", "selection": [], "selectionMode": "none", "stack": "off", "legend": { "rendered": "on", "position": "auto" }, "splitterPosition": 0.5, "splitDualY": "off" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
    exports.AreaChart = AreaChartWithoutDefaultedGenerics;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/area-chart',["require", "exports", "oj-c/area-chart/area-chart"], function (require, exports, area_chart_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AreaChart = void 0;
    Object.defineProperty(exports, "AreaChart", { enumerable: true, get: function () { return area_chart_1.AreaChart; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/area-chart-item',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});

define('oj-c/area-chart-series/area-chart-series',["require", "exports", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent"], function (require, exports, translationBundle_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AreaChartSeries = exports.AreaChartSeriesDefaults = void 0;
    exports.AreaChartSeriesDefaults = {
        drilling: 'inherit'
    };
    exports.AreaChartSeries = (0, ojvcomponent_1.registerCustomElement)('oj-c-area-chart-series', 
    /**
     *@classdesc
     *<h3 id="areaChartSeriesOverview-section">
     *   JET Area Chart Series
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#areaChartSeriesOverview-section"></a>
     * </h3>
     *
     * <p>The oj-c-area-chart-series element is used to declare series properties. See the Help documentation for more information</p>
     *
     *<pre class="prettyprint">
     * <code>
     * &lt;oj-c-area-chart data="[[dataProvider]]">
     *  &lt;template slot='seriesTemplate'>
     *    &lt;oj-c-area-chart-series
     *      drilling='on'
     *      marker-shape='[[ $current.id == "Series 1" ? "square" : "circle" ]]'>
     *    &lt;/oj-c-area-chart-series>
     *  &lt;/template>
     * &lt;/oj-c-area-chart>
     * </code>
     * </pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     *  Read the <a target="_blank" href="oj-c.AreaChart.html#a11y-section">Accessibility Section</a> of the oj-c-area-chart component for details about making this component accessible.
     * </p>
     *
     * @ojmetadata subcomponentType "data"
     * @ojmetadata description "The oj-c-area-chart-series element is used to declare series properties in the seriesTemplate"
     * @ojmetadata displayName "AreaChartSeries"
     * @ojmetadata main "oj-c/area-chart-series"
     * @ojmetadata help "oj-c.AreaChartSeries.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   }
     * }
     * @ojmetadata since "16.0.0"
     *
     */
    ({ drilling = exports.AreaChartSeriesDefaults.drilling, 
    /* @ts-ignore */
    ...props }) => {
        return null;
    }, "AreaChartSeries", { "properties": { "assignedToY2": { "type": "string", "enumValues": ["off", "on"] }, "categories": { "type": "Array<string>" }, "color": { "type": "string" }, "drilling": { "type": "string", "enumValues": ["inherit", "off", "on"] }, "lineType": { "type": "string", "enumValues": ["curved", "straight"] }, "markerShape": { "type": "string", "enumValues": ["auto", "square", "circle", "diamond", "human", "plus", "star", "triangleDown", "triangleUp"] }, "markerColor": { "type": "string" }, "markerDisplayed": { "type": "string" }, "markerSize": { "type": "number" }, "name": { "type": "string" }, "shortDesc": { "type": "string" } } }, { "drilling": "inherit" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/area-chart-series',["require", "exports", "oj-c/area-chart-series/area-chart-series"], function (require, exports, area_chart_series_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AreaChartSeries = void 0;
    Object.defineProperty(exports, "AreaChartSeries", { enumerable: true, get: function () { return area_chart_series_1.AreaChartSeries; } });
});

define('oj-c/area-chart-group/area-chart-group',["require", "exports", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent"], function (require, exports, translationBundle_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AreaChartGroup = exports.AreaChartGroupDefaults = void 0;
    exports.AreaChartGroupDefaults = {
        drilling: 'inherit'
    };
    exports.AreaChartGroup = (0, ojvcomponent_1.registerCustomElement)('oj-c-area-chart-group', 
    /**
     *@classdesc
     *<h3 id="areaChartGroupOverview-section">
     *   JET Area Chart Group
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#areaChartGroupOverview-section"></a>
     * </h3>
     *
     * <p>The oj-c-area-chart-group element is used to declare group properties. See the Help documentation for more information.</p>
     *
     *<pre class="prettyprint">
     * <code>
     * &lt;oj-c-area-chart data="[[dataProvider]]">
     *  &lt;template slot='groupTemplate'>
     *    &lt;oj-c-area-chart-group
     *      drilling='on'
     *      label-style='[[$current.depth == 1 ? {"fontWeight":"bold"} : {"fontStyle":"italic"}]]'>
     *    &lt;/oj-c-area-chart-group>
     *  &lt;/template>
     * &lt;/oj-c-area-chart>
     * </code>
     * </pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     *  Read the <a target="_blank" href="oj-c.AreaChart.html#a11y-section">Accessibility Section</a> of the oj-c-area-chart component for details about making this component accessible.
     * </p>
     *
     * @ojmetadata subcomponentType "data"
     * @ojmetadata description "The oj-c-area-chart-group element is used to declare group properties in the groupTemplate"
     * @ojmetadata displayName "AreaChartGroup"
     * @ojmetadata main "oj-c/area-chart-group"
     * @ojmetadata help "oj-c.AreaChartGroup.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   }
     * }
     * @ojmetadata since "16.0.0"
     *
     */
    ({ drilling = exports.AreaChartGroupDefaults.drilling, 
    /* @ts-ignore */
    ...props }) => {
        return null;
    }, "AreaChartGroup", { "properties": { "drilling": { "type": "string", "enumValues": ["inherit", "off", "on"] }, "name": { "type": "string" }, "shortDesc": { "type": "string" } } }, { "drilling": "inherit" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/area-chart-group',["require", "exports", "oj-c/area-chart-group/area-chart-group"], function (require, exports, area_chart_group_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AreaChartGroup = void 0;
    Object.defineProperty(exports, "AreaChartGroup", { enumerable: true, get: function () { return area_chart_group_1.AreaChartGroup; } });
});

define('oj-c/date-picker/date-picker',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/hooks", "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_DatePicker", "@oracle/oraclejet-preact/UNSAFE_IntlDateTime", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/utils/UNSAFE_calendarDateUtils"], function (require, exports, jsx_runtime_1, translationBundle_1, hooks_1, ojvcomponent_1, UNSAFE_DatePicker_1, UNSAFE_IntlDateTime_1, UNSAFE_useTabbableMode_1, UNSAFE_calendarDateUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DatePicker = void 0;
    exports.DatePicker = (0, ojvcomponent_1.registerCustomElement)('oj-c-date-picker', 
    /**
     * @classdesc
     * <h3 id="datePickerOverview-section">
     *   JET DatePicker Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#datePickerOverview-section"></a>
     * </h3>
     *
     * <p>Description: A DatePicker is a calendar interface that allows users to select a single date.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-date-picker value="2023-03-20">&lt;/oj-c-date-picker></code></pre>
     *
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Month/Year picker buttons</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Toggles between Date picker mode and Month/Year picker mode.</td>
     *     </tr>
     *     <tr>
     *       <td>Prev/Next buttons</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Moves to the prev/next month in the date picker or to the prev/next decade in the year picker.</td>
     *     </tr>
     *     <tr>
     *       <td>Today button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Navigates to the Year and Month that contains today's date.</td>
     *     </tr>
     *     <tr>
     *       <td>Day Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Selects this day as the current date.</td>
     *     </tr>
     *     <tr>
     *       <td>Month Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>In the month picker, selects this month and returns to the date picker, refreshing the display to show the selected month.</td>
     *     </tr>
     *     <tr>
     *       <td>Year Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>In the year picker, selects this year and returns to the date picker, refreshing the display to show the selected year.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Date Picker</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td>
     *         Moves the focus to next element in the date picker sequence. Only one element in the calendar grid is in the Tab sequence
     *         (current day/month/year or selected day/month/year depending on scenario). If focus is on the last tabbable element
     *         inside the date picker, moves focus off the date picker to the next tabbable element on the page.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Date Picker</td>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>
     *         Moves the focus to the previous tabbable element inside the date picker. If focus is on the first tabbable element
     *         inside the date picker, moves focus off the date picker to the previous tabbable element on the page.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Date Picker</td>
     *       <td><kbd>Enter/Space</kbd></td>
     *       <td>
     *         Selects the currently focused day or activates the button currently focused.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>PageUp</kbd></td>
     *       <td>Changes the calendar grid to the previous month. Moves focus to the closest day in the previous month.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>PageDown</kbd></td>
     *       <td>Changes the calendar grid to the next month. Moves focus to the closest day in the next month.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>Shift + PageUp</kbd></td>
     *       <td>Changes the calendar grid to the previous year. Moves focus to the closest day of the same month in the previous year.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>Shift + PageDown</kbd></td>
     *       <td>Changes the calendar grid to the next year. Moves focus to the closest day of the same month in the next year.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>Ctrl + Alt + T or Ctrl + Option + T</kbd></td>
     *      <td>Changes the calendar grid to the year and month that contains today's date. Moves focus to Today.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>Go to the first day of the current month.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>End</kbd></td>
     *       <td>Go to the last day of the current month.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>ArrowLeft</kbd></td>
     *       <td>Moves focus to the previous day. In RTL, this will move focus to the next day.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>ArrowRight</kbd></td>
     *       <td>Moves focus to the next day. In RTL, this will move focus to the previous day.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>ArrowUp</kbd></td>
     *       <td>Moves focus to the same day of the previous week.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>ArrowDown</kbd></td>
     *       <td>Moves focus to the same day of the next week.</td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>Enter/Space</kbd></td>
     *       <td>
     *         Selects the currently focused month and returns to the date picker, refreshing the display to show the selected month.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Moves focus to four months back from the current focused month.</td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Moves focus to four months ahead from the current focused month.</td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Moves focus to the next month. In RTL, this will move focus to the previous month.</td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Moves focus to the previous month. In RTL, this will move focus to the next month.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>Enter/Space</kbd></td>
     *       <td>
     *         Selects the currently focused year and returns to the date picker, refreshing the display to show the selected month.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>PageUp</kbd></td>
     *       <td>Changes the year grid to the previous decade. The focus remains in the same location with respect to the current decade.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>PageDown</kbd></td>
     *       <td>Changes the year grid to the next decade. The focus remains in the same location with respect to the current decade.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Moves focus to four years back from the current focused year. If that year is not in the year grid, go back 1 decade.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Moves focus to four years ahead from the current focused year. If that year is not in the year grid, go ahead 1 decade.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Moves focus to the next year. In RTL, this will move focus to the previous year.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Moves focus to the previous year. In RTL, this will move focus to the next year.</td>
     *     </tr>
     *   </tbody>
     * </table>
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * The oj-c-date-picker is not intended to be a labelled component.  Component authors using this component should use the aria-describedby to give
     * a description of the date being entered.
     * </p>
     *
     * @ojmetadata description "A DatePicker is a calendar interface that allows users to select a single date."
     * @ojmetadata displayName "DatePicker"
     * @ojmetadata help "oj-c.DatePicker.html"
     * @ojmetadata main "oj-c/date-picker"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/date-picker"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-date"
     *   }
     * }
     * @ojmetadata since "17.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "17.1.0",
     *     "value": ["oj-date-picker"]
     *   }
     * ]
     */
    ({ dayFormatter, daysOutsideMonth = 'hidden', monthAndYearPicker = 'on', max = null, maxWidth, min = null, readonly = false, todayButton = 'visible', todayTimeZone, value = null, width, weekDisplay = 'none', onValueChanged, ...otherProps }) => {
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(value)) {
            throw new Error('value must be a date-only ISO string');
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(min)) {
            throw new Error('min must be a date-only ISO string');
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(max)) {
            throw new Error('max must be a date-only ISO string');
        }
        // we know these are date only ISO strings, so comparing strings should be fine.
        if (max && min && max < min) {
            throw new Error('max must be greater than or equal to min');
        }
        const maxCalendarDate = max ? (0, UNSAFE_calendarDateUtils_1.getCalendarDateFromIso)(max) : undefined;
        const minCalendarDate = min ? (0, UNSAFE_calendarDateUtils_1.getCalendarDateFromIso)(min) : undefined;
        const valueCalendarDate = value
            ? (0, UNSAFE_calendarDateUtils_1.getCalendarDateFromIso)(value)
            : undefined;
        const onCommitHandler = (0, hooks_1.useCallback)(({ value, previousValue }) => {
            if (onValueChanged && value !== previousValue) {
                value
                    ? onValueChanged((0, UNSAFE_calendarDateUtils_1.getIsoDateStr)(value.year, value.month, value.day))
                    : onValueChanged(null);
            }
        }, [onValueChanged]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: otherProps.id, children: (0, jsx_runtime_1.jsx)(UNSAFE_DatePicker_1.DatePicker, { dayFormatter: dayFormatter ?? undefined, daysOutsideMonth: daysOutsideMonth, monthAndYearPicker: monthAndYearPicker, max: maxCalendarDate, min: minCalendarDate, isReadonly: readonly, todayButton: todayButton, todayTimeZone: todayTimeZone ?? undefined, value: valueCalendarDate, weekDisplay: weekDisplay, width: width, maxWidth: maxWidth, onCommit: onCommitHandler }) }));
    }, "DatePicker", { "properties": { "dayFormatter": { "type": "function" }, "daysOutsideMonth": { "type": "string", "enumValues": ["hidden", "selectable"] }, "monthAndYearPicker": { "type": "string", "enumValues": ["off", "on"] }, "max": { "type": "string|null" }, "maxWidth": { "type": "number|string" }, "min": { "type": "string|null" }, "readonly": { "type": "boolean" }, "todayButton": { "type": "string", "enumValues": ["hidden", "visible"] }, "todayTimeZone": { "type": "string" }, "value": { "type": "string|null", "writeback": true }, "weekDisplay": { "type": "string", "enumValues": ["number", "none"] }, "width": { "type": "number|string" } }, "extension": { "_WRITEBACK_PROPS": ["value"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] } }, { "daysOutsideMonth": "hidden", "monthAndYearPicker": "on", "max": null, "min": null, "readonly": false, "todayButton": "visible", "value": null, "weekDisplay": "none" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/date-picker',["require", "exports", "oj-c/date-picker/date-picker"], function (require, exports, date_picker_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DatePicker = void 0;
    Object.defineProperty(exports, "DatePicker", { enumerable: true, get: function () { return date_picker_1.DatePicker; } });
});


define('oj-c/dialog/dialog',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_Layer", "@oracle/oraclejet-preact/UNSAFE_Dialog", "preact/hooks", "ojs/ojcontext", "css!oj-c/dialog/dialog-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_Layer_1, UNSAFE_Dialog_1, hooks_1, Context) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dialog = void 0;
    const LAYER_CONTENT = Symbol.for('__oj_c_layer_content');
    exports.Dialog = (0, ojvcomponent_1.registerCustomElement)('oj-c-dialog', 
    /**
     * @classdesc
     * <h3 id="dialogOverview-section">
     *   JET Dialog
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dialogOverview-section"></a>
     * </h3>
     * <p>
     *   Description: A Dialog is a floating window that typically contains a header, content and footer area.
     *   A Dialog is typically modal and centered in viewport. The dialog window can be moved by dragging on the title area,
     *   and closed with the 'x' icon (by default). Dialogs can also be resized by dragging on edges or corners of the dialog component.
     * </p>
     * <p>
     *   If the content length exceeds the maximum height, a scrollbar will automatically appear.
     * </p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-dialog opened="true">
     *    &lt;div slot="header">Dialog Header&lt;/div>
     *    &lt;div slot="body">Dialog Body&lt;/div>
     *    &lt;div slot="footer">Dialog Footer&lt;/div>
     * &lt;/oj-c-dialog>
     *
     * Main section content
     * </code></pre>
     *
     * <h3 id="focus-section">
     *   Focus
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#focus-section"></a>
     * </h3>
     *
     * <p>Upon opening a dialog, focus is automatically moved to the first item that matches the following:</p>
     * <ol>
     *  <li>The first <code>:tabbable</code> element within the dialog body</li>
     *  <li>The first <code>:tabbable</code> element within the dialog footer</li>
     *  <li>The dialog's close button</li>
     *  <li>The dialog itself</li>
     * </ol>
     * <p>The use of the HTML <code>autofocus</code> global attribute is discouraged.
     * If specified, the dialog will try to honor it but it may have undesirable implications for accessibility.
     * For more details, see the <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus#accessibility_concerns">Accessibility concerns section</a>.</p>
     *
     * <p>While open, the dialog widget ensures that tabbing cycles focus between elements within the dialog itself, not elements outside of it. Modal dialogs additionally prevent mouse users from clicking on elements outside of the dialog.</p>
     *
     * <p>Upon closing a dialog, focus is automatically returned to the element that had focus when the dialog was opened.</p>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     * <table class="keyboard-table">
     *  <thead>
     *    <tr>
     *      <th>Target</th>
     *      <th>Key</th>
     *      <th>Action</th>
     *    </tr>
     *  </thead>
     *  <tbody>
     *    <tr>
     *       <td rowspan = "3">Dialog</td>
     *       <td><kbd>Tab</kbd> or <kbd>Shift + Tab</kbd></td>
     *       <td>Navigate the content of the Dialog.</td>
     *    </tr>
     *    <tr>
     *      <td><kbd>F6</kbd></td>
     *      <td>Move focus to the launcher for a Dialog with modeless modality.</td>
     *    </tr>
     *    <tr>
     *      <td><kbd>Esc</kbd></td>
     *      <td>Close the Dialog.</td>
     *    </tr>
     *    <tr>
     *       <td>Dialog Close Icon</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Close the Dialog.</td>
     *     </tr>
     *    <tr>
     *      <td rowspan = "1">Dialog Launcher</td>
     *      <td><kbd>F6</kbd></td>
     *      <td>Move focus to the first tab stop within the open Dialog. If there is not a tab stop
     *          within the content, focus is established on the Dialog.</td>
     *     </tr>
     *  </tbody>
     * </table>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *  <thead>
     *    <tr>
     *      <th>Target</th>
     *      <th>Gesture</th>
     *      <th>Action</th>
     *    </tr>
     *  </thead>
     *  <tbody>
     *    <tr>
     *       <td rowspan = "3">Dialog Close Icon</td>
     *       <td>Tap</td>
     *       <td>Close the Dialog</td>
     *    </tr>
     *  </tbody>
     * </table>
     *
     * <h3>
     *   Sizing
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sizing"></a>
     * </h3>
     *
     * <p> Dialog dimensions, including <code class="prettyprint"> height, width, min-width, max-width, min-height</code> and <code class="prettyprint">max-height</code> are defined with attriutes. The default dialog dimensions are the following:
     *
     * <ul>
     *  <li> <code class="prettyprint">height: auto</code> </li>
     *  <li> <code class="prettyprint">width: 600px</code> </li>
     *  <li> <code class="prettyprint">min-width: 200px</code> </li>
     *  <li> <code class="prettyprint">max-width: min(600px, 90vw)</code> </li>
     *  <li> <code class="prettyprint">max-height: min(600px, 90vh)</code> </li>
     * </ul>
     *
     * In most cases, you will want to use the default <code class="prettyprint">height:auto</code>, since this will automatically adjust the height based on the content.
     * Users can change the dialog dimensions using style attributes:
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-dialog id="wideDialog" title="Wide Dialog" width="400px" min-width="100px" max-width="500px"&gt;
     *    &lt;div slot="body"&gt;
     *       &lt;p&gt; Dialog Text
     *    &lt;/div&gt;
     * &lt;/oj-c-dialog&gt;
     * </code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <h4> role </h4>
     * By default, the role will be set to dialog.
     * This can be observed by inspecting the DOM:
     *
     * <pre class="prettyprint">
     * <code>
     *  &lt;div class="ojdialog ..." role="dialog"&gt;
     * </code></pre>
     *
     * This can be changed using the role attribute. WAI-ARIA recommends that role="dialog" be used if the dialog expects input (such as text input),
     * otherwise, use the role attribute to assign role="alertdialog".
     *
     * <h4> aria-labelledby </h4>
     *
     * For simple dialog headers specified using the dialog-title attribute, the dialog component takes care of the
     * <code class="prettyprint">aria-labelledby</code> attribute and sets it automatically unless explicitly specified by the user.
     * For custom dialog headers specified using the header slot, the user is responsible for setting the
     * <code class="prettyprint">aria-labelledby</code> attribute and its association with the custom header content.
     *
     * <h4> aria-describedby </h4>
     *
     * If the dialog contains additional descriptive text besides the dialog title, this text can be associated
     * with the dialog using the <code class="prettyprint">aria-describedby</code> attribute. Unlike the
     * <code class="prettyprint">aria-labelledby</code> association,
     * the <code class="prettyprint">aria-describedby</code> attribute is never generated and set automatically.
     * It is up to the user to specify the attribute
     * on <code class="prettyprint">oj-dialog</code> and link it to the element containing the additional description:
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-dialog id="dialog" title="Accessible Title" aria-describedby="desc"&gt;
     *    &lt;div slot="body"&gt;
     *       &lt;p id="desc"&gt; This is a dialog with accessible description.
     *    &lt;/div&gt;
     * &lt;/oj-c-dialog&gt;
     * </code></pre>
     *
     * <h3 id="reparenting-section">
     *   Reparenting
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#reparenting-section"></a>
     * </h3>
     * <p id="reparenting-strategy">
     *    When dialogs are open, they will be reparented in the document and reparented back when
     *    closed. When open, the location of the dialog within the document will be in context of
     *    how it's used. Dialogs open from other dialogs will be relocated in the document into the
     *    nearest parent dialog's layer. The dialogs layer defines its z-index weight "stacking
     *    context".
     *    The context of opening is defined by the launcher argument passed to the open method.  If
     *    not open from another dialog, the dialog will be reparented to a container in the document
     *    body. Dialogs of the same type are assigned the same z-index values.  The layering between
     *    peer popups reflect the opening order.
     * </p>
     * <p>
     *     There are known caveats with this design. However, these scenarios are considered "bad use"
     *     based on our JET popup strategy.
     *  </p>
     *  <ol>
     *    <li>Events raised within the dialog will not bubble up to the dialog's original ancestors.
     *        Instead, listeners for dialog events should be applied to either the dialog's root
     *        element, or the document.</li>
     *    <li>Likewise, developers should not use CSS descendant selectors, or similar logic, that
     *        assumes that the popup will remain a child of its original parent.</li>
     *    <li>Dialogs containing iframes are problematic.  The iframe elements "may" fire a HTTP GET
     *        request for its src attribute each time the iframe is reparented in the document.</li>
     *    <li>If an iframe is added to the dialog's content, it must not be the first or last tab stop
     *        within the popup or keyboard and VoiceOver navigation will not remain within the dialog.</li>
     *    <li>In some browsers, reparenting a dialog that contains elements having overflow, will cause
     *        these overflow elements to reset their scrollTop.</li>
     *  </ol>
     *
     * <h3 id="rtl-section">
     *   Reading direction
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
     * </h3>
     *
     * <p> Setting the reading direction (LTR or RTL) is supported by setting the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> element of the page.  As with any JET component, in the unusual case that the reading direction
     * is changed post-init, the dialog must be <code class="prettyprint">refresh()</code>ed, or the page must be reloaded.
     *
     *<h3>Additional Examples</h3>
     *
     * <p> The following defines a basic dialog, with an ok button in the footer:
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-dialog id="dialogWithFooter" dialog-title="Dialog with Footer" width=400px" min-width="100px" max-widt="500px"&gt;
     *    &lt;div slot="body"&gt;
     *       &lt;p&gt; Dialog Text
     *    &lt;/div&gt;
     *    &lt;div slot="footer"&gt;
     *       &lt;oj-button id="okButton"&gt; OK &lt;/oj-button&gt;
     *    &lt;/div&gt;
     * &lt;/oj-c-dialog&gt;
     *
     * </code></pre>
     *
     * Note that you will need to define your own event handlers for the ok and close buttons (see the demos for examples of this).
     *
     * <p> A dialog with user-defined header is shown next. Arbitrary header content can be defined using a user-defined header.
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-dialog id="dialog" dialog-title="Dialog Title"&gt;
     *    &lt;div slot="header"&gt;
     *       &lt;span id="dialog-title-id" class="dialog-title"&gt; User Defined Header&lt;/span&gt;
     *    &lt;/div&gt;
     *    &lt;div slot="body"&gt;
     *       &lt;p&gt; Dialog Text
     *    &lt;/div&gt;
     * &lt;/oj-dialog&gt;
     * </code></pre>
     *
     *
     * @ojmetadata description 'A Dialog is a floating window that typically contains a header, content and footer area.
     * A Dialog is typically modal and centered in viewport.'
     * @ojmetadata displayName 'Dialog'
     * @ojmetadata help 'oj-c.Dialog.html'
     * @ojmetadata main 'oj-c/dialog'
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "19.0.0",
     *     "value": ["oj-dialog"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Layout & Nav"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/dialog"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-dialog",
     *     "uxSpecs": [
     *       "dialog"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *      "header",
     *      "body",
     *      "footer",
     *      "cancelBehavior",
     *      "dialogTitle",
     *      "dragAffordance",
     *      "headerDecoration",
     *      "launcher,
     *      "modality"
     *      "opened"
     *      "resizeBehavior",
     *      "role",
     *      "anchor",
     *      "placement",
     *      "offset",
     *      "collision",
     *      "onOpenedChanged",
     *      "onOjOpen",
     *      "onOjBeforeClose",
     *      "onOjClose",
     *      "onOjFocus",
     *      // Sizing interpolations
     *      "width",
     *      "minWidth",
     *      "maxWidth",
     *      "height",
     *      "minHeight",
     *      "maxHeight",
     *     ]
     *   }
     * ]
     * @ojmetadata since "18.0.0"
     */
    ({ id, header, body, footer, cancelBehavior = 'none', dialogTitle, dragAffordance = 'none', headerDecoration = 'on', launcher, modality = 'modal', opened = false, resizeBehavior = 'none', anchor, placement, offset, onOjOpen, onOjBeforeClose, onOjClose, onOjFocus, 
    // Drag&Resize
    onOjDragStart, onOjDragMove, onOjDragEnd, onOjResizeStart, onOjResize, onOjResizeEnd, onOpenedChanged, 
    // role = "dialog",
    // Sizing interpolations
    width, minWidth, maxWidth, height, minHeight, maxHeight, ...otherProps }) => {
        const rootRef = (0, hooks_1.useRef)(null);
        const anchorRef = (0, hooks_1.useRef)(null);
        const launcherRef = (0, hooks_1.useRef)(null);
        const resolveBusyState = (0, hooks_1.useRef)();
        const didMountRef = (0, hooks_1.useRef)(false);
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-dialog id='${id}' is ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const preactRef = (0, hooks_1.useCallback)((elem) => {
            if (rootRef.current) {
                if (elem) {
                    const layerElem = elem;
                    layerElem[UNSAFE_Layer_1.LOGICAL_PARENT] = rootRef.current;
                    rootRef.current[LAYER_CONTENT] = elem;
                }
                else {
                    if (rootRef.current[LAYER_CONTENT]) {
                        const layerElem = rootRef.current[LAYER_CONTENT];
                        delete layerElem[UNSAFE_Layer_1.LOGICAL_PARENT];
                        delete rootRef.current[LAYER_CONTENT];
                    }
                }
            }
        }, []);
        (0, hooks_1.useEffect)(() => {
            return () => {
                // Resolve current busy state on unmount
                if (resolveBusyState.current) {
                    resolveBusyState.current();
                }
            };
        }, []);
        (0, hooks_1.useEffect)(() => {
            // The busy state is not added on the first render, but on each subsequent toggle
            if (!didMountRef.current) {
                didMountRef.current = true;
                return;
            }
            // Resolve current busy state is transition is already in progress
            if (resolveBusyState.current) {
                resolveBusyState.current();
            }
            resolveBusyState.current = addBusyState('animating');
        }, [opened, addBusyState]);
        let defaultPlacement = placement;
        const isObject = (value) => {
            return typeof value === 'object' && !Array.isArray(value) && value !== null;
        };
        // Resolve launcher to pass launcherRef to Preact Dialog.
        let localLauncher;
        if (typeof launcher === 'string') {
            const launcherEl = document.querySelector(launcher);
            if (launcherEl) {
                localLauncher = launcherEl;
            }
        }
        else if (launcher instanceof HTMLElement) {
            if (document.body.contains(launcher)) {
                localLauncher = launcher;
            }
        }
        else {
            localLauncher = document.activeElement;
        }
        if (!placement) {
            if (!anchor || anchor instanceof Window || anchor === 'window') {
                defaultPlacement = 'center';
            }
            else {
                defaultPlacement = 'bottom-start';
            }
        }
        // Resolve anchor to pass anchorRef to Preact Popup.
        // Similarly to launcher (see above) we allow 'string | Element' for anchor here.
        // Anchor can remain undefinyarn ed (anchorRef.current === undefined) to default to Window.
        let localAnchor;
        if (anchor instanceof Window || anchor === 'window') {
            localAnchor = undefined;
        }
        else if (typeof anchor === 'string') {
            // 2a. Custom anchor (string)
            const queriedAnchor = document.querySelector(anchor);
            localAnchor = queriedAnchor;
        }
        else if (anchor instanceof Element) {
            // 2b. Custom anchor (Element) or default to 'launcher'
            localAnchor = document.body.contains(anchor) ? anchor : undefined;
        }
        else if (isObject(anchor)) {
            if (typeof anchor?.x === 'number' && typeof anchor?.y === 'number') {
                // Coord type, (unlike Offset, x and y are mandatory in Coord)
                localAnchor = anchor;
            }
        }
        const handleOnClose = async (detail) => {
            if (cancelBehavior != 'none') {
                // Allow veto by triggering onOjBeforeClose.
                // AutoDismiss controls closing using an outside click.
                // Closing with ESC key can be vetoed but no property control is available
                // This setting matches legacy Popup
                try {
                    // Cancelable ojBeforeClose event
                    await onOjBeforeClose?.(detail);
                    onOpenedChanged?.(false);
                }
                catch (_) {
                    // Closing was canceled so short circuit out here
                }
            }
        };
        const handleOnTransitionEnd = async (value) => {
            // Resolve and reset busy state
            if (resolveBusyState.current) {
                resolveBusyState.current();
                resolveBusyState.current = undefined;
            }
            if (value) {
                // Dialog's opening gets finished
                onOjOpen?.();
            }
            else {
                // Dialog's closing gets finished
                onOjClose?.();
            }
        };
        const handleOnFocus = () => {
            onOjFocus?.();
        };
        const convertDragMovePayload = (detail) => {
            const originalPosition = {
                x: detail.originalPosition.x,
                y: detail.originalPosition.y
            };
            const position = { x: detail.position.x, y: detail.position.y };
            return { originalPosition, position };
        };
        const convertResizePayload = (detail) => {
            const originalPosition = {
                x: detail.originalPosition.x,
                y: detail.originalPosition.y
            };
            const position = { x: detail.position.x, y: detail.position.y };
            const originalSize = {
                width: detail.originalSize.width,
                height: detail.originalSize.height
            };
            const size = { width: detail.size.width, height: detail.size.height };
            return { originalPosition, position, originalSize, size };
        };
        const handleOnDragStart = (detail) => {
            onOjDragStart?.(convertDragMovePayload(detail));
        };
        const handleOnDragMove = (detail) => {
            onOjDragMove?.(convertDragMovePayload(detail));
        };
        const handleOnDragEnd = (detail) => {
            onOjDragEnd?.(convertDragMovePayload(detail));
        };
        const handleOnResizeStart = (detail) => {
            onOjResizeStart?.(convertResizePayload(detail));
        };
        const handleOnResize = (detail) => {
            onOjResize?.(convertResizePayload(detail));
        };
        const handleOnResizeEnd = (detail) => {
            onOjResizeEnd?.(convertResizePayload(detail));
        };
        const { width: flexibleCompWidth, height: flexibleCompHeight, anchorRef: flexibleCompAnchorRef, ...flexibleCompProps } = (0, UNSAFE_Dialog_1.useFlexibleComponent)({
            isDraggable: dragAffordance === 'header',
            isResizable: resizeBehavior === 'resizable',
            onDragStart: handleOnDragStart,
            onDragMove: handleOnDragMove,
            onDragEnd: handleOnDragEnd,
            onResizeStart: handleOnResizeStart,
            onResize: handleOnResize,
            onResizeEnd: handleOnResizeEnd
        });
        // Set refs for Pract API
        anchorRef.current = localAnchor;
        launcherRef.current = localLauncher;
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, id: id, children: (0, jsx_runtime_1.jsx)(UNSAFE_Dialog_1.Dialog, { ref: preactRef, header: header || dialogTitle, launcherRef: launcherRef, footer: footer, modality: modality, isOpen: opened, cancelBehavior: cancelBehavior, resizeBehavior: resizeBehavior, 
                // Draggable, Resizable
                dragAffordance: dragAffordance, headerDecoration: headerDecoration, ...flexibleCompProps, 
                // Position
                anchorRef: flexibleCompAnchorRef || anchorRef, placement: flexibleCompAnchorRef ? defaultPlacement : placement, offset: flexibleCompAnchorRef ? 0 : offset, onClose: handleOnClose, onTransitionEnd: handleOnTransitionEnd, onFocusSet: handleOnFocus, width: flexibleCompWidth || width, minWidth: minWidth, maxWidth: maxWidth, height: flexibleCompHeight || height, minHeight: minHeight, maxHeight: maxHeight, role: otherProps['role'], "aria-describedby": otherProps['aria-describedby'], "aria-label": otherProps['aria-label'], "aria-labelledby": otherProps['aria-labelledby'], children: body }) }));
    }, "Dialog", { "slots": { "header": {}, "body": {}, "footer": {} }, "properties": { "cancelBehavior": { "type": "string", "enumValues": ["none", "icon", "escape"] }, "dialogTitle": { "type": "string" }, "dragAffordance": { "type": "string", "enumValues": ["none", "header"] }, "headerDecoration": { "type": "string", "enumValues": ["off", "on"] }, "launcher": { "type": "string|Element" }, "modality": { "type": "string", "enumValues": ["modal", "modeless"] }, "opened": { "type": "boolean", "writeback": true }, "resizeBehavior": { "type": "string", "enumValues": ["none", "resizable"] }, "anchor": { "type": "string|Element|object" }, "placement": { "type": "string", "enumValues": ["center", "end", "start", "top", "bottom", "top-start", "top-end", "start-top", "start-bottom", "bottom-start", "bottom-end", "end-top", "end-bottom"] }, "offset": { "type": "number|object" }, "width": { "type": "number|string" }, "minWidth": { "type": "number|string" }, "maxWidth": { "type": "number|string" }, "height": { "type": "number|string" }, "minHeight": { "type": "number|string" }, "maxHeight": { "type": "number|string" } }, "events": { "ojOpen": {}, "ojBeforeClose": { "cancelable": true }, "ojClose": {}, "ojFocus": {}, "ojDragStart": {}, "ojDragMove": {}, "ojDragEnd": {}, "ojResizeStart": {}, "ojResize": {}, "ojResizeEnd": {} }, "extension": { "_WRITEBACK_PROPS": ["opened"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "aria-label", "aria-labelledby", "role", "id"] } }, { "cancelBehavior": "none", "dragAffordance": "none", "headerDecoration": "on", "modality": "modal", "opened": false, "resizeBehavior": "none" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/dialog',["require", "exports", "oj-c/dialog/dialog"], function (require, exports, dialog_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dialog = void 0;
    Object.defineProperty(exports, "Dialog", { enumerable: true, get: function () { return dialog_1.Dialog; } });
});


define('oj-c/highlight-text/highlight-text',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_HighlightText", "css!oj-c/highlight-text/highlight-text-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_HighlightText_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HighlightText = void 0;
    exports.HighlightText = (0, ojvcomponent_1.registerCustomElement)('oj-c-highlight-text', 
    /**
     * @classdesc
     * <h3 id="highlightTextOverview-section">
     *   JET Highlight Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#highlightTextOverview-section"></a>
     * </h3>
     * <p>Description: JET Highlight Text renders text with highlighting applied.</p>
     *
     * <p>JET Highlight Text renders a text string with highlighting applied to the given text to match.</p>
     *
     * A Highlight Text can be created with the following markup.</p>
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-highlight-text
     *   text='My text to apply highlighting to.'
     *   match-text='igh'>
     * &lt;/oj-c-highlight-text>
     * </code></pre>
     *
     * @ojmetadata displayName "Highlight Text"
     * @ojmetadata description "A Highlight Text renders text with highlighting applied."
     * @ojmetadata help "oj-c.HighlightText.html"
     * @ojmetadata main "oj-c/highlight-text"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "defaultColumns": 6,
     *     "minColumns": 2,
     *     "module": "oj-c/highlight-text"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-background-color"
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "text",
     *       "matchText"
     *     ]
     *   }
     * ]
     * @ojmetadata since "15.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-highlight-text"]
     *   }
     * ]
     */
    ({ matchText, text }) => {
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_HighlightText_1.HighlightText, { matchText: matchText, children: text }) }));
    }, "HighlightText", { "properties": { "matchText": { "type": "string" }, "text": { "type": "string" } } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/highlight-text',["require", "exports", "oj-c/highlight-text/highlight-text"], function (require, exports, highlight_text_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HighlightText = void 0;
    Object.defineProperty(exports, "HighlightText", { enumerable: true, get: function () { return highlight_text_1.HighlightText; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext',["require", "exports", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext"], function (require, exports, UNSAFE_useFormContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useMergedFormContext = useMergedFormContext;
    /**
     * This hook merges values set via binding propagation with values propagated via form context.
     *
     * If we are in VDOM, form context is passed via Context and there is no binding propagation.
     * However, values may still be set directly on the component and should take precedence
     * if present.
     *
     * If we are in MVVM, binding propagation is in effect however there will still be values in
     * context because we create FormContext with defaults.
     *
     * Individual form components need to consume and then reprovide form context in order to achieve
     * mixed readonly. This is done by relying on the merged context produced by this hook. Additionally,
     * in order for things to work properly in both VDOM/MVVM we can no longer use property defaulting for
     * any props that are propagated, because the default value will always "win". This hook also
     * returns fallback values for certain props, which are used in lieu of defaults.
     *
     * @param propContainerReadonly The component's containerReadonly property
     * @param propLabelWrapping The component's labelWrapping property
     * @param propReadonly The component's readonly property
     * @param propTextAlign The component's textAlign property
     * @param propUserAssistanceDensity The component's userAssistanceDensity property
     * @returns
     */
    function useMergedFormContext({ propContainerReadonly, propLabelWrapping, propReadonly, propTextAlign, propUserAssistanceDensity }) {
        // Consume the parent form context.
        const formContext = (0, UNSAFE_useFormContext_1.useFormContext)();
        // Determine the userAssistanceDensity value from propUserAssistanceDensity, which may be set
        // via binding propagation or directly on the component. If undefined, falls back to the
        // default form context value which is 'reflow'.
        const uadValue = propUserAssistanceDensity ?? formContext.userAssistanceDensity;
        // Determine the readonly value from propReadonly, which may be set via binding propagation
        // or directly on the component. If undefined, falls back to the default form context value
        // which is 'false'.
        const readonlyValue = propReadonly ?? formContext.isReadonly;
        // Merge the parent context values with values needed to support mixed readonly.
        const { isFormLayout: formContextIsFormLayout, isReadonly: formContextIsReadonly, labelWrapping: formContextLabelWrapping, textAlign: formContextTextAlign, ...otherFormContextProps } = formContext;
        // containerProps is the merged context that should be reprovided by a consuming component.
        const containerProps = {
            ...otherFormContextProps,
            isFormLayout: propContainerReadonly !== undefined || formContextIsFormLayout,
            isReadonly: propContainerReadonly ?? formContextIsReadonly,
            labelWrapping: propLabelWrapping ?? formContextLabelWrapping,
            textAlign: propTextAlign ?? formContextTextAlign
        };
        return {
            containerProps,
            readonlyValue,
            uadValue
        };
    }
});

define('oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText',["require", "exports", "preact/hooks"], function (require, exports, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useAssistiveText = useAssistiveText;
    /**
     * Determines which user assistance text should be shown
     *
     * @param help The help object
     * @param validatorHint The first validator hint
     * @param helpHints The helpHints object
     * @param converterHint The converter hint
     * @param displayOptions The display options for auxiliary content
     * @param userAssistanceDensity The user assistance density
     * @returns The help text that needs to be shown based on the order of precedence
     */
    function determineAssistiveText(help, validatorHint, helpHints, converterHint, displayOptions, userAssistanceDensity) {
        // In the Redwood theme for clarity only one user assistance text shows to the user,
        // even if multiple user assistance text properties are on the component. The order of
        // precedence from highest to lowest is below:
        // - help.instruction
        // - validator hint
        // - help-hints.definition
        // - converter hint
        // For compact user assistance density, the help hints definition will be treated like
        // help hints source text, not like regular assistive text.
        const helpHintsDef = userAssistanceDensity !== 'compact' ? helpHints?.definition : undefined;
        return (help?.instruction ||
            (displayOptions?.validatorHint === 'none' ? undefined : validatorHint) ||
            helpHintsDef ||
            (displayOptions?.converterHint === 'none' ? undefined : converterHint));
    }
    /**
     * Fetches the hint strings from the validator array
     *
     * @param validators The current validators
     * @returns The joined hint string
     */
    function determineSyncValidatorHints(validators) {
        if (!validators.length) {
            return undefined;
        }
        const syncHints = validators
            .map((validator) => 
        // getHint function determines sync validators
        typeof validator.getHint === 'function'
            ? validator.getHint()
            : undefined)
            .filter(Boolean);
        return syncHints.join('\n');
    }
    /**
     * A custom hook to determine which assistive text should be shown.
     */
    function useAssistiveText({ addBusyState, converter, displayOptions, help, helpHints, userAssistanceDensity, validators }) {
        const [validatorHint, setValidatorHint] = (0, hooks_1.useState)(!validators || !validators.length ? undefined : determineSyncValidatorHints(validators));
        const staleIdentity = (0, hooks_1.useRef)();
        // Get the validator hint
        (0, hooks_1.useEffect)(() => {
            // clear state when there are no validators
            if (!validators || !validators.length) {
                setValidatorHint(undefined);
                return;
            }
            // set the hints from the sync validators first and then
            // resolve and append the validator hints from async validators
            setValidatorHint(determineSyncValidatorHints(validators));
            const asyncHints = validators
                .map((validator) => 
            // hint property determines sync validators
            validator.hint)
                .filter(Boolean);
            // If an update to the validators occurs while fetching the async validators'
            // hint, the initial fetch could become stale. We need an identity for each fetches
            // to determine the latest one. Only the latest hint will be set as a state.
            // We will be using a symbol for each batch of async hints fetch.
            const localStaleIdentity = (staleIdentity.current = Symbol());
            const resolver = addBusyState?.('resolving the async validator hints');
            Promise.allSettled(asyncHints).then((hints) => {
                setValidatorHint((currentHints) => {
                    const treatedHints = hints
                        .map((result) => (result.status === 'fulfilled' ? result.value : undefined))
                        .filter(Boolean);
                    // Do not update the state if this has gone stale or
                    // if there are no resolved hints
                    if (localStaleIdentity !== staleIdentity.current || !treatedHints.length) {
                        return currentHints;
                    }
                    // if there are resolved hints, append them to the existing hints
                    // Note that it is ok to append to the existing state. This is because,
                    // when the validators change, the setValidatorHint call before this one
                    // sets the state with the sync validators' hint. This overwrites the previous
                    // state and appending here is just a continuation of the previous state update.
                    return [currentHints, ...treatedHints].join('\n');
                });
                resolver?.();
            });
        }, [validators]);
        // In the Redwood theme for clarity only one user assistance text shows to the user,
        // even if multiple user assistance text properties are on the component. The order of
        // precedence from highest to lowest is below:
        // - help.instruction
        // - validator hint
        // - help-hints.definition
        // - converter hint
        // For compact user assistance density, the help hints definition should override the
        // help hints source text.
        const helpSourceText = userAssistanceDensity !== 'compact'
            ? helpHints?.sourceText
            : helpHints?.definition || helpHints?.sourceText;
        return {
            assistiveText: determineAssistiveText(help, validatorHint, helpHints, converter?.getHint?.() ?? undefined, displayOptions, userAssistanceDensity),
            helpSourceLink: helpHints?.source,
            helpSourceText
        };
    }
});

define('oj-c/input-date-mask/CalendarDateConverter',["require", "exports", "@oracle/oraclejet-preact/utils/UNSAFE_calendarDateUtils", "ojs/ojconfig"], function (require, exports, UNSAFE_calendarDateUtils_1, ojconfig_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CalendarDateConverter = void 0;
    // A converter for the oj-c-input-date-mask component. It throws an error on parse if it is an incomplete date.
    class CalendarDateConverter {
        constructor(options) {
            this.locale = options?.locale ?? (0, ojconfig_1.getLocale)();
            this.calendarDateConverter_parseErrorFn = options?.calendarDateConverter_parseErrorFn;
            this.customMask = options?.customMask;
        }
        format(value) {
            const calendarDate = (0, UNSAFE_calendarDateUtils_1.getCalendarDateFromIso)(value);
            if (!calendarDate) {
                throw new Error('value must be a date-only ISO string');
            }
            return calendarDate;
        }
        // throws an error if the input is not a complete calendar date.
        parse(input) {
            // if calendar date is not complete, throw an error which we will catch and format into a better error.
            if (input !== undefined && !(0, UNSAFE_calendarDateUtils_1.isCompleteCalendarDate)(input)) {
                const now = new Date();
                // getFullYear returns the year for the date according to local time.
                const currentYear = now.getFullYear();
                const formattedDateExample = (0, UNSAFE_calendarDateUtils_1.formatIsoDateStrAsExample)(this.locale, `${currentYear}-11-29`, this.customMask);
                const errorStr = this.calendarDateConverter_parseErrorFn &&
                    this.calendarDateConverter_parseErrorFn({
                        dateExample: formattedDateExample
                    });
                throw new Error(errorStr ?? 'parse failed');
            }
            // At this point we know that the input is a complete date, but typescript does not know, so tell it.
            const completeDate = input;
            // parse a full CalendarDate to an ISO string.
            return (0, UNSAFE_calendarDateUtils_1.getIsoDateStr)(completeDate.year, completeDate.month, completeDate.day);
        }
    }
    exports.CalendarDateConverter = CalendarDateConverter;
});

define('oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages',["require", "exports", "preact/hooks"], function (require, exports, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useComponentMessages = useComponentMessages;
    /**
     * A custom hook that returns the correct messages to show based on
     * certain properties of the component.
     *
     * @param param0 The props for the useComponentMessages hook
     * @returns An array of messages to display
     */
    function useComponentMessages({ evMessages, messagesCustom, readonly, readonlyUserAssistanceShown }) {
        // If the component is readonly:
        //   a) readonlyUserAssistanceShown === 'confirmationAndInfoMessages'
        //      filter messagesCustom and only return info/confirmation messages
        //   b) readonlyUserAssistanceShown === 'none', return an empty array
        //
        // If the component is not readonly, return the useEditableValue messages
        // which contain the messagesCustom messages in addition to converter and
        // validator messages.
        const componentMessages = (0, hooks_1.useMemo)(() => {
            return readonly
                ? readonlyUserAssistanceShown === 'confirmationAndInfoMessages'
                    ? messagesCustom?.filter((message) => message.severity === 'confirmation' || message.severity === 'info')
                    : []
                : evMessages;
        }, [messagesCustom, readonly, readonlyUserAssistanceShown, evMessages]);
        return componentMessages;
    }
});

define('oj-c/input-date-text/useImplicitDateRangeValidator',["require", "exports", "ojs/ojvalidator-localdaterange", "preact/hooks"], function (require, exports, ojvalidator_localdaterange_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useImplicitDateRangeValidator = useImplicitDateRangeValidator;
    /**
     * Custom hook that creates an implicit DateTimeRangeValidator for oj-c-input-date if there is a min or max property.
     * Otherwise it will return null.
     *
     * @returns A DateTimeRangeValidator instance or null
     */
    function useImplicitDateRangeValidator({ formatObj, dateRangeOverflowMessageDetail, dateRangeUnderflowMessageDetail, max, min }) {
        const dateRangeValidator = (0, hooks_1.useMemo)(() => {
            if (min !== undefined || max !== undefined) {
                return new ojvalidator_localdaterange_1.LocalDateRangeValidator({
                    formatObj,
                    max,
                    min,
                    rangeOverflowMessageDetail: dateRangeOverflowMessageDetail,
                    rangeUnderflowMessageDetail: dateRangeUnderflowMessageDetail
                });
            }
            return null;
        }, [formatObj, dateRangeOverflowMessageDetail, dateRangeUnderflowMessageDetail, min, max]);
        return dateRangeValidator;
    }
});

define('oj-c/hooks/UNSAFE_useEditableValue/utils',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.treatNull = exports.normalizeValue = exports.isShallowEqual = exports.hasErrorMessages = exports.getVirtualKeyboardHintFromConverter = exports.createMessageFromError = void 0;
    /**
     * Creates a component message for the provided error
     *
     * @param error The error object
     * @returns The component message for the error provided
     */
    const createMessageFromError = (error) => {
        if (typeof error.getMessage === 'function') {
            return {
                severity: 'error',
                detail: error.getMessage().detail
            };
        }
        return { severity: 'error', detail: error.message };
    };
    exports.createMessageFromError = createMessageFromError;
    /**
     * Treats the value for `null` and replaces it with the provided defaultValue
     * or undefined.
     *
     * @param value The value that needs to be treated
     * @param defaultValue The value to used when the provided value is null
     * @returns the null treated value
     */
    const treatNull = (value, defaultValue) => {
        if (value === null) {
            return defaultValue;
        }
        return value;
    };
    exports.treatNull = treatNull;
    /**
     * Normalizes an empty string to null.
     * @param value
     * @returns null if the value is an empty string
     */
    const normalizeValue = (value) => {
        if (typeof value === 'string' && value === '') {
            return null;
        }
        return value;
    };
    exports.normalizeValue = normalizeValue;
    /**
     * Shallow compares two arrays.
     *
     * @param a The first array
     * @param b The second array
     * @returns Result of the shallow compare
     */
    const isShallowEqual = (a, b) => a === b || (a.length === b.length && a.every((v, i) => v === b[i]));
    exports.isShallowEqual = isShallowEqual;
    /**
     * Return true if there are any messsages with "error" severity.
     * @param messages
     * @returns True if there are any messages with "error" severity
     */
    const hasErrorMessages = (messages) => {
        return !!messages && messages.some((message) => message.severity === 'error');
    };
    exports.hasErrorMessages = hasErrorMessages;
    /**
     * If there is a converter and the converter's resolvedOptions have a virtualKeyboardHint
     * property, return the virtualKeyboardHint. Otherwise return 'text'.
     * @param converter
     * @returns The virtual keyboard hint from the converter or 'text'
     */
    const getVirtualKeyboardHintFromConverter = (converter) => {
        let virtualKeyboardHint;
        if (converter && converter.resolvedOptions) {
            const resOptions = converter.resolvedOptions();
            virtualKeyboardHint = resOptions?.virtualKeyboardHint ?? 'text';
        }
        else {
            virtualKeyboardHint = 'text';
        }
        return virtualKeyboardHint;
    };
    exports.getVirtualKeyboardHintFromConverter = getVirtualKeyboardHintFromConverter;
});

define('oj-c/hooks/UNSAFE_useEditableValue/converterUtils',["require", "exports", "./utils"], function (require, exports, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.format = format;
    exports.parse = parse;
    /**
     * Parses the raw value from the UI to the internal value of the component
     * using the converter provided.
     * @param displayValue The raw value from the UI that needs to be parsed
     * @param converter The converter to be used for parsing
     * @param translateConverterParseError Function used to replace the converter error with a user-friendly message.
     * @returns The result of the conversion
     */
    function parse(displayValue, converter, translateConverterParseError) {
        if (displayValue === undefined) {
            // If displayValue is undefined, return null as the value.
            return { result: 'success', value: null };
        }
        if (shouldSkipParse(displayValue)) {
            // If displayValue is '' or null, we don't parse it.
            return { result: 'success', value: displayValue };
        }
        try {
            return {
                result: 'success',
                value: converter.parse(displayValue)
            };
        }
        catch (error) {
            // Replace converter error with a user friendly error if needed.
            const message = translateConverterParseError?.(error) ?? (0, utils_1.createMessageFromError)(error);
            return {
                result: 'failure',
                error: message
            };
        }
    }
    /**
     * Formats the component value to a display value that will be shown in the UI
     * @param value The component value to be formatted to show in the UI
     * @param defaultValue The default value that needs to be shown in some cases
     * @param converter The converter to be used for formatting
     * @returns The result of the conversion
     */
    function format(value, defaultValue, converter) {
        if (shouldSkipFormat(value)) {
            return { result: 'success', value: defaultValue };
        }
        try {
            return {
                result: 'success',
                value: converter.format(value)
            };
        }
        catch (error) {
            return {
                result: 'failure',
                error: (0, utils_1.createMessageFromError)(error)
            };
        }
    }
    /**
     * Determines if the converter's parse should be skipped for this value.
     * parse gets called to parse the user's input.
     * If the user clears the field, the displayed value is '', and we want to push null to the value, not ''.
     * The component code may normalize the value from '' to null before calling parse, so we also skip for null.
     * See useEditable#normalizeAndParseValue.
     *
     * @param value The value to be tested
     * @returns boolean result
     */
    function shouldSkipParse(value) {
        return value === '' || value === null;
    }
    /**
     * Determines if the converter's format should be skipped for this value.
     * format gets called to format the component's model value to display to the user.
     * As per the most strict converter contract we could have,
     *   format(value:V) : {string}
     *   parse(value:string) : {(V)}
     * format will not expect null, so if model value is null, we skip calling the converter's format.
     * We do not skip formatting ''. If the model value is '', and the converter does not allow to format strings, the
     * converter will throw an error.
     *
     * @param value The value to be tested
     * @returns boolean result
     */
    function shouldSkipFormat(value) {
        return value === null;
    }
});

define('oj-c/editable-value/UNSAFE_useStaleIdentity/useStaleIdentity',["require", "exports", "preact/hooks"], function (require, exports, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useStaleIdentity = useStaleIdentity;
    /**
     * A custom hook that helps with managing identities that would help determine
     * whether an async process has gone stale or not.
     *
     * @returns An object that includes various operation related to managing stale identity
     */
    function useStaleIdentity() {
        const staleIdentityMap = (0, hooks_1.useRef)(new Map());
        const setStaleIdentity = (0, hooks_1.useCallback)(
        /**
         * A function that creates a new stale identity
         *
         * @param id A unique identifier for this staleIdentity (should start with the name of the hook that uses this)
         * @returns an object with helpers that would help determine if this has gone stale
         */
        (id) => {
            const localStaleIdentity = Symbol();
            staleIdentityMap.current.set(id, localStaleIdentity);
            // return a function that checks for the local stale determine
            // if this has gone stale
            return {
                isStale: () => localStaleIdentity !== staleIdentityMap.current.get(id)
            };
        }, []);
        // setStaleIdentity is guaranteed to be the same across rerenders
        return { setStaleIdentity };
    }
});

define('oj-c/hooks/UNSAFE_useEditableValue/reducer',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reducer = reducer;
    exports.addComponentMessage = addComponentMessage;
    exports.addHiddenMessage = addHiddenMessage;
    exports.clearAllMessages = clearAllMessages;
    exports.showHiddenMessages = showHiddenMessages;
    exports.updateComponentMessages = updateComponentMessages;
    exports.updateCustomMessages = updateCustomMessages;
    exports.updateDisplayValue = updateDisplayValue;
    exports.updateHiddenMessages = updateHiddenMessages;
    exports.updatePreviousConverter = updatePreviousConverter;
    exports.updatePreviousDeferredValidators = updatePreviousDeferredValidators;
    exports.updatePreviousDisabled = updatePreviousDisabled;
    exports.updatePreviousReadonly = updatePreviousReadonly;
    exports.updatePreviousValidators = updatePreviousValidators;
    exports.updatePreviousValue = updatePreviousValue;
    exports.updateTransientValue = updateTransientValue;
    exports.updateValidStatus = updateValidStatus;
    exports.updateValue = updateValue;
    /**
     * Reducer which manages state for useEditableValue hook.
     * @param state
     * @param action
     * @returns
     */
    function reducer(state, action) {
        const customMsgs = state.customMessages ?? [];
        const hiddenMsgs = state.hiddenMessages;
        const componentMsgs = state.componentMessages;
        const shownMsgs = state.shownMessages;
        switch (action.type) {
            case 'ADD_COMPONENT_MESSAGE':
                return {
                    ...state,
                    componentMessages: [...componentMsgs, action.payload],
                    shownMessages: [...shownMsgs, action.payload]
                };
            case 'ADD_HIDDEN_MESSAGE':
                return {
                    ...state,
                    hiddenMessages: [...hiddenMsgs, action.payload]
                };
            case 'CLEAR_ALL_MESSAGES':
                return {
                    ...state,
                    shownMessages: [],
                    hiddenMessages: [],
                    customMessages: [],
                    componentMessages: []
                };
            case 'SHOW_HIDDEN_MESSAGES':
                // If there are no hidden messages in the state, return the original state.
                // Otherwise, we will end up clearing some messages incorrectly when this action is
                // dispatched multiple time during the same render cycle.
                // The reducer's state here always has the latest value. So, during the first dispatch,
                // it clears the hiddenMessages and updates the shownMessages. During the next, it does the same thing,
                // but the hiddenMessages were already cleared. So, the new shownMessages will only contain customMgs and
                // componentMgs. The hiddenMessages are now lost.
                return hiddenMsgs.length === 0
                    ? state
                    : {
                        ...state,
                        hiddenMessages: [],
                        shownMessages: [...customMsgs, ...componentMsgs, ...hiddenMsgs]
                    };
            case 'UPDATE_DISPLAY_VALUE':
                return {
                    ...state,
                    displayValue: action.payload
                };
            case 'UPDATE_VALID':
                return {
                    ...state,
                    valid: action.payload
                };
            case 'UPDATE_VALUE':
                return {
                    ...state,
                    value: action.payload
                };
            case 'UPDATE_TRANSIENT_VALUE':
                return {
                    ...state,
                    transientValue: action.payload
                };
            case 'UPDATE_PREVIOUS_CONVERTER':
                return {
                    ...state,
                    previousConverter: action.payload
                };
            case 'UPDATE_PREVIOUS_DEFERRED_VALIDATORS':
                return {
                    ...state,
                    previousDeferredValidators: action.payload
                };
            case 'UPDATE_PREVIOUS_DISABLED':
                return {
                    ...state,
                    previousDisabled: action.payload
                };
            case 'UPDATE_PREVIOUS_READONLY':
                return {
                    ...state,
                    previousReadonly: action.payload
                };
            case 'UPDATE_PREVIOUS_VALIDATORS':
                return {
                    ...state,
                    previousValidators: action.payload
                };
            case 'UPDATE_PREVIOUS_VALUE':
                return {
                    ...state,
                    previousValue: action.payload
                };
            case 'UPDATE_COMPONENT_MESSAGES':
                return {
                    ...state,
                    componentMessages: action.payload,
                    shownMessages: [...customMsgs, ...action.payload]
                };
            case 'UPDATE_HIDDEN_MESSAGES':
                return {
                    ...state,
                    hiddenMessages: action.payload
                };
            case 'UPDATE_CUSTOM_MESSAGES':
                return {
                    ...state,
                    customMessages: action.payload,
                    shownMessages: [...action.payload, ...componentMsgs]
                };
            default:
                return state;
        }
    }
    //////////////////////////////////////////////////////////////////
    // UTILTIES TO UPDATE STATE AND INVOKE CALLBACKS
    // To keep these pure functions, the dispatch method and callbacks
    // as passed from the useEV hook.
    ///////////////////////////////////////////////////////////////////
    // Update the display value and call onRawValueChanged.
    function updateDisplayValue(dispatch, displayValue, { onRawValueChanged }) {
        dispatch({ type: 'UPDATE_DISPLAY_VALUE', payload: displayValue });
        onRawValueChanged?.(displayValue);
    }
    // Update valid and call onValidChanged.
    function updateValidStatus(dispatch, state, { onValidChanged }) {
        dispatch({ type: 'UPDATE_VALID', payload: state });
        onValidChanged?.(state);
    }
    // Update value and call onValueChanged.
    function updateValue(dispatch, value, { onValueChanged }) {
        dispatch({ type: 'UPDATE_VALUE', payload: value });
        onValueChanged?.(value);
    }
    // Update transient value and call onTransientValueChanged.
    function updateTransientValue(dispatch, transientValue, { onTransientValueChanged }) {
        dispatch({ type: 'UPDATE_TRANSIENT_VALUE', payload: transientValue });
        onTransientValueChanged?.(transientValue);
    }
    // Update component messages.
    function updateComponentMessages(dispatch, messages) {
        dispatch({ type: 'UPDATE_COMPONENT_MESSAGES', payload: messages });
    }
    // Update hidden messages.
    function updateHiddenMessages(dispatch, messages) {
        dispatch({ type: 'UPDATE_HIDDEN_MESSAGES', payload: messages });
    }
    // Update custom messages.
    function updateCustomMessages(dispatch, messages) {
        dispatch({ type: 'UPDATE_CUSTOM_MESSAGES', payload: messages });
    }
    // Update the previous value stored in the state.
    function updatePreviousValue(dispatch, value) {
        dispatch({ type: 'UPDATE_PREVIOUS_VALUE', payload: value });
    }
    // Update the previousConverter stored in state.
    function updatePreviousConverter(dispatch, converter) {
        dispatch({ type: 'UPDATE_PREVIOUS_CONVERTER', payload: converter });
    }
    // Update the previousDeferredValidators stored in state.
    function updatePreviousDeferredValidators(dispatch, validators) {
        dispatch({ type: 'UPDATE_PREVIOUS_DEFERRED_VALIDATORS', payload: validators });
    }
    // Update previousDisabled.
    function updatePreviousDisabled(dispatch, disabled) {
        dispatch({ type: 'UPDATE_PREVIOUS_DISABLED', payload: disabled });
    }
    // Update previousReadonly.
    function updatePreviousReadonly(dispatch, readonly) {
        dispatch({ type: 'UPDATE_PREVIOUS_READONLY', payload: readonly });
    }
    // Update the previousValidators stored in state.
    function updatePreviousValidators(dispatch, validators) {
        dispatch({ type: 'UPDATE_PREVIOUS_VALIDATORS', payload: validators });
    }
    // Clear all messages and call onMessagesCustomChanged.
    function clearAllMessages(dispatch, _value, { onMessagesCustomChanged }) {
        dispatch({ type: 'CLEAR_ALL_MESSAGES' });
        onMessagesCustomChanged?.([]);
    }
    // Show hidden messages from deferred validation.
    function showHiddenMessages(dispatch) {
        dispatch({ type: 'SHOW_HIDDEN_MESSAGES' });
    }
    // Add a component message.
    function addComponentMessage(dispatch, message) {
        dispatch({ type: 'ADD_COMPONENT_MESSAGE', payload: message });
    }
    // Add a hidden message.
    function addHiddenMessage(dispatch, message) {
        dispatch({ type: 'ADD_HIDDEN_MESSAGE', payload: message });
    }
});

define('oj-c/hooks/UNSAFE_useEditableValue/validationUtils',["require", "exports", "./utils"], function (require, exports, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAsync = validateAsync;
    exports.validateSync = validateSync;
    /**
     * Performs validation synchronously with synchronous validators.
     * This method is called by useEditableValue to run deferred validators.
     * @param param0 The input for performing the validation
     * @returns The validation result
     */
    function validateSync({ validators, value }) {
        const errors = [];
        for (const validator of validators) {
            try {
                validator.validate(value);
            }
            catch (error) {
                errors.push((0, utils_1.createMessageFromError)(error));
            }
        }
        if (errors.length) {
            return { result: 'failure', errors };
        }
        return { result: 'success' };
    }
    /**
     * This method is called by useEditableValue to run full validation, which
     * may include a mix of both synchronous and asynchronous validators.
     * Any synchronous validation errors are returned as part of the validation result.
     * If there are asynchronous validators, they are returned as an Array of Promises
     * that resolve to (ValidatorErrorResult | void) when validation completes.
     * Calling code will need to await these promises and handle the results accordingly.
     * @param param0 The input for performing the validation
     * @returns The async validation result, which can include synchronous validation errors as well
     * as an array of promises for the async validations
     */
    function validateAsync({ validators, value }) {
        const doValidate = (validator, value) => {
            try {
                const validateResult = validator.validate(value);
                // The api contract for an async validator's validate method is that it returns a Promise that
                // resolves to void if the validation passes or a Promise that rejects with an error if it fails.
                // The api contract for a sync validator's validate method is it returns void if the validation passes
                // or it throws an error if it fails. This method wraps the latter inside a promise as well.
                if (validateResult instanceof Promise) {
                    return validateResult.then(
                    // resolved promise is a successful validation, do not
                    // need to do anything here
                    () => { }, 
                    // rejected promise is a failed validation, construct and return
                    // back the ValidatorErrorResult
                    (error) => {
                        return {
                            message: (0, utils_1.createMessageFromError)(error),
                            messageDisplayStrategy: error?.messageDisplayStrategy
                        };
                    });
                }
            }
            catch (error) {
                return {
                    message: (0, utils_1.createMessageFromError)(error),
                    messageDisplayStrategy: error?.messageDisplayStrategy
                };
            }
            return;
        };
        const errors = [];
        const maybeErrorPromises = [];
        for (const validator of validators) {
            const maybeValidatorErrorResult = doValidate(validator, value);
            if (maybeValidatorErrorResult !== undefined) {
                if (maybeValidatorErrorResult instanceof Promise) {
                    // this could resolve to a ValidatorErrorResult or it could resolve to void.
                    maybeErrorPromises.push(maybeValidatorErrorResult);
                }
                else {
                    errors.push(maybeValidatorErrorResult);
                }
            }
        }
        return {
            errors,
            maybeErrorPromises
        };
    }
});

define('oj-c/hooks/UNSAFE_useEditableValue/useEditableValue',["require", "exports", "preact/hooks", "./converterUtils", "./utils", "oj-c/editable-value/UNSAFE_useStaleIdentity/useStaleIdentity", "./reducer", "./validationUtils"], function (require, exports, hooks_1, converterUtils_1, utils_1, useStaleIdentity_1, reducer_1, validationUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useEditableValue = useEditableValue;
    /**
     * A custom hook to handle value and value based life cycle of an editable component.
     * This uses a reducer to handle form component states like value, displayValue, valid, etc.
     */
    function useEditableValue({ addBusyState, ariaDescribedBy, converter, defaultDisplayValue, deferredValidators, disabled, displayOptions, messagesCustom, onDisplayValueChanged, onMessagesCustomChanged, onRawValueChanged, onTransientValueChanged, onValidChanged: propOnValidChanged, onValueChanged, translateConverterParseError, readonly, validators, value }) {
        const initialRender = (0, hooks_1.useRef)(true);
        const { setStaleIdentity } = (0, useStaleIdentity_1.useStaleIdentity)();
        const [state, dispatch] = (0, hooks_1.useReducer)((reducer_1.reducer), {
            shownMessages: [],
            hiddenMessages: [],
            customMessages: messagesCustom,
            componentMessages: [],
            value: value,
            valid: 'pending'
        }, (args) => {
            const conversion = converter
                ? (0, converterUtils_1.format)(value, defaultDisplayValue, converter)
                : { result: 'success', value: (0, utils_1.treatNull)(value, defaultDisplayValue) };
            return {
                ...args,
                displayValue: conversion.result === 'success' ? conversion.value : defaultDisplayValue
            };
        });
        // JET-67412: Prevent redundant calls to onValidChanged.
        // Keep track of the current value of valid, and only call the original propOnValidChanged
        // if the new value differs from the current one. We use a Ref instead of relying on reducer
        // state because state updates only occur after all validation, sync or async, is complete.
        // Therefore we can't always rely on state.valid being up to date.
        // We also keep track of whether the component ever became valid so we can provide immediate
        // feedback when there are validators with hidden messages (e.g. SelectionRangeValidator).
        const currentValidRef = (0, hooks_1.useRef)();
        const componentWasValidRef = (0, hooks_1.useRef)(false);
        const onValidChanged = (0, hooks_1.useCallback)((newValid) => {
            if (newValid !== currentValidRef.current) {
                currentValidRef.current = newValid;
                propOnValidChanged?.(newValid);
            }
        }, [propOnValidChanged]);
        // Call a helper function to update the state and call any callbacks, if needed.
        const _dispatch = (0, hooks_1.useCallback)((updateFn, payload) => {
            updateFn(dispatch, payload, {
                onMessagesCustomChanged,
                onRawValueChanged,
                onTransientValueChanged,
                onValidChanged,
                onValueChanged
            });
            return true;
        }, [
            dispatch,
            onMessagesCustomChanged,
            onRawValueChanged,
            onTransientValueChanged,
            onValidChanged,
            onValueChanged
        ]);
        // Run deferred validation with a trimmed value.
        const validateDeferredSync = (0, hooks_1.useCallback)((value) => {
            const valueToSendToDeferredValidation = typeof value === 'string' ? value.trim() : value;
            const deferredValidate = (0, validationUtils_1.validateSync)({
                validators: deferredValidators ?? [],
                value: valueToSendToDeferredValidation
            });
            return deferredValidate;
        }, [deferredValidators]);
        // This method allows the value to be set outside of the hook; this is used by the
        // select components after syncing value to valueItems.
        const setValue = (0, hooks_1.useCallback)((value) => {
            _dispatch(reducer_1.updateValue, value);
        }, [_dispatch]);
        // This method allows the display value to be set outside of the hook; this is used by the
        // select components after syncing value to valueItems.
        const setDisplayValue = (0, hooks_1.useCallback)((value) => {
            _dispatch(reducer_1.updateDisplayValue, value);
        }, [_dispatch]);
        // This method allows the transient value to be set outside of the hook; this is used
        // by input number to set the last valid value while spinning.
        const setTransientValue = (0, hooks_1.useCallback)((transientValue) => {
            _dispatch(reducer_1.updateTransientValue, transientValue);
        }, [_dispatch]);
        // Run conversion on a value (i.e. format it) to get a new display value.
        // If conversion fails, display errors and set valid to "invalidShown".
        const formatValue = (0, hooks_1.useCallback)((value) => {
            let newDisplayValue;
            if (!converter) {
                // If there is no converter, use the treated value (null -> defaultDisplayValue).
                // This mimics useConverter#format.
                newDisplayValue = (0, utils_1.treatNull)(value, defaultDisplayValue);
            }
            else {
                const conversion = (0, converterUtils_1.format)(value, defaultDisplayValue, converter);
                if (conversion.result === 'failure') {
                    _dispatch(reducer_1.updateComponentMessages, [conversion.error]);
                    _dispatch(reducer_1.updateValidStatus, 'invalidShown');
                    // When formatting fails, return the original treated value.
                    newDisplayValue = (0, utils_1.treatNull)(value, defaultDisplayValue);
                }
                else {
                    newDisplayValue = conversion.value;
                }
            }
            return newDisplayValue;
        }, [converter, defaultDisplayValue, _dispatch]);
        // Update the display value by formatting the given value.
        const refreshDisplayValue = (0, hooks_1.useCallback)((value) => {
            const newDisplayValue = formatValue(value);
            _dispatch(reducer_1.updateDisplayValue, newDisplayValue);
            // onDisplayValueChanged is used by the select components to update their valueItems whenever
            // displayValue is updated by useEditableValue and its reducer. Value items are not managed
            // by this hook, although you could think of them as the display value of the select. So
            // whenever displayValue changes, select components need to update their valueItems.
            onDisplayValueChanged?.();
            return true;
        }, [_dispatch, formatValue, onDisplayValueChanged]);
        // Get the value to validate from the component.
        const getValueForValidation = (0, hooks_1.useCallback)(() => {
            if (state.valid !== 'invalidShown') {
                return { result: 'success', value: state.value };
            }
            // If there is no converter, return the display value but cast it to V.
            if (!converter) {
                // If displayValue is '', like when the user clears the field, we want the value to be normalized to null.
                return { result: 'success', value: (0, utils_1.normalizeValue)(state.displayValue) };
            }
            // If we get here, get the value candidate from the display value and parse it to get the value.
            return (0, converterUtils_1.parse)((0, utils_1.normalizeValue)(state.displayValue), converter, translateConverterParseError);
        }, [converter, state.displayValue, state.valid, state.value, translateConverterParseError]);
        // Parse a display value to get the new value.
        const normalizeAndParseValue = (0, hooks_1.useCallback)((value) => {
            if (!converter) {
                return {
                    result: 'success',
                    value: (0, utils_1.normalizeValue)(value)
                };
            }
            return (0, converterUtils_1.parse)((0, utils_1.normalizeValue)(value), converter, translateConverterParseError);
        }, [converter, translateConverterParseError]);
        // Parses a display value. If parsing fails, display errors and update valid.
        // This callback is used by input number, which uses it in order to step/spin.
        const parseValue = (0, hooks_1.useCallback)((value) => {
            const conversion = normalizeAndParseValue(value);
            if (conversion.result === 'failure') {
                // Conversion failed. Update messages and valid and return.
                _dispatch(reducer_1.updateComponentMessages, [conversion.error]);
                _dispatch(reducer_1.updateValidStatus, 'invalidShown');
            }
            return conversion;
        }, [_dispatch, normalizeAndParseValue]);
        // Run both deferred and non-deferred validation and update messages.
        // Returns a promise that resolves to true if validation passes.
        const fullValidate = (0, hooks_1.useCallback)(async (value, options = {}) => {
            const { doNotClearMessagesCustom = false, forceHiddenMessagesToBeShown = false } = options;
            const hasCustomErrorMessages = doNotClearMessagesCustom && (0, utils_1.hasErrorMessages)(messagesCustom);
            // Clear all the messages including messagesCustom (if doNotClearMessagesCustom flag is not set)
            // before running the validation. If there are any validation errors, we will show the errors after this.
            if (doNotClearMessagesCustom) {
                _dispatch(reducer_1.updateComponentMessages, []);
                _dispatch(reducer_1.updateHiddenMessages, []);
            }
            else {
                _dispatch(reducer_1.clearAllMessages);
            }
            // If there are no validators, return early.
            if ((!validators || validators.length === 0) &&
                (!deferredValidators || deferredValidators.length === 0)) {
                // No validators mean all values are valid.
                // Set invalidShown when still showing custom error messages but return true as the validation succeeded.
                _dispatch(reducer_1.updateValidStatus, hasCustomErrorMessages ? 'invalidShown' : 'valid');
                return true;
            }
            // Run the deferred validator (e.g. required).
            const shownSyncErrors = [];
            const hiddenSyncErrors = [];
            const deferredValidate = validateDeferredSync(value);
            deferredValidate.result === 'failure' && shownSyncErrors.push(...deferredValidate.errors);
            // Next we will run the regular validators.
            // We don't run these when value is null (e.g., the field is empty)
            // or undefined (input-date-mask field is empty).
            let nonDeferredValidate = undefined;
            if (value !== null && value !== undefined) {
                nonDeferredValidate = (0, validationUtils_1.validateAsync)({ validators: validators ?? [], value });
                nonDeferredValidate.errors.forEach(({ message, messageDisplayStrategy }) => {
                    // messageDisplayStrategy === undefined -> messages should display immediately
                    // messageDisplayStrategy === displayOnBlur -> hide the messages, unless the
                    // component was previously valid; then we want immediate feedback.
                    if (messageDisplayStrategy === 'displayOnBlur' &&
                        !componentWasValidRef.current &&
                        !forceHiddenMessagesToBeShown) {
                        hiddenSyncErrors.push(message);
                    }
                    else {
                        shownSyncErrors.push(message);
                    }
                });
            }
            const maybeErrorPromises = nonDeferredValidate?.maybeErrorPromises ?? [];
            const hasSyncError = shownSyncErrors.length !== 0 || hiddenSyncErrors.length !== 0;
            // If there are no sync errors and no async validations, set the valid state and return.
            if (!hasSyncError && !maybeErrorPromises.length) {
                _dispatch(reducer_1.updateValidStatus, hasCustomErrorMessages ? 'invalidShown' : 'valid');
                return true;
            }
            // If there are any sync errors, update messages and valid.
            if (shownSyncErrors.length !== 0) {
                _dispatch(reducer_1.updateComponentMessages, shownSyncErrors);
                _dispatch(reducer_1.updateValidStatus, 'invalidShown');
            }
            else if (hiddenSyncErrors.length !== 0) {
                _dispatch(reducer_1.updateHiddenMessages, hiddenSyncErrors);
                _dispatch(reducer_1.updateValidStatus, 'invalidHidden');
            }
            // If no async validations, nothing to do here and you can return
            // the validation result based on the sync errors.
            if (!maybeErrorPromises.length) {
                return !hasSyncError;
            }
            // Set valid status to pending before starting async validation, only if there are no sync errors
            // because we want to fail-fast. We don't need to set it before sync validation because reducer
            // updates are asynchronous and by the time the update happens, the valid state is already known.
            !hasSyncError && _dispatch(reducer_1.updateValidStatus, 'pending');
            // Now we have to deal with the async validation, so setup busyState and stale identity.
            const resolver = addBusyState?.('running asynchronous validation');
            // An async function will always run synchronously until the first await statement:
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#description
            // So, setup a stale identity here. This helps us know if the validation has gone stale while processing.
            const { isStale } = setStaleIdentity('useEditableValue-full-validate');
            let hasAsyncShownError = false;
            let hasAsyncHiddenError = false;
            const asyncValidations = [];
            for (const maybeErrorPromise of maybeErrorPromises) {
                const asyncValidation = maybeErrorPromise.then((maybeValidationError) => {
                    // If the promise resolves with an error, handle it right away.
                    if (maybeValidationError && !isStale()) {
                        const { messageDisplayStrategy, message } = maybeValidationError;
                        if (messageDisplayStrategy === 'displayOnBlur' &&
                            !componentWasValidRef.current &&
                            !forceHiddenMessagesToBeShown) {
                            _dispatch(reducer_1.addHiddenMessage, message);
                            hasAsyncHiddenError = true;
                        }
                        else {
                            _dispatch(reducer_1.addComponentMessage, message);
                            hasAsyncShownError = true;
                        }
                    }
                });
                asyncValidations.push(asyncValidation);
            }
            // Wait for all the async validators to complete.
            await Promise.all(asyncValidations);
            const hasAsyncError = hasAsyncHiddenError || hasAsyncShownError;
            const hasAnyHiddenErrors = hasAsyncHiddenError || hiddenSyncErrors.length !== 0;
            const hasAnyShownErrors = hasAsyncShownError || shownSyncErrors.length !== 0;
            // If this transaction has not gone stale, set the valid prop.
            if (!isStale()) {
                if (!hasSyncError && !hasAsyncError) {
                    _dispatch(reducer_1.updateValidStatus, hasCustomErrorMessages ? 'invalidShown' : 'valid');
                }
                else if (hasAnyShownErrors) {
                    _dispatch(reducer_1.updateValidStatus, 'invalidShown');
                }
                else if (hasAnyHiddenErrors) {
                    _dispatch(reducer_1.updateValidStatus, hasCustomErrorMessages ? 'invalidShown' : 'invalidHidden');
                }
            }
            // Resolve the busy state.
            resolver?.();
            // Even though this validation might have gone stale, always return the correct result for the validation.
            // Consuming code can keep track of stale requests and act accordingly as needed.
            return !hasSyncError && !hasAsyncError;
        }, [
            addBusyState,
            _dispatch,
            deferredValidators,
            messagesCustom,
            setStaleIdentity,
            validateDeferredSync,
            validators
        ]);
        // A function that runs full validation by getting the value from the component.
        // This validation will not clear any messagesCustom set by the app.
        // If validation succeeds, updates both the value and display value.
        const runFullValidationAndUpdateValue = async () => {
            // If disabled or readonly, do nothing.
            if (disabled || readonly)
                return;
            // Get the value to validate. If conversion fails, stop.
            const conversion = getValueForValidation();
            if (conversion.result === 'failure') {
                _dispatch(reducer_1.updateComponentMessages, [conversion.error]);
                _dispatch(reducer_1.updateValidStatus, 'invalidShown');
                return;
            }
            const newValue = conversion.value;
            const validated = await validateValueOnInternalChange(newValue, {
                doNotClearMessagesCustom: true
            });
            // If validation succeeds, update both the value and display value.
            validated && _dispatch(reducer_1.updateValue, newValue) && refreshDisplayValue(newValue);
        };
        const validateValueOnExternalChange = (0, hooks_1.useCallback)(
        /**
         * A function that runs validation when the value is changed externally.
         *
         * @param value The new value provided by the app
         * @returns The result of the validation
         */
        (value) => {
            //  Clear all messages.
            _dispatch(reducer_1.clearAllMessages);
            // Run deferred validation.
            const validated = validateDeferredSync(value);
            // Update valid state.
            validated.result === 'failure' && _dispatch(reducer_1.updateHiddenMessages, validated.errors);
            _dispatch(reducer_1.updateValidStatus, validated.result === 'failure' ? 'invalidHidden' : 'valid');
            // We always return true even if the value is not valid when changed externally.
            return true;
        }, [_dispatch, validateDeferredSync]);
        const validateValueOnInternalChange = (0, hooks_1.useCallback)(
        /**
         * A function that validates a user typed value.
         *
         * @param value The new value typed by the user
         * @returns A promise that resolves to true if validation succeeds
         */
        async (value, options = {}) => {
            // An async function will always run synchronously until after the first await statement.
            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function#description
            // So, setup a stale identity here.
            const { isStale } = setStaleIdentity('useEditableValue-validateValueOnInternalChange');
            const resolver = addBusyState?.('Running validateValueOnInternalChange');
            const validationResult = await fullValidate(value, options);
            resolver?.();
            // If a new value has come in, we want to ignore the result of the pending validation
            // and return false so neither value nor displayValue is updated.
            if (isStale()) {
                return false;
            }
            return validationResult;
        }, [addBusyState, fullValidate, setStaleIdentity]);
        const onCommitValue = (0, hooks_1.useCallback)(async (value, doCommitOnValid = true) => {
            const validated = await validateValueOnInternalChange(value);
            validated && doCommitOnValid && _dispatch(reducer_1.updateValue, value);
            // Update componentWasValidRef here so it is only updated after user interaction.
            // If the component ever becomes valid and then becomes invalid due to hidden
            // messages, we show them instead to provide immediate user feedback.
            if (validated) {
                componentWasValidRef.current = true;
            }
            return validated;
        }, [_dispatch, validateValueOnInternalChange]);
        // Callback used to handle onCommit events.
        const onCommit = (0, hooks_1.useCallback)(async ({ value }) => {
            const conversion = parseValue(value);
            if (conversion.result === 'failure') {
                // parseValue will display messages and set valid in this case.
                return false;
            }
            const parsedValue = conversion.value;
            const succeeded = await onCommitValue(parsedValue);
            succeeded && refreshDisplayValue(parsedValue);
            return succeeded;
        }, [onCommitValue, parseValue, refreshDisplayValue]);
        // Callback used to handle onInput events.
        const onInput = (0, hooks_1.useCallback)(({ value }) => {
            // Do not use formatter when simply pushing back the value from onInput.
            _dispatch(reducer_1.updateDisplayValue, value ?? defaultDisplayValue);
        }, [_dispatch, defaultDisplayValue]);
        // This is the component's validate method. It follows the same rules as big jet's validate method does.
        // Validation lifecycle (clearAllMessages, parse, validate, format) is skipped if readonly or disabled
        // and 'valid' is returned.
        const validate = (0, hooks_1.useCallback)(async () => {
            if (readonly || disabled) {
                return 'valid';
            }
            // Parse the display value to get the value to validate. If conversion fails, return 'invalid'.
            const conversion = parseValue(state.displayValue);
            if (conversion.result === 'failure') {
                // parseValue will display messages and update valid in this case.
                return 'invalid';
            }
            const newValue = conversion.value;
            const resolver = addBusyState?.('Running component method validate');
            const validated = await fullValidate(newValue, { forceHiddenMessagesToBeShown: true });
            // resolve busy state
            resolver?.();
            // If validation succeeds, update both the value and display value (only if new value is different).
            // Note: fullValidate handles updating the valid state, depending on whether validation succeeded.
            if (validated) {
                if (newValue !== state.value) {
                    _dispatch(reducer_1.updateValue, newValue);
                    refreshDisplayValue(newValue);
                }
                return 'valid';
            }
            return 'invalid';
        }, [
            addBusyState,
            disabled,
            _dispatch,
            fullValidate,
            parseValue,
            readonly,
            refreshDisplayValue,
            state.displayValue,
            state.value
        ]);
        // This is the component's reset method.
        const reset = (0, hooks_1.useCallback)(() => {
            // We are pushing the component value to the UI, so only run deferred validation.
            // This is similar to setting the value externally.
            validateValueOnExternalChange(state.value);
            refreshDisplayValue(state.value);
        }, [refreshDisplayValue, state.value, validateValueOnExternalChange]);
        // This is the component's showMessages method.
        const showMessages = (0, hooks_1.useCallback)(() => {
            // If there are hidden messages, show them and set valid to invalidShown.
            if (state.hiddenMessages && state.hiddenMessages.length > 0) {
                _dispatch(reducer_1.showHiddenMessages);
                _dispatch(reducer_1.updateValidStatus, 'invalidShown');
            }
        }, [_dispatch, state.hiddenMessages]);
        const clearInteractionFlags = (0, hooks_1.useCallback)(() => {
            // This flag is reset when the user finishes interacting and tabs or clicks away.
            // It is used to force hidden messages to be shown.
            componentWasValidRef.current = false;
        }, []);
        const addMessage = (0, hooks_1.useCallback)((message) => {
            _dispatch(reducer_1.addComponentMessage, message);
        }, [_dispatch]);
        // VALUE CHANGED LIFECYCLE (chores to run when the value is programmatically changed)
        // 1. Update the previous value.
        // 2. Clear all messages.
        // 3. Run deferred validation.
        // 4. If it fails, set valid to invalidHidden; otherwise set valid to valid.
        // 5. Always update state with new value and display value.
        // This gets called when the value is changed either programmatically or by the user.
        if (!initialRender.current && state.previousValue !== value) {
            _dispatch(reducer_1.updatePreviousValue, value);
            // Ignore if value being pushed from the parent is the same as our internal state.
            // This happens when the user changes the value and commits.
            if (value !== state.value) {
                validateValueOnExternalChange(value);
                // We always set the value even if it is not valid when changed externally.
                _dispatch(reducer_1.updateValue, value);
                refreshDisplayValue(value);
            }
        }
        // CONVERTER CHANGED LIFECYCLE  (chores to run when the converter is changed)
        // 1. If valid == invalidShown, run full validation including conversion and update the value.
        // 2. If valid != invalidShown, update the display value only.
        if (!initialRender.current && state.previousConverter !== converter) {
            _dispatch(reducer_1.updatePreviousConverter, converter);
            state.valid !== 'invalidShown' && refreshDisplayValue(value);
            // Run full validation including conversion and update the value. This will happen
            // asynchronously if there are any async validators.
            state.valid === 'invalidShown' && runFullValidationAndUpdateValue();
        }
        // VALIDATORS CHANGED LIFECYCLE  (chores to run when the validators are changed)
        // 1. If valid state == valid or state == invalidHidden, do nothing.
        // 2. If valid state == invalidShown, run full validation with the current value and validators.
        if (!initialRender.current && state.previousValidators !== validators) {
            _dispatch(reducer_1.updatePreviousValidators, validators);
            // Run full validation including conversion and update the value. This will happen
            // asynchronously if there are any async validators.
            state.valid === 'invalidShown' && runFullValidationAndUpdateValue();
        }
        // MESSAGES CUSTOM CHANGED LIFECYCLE  (chores to run when messagesCustom is changed)
        // 1. If contains errors, set valid to invalidShown.
        // 2. If does not contain errors:
        //    If valid state is pending, do nothing
        //    Otherwise, if no errors in any type of messages set valid to "valid" OR
        //    if there are hidden messages set valid to "invalidHidden"
        if (!initialRender.current &&
            ((!state.customMessages && messagesCustom) ||
                (state.customMessages && !messagesCustom) ||
                (state.customMessages &&
                    messagesCustom &&
                    !(0, utils_1.isShallowEqual)(state.customMessages, messagesCustom)))) {
            const compMsgs = state.componentMessages ?? [];
            const hiddenMsgs = state.hiddenMessages ?? [];
            const customMsgs = messagesCustom ?? [];
            const hasErrors = (0, utils_1.hasErrorMessages)(customMsgs);
            const hasHiddenMessages = hiddenMsgs.length > 0;
            const hasNoMessages = compMsgs.length === 0 && hiddenMsgs.length === 0 && customMsgs.length === 0;
            _dispatch(reducer_1.updateCustomMessages, customMsgs);
            hasErrors && _dispatch(reducer_1.updateValidStatus, 'invalidShown');
            !hasErrors &&
                state.valid !== 'pending' &&
                ((hasNoMessages && _dispatch(reducer_1.updateValidStatus, 'valid')) ||
                    (hasHiddenMessages && _dispatch(reducer_1.updateValidStatus, 'invalidHidden')));
        }
        // REQUIRED CHANGED LIFECYCLE
        // Chores to do if deferredValidators change (this happens when the required property is toggled).
        // We don't run these if disabled or readonly, except when required is toggled to false.
        // 1. If component is in valid state, run deferred validation
        // 2. If the component is in invalidHidden state and deferred validators are cleared,
        //    clear messages and do not run validation
        // 3. If the component is in invalidShown state, clear messages (not messagesCustom) and
        //    run normal validation
        if (!initialRender.current &&
            (state.previousDeferredValidators !== deferredValidators ||
                state.previousDisabled !== disabled ||
                state.previousReadonly !== readonly)) {
            const isRequiredToggledToFalse = deferredValidators?.length === 0;
            state.previousDeferredValidators !== deferredValidators &&
                _dispatch(reducer_1.updatePreviousDeferredValidators, deferredValidators);
            state.previousDisabled !== disabled && _dispatch(reducer_1.updatePreviousDisabled, disabled);
            state.previousReadonly !== readonly && _dispatch(reducer_1.updatePreviousReadonly, readonly);
            // Run validation if required has been toggled to false (regardless of what
            // readonly/disabled are), or if the component is enabled.
            if (isRequiredToggledToFalse || (!readonly && !disabled)) {
                switch (state.valid) {
                    case 'valid': {
                        const conversion = getValueForValidation();
                        // If getValueForValidation fails, show errors and update valid.
                        if (conversion.result === 'failure') {
                            _dispatch(reducer_1.updateComponentMessages, [conversion.error]);
                            _dispatch(reducer_1.updateValidStatus, 'invalidShown');
                        }
                        else {
                            // Run deferred validation on the value.
                            const deferredValidate = validateDeferredSync(conversion.value);
                            deferredValidate.result === 'failure' &&
                                _dispatch(reducer_1.updateHiddenMessages, deferredValidate.errors) &&
                                _dispatch(reducer_1.updateValidStatus, 'invalidHidden');
                        }
                        break;
                    }
                    case 'invalidHidden':
                        if (deferredValidators?.length === 0) {
                            // no deferred validators, so clear messages and set to valid
                            _dispatch(reducer_1.updateValidStatus, 'valid');
                            _dispatch(reducer_1.updateHiddenMessages, []);
                        }
                        break;
                    case 'invalidShown':
                        runFullValidationAndUpdateValue();
                        break;
                }
            }
        }
        // INITIAL RENDER LIFECYCLE
        // 1. Run deferred validation using the initial value, if not readonly or disabled.
        // 2. Update valid based on result of validation and if there are custom messages.
        // 3. Format and update the display value.
        if (initialRender.current) {
            initialRender.current = false;
            // Store the current value of props so we can see if they change and run needed chores.
            _dispatch(reducer_1.updatePreviousValue, value);
            _dispatch(reducer_1.updatePreviousConverter, converter);
            _dispatch(reducer_1.updatePreviousValidators, validators);
            _dispatch(reducer_1.updatePreviousDeferredValidators, deferredValidators);
            _dispatch(reducer_1.updatePreviousDisabled, disabled);
            _dispatch(reducer_1.updatePreviousReadonly, readonly);
            _dispatch(reducer_1.updateCustomMessages, messagesCustom);
            // Initialize transient value from value.
            _dispatch(reducer_1.updateTransientValue, value);
            // Run deferred validation only if component is enabled. Otherwise, set valid state to 'valid'.
            if (!disabled && !readonly) {
                const validated = validateDeferredSync(value);
                validated.result === 'failure' &&
                    _dispatch(reducer_1.updateHiddenMessages, validated.errors) &&
                    _dispatch(reducer_1.updateValidStatus, (0, utils_1.hasErrorMessages)(messagesCustom) ? 'invalidShown' : 'invalidHidden');
                validated.result === 'success' &&
                    _dispatch(reducer_1.updateValidStatus, (0, utils_1.hasErrorMessages)(messagesCustom) ? 'invalidShown' : 'valid') &&
                    refreshDisplayValue(value);
            }
            else {
                // initial render for readonly or disabled, we want to format the value
                // and update the rawValue.
                _dispatch(reducer_1.updateValidStatus, 'valid');
                refreshDisplayValue(value);
            }
        }
        return {
            value: state.value,
            addMessage,
            clearInteractionFlags,
            displayValue: state.displayValue,
            formatValue,
            methods: {
                reset,
                showMessages,
                validate
            },
            onCommitValue,
            parseValue,
            refreshDisplayValue,
            setDisplayValue,
            setTransientValue,
            setValue,
            textFieldProps: {
                'aria-describedby': ariaDescribedBy,
                messages: displayOptions?.messages !== 'none' ? state.shownMessages : undefined,
                onCommit,
                onInput,
                value: state.displayValue
            },
            validateValueOnExternalChange
        };
    }
});

define('oj-c/hooks/UNSAFE_useEditableValue/index',["require", "exports", "./utils", "./useEditableValue"], function (require, exports, utils_1, useEditableValue_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useEditableValue = exports.treatNull = exports.getVirtualKeyboardHintFromConverter = void 0;
    Object.defineProperty(exports, "getVirtualKeyboardHintFromConverter", { enumerable: true, get: function () { return utils_1.getVirtualKeyboardHintFromConverter; } });
    Object.defineProperty(exports, "treatNull", { enumerable: true, get: function () { return utils_1.treatNull; } });
    Object.defineProperty(exports, "useEditableValue", { enumerable: true, get: function () { return useEditableValue_1.useEditableValue; } });
});

define('oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators',["require", "exports", "ojs/ojvalidator-required", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle"], function (require, exports, RequiredValidator, hooks_1, UNSAFE_useTranslationBundle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useDeferredValidators = useDeferredValidators;
    /**
     * A custom hook the creates deferred validators based on certain properties
     * of the component, e.g., the required property.
     *
     * @param param0 The props for the useDeferredValidators hook
     * @returns An array of deferred validators
     */
    function useDeferredValidators({ labelHint, required, requiredMessageDetail: propRequiredMessageDetail }) {
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const requiredMessageDetail = propRequiredMessageDetail || translations.formControl_requiredMessageDetail();
        const requiredValidator = (0, hooks_1.useMemo)(() => {
            if (required) {
                return new RequiredValidator({
                    label: labelHint,
                    messageDetail: requiredMessageDetail
                });
            }
            return null;
        }, [required]);
        return (0, hooks_1.useMemo)(() => [requiredValidator].filter(Boolean), [requiredValidator]);
    }
});

define('oj-c/input-date-mask/useInputDateMaskPreact',["require", "exports", "./CalendarDateConverter", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "ojs/ojconverter-preferences", "@oracle/oraclejet-preact/utils/UNSAFE_calendarDateUtils", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/input-date-text/useImplicitDateRangeValidator", "ojs/ojconfig", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators"], function (require, exports, CalendarDateConverter_1, hooks_1, UNSAFE_useTranslationBundle_1, ojconverter_preferences_1, UNSAFE_calendarDateUtils_1, useComponentMessages_1, useImplicitDateRangeValidator_1, ojconfig_1, index_1, useDeferredValidators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMasksFromDatePatternPreferences = void 0;
    exports.useInputDateMaskPreact = useInputDateMaskPreact;
    /**
     * This hook manages state and other related props for the Input Date Mask component.
     */
    function useInputDateMaskPreact({ dateRangeOverflowMessageDetail, dateRangeUnderflowMessageDetail, disabled, displayOptions, labelEdge, labelHint, labelStartWidth, max, messagesCustom, min, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, textAlign, userAssistanceDensity, validators, value: propValue, onMessagesCustomChanged, onRawValueChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        // Treat null as undefined for the min/max options.
        const minTreatNull = (0, index_1.treatNull)(min);
        const maxTreatNull = (0, index_1.treatNull)(max);
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const calendarDateConverter_parseErrorFn = translations.calendarDateConverter_parseError;
        // User preferences are set before the application runs, and never after that.
        const masksFromUserPref = (0, hooks_1.useMemo)(() => {
            return (0, exports.getMasksFromDatePatternPreferences)();
        }, []);
        const implicitConverter = (0, hooks_1.useMemo)(() => {
            return new CalendarDateConverter_1.CalendarDateConverter({
                calendarDateConverter_parseErrorFn,
                customMask: masksFromUserPref
            });
        }, [calendarDateConverter_parseErrorFn, masksFromUserPref]);
        // returns a formatted date to use in the example.
        // Memoize this because formatObj in useImplicitDateRangeValidator is a dependency. If we do not memoize,
        // then our code would create a new converter on every keystroke the user types.
        const exampleFormatter = (0, hooks_1.useMemo)(() => {
            return {
                format: (value) => {
                    // Format based on masks from user pref, if any, or the locale.
                    return (0, UNSAFE_calendarDateUtils_1.formatIsoDateStrAsExample)((0, ojconfig_1.getLocale)(), value, masksFromUserPref);
                }
            };
        }, [masksFromUserPref]);
        const implicitComponentValidator = (0, useImplicitDateRangeValidator_1.useImplicitDateRangeValidator)({
            formatObj: exampleFormatter,
            dateRangeOverflowMessageDetail,
            dateRangeUnderflowMessageDetail,
            max: maxTreatNull,
            min: minTreatNull
        });
        const combinedValidators = (0, hooks_1.useMemo)(() => {
            const v1 = implicitComponentValidator ? [implicitComponentValidator] : [];
            const v2 = validators ? validators : [];
            return [...v1, ...v2];
        }, [implicitComponentValidator, validators]);
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const { methods, textFieldProps: evTextFieldProps, value } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            converter: implicitConverter,
            defaultDisplayValue: undefined,
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onRawValueChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            validators: combinedValidators,
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        // this is used to determine isRequiredShown
        const hasNoValue = value === undefined || !isPartialDate(textFieldProps.value);
        return {
            methods,
            inputDateMaskProps: {
                isDisabled: disabled,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                label: labelHint,
                labelEdge,
                labelStartWidth,
                masks: masksFromUserPref,
                messages,
                textAlign,
                userAssistanceDensity,
                ...textFieldProps
            }
        };
    }
    const isPartialDate = (value) => {
        if (value === undefined)
            return false;
        return value.year !== undefined || value.month !== undefined || value.day !== undefined;
    };
    // get the DatePlaceholders array. If it is not undefined, we will set this on the masks property of InputDateMask.
    // If the pattern has MMM in it, then it must be in their language and use their locale since MMM is an abbreviation for the month not a number.
    // For example, it can be Oct for October in English.
    // Therefore, if the pattern has MMM in it, we assume that they are using locale and we will not set a custom masks.
    // They will get the order of month, day and year and the placeholder based on their locale.
    const getMasksFromDatePatternPreferences = () => {
        // get the user preference pattern for date, and from that we get order of year, month, day and store it in
        // masks: DatePlaceholders;
        // masks overrides the locale specific order of the individual date segments as well as the locale specific separator.
        // we use masks when we show a date in an error message and we pass it to the PreactInputDateMask.
        // this way the order of the month, day, year segments in the field matches the order of any error messages, like
        // 'Enter a complete date like this: 11/29/2023'.
        const prefs = (0, ojconverter_preferences_1.getDateTimePreferences)();
        const pattern = prefs.dateStyle?.short?.pattern;
        // return undefined if no pattern or if pattern contains MMM/mmm
        if (!pattern || pattern.toUpperCase().includes('MMM')) {
            return undefined;
        }
        return (0, UNSAFE_calendarDateUtils_1.getDatePlaceholdersFromPattern)(pattern);
    };
    exports.getMasksFromDatePatternPreferences = getMasksFromDatePatternPreferences;
});


define('oj-c/input-date-mask/input-date-mask',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_InputDateMask", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojcontext", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "./useInputDateMaskPreact", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "@oracle/oraclejet-preact/UNSAFE_IntlDateTime", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "css!oj-c/input-date-mask/input-date-mask-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_InputDateMask_1, useAssistiveText_1, Context, ojvcomponent_1, compat_1, hooks_1, useInputDateMaskPreact_1, UNSAFE_classNames_1, FormControl_1, Layout_1, UNSAFE_IntlDateTime_1, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputDateMask = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    /**
     * @classdesc
     * <h3 id="InputDateMaskOverview-section">
     *   JET Input Date Mask Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#InputDateMaskOverview-section"></a>
     * </h3>
     *
     * <p>Description: A JET Input Date Mask allows a user to individually edit, step, or spin the
     * values of the month, day, and year fields of a calendar date.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-input-date-mask label-hint="Date">&lt;/oj-c-input-date-mask></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
    
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required validator is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation is run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property (if available) changes.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>required property can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * The mask placeholder is shown when the field is empty and has focus. The mask placeholder is not configurable.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Field (Not a Segment)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to first segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Segment</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Segment</td>
     *       <td><kbd>Double Tap</kbd></td>
     *       <td>If the date is complete, selects the entire date. Hitting backspace clears it.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Field</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Sets focus to first segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Field</td>
     *       <td><kbd>Ctrl + A</kbd> or <kbd>Command + A</kbd></td>
     *       <td>If the date is complete, selects the entire date. Double clicking on the field also selects the date.</td>
     *     </tr>
     *     <tr>
     *       <td>Field with date selected</td>
     *       <td><kbd>Backspace/Delete</kbd></td>
     *       <td>Backspace or delete key clears the date. The mask placeholders will be shown again and focus will be on the first segment.</td>
     *     </tr>
     *     <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>Backspace/Delete</kbd></td>
     *       <td>Clears the date segment. Focus remains on the date segment.</td>
     *     </tr>
     *     <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Moves focus to the segment on the right. If focus is on the rightmost segment, the focus does not move.</td>
     *     </tr>
     *     <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Moves focus to the segment on the left. If focus is on the leftmost segment, the focus does not move.</td>
     *     </tr>
     *    <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>UpArrow/DownArrow</kbd></td>
     *       <td>Increments or decrements the number by one in the segment. If there is no number in the segment, it initializes it to the current date.</td>
     *     </tr>
     *    <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>End</kbd></td>
     *       <td>Increments the segment to the maximum number for the segment. For example, if on the month segment, this will set the number to 12. If on the year segment, this will set the number to 2100.</td>
     *     </tr>
     *    <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>Decrements the segment to the minimum number for the segment. For example, if on the month segment, this will set the number to 1. If on the year segment, this will set the number to 1900.</td>
     *     </tr>
     *    <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>Page Up/Page Down</kbd></td>
     *       <td>Increments or decrements the number by two in the month segment, by seven in the day segment, or by five in the year segment. If there is no number in the segment, it initializes it to the current date.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata displayName "InputDateMask"
     * @ojmetadata description "An input date mask field allows a user to individually edit, step, or spin the values of the month, day, and year fields of a calendar date."
     * @ojmetadata help "oj-c.InputDateMask.html"
     * @ojmetadata main "oj-c/input-date-mask"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/input-date-mask",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-date",
     *     "uxSpecs": [
     *       "input-date-mask"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "readonly",
     *       "required"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "16.0.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    const InputDateMaskImpl = ({ columnSpan = 1, containerReadonly: propContainerReadonly, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, labelWrapping: propLabelWrapping, maxWidth, messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, validators = validatorsDefault, value = null, width, ...otherProps }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const inputDateMaskRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((description = 'InputDateMask: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current).getBusyContext().addBusyState({ description })
                : () => { }; // if the component is not mounted return Noop
        }, []);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        const { inputDateMaskProps, methods } = (0, useInputDateMaskPreact_1.useInputDateMaskPreact)({
            disabled,
            displayOptions,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            validators,
            value,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => inputDateMaskRef.current?.blur(),
            focus: () => inputDateMaskRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: inputDateMaskProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(value)) {
            throw new Error('value must be a date-only ISO string');
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(otherProps.min)) {
            throw new Error('min must be a date-only ISO string');
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(otherProps.max)) {
            throw new Error('max must be a date-only ISO string');
        }
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: maxWidth === 'md' || maxWidth === 'sm' ? maxWidth : 'none',
            width: width === 'md' || width === 'sm' ? width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = width === 'md' || width === 'sm' ? undefined : width;
        const maxWidthStyle = maxWidth === 'md' || maxWidth === 'sm' ? undefined : maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return (
        // Even though we are handling the styling here, we pass the columnSpan property down to the
        // Preact component because it may be needed for other purposes, like calculating the start
        // label width.
        (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: otherProps.id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_InputDateMask_1.InputDateMask, { ref: inputDateMaskRef, ...assistiveTextProps, ...inputDateMaskProps, columnSpan: columnSpan, variant: variant }) }) }));
    };
    exports.InputDateMask = (0, ojvcomponent_1.registerCustomElement)('oj-c-input-date-mask', (0, compat_1.forwardRef)(InputDateMaskImpl), "InputDateMask", { "properties": { "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "dateRangeOverflowMessageDetail": { "type": "string" }, "dateRangeUnderflowMessageDetail": { "type": "string" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "max": { "type": "string|null" }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "min": { "type": "string|null" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "string|null", "writeback": true }, "width": { "type": "number|string" }, "rawValue": { "type": "object", "properties": { "year": { "type": "number" }, "month": { "type": "number" }, "day": { "type": "number" } }, "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "columnSpan": 1, "disabled": false, "displayOptions": { "messages": "display", "validatorHint": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "validators": [], "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/input-date-mask',["require", "exports", "oj-c/input-date-mask/input-date-mask"], function (require, exports, input_date_mask_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputDateMask = void 0;
    Object.defineProperty(exports, "InputDateMask", { enumerable: true, get: function () { return input_date_mask_1.InputDateMask; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/input-date-picker/useCombinedImplicitValidators',["require", "exports", "preact/hooks"], function (require, exports, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCombinedImplicitValidators = void 0;
    /**
     * A custom hook that combines multiple implicit validators to a single validator
     * for oj-c-input-date-picker. The returned combined validator will fail-fast. The
     * argument order will dictate the order in which the validators are executed.
     *
     * @param validators implicit validators
     * @returns a combined validator
     */
    const useCombinedImplicitValidators = (...validators) => (0, hooks_1.useMemo)(() => ({
        validate(value) {
            for (const validator of validators) {
                validator?.validate(value);
            }
        }
    }), 
    // eslint-disable-next-line
    [...validators]);
    exports.useCombinedImplicitValidators = useCombinedImplicitValidators;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/input-date-picker/useImplicitCalendarDateConverter',["require", "exports", "oj-c/input-date-mask/CalendarDateConverter", "oj-c/input-date-mask/useInputDateMaskPreact", "preact/hooks"], function (require, exports, CalendarDateConverter_1, useInputDateMaskPreact_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useImplicitCalendarDateConverter = void 0;
    /**
     * Custom hook that creates an implicit CalendarDateConverter for oj-c-input-date-picker.
     *
     * @returns A CalendarDateConverter instance
     */
    const useImplicitCalendarDateConverter = ({ calendarDateConverter_parseErrorFn }) => {
        // User preferences are set before the application runs, and never after that.
        const masksFromUserPref = (0, hooks_1.useMemo)(() => {
            return (0, useInputDateMaskPreact_1.getMasksFromDatePatternPreferences)();
        }, []);
        // Create a converter for getting min/max
        return (0, hooks_1.useMemo)(() => {
            return new CalendarDateConverter_1.CalendarDateConverter({
                calendarDateConverter_parseErrorFn,
                customMask: masksFromUserPref
            });
        }, [calendarDateConverter_parseErrorFn, masksFromUserPref]);
    };
    exports.useImplicitCalendarDateConverter = useImplicitCalendarDateConverter;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/input-date-picker/utils',["require", "exports", "@oracle/oraclejet-preact/utils/UNSAFE_calendarDateUtils"], function (require, exports, UNSAFE_calendarDateUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertCompleteDate = exports.compareCalendarDates = void 0;
    /**
     * Compares two dates of type CalendarDateRequired.
     * @param val1 first calendar date
     * @param val2 second calendar date
     * @returns 0 if the same calendar date. 1 if val1 > val2. -1 if val1 < val2.
     */
    const compareCalendarDates = (val1, val2) => {
        if (val1.year === val2.year && val1.month === val2.month && val1.day === val2.day) {
            return 0;
        }
        if (val1.year === val2.year) {
            if (val1.month === val2.month) {
                return val1.day > val2.day ? 1 : -1;
            }
            return val1.month > val2.month ? 1 : -1;
        }
        return val1.year > val2.year ? 1 : -1;
    };
    exports.compareCalendarDates = compareCalendarDates;
    /**
     * Makes sure that the provided date is a complete date.
     * Note: The function needs to be declared this way for TS assertion to work correctly.
     * @param date The date to check
     * @throws {Error} if the provided date is not a complete date
     */
    const assertCompleteDate = (date) => {
        if (!(0, UNSAFE_calendarDateUtils_1.isCompleteCalendarDate)(date))
            // no translation needed as this error is for the app developer.
            throw new Error('DateRestrictionValidator: Expected full date, but received partial date');
    };
    exports.assertCompleteDate = assertCompleteDate;
});

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
define('oj-c/input-date-picker/DateRangeValidator',["require", "exports", "./utils"], function (require, exports, utils_1) {
    "use strict";
    var _DateRangeValidator_instances, _DateRangeValidator_getOverflowErrorDetail, _DateRangeValidator_getUnderflowErrorDetail;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateRangeValidator = void 0;
    /**
     * Constructs a DateRangeValidator that ensures the date provided is
     * within the range specified using min and max.
     * @template V type of the value to be validated
     * @implements {Validator}
     */
    class DateRangeValidator {
        /**
         * Instantiates the DateRangeValidator
         * @param options The validator options
         */
        constructor(options) {
            _DateRangeValidator_instances.add(this);
            if (options.min && options.max && (0, utils_1.compareCalendarDates)(options.min, options.max) > 0) {
                // this is an app developer error, so it doesn't need to be translated.
                throw new Error('min must be less than max');
            }
            this.options = options;
        }
        /**
         * Validates that the provided date is within the range
         * @param value The date to be validated
         * @throws {Error} when the date is not within the range
         */
        validate(value) {
            if (value === null)
                return;
            const { converter, max, min } = this.options;
            // if value is specified, then convert the value to CalendarDate format
            const valueCalendarDate = converter.format(value);
            // assert that the value is a complete calendar date
            (0, utils_1.assertCompleteDate)(valueCalendarDate);
            if (max && (0, utils_1.compareCalendarDates)(valueCalendarDate, max) > 0) {
                throw new Error(__classPrivateFieldGet(this, _DateRangeValidator_instances, "m", _DateRangeValidator_getOverflowErrorDetail).call(this, value, max));
            }
            if (min && (0, utils_1.compareCalendarDates)(valueCalendarDate, min) < 0) {
                throw new Error(__classPrivateFieldGet(this, _DateRangeValidator_instances, "m", _DateRangeValidator_getUnderflowErrorDetail).call(this, value, min));
            }
        }
    }
    exports.DateRangeValidator = DateRangeValidator;
    _DateRangeValidator_instances = new WeakSet(), _DateRangeValidator_getOverflowErrorDetail = function _DateRangeValidator_getOverflowErrorDetail(value, max) {
        const { converter, dateRangeOverflowMessageDetail, defaultRangeOverflowMessageDetailFn, formatObj } = this.options;
        const isoMax = converter.parse(max);
        const maxString = formatObj.format(isoMax);
        if (dateRangeOverflowMessageDetail) {
            const valueString = formatObj.format(value);
            return dateRangeOverflowMessageDetail({ value: valueString, max: maxString });
        }
        return defaultRangeOverflowMessageDetailFn({ max: maxString });
    }, _DateRangeValidator_getUnderflowErrorDetail = function _DateRangeValidator_getUnderflowErrorDetail(value, min) {
        const { converter, dateRangeUnderflowMessageDetail, defaultRangeUnderflowMessageDetailFn, formatObj } = this.options;
        const isoMin = converter.parse(min);
        const minString = formatObj.format(isoMin);
        if (dateRangeUnderflowMessageDetail) {
            const valueString = formatObj.format(value);
            return dateRangeUnderflowMessageDetail({ value: valueString, min: minString });
        }
        return defaultRangeUnderflowMessageDetailFn({ min: minString });
    };
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/input-date-picker/useImplicitDateRangeValidator',["require", "exports", "preact/hooks", "./DateRangeValidator"], function (require, exports, hooks_1, DateRangeValidator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useImplicitDateRangeValidator = void 0;
    /**
     * Custom hook that creates an implicit DateRangeValidator for oj-c-input-date-picker
     * if there is a dayFormatter property. Otherwise it will return null.
     *
     * @returns A DateRangeValidator instance or null
     */
    const useImplicitDateRangeValidator = ({ converter, defaultRangeOverflowMessageDetailFn, defaultRangeUnderflowMessageDetailFn, dateRangeOverflowMessageDetail, dateRangeUnderflowMessageDetail, formatObj, max, min }) => (0, hooks_1.useMemo)(() => {
        // if there is no min and no max, no need for validation
        if (!min && !max)
            return undefined;
        // since there is a min or max, return a validator
        return new DateRangeValidator_1.DateRangeValidator({
            converter,
            defaultRangeOverflowMessageDetailFn,
            defaultRangeUnderflowMessageDetailFn,
            dateRangeOverflowMessageDetail,
            dateRangeUnderflowMessageDetail,
            formatObj,
            max,
            min
        });
    }, [
        converter,
        defaultRangeOverflowMessageDetailFn,
        defaultRangeUnderflowMessageDetailFn,
        dateRangeOverflowMessageDetail,
        dateRangeUnderflowMessageDetail,
        formatObj,
        max,
        min
    ]);
    exports.useImplicitDateRangeValidator = useImplicitDateRangeValidator;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
define('oj-c/input-date-picker/DateRestrictionValidator',["require", "exports", "./utils"], function (require, exports, utils_1) {
    "use strict";
    var _DateRestrictionValidator_instances, _DateRestrictionValidator_getErrorDetail, _DateRestrictionValidator_getDayState;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DateRestrictionValidator = void 0;
    /**
     * Constructs a DateRestrictionValidator that ensures the date provided is
     * not a disabled or restricted date.
     * @template V type of the value to be validated
     * @implements {Validator}
     */
    class DateRestrictionValidator {
        /**
         * Instantiates the DateRestrictionValidator
         * @param options The validator options
         */
        constructor(options) {
            _DateRestrictionValidator_instances.add(this);
            this.options = options;
        }
        /**
         * Validates that the provided date is not disabled or restricted
         * @param value The date to be validated
         * @throws {Error} when the date is disabled or restricted
         */
        validate(value) {
            if (value == null)
                return;
            // if value is specified, then convert the value to CalendarDate format
            const valueCalendarDate = this.options.converter.format(value);
            // if it is not disabled or restricted, then return
            const { state } = __classPrivateFieldGet(this, _DateRestrictionValidator_instances, "m", _DateRestrictionValidator_getDayState).call(this, valueCalendarDate);
            if (state === 'enabled')
                return;
            // validation failed, construct the error message and throw
            throw new Error(__classPrivateFieldGet(this, _DateRestrictionValidator_instances, "m", _DateRestrictionValidator_getErrorDetail).call(this, value, state));
        }
    }
    exports.DateRestrictionValidator = DateRestrictionValidator;
    _DateRestrictionValidator_instances = new WeakSet(), _DateRestrictionValidator_getErrorDetail = function _DateRestrictionValidator_getErrorDetail(value, state) {
        if (this.options.dateRestrictionMessageDetail)
            return this.options.dateRestrictionMessageDetail({ state, value });
        return this.options.defaultRestrictionMessageDetail();
    }, _DateRestrictionValidator_getDayState = function _DateRestrictionValidator_getDayState(date) {
        (0, utils_1.assertCompleteDate)(date);
        return this.options.dayFormatter(date);
    };
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/input-date-picker/useImplicitDateRestrictionValidator',["require", "exports", "preact/hooks", "./DateRestrictionValidator"], function (require, exports, hooks_1, DateRestrictionValidator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useImplicitDateRestrictionValidator = void 0;
    /**
     * Custom hook that creates an implicit DateRestrictionValidator for oj-c-input-date-picker
     * if there is a dayFormatter property. Otherwise it will return null.
     *
     * @returns A DateRestrictionValidator instance or null
     */
    const useImplicitDateRestrictionValidator = ({ converter, dateRestrictionMessageDetail, dayFormatter, defaultRestrictionMessageDetail }) => (0, hooks_1.useMemo)(() => {
        if (!dayFormatter)
            return undefined;
        return new DateRestrictionValidator_1.DateRestrictionValidator({
            converter,
            dateRestrictionMessageDetail,
            dayFormatter,
            defaultRestrictionMessageDetail
        });
    }, [converter, dateRestrictionMessageDetail, dayFormatter, defaultRestrictionMessageDetail]);
    exports.useImplicitDateRestrictionValidator = useImplicitDateRestrictionValidator;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/input-date-picker/useInputDatePicker',["require", "exports", "@oracle/oraclejet-preact/UNSAFE_IntlDateTime", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "@oracle/oraclejet-preact/utils/UNSAFE_calendarDateUtils", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "oj-c/input-date-mask/useInputDateMaskPreact", "preact/hooks", "./useCombinedImplicitValidators", "./useImplicitCalendarDateConverter", "./useImplicitDateRangeValidator", "./useImplicitDateRestrictionValidator", "./utils", "ojs/ojcontext", "ojs/ojconfig", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "@oracle/oraclejet-preact/utils/UNSAFE_classNames"], function (require, exports, UNSAFE_IntlDateTime_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTranslationBundle_1, UNSAFE_calendarDateUtils_1, Layout_1, useAssistiveText_1, useMergedFormContext_1, useInputDateMaskPreact_1, hooks_1, useCombinedImplicitValidators_1, useImplicitCalendarDateConverter_1, useImplicitDateRangeValidator_1, useImplicitDateRestrictionValidator_1, utils_1, Context, ojconfig_1, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1, UNSAFE_classNames_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useInputDatePicker = void 0;
    /**
     * A custom hook that adds functionality to the InputDatePicker component.
     */
    const useInputDatePicker = (props, ref) => {
        // first assert that all the props are expected
        assertProps(props);
        // get the translation resources
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        // create refs for busyState and adding methods
        const rootRef = (0, hooks_1.useRef)(null);
        const inputDatePickerRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((description = 'InputDatePicker: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current).getBusyContext().addBusyState({ description })
                : () => { }; // if the component is not mounted return Noop
        }, []);
        // merge the props with form context
        const { containerProps: formContextValue, readonlyValue: mergedReadonly, uadValue: mergedUserAssistanceDensity } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly: props.containerReadonly,
            propLabelWrapping: props.labelWrapping,
            propReadonly: props.readonly,
            propUserAssistanceDensity: props.userAssistanceDensity,
            propTextAlign: props.textAlign
        });
        // get the variant
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        // create implicit converter
        const implicitConverter = (0, useImplicitCalendarDateConverter_1.useImplicitCalendarDateConverter)({
            calendarDateConverter_parseErrorFn: translations.calendarDateConverter_parseError
        });
        // get min and max as CalendarDate
        const { max: maxCalendarDate, min: minCalendarDate } = useMinMax({
            converter: implicitConverter,
            max: props.max,
            min: props.min
        });
        // make sure that min and max are complete dates
        if (maxCalendarDate)
            (0, utils_1.assertCompleteDate)(maxCalendarDate);
        if (minCalendarDate)
            (0, utils_1.assertCompleteDate)(minCalendarDate);
        // User preferences are set before the application runs, and never after that.
        const masksFromUserPref = (0, hooks_1.useMemo)(() => {
            return (0, useInputDateMaskPreact_1.getMasksFromDatePatternPreferences)();
        }, []);
        // returns a formatted date to use in the example.
        // Memoize this because formatObj in useImplicitDateRangeValidator is a dependency.
        const exampleFormatter = (0, hooks_1.useMemo)(() => {
            return {
                format: (value) => {
                    // Format based on masks from user pref, if any, or the locale.
                    return (0, UNSAFE_calendarDateUtils_1.formatIsoDateStrAsExample)((0, ojconfig_1.getLocale)(), value, masksFromUserPref);
                }
            };
        }, [masksFromUserPref]);
        // create implicit validators
        const implicitDateRestrictionValidator = (0, useImplicitDateRestrictionValidator_1.useImplicitDateRestrictionValidator)({
            converter: implicitConverter,
            dateRestrictionMessageDetail: props.dateRestrictionMessageDetail,
            dayFormatter: props.dayFormatter,
            defaultRestrictionMessageDetail: translations.inputDatePicker_dateRestrictionMessageDetail
        });
        const implicitDateRangeValidator = (0, useImplicitDateRangeValidator_1.useImplicitDateRangeValidator)({
            converter: implicitConverter,
            dateRangeOverflowMessageDetail: props.dateRangeOverflowMessageDetail,
            dateRangeUnderflowMessageDetail: props.dateRangeUnderflowMessageDetail,
            defaultRangeOverflowMessageDetailFn: translations.inputDatePicker_dateRangeOverflowMessageDetail,
            defaultRangeUnderflowMessageDetailFn: translations.inputDatePicker_dateRangeUnderflowMessageDetail,
            formatObj: exampleFormatter,
            max: maxCalendarDate,
            min: minCalendarDate
        });
        // If a date is both out of range and disabled/restricted, we only need to show a single
        // message. The out of range error takes precedence and only that should be shown. So, we
        // combine the implicit validators into one.
        const implicitValidator = (0, useCombinedImplicitValidators_1.useCombinedImplicitValidators)(implicitDateRangeValidator, implicitDateRestrictionValidator);
        // merge validators
        const mergedValidators = (0, hooks_1.useMemo)(() => [implicitValidator, ...(props.validators ?? [])], [implicitValidator, props.validators]);
        // this component has the same functionality as the input-date-mask,
        // so we reuse the useInputDateMaskPreact hook here
        const { inputDateMaskProps, methods } = (0, useInputDateMaskPreact_1.useInputDateMaskPreact)({
            ...props,
            // overrides
            readonly: mergedReadonly,
            validators: mergedValidators,
            userAssistanceDensity: mergedUserAssistanceDensity,
            // we handled min and max here, so do not pass props related
            // to min and max
            dateRangeOverflowMessageDetail: undefined,
            dateRangeUnderflowMessageDetail: undefined,
            max: undefined,
            min: undefined
        }, addBusyState);
        // get assistive text props
        const { assistiveText, helpSourceLink, helpSourceText } = (0, useAssistiveText_1.useAssistiveText)({
            addBusyState,
            displayOptions: props.displayOptions,
            help: props.help,
            helpHints: props.helpHints,
            userAssistanceDensity: inputDateMaskProps.userAssistanceDensity,
            validators: props.validators ?? []
        });
        // add methods to ref
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => inputDatePickerRef.current?.blur(),
            focus: () => inputDatePickerRef.current?.focus(),
            ...methods
        }), [methods]);
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: props.maxWidth === 'md' || props.maxWidth === 'sm' ? props.maxWidth : 'none',
            width: props.width === 'md' || props.width === 'sm' ? props.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[props.columnSpan ?? 1],
            formContextValue.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = props.width === 'md' || props.width === 'sm' ? undefined : props.width;
        const maxWidthStyle = props.maxWidth === 'md' || props.maxWidth === 'sm' ? undefined : props.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return {
            formContextValue,
            inputDatePickerProps: {
                'aria-describedby': inputDateMaskProps['aria-describedby'],
                assistiveText: assistiveText,
                dayFormatter: props.dayFormatter,
                daysOutsideMonth: props.daysOutsideMonth,
                helpSourceLink: helpSourceLink,
                helpSourceText: helpSourceText,
                isDisabled: inputDateMaskProps.isDisabled,
                isReadonly: inputDateMaskProps.isReadonly,
                isRequired: inputDateMaskProps.isRequired,
                isRequiredShown: inputDateMaskProps.isRequiredShown,
                label: inputDateMaskProps.label,
                labelEdge: inputDateMaskProps.labelEdge,
                labelStartWidth: inputDateMaskProps.labelStartWidth,
                masks: inputDateMaskProps.masks,
                max: maxCalendarDate,
                messages: inputDateMaskProps.messages,
                min: minCalendarDate,
                monthAndYearPicker: props.monthAndYearPicker,
                onCommit: inputDateMaskProps.onCommit,
                onInput: inputDateMaskProps.onInput,
                ref: inputDatePickerRef,
                textAlign: inputDateMaskProps.textAlign,
                todayTimeZone: props.todayTimeZone,
                todayButton: props.todayButton,
                userAssistanceDensity: inputDateMaskProps.userAssistanceDensity,
                value: inputDateMaskProps.value,
                variant: variant,
                weekDisplay: props.weekDisplay
            },
            rootProps: {
                id: props.id,
                // Because we are handling columnSpan here, there is no need to pass the this property down to the
                // Preact InputDatePicker component.
                class: rootClasses,
                style: styleProps.style,
                ref: rootRef
            }
        };
    };
    exports.useInputDatePicker = useInputDatePicker;
    /**
     * Asserts if the props provided are valid.
     * @param props The props provided to the InputDatePicker
     * @throws If any of the props provided has invalid value.
     */
    const assertProps = (props) => {
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(props.value)) {
            throw new Error(`InputDatePicker - value must be a date-only ISO string: ${props.value}`);
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(props.min)) {
            throw new Error(`InputDatePicker - min must be a date-only ISO string: ${props.min}`);
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(props.max)) {
            throw new Error(`InputDatePicker - max must be a date-only ISO string: ${props.max}`);
        }
    };
    /**
     * A custom hook for getting min and max as CalendarDate
     */
    const useMinMax = ({ converter, max, min }) => {
        // convert min and max
        return (0, hooks_1.useMemo)(() => ({
            max: max ? converter.format(max) : undefined,
            min: min ? converter.format(min) : undefined
        }), [converter, max, min]);
    };
});


define('oj-c/input-date-picker/input-date-picker',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_InputDatePicker", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "ojs/ojvcomponent", "preact/compat", "./useInputDatePicker", "css!oj-c/input-date-picker/input-date-picker-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_InputDatePicker_1, UNSAFE_useFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, ojvcomponent_1, compat_1, useInputDatePicker_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputDatePicker = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    /**
     * @classdesc
     * <h3 id="InputDatePickerOverview-section">
     *   JET Input Date Picker Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#InputDatePickerOverview-section"></a>
     * </h3>
     *
     * <p>Description: A JET Input Date Picker allows users to enter or select a single date using a
     * calendar interface.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-input-date-picker label-hint="Date">&lt;/oj-c-input-date-picker></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
    
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required validator is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation is run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property (if available) changes.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>required property can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * The mask placeholder is shown when the field is empty and has focus. The mask placeholder is not configurable.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input field (Not a Segment)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to first segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field segment</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field segment</td>
     *       <td><kbd>Double Tap</kbd></td>
     *       <td>If the date is complete, selects the entire date. Hitting backspace clears it.</td>
     *     </tr>
     *      <tr>
     *       <td>Calendar icon (When the date picker is not open)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Opens the Date Picker and moves the focus to the first focusable element in the DatePicker.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar icon (When the date picker is open)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Closes the Date Picker.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Sets focus to first segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>Ctrl + A</kbd> or <kbd>Command + A</kbd></td>
     *       <td>If the date is complete, selects the entire date. Double clicking on the field also selects the date.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field with date selected</td>
     *       <td><kbd>Backspace/Delete</kbd></td>
     *       <td>Backspace or delete key clears the date. The mask placeholders will be shown again and focus will be on the first segment.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field segment</td>
     *       <td><kbd>Backspace/Delete</kbd></td>
     *       <td>Clears the date segment. Focus remains on the date segment.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field segment</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Moves focus to the segment on the right. If focus is on the rightmost segment, the focus does not move.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field segment</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Moves focus to the segment on the left. If focus is on the leftmost segment, the focus does not move.</td>
     *     </tr>
     *    <tr>
     *       <td>Input field segment</td>
     *       <td><kbd>UpArrow/DownArrow</kbd></td>
     *       <td>Increments or decrements the number by one in the segment. If there is no number in the segment, it initializes it to the current date.</td>
     *     </tr>
     *    <tr>
     *       <td>Input field segment</td>
     *       <td><kbd>End</kbd></td>
     *       <td>Increments the segment to the maximum number for the segment. For example, if on the month segment, this will set the number to 12. If on the year segment, this will set the number to 2100.</td>
     *     </tr>
     *    <tr>
     *       <td>Input field segment</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>Decrements the segment to the minimum number for the segment. For example, if on the month segment, this will set the number to 1. If on the year segment, this will set the number to 1900.</td>
     *     </tr>
     *    <tr>
     *       <td>Input field segment</td>
     *       <td><kbd>Page Up/Page Down</kbd></td>
     *       <td>Increments or decrements the number by two in the month segment, by seven in the day segment, or by five in the year segment. If there is no number in the segment, it initializes it to the current date.</td>
     *     </tr>
     *     <tr>
     *       <td>Date Picker</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Closes the date picker.</td>
     *     </tr>
     *     <tr>
     *       <td>Date Picker</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td>
     *         Moves the focus to next element in the date picker sequence. Only one element in the calendar grid is in the Tab sequence
     *         (current day/month/year or selected day/month/year depending on scenario). If focus is on the last tabbable element
     *         inside the date picker, moves focus to the first tabbable element inside the date picker.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Date Picker</td>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>
     *         Moves the focus to the previous tabbable element inside the date picker. If focus is on the first tabbable element
     *         inside the date picker, moves focus to the last tabbable element inside the date picker.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Date Picker</td>
     *       <td><kbd>Enter/Space</kbd></td>
     *       <td>
     *         Selects the currently focused day or activates the button currently focused.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>PageUp</kbd></td>
     *       <td>Changes the calendar grid to the previous month. Moves focus to the closest day in the previous month.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>PageDown</kbd></td>
     *       <td>Changes the calendar grid to the next month. Moves focus to the closest day in the next month.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>Shift + PageUp</kbd></td>
     *       <td>Changes the calendar grid to the previous year. Moves focus to the closest day of the same month in the previous year.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>Shift + PageDown</kbd></td>
     *       <td>Changes the calendar grid to the next year. Moves focus to the closest day of the same month in the next year.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>Ctrl + Alt + T or Ctrl + Option + T</kbd></td>
     *      <td>Changes the calendar grid to the year and month that contains today's date. Moves focus to Today.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>Go to the first day of the current month.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>End</kbd></td>
     *       <td>Go to the last day of the current month.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>ArrowLeft</kbd></td>
     *       <td>Moves focus to the previous day. In RTL, this will move focus to the next day.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>ArrowRight</kbd></td>
     *       <td>Moves focus to the next day. In RTL, this will move focus to the previous day.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>ArrowUp</kbd></td>
     *       <td>Moves focus to the same day of the previous week.</td>
     *     </tr>
     *     <tr>
     *       <td>Calendar Grid</td>
     *       <td><kbd>ArrowDown</kbd></td>
     *       <td>Moves focus to the same day of the next week.</td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>Enter/Space</kbd></td>
     *       <td>
     *         Selects the currently focused month and returns to the date picker, refreshing the display to show the selected month.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Moves focus to four months back from the current focused month.</td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Moves focus to four months ahead from the current focused month.</td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Moves focus to the next month. In RTL, this will move focus to the previous month.</td>
     *     </tr>
     *     <tr>
     *       <td>Months Grid</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Moves focus to the previous month. In RTL, this will move focus to the next month.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>Enter/Space</kbd></td>
     *       <td>
     *         Selects the currently focused year and returns to the date picker, refreshing the display to show the selected month.
     *       </td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>PageUp</kbd></td>
     *       <td>Changes the year grid to the previous decade. The focus remains in the same location with respect to the current decade.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>PageDown</kbd></td>
     *       <td>Changes the year grid to the next decade. The focus remains in the same location with respect to the current decade.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Moves focus to four years back from the current focused year. If that year is not in the year grid, go back 1 decade.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Moves focus to four years ahead from the current focused year. If that year is not in the year grid, go ahead 1 decade.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Moves focus to the next year. In RTL, this will move focus to the previous year.</td>
     *     </tr>
     *     <tr>
     *       <td>Years Grid</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Moves focus to the previous year. In RTL, this will move focus to the next year.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata displayName "InputDatePicker"
     * @ojmetadata description "An input date picker allows users to enter or select a single date using a calendar interface."
     * @ojmetadata help "oj-c.InputDatePicker.html"
     * @ojmetadata main "oj-c/input-date-picker"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "17.1.0",
     *     "value": ["oj-input-date"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/input-date-picker",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-type-date-input"
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "readonly",
     *       "required"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "17.0.0"
     */
    function InputDatePickerImpl({ columnSpan = 1, daysOutsideMonth = 'hidden', disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, messagesCustom = messagesCustomDefault, monthAndYearPicker = 'on', readonlyUserAssistanceShown = 'none', required = false, todayButton = 'visible', validators = validatorsDefault, value = null, weekDisplay = 'none', ...otherProps }, ref) {
        const { formContextValue, inputDatePickerProps, rootProps } = (0, useInputDatePicker_1.useInputDatePicker)({
            columnSpan,
            daysOutsideMonth,
            disabled,
            displayOptions,
            help,
            helpHints,
            messagesCustom,
            monthAndYearPicker,
            readonlyUserAssistanceShown,
            required,
            todayButton,
            validators,
            value,
            weekDisplay,
            ...otherProps
        }, ref);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ...rootProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: formContextValue, children: (0, jsx_runtime_1.jsx)(UNSAFE_InputDatePicker_1.InputDatePicker, { ...inputDatePickerProps, columnSpan: columnSpan }) }) }));
    }
    exports.InputDatePicker = (0, ojvcomponent_1.registerCustomElement)('oj-c-input-date-picker', (0, compat_1.forwardRef)(InputDatePickerImpl), "InputDatePicker", { "properties": { "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "dateRangeOverflowMessageDetail": { "type": "function" }, "dateRangeUnderflowMessageDetail": { "type": "function" }, "dateRestrictionMessageDetail": { "type": "function" }, "dayFormatter": { "type": "function" }, "daysOutsideMonth": { "type": "string", "enumValues": ["hidden", "selectable"] }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "max": { "type": "string|null" }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "min": { "type": "string|null" }, "monthAndYearPicker": { "type": "string", "enumValues": ["off", "on"] }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "todayTimeZone": { "type": "string" }, "todayButton": { "type": "string", "enumValues": ["hidden", "visible"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "string|null", "writeback": true }, "weekDisplay": { "type": "string", "enumValues": ["number", "none"] }, "width": { "type": "number|string" }, "rawValue": { "type": "object", "properties": { "year": { "type": "number" }, "month": { "type": "number" }, "day": { "type": "number" } }, "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "columnSpan": 1, "daysOutsideMonth": "hidden", "disabled": false, "displayOptions": { "messages": "display", "validatorHint": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "messagesCustom": [], "monthAndYearPicker": "on", "readonlyUserAssistanceShown": "none", "required": false, "todayButton": "visible", "validators": [], "value": null, "weekDisplay": "none" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/input-date-picker',["require", "exports", "oj-c/input-date-picker/input-date-picker"], function (require, exports, input_date_picker_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputDatePicker = void 0;
    Object.defineProperty(exports, "InputDatePicker", { enumerable: true, get: function () { return input_date_picker_1.InputDatePicker; } });
});

define('oj-c/input-date-text/useImplicitDateConverter',["require", "exports", "preact/hooks", "ojs/ojconverter-localdate"], function (require, exports, hooks_1, ojconverter_localdate_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useImplicitDateConverter = useImplicitDateConverter;
    /**
     * A custom hook the creates an implicit date converter if the converter was not passed in to the component.
     *
     * @param param0 The props for the useImplicitDateConverter hook
     * @returns the converter
     */
    function useImplicitDateConverter({ converter }) {
        // Since user preferences are merged in by the LocalDateConverter's constructor, we need
        // a new converter for each component instance if one hasn't been supplied.
        const implicitConverter = (0, hooks_1.useMemo)(() => {
            return converter ?? new ojconverter_localdate_1.LocalDateConverter({ dateStyle: 'short' });
        }, [converter]);
        return implicitConverter;
    }
});

define('oj-c/input-date-text/useInputDateTextPreact',["require", "exports", "preact/hooks", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "./useImplicitDateConverter", "./useImplicitDateRangeValidator", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators"], function (require, exports, hooks_1, useComponentMessages_1, useImplicitDateConverter_1, useImplicitDateRangeValidator_1, index_1, useDeferredValidators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useInputDateTextPreact = useInputDateTextPreact;
    /**
     * This hook manages state and other related props for the Input Date Text component.
     * Note that InputDateText uses PreactInputText.
     */
    function useInputDateTextPreact({ autocomplete = 'on', autofocus, converter: propConverter, dateRangeOverflowMessageDetail, dateRangeUnderflowMessageDetail, disabled, displayOptions, labelEdge, labelHint, labelStartWidth, max, messagesCustom, min, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, textAlign, userAssistanceDensity, validators, value: propValue, onMessagesCustomChanged, onRawValueChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        // Treat null as undefined for the min/max options.
        const minTreatNull = (0, index_1.treatNull)(min);
        const maxTreatNull = (0, index_1.treatNull)(max);
        // If no converter, use an instance of LocalDateConverter which uses the stricter, newer format/parse type that doesn't allow null.
        const converter = (0, useImplicitDateConverter_1.useImplicitDateConverter)({
            converter: propConverter
        });
        const implicitComponentValidator = (0, useImplicitDateRangeValidator_1.useImplicitDateRangeValidator)({
            formatObj: converter,
            dateRangeOverflowMessageDetail,
            dateRangeUnderflowMessageDetail,
            max: maxTreatNull,
            min: minTreatNull
        });
        const combinedValidators = (0, hooks_1.useMemo)(() => {
            const v1 = implicitComponentValidator ? [implicitComponentValidator] : [];
            const v2 = validators ? validators : [];
            return [...v1, ...v2];
        }, [implicitComponentValidator, validators]);
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const { methods, textFieldProps: evTextFieldProps, value } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            converter,
            defaultDisplayValue: '',
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onRawValueChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            validators: combinedValidators,
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        const hasNoValue = value === null || (typeof value === 'string' && value === '');
        return {
            methods,
            // Certain props will have null as default values, but we need them to be
            // undefined in the preact component.
            inputTextProps: {
                autoComplete: autocomplete,
                autoFocus: autofocus,
                isDisabled: disabled,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                label: labelHint,
                labelEdge,
                labelStartWidth,
                messages,
                textAlign,
                userAssistanceDensity,
                ...textFieldProps
            }
        };
    }
});


define('oj-c/input-date-text/input-date-text',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_InputText", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojcontext", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "./useInputDateTextPreact", "@oracle/oraclejet-preact/UNSAFE_IntlDateTime", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "css!oj-c/input-date-text/input-date-text-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_InputText_1, useAssistiveText_1, Context, ojvcomponent_1, compat_1, hooks_1, useInputDateTextPreact_1, UNSAFE_IntlDateTime_1, UNSAFE_classNames_1, FormControl_1, Layout_1, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputDateText = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display',
        converterHint: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    /**
     * @classdesc
     * <h3 id="inputDateTextOverview-section">
     *   JET InputDateText Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputDateTextOverview-section"></a>
     * </h3>
     *
     * <p>Description: A JET InputDateText provides basic support for manual entry of dates in an input field.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-input-date-text value="2023-03-20" label-hint="Date">&lt;/oj-c-input-date-text></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
    
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>The required and placeholder properties also can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * Placeholder is shown when the field is empty and has focus.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to input. Show user assistance text.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the input. Show user assistance text.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     * <p>
     * The placeholder text is not read reliably by the screen reader. For accessibility reasons,
     * you need to associate the text to its JET form component using aria-describedby.
     * </p>
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     * @ojmetadata displayName "InputDateText"
     * @ojmetadata description "An input date text allows the user to enter a date value."
     * @ojmetadata help "oj-c.InputDateText.html"
     * @ojmetadata main "oj-c/input-date-text"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/input-date-text",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-date",
     *     "uxSpecs": [
     *       "input-date-text"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "readonly",
     *       "required"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "15.0.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    const InputDateTextImpl = ({ autocomplete = 'on', columnSpan = 1, containerReadonly: propContainerReadonly, converter = null, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, labelWrapping: propLabelWrapping, messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, validators = validatorsDefault, value = null, ...otherProps }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const inputDateTextRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc = 'InputDateText: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-input-date-text id=${id} is ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        const { inputTextProps, methods } = (0, useInputDateTextPreact_1.useInputDateTextPreact)({
            autocomplete,
            converter,
            disabled,
            displayOptions,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            validators,
            value,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => inputDateTextRef.current?.blur(),
            focus: () => inputDateTextRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            converter,
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: inputTextProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(value)) {
            throw new Error('value must be a date-only ISO string');
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(otherProps.min)) {
            throw new Error('min must be a date-only ISO string');
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isDateOnlyIsoString(otherProps.max)) {
            throw new Error('max must be a date-only ISO string');
        }
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? otherProps.maxWidth : 'none',
            width: otherProps.width === 'md' || otherProps.width === 'sm' ? otherProps.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = otherProps.width === 'md' || otherProps.width === 'sm' ? undefined : otherProps.width;
        const maxWidthStyle = otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? undefined : otherProps.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_InputText_1.InputText, { ref: inputDateTextRef, ...assistiveTextProps, ...inputTextProps, columnSpan: columnSpan, variant: variant }) }) }));
    };
    exports.InputDateText = (0, ojvcomponent_1.registerCustomElement)('oj-c-input-date-text', (0, compat_1.forwardRef)(InputDateTextImpl), "InputDateText", { "properties": { "autocomplete": { "type": "string" }, "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "converter": { "type": "object|null", "properties": { "format": { "type": "function" }, "parse": { "type": "function" } } }, "dateRangeOverflowMessageDetail": { "type": "string" }, "dateRangeUnderflowMessageDetail": { "type": "string" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "converterHint": { "type": "string", "enumValues": ["none", "display"] }, "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "max": { "type": "string|null" }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "min": { "type": "string|null" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "string|null", "writeback": true }, "width": { "type": "number|string" }, "rawValue": { "type": "string", "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id", "autofocus"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "autocomplete": "on", "columnSpan": 1, "converter": null, "disabled": false, "displayOptions": { "messages": "display", "converterHint": "display", "validatorHint": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "validators": [], "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/input-date-text',["require", "exports", "oj-c/input-date-text/input-date-text"], function (require, exports, input_date_text_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputDateText = void 0;
    Object.defineProperty(exports, "InputDateText", { enumerable: true, get: function () { return input_date_text_1.InputDateText; } });
});

define('oj-c/input-month-mask/CalendarMonthConverter',["require", "exports", "@oracle/oraclejet-preact/utils/UNSAFE_calendarDateUtils", "ojs/ojconfig"], function (require, exports, UNSAFE_calendarDateUtils_1, ojconfig_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CalendarMonthConverter = void 0;
    // A converter for the oj-c-input-month-mask component. It throws an error on parse if it is incomplete. It must have year and month.
    class CalendarMonthConverter {
        constructor(options) {
            this.locale = options?.locale ?? (0, ojconfig_1.getLocale)();
            this.calendarMonthConverter_parseErrorFn = options?.calendarMonthConverter_parseErrorFn;
            this.customMask = options?.customMask;
        }
        format(value) {
            // Check if the value is a complete object
            if (!(0, UNSAFE_calendarDateUtils_1.isCompleteCalendarMonth)(value)) {
                throw new Error('value must have year and month');
            }
            return value;
        }
        // throws an error if the input does not have both year and month.
        parse(input) {
            // if calendar date is not complete, throw an error which we will catch and format into a better error.
            if (input !== undefined && !(0, UNSAFE_calendarDateUtils_1.isCompleteCalendarMonth)(input)) {
                const now = new Date();
                // getFullYear returns the year for the date according to local time.
                const currentYear = now.getFullYear();
                const formattedDateExample = (0, UNSAFE_calendarDateUtils_1.formatIsoDateStrAsExample)(this.locale, `${currentYear}-11-29`, this.customMask, 'month');
                const errorStr = this.calendarMonthConverter_parseErrorFn &&
                    this.calendarMonthConverter_parseErrorFn({
                        dateExample: formattedDateExample
                    });
                throw new Error(errorStr ?? 'parse failed');
            }
            // At this point we know that the input has year and month, but typescript does not know, so tell it.
            return input;
        }
    }
    exports.CalendarMonthConverter = CalendarMonthConverter;
});

define('oj-c/input-month-mask/CalendarMonthRangeValidator',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CalendarMonthRangeValidator = void 0;
    // This class is used to validate that a value falls within
    // the range specified by min and max. If it doesn't, an Error is thrown with a message detail.
    class CalendarMonthRangeValidator {
        constructor(options) {
            if (options.min &&
                options.max &&
                CalendarMonthRangeValidator._compareCalendarMonths(options.min, options.max) > 0) {
                // this is an app developer error, so it doesn't need to be translated.
                throw new Error('min must be less than max');
            }
            this.defaultRangeOverflowMessageDetailFn = options.defaultRangeOverflowMessageDetailFn;
            this.defaultRangeUnderflowMessageDetailFn = options.defaultRangeUnderflowMessageDetailFn;
            this.min = options.min;
            this.max = options.max;
            this.dateRangeOverflowMessageDetail = options.dateRangeOverflowMessageDetail;
            this.dateRangeUnderflowMessageDetail = options.dateRangeUnderflowMessageDetail;
            this.formatObj = options.formatObj;
        }
        // Validates the minimum + maximum conditions. If the value is null, just return.
        validate(value) {
            const messageDetailRangeOverflow = this.dateRangeOverflowMessageDetail;
            const messageDetailRangeUnderflow = this.dateRangeUnderflowMessageDetail;
            const min = this.min;
            const max = this.max;
            if (value === null) {
                return;
            }
            const valStr = value ? this.formatObj.format(value) : value;
            if (max && CalendarMonthRangeValidator._compareCalendarMonths(value, max) > 0) {
                const maxStr = this.formatObj.format(max);
                const detail = messageDetailRangeOverflow
                    ? messageDetailRangeOverflow({ max: maxStr, value: valStr })
                    : this.defaultRangeOverflowMessageDetailFn({ max: maxStr });
                throw new Error(detail);
            }
            if (min && CalendarMonthRangeValidator._compareCalendarMonths(value, min) < 0) {
                const minStr = this.formatObj.format(min);
                const detail = messageDetailRangeUnderflow
                    ? messageDetailRangeUnderflow({ min: minStr, value: valStr })
                    : this.defaultRangeUnderflowMessageDetailFn({ min: minStr });
                throw new Error(detail);
            }
            return value;
        }
        /**
         * Compares two dates of type CalendarMonthRequired.
         * @param {CalendarMonthRequired} val1 first month/year value
         * @param {CalendarMonthRequired} val2 second month/year value
         * @return {number} 0 if the same month and year. 1 if val1 > val2. -1 if val1 < val2.
         * @private
         * @static
         */
        static _compareCalendarMonths(val1, val2) {
            if (val1.year === val2.year && val1.month === val2.month) {
                return 0;
            }
            if (val1.year === val2.year) {
                return val1.month > val2.month ? 1 : -1;
            }
            return val1.year > val2.year ? 1 : -1;
        }
    }
    exports.CalendarMonthRangeValidator = CalendarMonthRangeValidator;
});

define('oj-c/input-month-mask/useImplicitCalendarMonthRangeValidator',["require", "exports", "preact/hooks", "./CalendarMonthRangeValidator", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle"], function (require, exports, hooks_1, CalendarMonthRangeValidator_1, UNSAFE_useTranslationBundle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useImplicitCalendarMonthRangeValidator = useImplicitCalendarMonthRangeValidator;
    /**
     * Custom hook that creates an implicit CalendarMonthRangeValidator for oj-c-input-month-mask if there is a min or max property.
     * Otherwise it will return null.
     *
     * @returns A CalendarMonthRangeValidator instance or null
     */
    function useImplicitCalendarMonthRangeValidator({ formatObj, dateRangeOverflowMessageDetail, dateRangeUnderflowMessageDetail, max, min }) {
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        // get the default message detail from the translation bundle.
        const defaultRangeOverflowMessageDetailFn = translations.inputMonthMask_dateRangeOverflowMessageDetail;
        const defaultRangeUnderflowMessageDetailFn = translations.inputMonthMask_dateRangeUnderflowMessageDetail;
        const calendarMonthRangeValidator = (0, hooks_1.useMemo)(() => {
            if (min !== undefined || max !== undefined) {
                return new CalendarMonthRangeValidator_1.CalendarMonthRangeValidator({
                    defaultRangeOverflowMessageDetailFn,
                    defaultRangeUnderflowMessageDetailFn,
                    formatObj,
                    max,
                    min,
                    dateRangeOverflowMessageDetail,
                    dateRangeUnderflowMessageDetail
                });
            }
            return null;
        }, [
            formatObj,
            dateRangeOverflowMessageDetail,
            dateRangeUnderflowMessageDetail,
            defaultRangeOverflowMessageDetailFn,
            defaultRangeUnderflowMessageDetailFn,
            min,
            max
        ]);
        return calendarMonthRangeValidator;
    }
});

define('oj-c/input-month-mask/useInputMonthMaskPreact',["require", "exports", "./CalendarMonthConverter", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "ojs/ojconverter-preferences", "@oracle/oraclejet-preact/utils/UNSAFE_calendarDateUtils", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "./useImplicitCalendarMonthRangeValidator", "ojs/ojconfig", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators"], function (require, exports, CalendarMonthConverter_1, hooks_1, UNSAFE_useTranslationBundle_1, ojconverter_preferences_1, UNSAFE_calendarDateUtils_1, useComponentMessages_1, useImplicitCalendarMonthRangeValidator_1, ojconfig_1, index_1, useDeferredValidators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useInputMonthMaskPreact = useInputMonthMaskPreact;
    /**
     * This hook manages state and other related props that we need InputMonthMask component.
     * In Preact we have an InputDateMask with granularity day|month, and on the corepack side we have oj-c-input-date-mask and oj-c-input-month-mask.
     */
    function useInputMonthMaskPreact({ dateRangeOverflowMessageDetail, dateRangeUnderflowMessageDetail, disabled, displayOptions, labelEdge, labelHint, labelStartWidth, max, messagesCustom, min, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, textAlign, userAssistanceDensity, validators, value: propValue, onMessagesCustomChanged, onRawValueChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        // Treat null as undefined for the min/max options.
        const minTreatNull = (0, index_1.treatNull)(min);
        const maxTreatNull = (0, index_1.treatNull)(max);
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const calendarMonthConverter_parseErrorFn = translations.calendarMonthConverter_parseError;
        // User preferences are set before the application runs, and never after that.
        const masksFromUserPref = (0, hooks_1.useMemo)(() => {
            return getMasksFromDatePatternPreferences();
        }, []);
        const implicitConverter = (0, hooks_1.useMemo)(() => {
            return new CalendarMonthConverter_1.CalendarMonthConverter({
                calendarMonthConverter_parseErrorFn,
                customMask: masksFromUserPref
            });
        }, [calendarMonthConverter_parseErrorFn, masksFromUserPref]);
        // returns a formatted date to use in the example.
        // Memoize this because formatObj in useImplicitCalendarMonthRangeValidator is a dependency. If we do not memoize,
        // then our code would create a new converter on every keystroke the user types.
        const exampleFormatter = (0, hooks_1.useMemo)(() => {
            return {
                format: (value) => {
                    // Format based on masks from user pref, if any, or the locale.
                    return (0, UNSAFE_calendarDateUtils_1.formatCalendarMonthRequiredAsExample)((0, ojconfig_1.getLocale)(), value, masksFromUserPref);
                }
            };
        }, [masksFromUserPref]);
        const implicitComponentValidator = (0, useImplicitCalendarMonthRangeValidator_1.useImplicitCalendarMonthRangeValidator)({
            formatObj: exampleFormatter,
            dateRangeOverflowMessageDetail,
            dateRangeUnderflowMessageDetail,
            max: maxTreatNull,
            min: minTreatNull
        });
        const combinedValidators = (0, hooks_1.useMemo)(() => {
            const v1 = implicitComponentValidator ? [implicitComponentValidator] : [];
            const v2 = validators ? validators : [];
            return [...v1, ...v2];
        }, [implicitComponentValidator, validators]);
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const { methods, textFieldProps: evTextFieldProps, value } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            converter: implicitConverter,
            defaultDisplayValue: undefined,
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onRawValueChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            validators: combinedValidators,
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        // this is used to determine isRequiredShown
        const hasNoValue = value === undefined || !isPartialDate(textFieldProps.value);
        return {
            methods,
            inputMonthMaskProps: {
                isDisabled: disabled,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                label: labelHint,
                labelEdge,
                labelStartWidth,
                masks: masksFromUserPref,
                messages,
                textAlign,
                userAssistanceDensity,
                ...textFieldProps
            }
        };
    }
    // A better name for this function is isAtLeastAPartialDate
    const isPartialDate = (value) => {
        if (value === undefined)
            return false;
        return value.year !== undefined || value.month !== undefined;
    };
    // get the MonthDatePlaceholders array. If it is not undefined, we will set this on the masks property of InputDateMask.
    const getMasksFromDatePatternPreferences = () => {
        // get the user preference pattern for date, and from that we get order of year, month and store it in
        // masks: MonthYearPlaceholders;
        // masks overrides the locale specific order of the individual date segments as well as the locale specific separator.
        // we use masks when we show a date in an error message and we pass it to the PreactInputDateMask.
        // this way the order of the month and year segments in the field matches the order of any error messages, like
        // 'Try again using a date like this: 11/2023'.
        const prefs = (0, ojconverter_preferences_1.getDateTimePreferences)();
        const pattern = prefs.dateStyle?.short?.pattern;
        // return undefined if no pattern or if pattern contains MMM/mmm
        // If the pattern has MMM in it, then it must be in their language and use their locale since MMM is an abbreviation for the month not a number.
        // For example, it can be Oct for October in English.
        // Therefore, if the pattern has MMM in it, we assume that they are using locale and we will not set a custom masks.
        // They will get the order of month, day and year and the placeholder based on their locale.
        if (!pattern || pattern.toUpperCase().includes('MMM')) {
            return undefined;
        }
        const datePlaceholders = (0, UNSAFE_calendarDateUtils_1.getDatePlaceholdersFromPattern)(pattern);
        const monthDatePlaceholder = (0, UNSAFE_calendarDateUtils_1.getMonthYearPlaceholdersFromDatePlaceholders)(datePlaceholders);
        return monthDatePlaceholder;
    };
});


define('oj-c/input-month-mask/input-month-mask',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_InputDateMask", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojcontext", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "./useInputMonthMaskPreact", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "@oracle/oraclejet-preact/utils/UNSAFE_calendarDateUtils", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "css!oj-c/input-month-mask/input-month-mask-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_InputDateMask_1, useAssistiveText_1, Context, ojvcomponent_1, compat_1, hooks_1, useInputMonthMaskPreact_1, UNSAFE_classNames_1, FormControl_1, Layout_1, UNSAFE_calendarDateUtils_1, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputMonthMask = void 0;
    // Define constants for object literal default values and [] to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    /**
     * @classdesc
     * <h3 id="InputMonthMaskOverview-section">
     *   JET Input Month Mask Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#InputMonthMaskOverview-section"></a>
     * </h3>
     *
     * <p>Description: A JET Input Month Mask allows a user to individually edit, step, or spin the
     * values of the month and year fields of a calendar month and year.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-input-month-mask label-hint="Expiration Date">&lt;/oj-c-input-month-mask></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
    
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present (even if it the component's implicit converter), the UI value is first converted (i.e., parsed).
     * If there is a parse error then the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required validator is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation is run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property (if available) changes.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>required property can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * The mask placeholder is shown when the field is empty and has focus. The mask placeholder is not configurable.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Field (Not a Segment)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to first segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Segment</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Segment</td>
     *       <td><kbd>Double Tap</kbd></td>
     *       <td>If the date is complete (both month and year are filled in), selects the entire date. Hitting backspace clears it.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Field</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Sets focus to first segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Field</td>
     *       <td><kbd>Control + A or Command + A</kbd></td>
     *       <td>If the date is complete (both month and year are filled in), selects the entire date. Double clicking on the field also selects the date.</td>
     *     </tr>
     *     <tr>
     *       <td>Field with date selected</td>
     *       <td><kbd>Backspace/Delete</kbd></td>
     *       <td>If the date is complete (both month and year are filled in), double click on the field selects the entire date. Backspace or delete key clears the date. The mask placeholders will be shown again and focus will be on the first segment.</td>
     *     </tr>
     *     <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>Backspace/Delete</kbd></td>
     *       <td>Clears the date segment. Focus remains on the date segment.</td>
     *     </tr>
     *     <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Moves focus to the segment on the right. If focus is on the rightmost segment, the focus does not move.</td>
     *     </tr>
     *     <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Moves focus to the segment on the left. If focus is on the leftmost segment, the focus does not move.</td>
     *     </tr>
     *    <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>UpArrow/DownArrow</kbd></td>
     *       <td>Increments or decrements the number by one in the segment. If there is no number in the segment, it initializes it to the current month and year.</td>
     *     </tr>
     *    <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>End</kbd></td>
     *       <td>Increments the segment to the maximum number for the segment. For example, if on the month segment, this will set the number to 12. If on the year segment, this will set the number to 2100.</td>
     *     </tr>
     *    <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>Decrements the segment to the minimum number for the segment. For example, if on the month segment, this will set the number to 1. If on the year segment, this will set the number to 1900.</td>
     *     </tr>
     *    <tr>
     *       <td>Date Segment</td>
     *       <td><kbd>Page Up/Page Down</kbd></td>
     *       <td>Increments or decrements the number by two in the month segment or by five in the year segment. If there is no number in the segment, it initializes it to the current month and year.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     * @ojmetadata displayName "InputMonthMask"
     * @ojmetadata description "An input month mask field allows a user to individually edit, step, or spin the values of the month and year fields."
     * @ojmetadata help "oj-c.InputMonthMask.html"
     * @ojmetadata main "oj-c/input-month-mask"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/input-month-mask",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-date",
     *     "uxSpecs": [
     *       "input-month-mask"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "readonly",
     *       "required"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "16.1.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    const InputMonthMaskImpl = ({ columnSpan = 1, containerReadonly: propContainerReadonly, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, labelWrapping: propLabelWrapping, messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, validators = validatorsDefault, value = null, ...otherProps }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const inputMonthMaskRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((description = 'InputMonthMask: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current).getBusyContext().addBusyState({ description })
                : () => { }; // if the component is not mounted return Noop
        }, []);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        const { inputMonthMaskProps, methods } = (0, useInputMonthMaskPreact_1.useInputMonthMaskPreact)({
            disabled,
            displayOptions,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            validators,
            value,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => inputMonthMaskRef.current?.blur(),
            focus: () => inputMonthMaskRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: inputMonthMaskProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        if (!(0, UNSAFE_calendarDateUtils_1.isValidCalendarMonthRequired)(value)) {
            throw new Error('If the value property is defined, it must be an object with year and month defined.');
        }
        if (!(0, UNSAFE_calendarDateUtils_1.isValidCalendarMonthRequired)(otherProps.min)) {
            throw new Error('If the min property is defined, it must be an object with year and month defined.');
        }
        if (!(0, UNSAFE_calendarDateUtils_1.isValidCalendarMonthRequired)(otherProps.max)) {
            throw new Error('If the max property is defined, it must be an object with year and month defined.');
        }
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? otherProps.maxWidth : 'none',
            width: otherProps.width === 'md' || otherProps.width === 'sm' ? otherProps.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = otherProps.width === 'md' || otherProps.width === 'sm' ? undefined : otherProps.width;
        const maxWidthStyle = otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? undefined : otherProps.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return (
        // Even though we are handling the styling here, we pass the columnSpan property down to the
        // Preact component because it may be needed for other purposes, like calculating the start
        // label width.
        (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: otherProps.id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_InputDateMask_1.InputDateMask, { ref: inputMonthMaskRef, ...assistiveTextProps, ...inputMonthMaskProps, columnSpan: columnSpan, variant: variant, granularity: "month" }) }) }));
    };
    exports.InputMonthMask = (0, ojvcomponent_1.registerCustomElement)('oj-c-input-month-mask', (0, compat_1.forwardRef)(InputMonthMaskImpl), "InputMonthMask", { "properties": { "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "dateRangeOverflowMessageDetail": { "type": "function" }, "dateRangeUnderflowMessageDetail": { "type": "function" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "max": { "type": "object|null", "properties": { "year": { "type": "number" }, "month": { "type": "number" } } }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "min": { "type": "object|null", "properties": { "year": { "type": "number" }, "month": { "type": "number" } } }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "object|null", "properties": { "year": { "type": "number" }, "month": { "type": "number" } }, "writeback": true }, "width": { "type": "number|string" }, "rawValue": { "type": "object", "properties": { "year": { "type": "number" }, "month": { "type": "number" } }, "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "columnSpan": 1, "disabled": false, "displayOptions": { "messages": "display", "validatorHint": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "validators": [], "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/input-month-mask',["require", "exports", "oj-c/input-month-mask/input-month-mask"], function (require, exports, input_month_mask_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputMonthMask = void 0;
    Object.defineProperty(exports, "InputMonthMask", { enumerable: true, get: function () { return input_month_mask_1.InputMonthMask; } });
});

define('oj-c/input-number/useImplicitNumberConverter',["require", "exports", "ojs/ojconverter-nativenumber", "preact/hooks"], function (require, exports, ojconverter_nativenumber_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useImplicitNumberConverter = useImplicitNumberConverter;
    /**
     * A custom hook the creates an implicit number converter if the converter was not passed in to the component.
     *
     * @param param0 The props for the useImplicitNumberConverter hook
     * @returns the converter
     */
    function useImplicitNumberConverter({ converter }) {
        const implicitConverter = (0, hooks_1.useMemo)(() => {
            return converter ?? new ojconverter_nativenumber_1.NumberConverter();
        }, [converter]);
        return implicitConverter;
    }
});

define('oj-c/input-number/useImplicitNumberRangeValidator',["require", "exports", "preact/hooks", "ojs/ojvalidator-numberrange"], function (require, exports, hooks_1, NumberRangeValidator) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useImplicitNumberRangeValidator = useImplicitNumberRangeValidator;
    /**
     * A custom hook the creates an implicit new NumberRangeValidator for oj-c-input-number if there is a min or max property.
     * Otherwise it will return null.
     *
     * @param param0 The props for the export function useImplicitNumberRangeValidator({
     hook
     * @returns A NumberRangeValidator instance or null
     */
    function useImplicitNumberRangeValidator({ converter, max, min, numberRangeExactMessageDetail, numberRangeOverflowMessageDetail, numberRangeUnderflowMessageDetail }) {
        const numberRangeValidator = (0, hooks_1.useMemo)(() => {
            if (min !== undefined || max !== undefined) {
                return new NumberRangeValidator({
                    converter,
                    max,
                    min,
                    messageDetail: {
                        exact: numberRangeExactMessageDetail,
                        rangeOverflow: numberRangeOverflowMessageDetail,
                        rangeUnderflow: numberRangeUnderflowMessageDetail
                    }
                });
            }
            return null;
        }, [
            converter,
            min,
            max,
            numberRangeExactMessageDetail,
            numberRangeOverflowMessageDetail,
            numberRangeUnderflowMessageDetail
        ]);
        return numberRangeValidator;
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/input-number/stepBasisUtils',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.determineSteppedValue = determineSteppedValue;
    /**
     * Adjusts the value to be "valid".
     * The logic follows that of HTML-5's input number.
     * http://www.w3.org/TR/html5/forms.html#dom-input-stepup
     * A valid value is one that is a multiple of
     * step starting at stepBase, where stepBase is min (if present),
     * else initial value (if present),
     * else (if type == number) 0
     * If max is not a valid value, stepUp/stepDown will never go to max. It
     * will go to the calculated valid max (one that is the largest value
     * that is an integral multiple of the step, and that is less than or equal
     * to the maximum.
     * @param {number} step - the step you want to adjust the value by. Negative values mean we are decreasing the number.
     * @param {number} stepOpt - the step option which is a positive number or 0. If it is negative, it will be abs(stepOpt)
     * @param {number} currentParsedValue - the current parsed value
     * @param {number} initialValue - the value when the component was created. This could be undefined or null in big jet. TODO: Can I make it 0?
     * @param {number} maxOpt - the max option
     * @param {number} minOpt - the min option
     * @returns {number} - the new value after it has been adjusted
     */
    function determineSteppedValue(step, stepOpt, currentParsedValue, initialValue, maxOpt, minOpt) {
        const precision = _precision(stepOpt, initialValue, minOpt);
        if (precision > 0) {
            const power = Math.pow(10, precision);
            // if minOpt, maxOpt, stepOpt are undefined, keep them that way
            // when we adjust the values to make them decimals, they should be whole numbers.
            // javascript sometimes gives them fractions (
            // e.g., 10000000.45*100=1000000044.9999999), so everywhere here we multiply
            // by power, round the value to make it a whole number.
            const minOptPower = minOpt !== undefined ? Math.round(minOpt * power) : minOpt;
            const maxOptPower = maxOpt != null ? Math.round(maxOpt * power) : maxOpt;
            const stepOptPower = Math.round(stepOpt * power);
            const adjustValuePower = _adjustValueForZeroPrecision(Math.round(step * power), stepOptPower, Math.round(currentParsedValue * power), initialValue !== undefined && initialValue !== null
                ? Math.round(initialValue * power)
                : initialValue, maxOptPower, minOptPower);
            return adjustValuePower / power;
        }
        return _adjustValueForZeroPrecision(step, stepOpt, currentParsedValue, initialValue, maxOpt, minOpt);
    }
    function _adjustValueForZeroPrecision(step, stepOpt, currentParsedValue, initialValue, maxOpt, minOpt) {
        // make sure we're at a valid step when we step up or down.
        // - find out where we are relative to the base.
        // follow these rules. use min, else use initial value, else use 0.
        // https://www.w3.org/TR/html5/forms.html#concept-input-min-zero
        let stepBase = minOpt != null ? minOpt : initialValue;
        if (stepBase === null || stepBase === undefined) {
            stepBase = 0;
        }
        // From http://www.w3.org/TR/html5/forms.html#dom-input-stepup:
        // If value subtracted from the step base is not an integral multiple
        // of the step, then set value to the nearest value that, when subtracted
        // from the step base, is an integral multiple of the allowed value step,
        // and that is less than value if the method invoked was stepDown() and
        // more than value if the method invoked was stepUp().
        // is value-stepBase an integral multiple of step?
        try {
            currentParsedValue = parseFloat(currentParsedValue.toFixed(0));
        }
        catch (e) {
            if (e instanceof TypeError) {
                // I've only seen this fail if they set a null converter.
                // Logger.warn("inputNumber's value after conversion is not a number. \n" +
                //                'The converter must convert the value to a Number. coercing using +');
                currentParsedValue = +currentParsedValue; // coerce
            }
        }
        let aboveMin = currentParsedValue - stepBase;
        let rounded = Math.round(aboveMin / stepOpt) * stepOpt;
        rounded = parseFloat(rounded.toFixed(0));
        const multiple = rounded === aboveMin;
        let newValue;
        if (!multiple) {
            if (step < 0) {
                aboveMin = Math.ceil(aboveMin / stepOpt) * stepOpt;
            }
            else {
                aboveMin = Math.floor(aboveMin / stepOpt) * stepOpt;
            }
            // rounding is based on 0, so adjust back to our base
            newValue = stepBase + aboveMin + step;
        }
        else {
            newValue = currentParsedValue + step;
        }
        // fix precision from bad JS floating point math
        // toFixed returns the newValue with a specific # of digits after the
        // decimal point (this_precision() looks at max of step/min/value's # of
        // digits.
        newValue = parseFloat(newValue.toFixed(0));
        if (minOpt != null && newValue < minOpt) {
            return minOpt;
        }
        if (maxOpt != null && newValue > maxOpt) {
            let validMax = Math.floor((maxOpt - stepBase) / stepOpt) * stepOpt + stepBase;
            // fix precision from bad JS floating point math
            validMax = parseFloat(validMax.toFixed(0));
            return validMax;
        }
        return newValue;
    }
    /**
     */
    function _precision(stepOpt, initialValue, minOpt) {
        let precision = _precisionOf(stepOpt);
        if (minOpt != null) {
            precision = Math.max(precision, _precisionOf(minOpt));
        }
        if (initialValue != null) {
            precision = Math.max(precision, _precisionOf(initialValue));
        }
        return precision;
    }
    /**
     * return the number of digits after the '.'
     * @param {number} num - number from which to calculate the precision
     */
    function _precisionOf(num) {
        const str = num.toString();
        const decimal = str.indexOf('.');
        return decimal === -1 ? 0 : str.length - decimal - 1;
    }
});

define('oj-c/input-number/useNumberInputTextPreact',["require", "exports", "preact/hooks", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "./useImplicitNumberConverter", "./useImplicitNumberRangeValidator", "preact/hooks", "./stepBasisUtils", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "ojs/ojconverter-nativenumber"], function (require, exports, hooks_1, index_1, useComponentMessages_1, useDeferredValidators_1, useImplicitNumberConverter_1, useImplicitNumberRangeValidator_1, hooks_2, stepBasisUtils_1, UNSAFE_useTranslationBundle_1, ojconverter_nativenumber_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useNumberInputTextPreact = useNumberInputTextPreact;
    /**
     * This hook manages state and other related props for the Preact NumberInputText
     * component. It is a very primitive component that takes aria-valuenow, aria-valuetext, aria-valuemin, aria-valuemax,
     * and whether or not the up/down buttons are shown and disabled, etc.
     */
    function useNumberInputTextPreact({ autocomplete = 'on', // TODO: Should we make this off in oj-c comps?
    autofocus, converter: propConverter, disabled, displayOptions, inputPrefix, inputSuffix, labelEdge, labelHint, labelStartWidth, max, messagesCustom, min, numberRangeExactMessageDetail, numberRangeOverflowMessageDetail, numberRangeUnderflowMessageDetail, placeholder, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, step, stepperVariant, textAlign, userAssistanceDensity, validators, value: propValue, virtualKeyboard, onMessagesCustomChanged, onRawValueChanged, onTransientValueChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        // Treat null as undefined for the min/max options. This will simplify the code.
        const minTreatNull = (0, index_1.treatNull)(min);
        const maxTreatNull = (0, index_1.treatNull)(max);
        // If no converter, use the IntlNumberConverter
        const converter = (0, useImplicitNumberConverter_1.useImplicitNumberConverter)({
            converter: propConverter
        });
        const implicitComponentValidator = (0, useImplicitNumberRangeValidator_1.useImplicitNumberRangeValidator)({
            converter,
            max: maxTreatNull,
            min: minTreatNull,
            numberRangeExactMessageDetail,
            numberRangeOverflowMessageDetail,
            numberRangeUnderflowMessageDetail
        });
        const combinedValidators = (0, hooks_1.useMemo)(() => {
            const v1 = implicitComponentValidator ? [implicitComponentValidator] : [];
            const v2 = validators ? validators : [];
            return [...v1, ...v2];
        }, [implicitComponentValidator, validators]);
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const converterParseError = translations.inputNumber_converterParseError();
        const translateConverterParseError = (0, hooks_2.useCallback)((error) => {
            // JET-54847: Display a user-friendly localized message if the parse failure is due to user input error.
            return error?.cause === ojconverter_nativenumber_1.USER_INPUT_ERROR
                ? { severity: 'error', detail: converterParseError }
                : undefined;
        }, [converterParseError]);
        // useEditableValue passes in propValue and passes out value. The only time they are different is when the component's
        // value property is programmatically changed, not changed by user action. Like if value is
        // programmatically changed, say like inputNumber.value = 20,
        // propValue will be 20 and value will be the previous value. Then in useEV->useValueLifecycle, setValue is called
        // when value is programmatically changed, and that triggers a re-render and then propValue and value will be the same.
        const { onCommitValue, formatValue, parseValue, methods, textFieldProps: evTextFieldProps, value, setValue, displayValue, setDisplayValue, setTransientValue } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            // We are casting this because legacy oj.Converter format returns string | null, but useEV's format
            // returns DV, which we set as string. In useEV/converterUtils we make sure not to call format when
            // the value is null and if format returns null we normalize it to return the defaultDisplayValue,
            // which is a string, so format never returns null.
            converter: converter,
            defaultDisplayValue: '',
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onRawValueChanged,
            onTransientValueChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            translateConverterParseError,
            validators: combinedValidators,
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        //
        const hasMin = minTreatNull !== undefined;
        const hasMax = maxTreatNull !== undefined;
        // these useRefs are to keep track of the spinning/stepping for async validation that could be slow.
        const isValidating = (0, hooks_2.useRef)(false);
        // this is used when the user clicks the up/down arrows faster than a slow validator can keep up.
        const stepQueue = (0, hooks_2.useRef)(new Array());
        // if we have a slow validator, then displayValue is what it is when the arrow is pressed. We use the displayValue
        // in doStep to get what we should increase or decrease. This ref keeps the most recent display value, not
        // what it was when the increase/decrease arrows were pressed.
        const currentDisplayValueInStep = (0, hooks_2.useRef)(displayValue);
        // We need to store the initial value so that we can use it to determine the step basis,
        // and also we recalculate step basis when value programmatically changes.
        const initialValue = (0, hooks_2.useRef)((0, index_1.treatNull)(propValue));
        // this only gets called when we programmatically change value, not when the user steps with arrows nor when the user commits a new value (that changes both value and propValue).
        // propValue changes when we programmatically change the value and it is different at this point than value.
        if (propValue !== value) {
            initialValue.current = (0, index_1.treatNull)(propValue);
        }
        // The setValueNow is updated:
        // 1. initial render, it is value.
        // 2. when value changes, either if value programmatically changes, or if value changes because it is committed.
        // 3. when the user steps or spins the number (see doStep). value doesn't change when we spin, so in this case value and valueNow diverge.
        // 4. when the user tries to commit and it fails validation (value doesn't change when validation fails, so in this case value and valueNow diverge).
        // if it is parseable, it is the number the user typed in. (see onCommit)
        const [valueNow, setValueNow] = (0, hooks_2.useState)((0, index_1.treatNull)(value));
        const [prevValue, setPrevValue] = (0, hooks_2.useState)(value);
        // this gets called anytime value changes which can be programmatically, or when the user steps with arrows or when the user commits a new value.
        if (value !== prevValue) {
            setPrevValue(value);
            setValueNow((0, index_1.treatNull)(value));
            // The setTransientValue is called when value changes, either programmatically or otherwise. It also changes during spinning
            // when the value doesn't get updated.
            setTransientValue(value);
        }
        // Used to track whether the user typed something into the field but did not commit.
        // This is used to calculate valueText, which in turn affects rendering, so it needs to be state.
        const [hasUncommittedDisplayValue, setHasUncommittedDisplayValue] = (0, hooks_2.useState)(false);
        // update every time we render if displayValue changes
        currentDisplayValueInStep.current = displayValue;
        // Overriding useEditableValue#onCommit to additionally set valueNow.
        const onCommit = (0, hooks_2.useCallback)(async ({ value }) => {
            setHasUncommittedDisplayValue(false);
            // parse
            const conversion = parseValue(value);
            if (conversion.result === 'failure') {
                // Parse failed. E.g., the user typed in a non-number.
                // In this case do nothing other than update valueNow and return
                // STATE: Commit (user action, stepping, end spinning, etc.) and parse failed.
                setValueNow(undefined);
                return;
            }
            // parse succeeded. onCommitValue tries to validate the value and commits it.
            const parsedValue = conversion.value;
            const commitSucceeded = await onCommitValue(parsedValue);
            if (commitSucceeded) {
                // if validation succeeds value is updated which in turn updates value/valueNow, so no need to do it explicitly here.
                const formattedValue = formatValue(parsedValue);
                setDisplayValue(formattedValue);
            }
            else {
                // The value the user typed in and tried to commit is not valid; validation failed.
                // E.g., a user typed in 800 when the range is 0-100. We want to disable the up button, we want aria-valuenow to show
                // 800.
                // STATE: Commit, parse succeeded, but validation failed.
                // parsedValue is number | null, setValueNow expects number | undefined.
                setValueNow(parsedValue ?? undefined);
            }
        }, [formatValue, parseValue, onCommitValue, setDisplayValue]);
        // Overriding useEditableValue#onInput so we can keep track if someone typed something in but didn't commit.
        // This is needed to figure out what valueText should be: displayValue unless someone typed something in but didn't commit.
        const onInput = (0, hooks_2.useCallback)(({ value }) => {
            // Do not use formatter when simply pushing back the text from event
            setDisplayValue(value ?? '');
            setHasUncommittedDisplayValue(true);
        }, [setDisplayValue]);
        const textFieldPropsWithOverride = { ...textFieldProps, onCommit, onInput };
        // This gets called when the user steps or spins. It is similar to the onCommit but it steps the value up or down first.
        // And it doesn't commit if it is spinning. It only commits the value if it is stepping or if spinning is complete.
        // stepping is a click, spinning is holding down the mouse or key. spinning is complete when they let go of the mouse or key.
        // This function will return right away if isValidating.current is true. isValidating.current is set to
        // false when the validation is done and this function is complete. This avoids running the validation
        // while a slow validator is still running.
        const doStep = (0, hooks_2.useCallback)(async (direction, doCommit) => {
            if (step === undefined || isValidating.current) {
                return;
            }
            // get the displayValue or if it is not set, use '0' and parse it to a number.
            const displayValueToStep = currentDisplayValueInStep.current || '0';
            const conversion = parseValue(displayValueToStep);
            if (conversion.result === 'failure') {
                // Conversion failed, do nothing
                return;
            }
            const parsedValue = conversion.value;
            // Take the parsed number and step it up or down based on direction, if any
            let newSteppedValue;
            if (direction !== undefined) {
                const stepValue = direction === 'increase' ? step : -1 * step;
                newSteppedValue = (0, stepBasisUtils_1.determineSteppedValue)(stepValue, step, parsedValue, initialValue.current, maxTreatNull, minTreatNull);
            }
            else {
                newSteppedValue = parsedValue;
            }
            // for spinning we want to run the full validation lifecycle, but not commit the value (doCommit is false).
            // for stepping, we want to run the full validation lifecycle and commit the value. (doCommit is true)
            isValidating.current = true;
            // no matter if it is valid or invalid, update the display value.
            const formattedValue = formatValue(newSteppedValue);
            setDisplayValue(formattedValue);
            currentDisplayValueInStep.current = formattedValue;
            // onCommit calls onCommitValue, not vice versa.
            // onCommitValue calls setValue if valid.
            // So stepping or spinning does not call onCommit.
            const commitSucceeded = await onCommitValue(newSteppedValue, doCommit);
            const isSpinning = doCommit === false;
            const valueCommitted = doCommit && commitSucceeded;
            // STATE: Spinning and VALID
            if (isSpinning && commitSucceeded) {
                // When spinning, we update the transientValue but only if the validation succeeded.
                // If we aren't spinning, the value is committed if valid, and the transientValue will get updated as a result, so no need to set it here.
                setTransientValue(newSteppedValue);
            }
            // STATE: Spinning or Stepping, parse succeeded, value was not committed.
            // If it is doCommit and VALID, then we don't need to because in that case value gets updated, and as a result, valueNow will be updated.
            if (!valueCommitted) {
                setValueNow(newSteppedValue);
            }
            isValidating.current = false;
        }, [
            formatValue,
            maxTreatNull,
            minTreatNull,
            parseValue,
            onCommitValue,
            setDisplayValue,
            setTransientValue,
            step
        ]);
        const processStepQueue = (0, hooks_2.useCallback)(async (direction) => {
            // kick off doStep and wait until it finishes. It could be slow if there is a slow validator.
            await doStep(direction, true);
            // if we have queued up more steps, process them
            if (stepQueue.current.length > 0) {
                // pull this out of the array, and call doStep again.
                const direction = stepQueue.current.shift();
                processStepQueue(direction);
            }
        }, [doStep]);
        // This gets called every time the user clicks on the up/down arrows
        // or presses the arrow up/down keys.
        // NumberInputText stops sending the step event when the up/down buttons are disabled.
        // If a user steps 3 times really fast, the number will step up 3 times, even if the validation is slow.
        const handleStep = (0, hooks_2.useCallback)(async ({ direction }) => {
            // if we are already processing something, then just push onto the queue and return
            if (isValidating.current) {
                // isValidating, so push direction onto the array and return.
                stepQueue.current.push(direction);
            }
            else {
                // not already processing.
                // kick off the process but do not wait for it to finish, return.
                processStepQueue(direction);
            }
        }, [processStepQueue]);
        // This gets called every 40ms while the user is holding down the arrow up/down key.
        const handleSpin = (0, hooks_2.useCallback)(async ({ direction }) => {
            // Don't commit until after spinning has completed.
            const doCommit = false;
            // clear the step queue if we start spinning
            stepQueue.current = [];
            // doStep will return early if it is waiting for validation to complete from a previous step or spin.
            doStep(direction, doCommit);
        }, [doStep]);
        // This gets called when the user releases the arrow key when spinning is complete.
        const handleSpinComplete = (0, hooks_2.useCallback)(async () => {
            // This will try to commit the latest value that the handleSpin handled. handleSpin does not commit.
            // We only commit when the spin is complete.
            // currentDisplayValueInStep.current is the most recent display value the spinning got to.
            // It could be valid or invalid. However, when handleSpinComplete is called it should never be undefined.
            // parseValue expects a string as the display value.
            const conversion = parseValue(currentDisplayValueInStep.current);
            if (conversion.result === 'failure') {
                // Parse failed.
                return;
            }
            // parse succeeded. onCommitValue tries to validate the value and commits it.
            await onCommitValue(conversion.value);
        }, [onCommitValue, parseValue]);
        // We calculate the valueText from other state.
        // We did have to add 'hasUncommittedDisplayValue' state for this calculation, but it doesn't
        // get updated as often as we would have to update the valueText if it were state.
        // Note: since format is potentially called on every render, which could throw an error, an
        // infinite rerender can happen because the new useEV attempts to rerender to show messages, which
        // leads to calling format again. To prevent this from happening, we cache the last valueText.
        const lastValueNow = (0, hooks_2.useRef)();
        const lastDisplayValue = (0, hooks_2.useRef)();
        const lastHasUncommittedDisplayValue = (0, hooks_2.useRef)();
        const lastValueText = (0, hooks_2.useRef)();
        let valueText;
        if (hasUncommittedDisplayValue !== lastHasUncommittedDisplayValue.current ||
            displayValue !== lastDisplayValue.current ||
            valueNow !== lastValueNow.current) {
            // If any of the params to calculateValueText have changed, call it again.
            valueText = calculateValueText(hasUncommittedDisplayValue, displayValue, // displayValue is always '' or an actual string value
            valueNow, formatValue);
            lastHasUncommittedDisplayValue.current = hasUncommittedDisplayValue;
            lastDisplayValue.current = displayValue;
            lastValueNow.current = valueNow;
            lastValueText.current = valueText;
        }
        else {
            valueText = lastValueText.current;
        }
        const normalizedVirtualKeyboard = virtualKeyboard === 'auto' ? (0, index_1.getVirtualKeyboardHintFromConverter)(converter) : virtualKeyboard;
        return {
            value,
            setValue,
            methods,
            // Certain props will have null as default values, but we need them to be
            // undefined in the preact component.
            inputNumberProps: {
                'aria-valuemax': maxTreatNull,
                'aria-valuemin': minTreatNull,
                'aria-valuenow': valueNow ?? undefined,
                'aria-valuetext': valueText,
                autoComplete: autocomplete,
                autoFocus: autofocus,
                hasSteppers: step !== undefined && step > 0,
                isDisabled: disabled,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || (0, index_1.treatNull)(value) === undefined),
                label: labelHint,
                labelEdge,
                labelStartWidth,
                stepperVariant,
                onSpin: step ? handleSpin : undefined, // step=0 is falsey
                onSpinComplete: step ? handleSpinComplete : undefined,
                onStep: step ? handleStep : undefined,
                placeholder,
                prefix: inputPrefix,
                suffix: inputSuffix,
                isStepDownDisabled: disabled ||
                    (hasMin &&
                        ((valueNow !== undefined && valueNow <= minTreatNull) ||
                            (displayValue === '' && minTreatNull === 0))),
                isStepUpDisabled: disabled ||
                    (hasMax &&
                        ((valueNow !== undefined && valueNow >= maxTreatNull) ||
                            (displayValue === '' && maxTreatNull === 0))),
                messages,
                textAlign,
                userAssistanceDensity,
                virtualKeyboard: normalizedVirtualKeyboard,
                ...textFieldPropsWithOverride
            }
        };
    }
    // calculate the valueText based on the input parameters.
    function calculateValueText(hasUncommittedDisplayValue, displayValue, valueNow, format) {
        // The displayValue is committed, so go ahead and use it for the valueText.
        if (!hasUncommittedDisplayValue) {
            return displayValue !== '' ? displayValue : undefined;
        }
        // The display value is not committed, that is, someone typed in and didn't try to commit it by pressing Enter/blur,
        // and we can't use displayValue for valuetext.
        let valueText;
        if (valueNow) {
            valueText = format(valueNow);
        }
        return valueText === '' || valueText === null ? undefined : valueText;
    }
});


define('oj-c/input-number/input-number',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_NumberInputText", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojcontext", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "./useNumberInputTextPreact", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "css!oj-c/input-number/input-number-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_NumberInputText_1, useAssistiveText_1, Context, ojvcomponent_1, compat_1, hooks_1, useNumberInputTextPreact_1, UNSAFE_classNames_1, FormControl_1, Layout_1, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputNumber = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        converterHint: 'display',
        messages: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    /**
     * @classdesc
     * <h3 id="inputNumberOverview-section">
     *   JET InputNumber Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputNumberOverview-section"></a>
     * </h3>
     *
     * <p>Description: The JET Input Number component enhances a browser input element into one that
     * holds numbers and it has a spinbox to quickly increment or decrement the number.
     * The value attribute must be a number and must be within the min and max range..</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-input-number value="20" label-hint="Input Number">&lt;/oj-c-input-number></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
    
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation lifecycle is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If the UI display value is empty, then the component normalizes the value to null.</li>
     * <li>
     *  If no converter is present, or the normalized value is null, then processing continues to next step. Otherwise,
     *  the UI value is first converted (i.e., parsed). If there is a parse error then the messages are shown and processing stops.
     * </li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * If the normalized value is null, then only the required validator is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>The required and placeholder properties also can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * Placeholder is shown when the field is empty and has focus.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Up Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Increment the number.</td>
     *     </tr>
     *     <tr>
     *       <td>Down Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Decrement the number.</td>
     *     </tr>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Set focus to the input. Show user assistance text. This may be inline or in a notewindow
     * depending upon theme and property settings.</td>
     *     </tr>
     *     <tr>
     *       <td>Elsewhere on Page</td>
     *       <td><kbd>Touch</kbd></td>
     *       <td>Submit the value you typed in the input field.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="4">Input</td>
     *       <td><kbd>Enter</kbd> or <kbd>Tab</kbd></td>
     *       <td>Submit the value you typed in the input field.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to input. Show user assistance text. This may be inline or in a notewindow
     * depending upon theme and property settings.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Increment the number.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Decrement the number.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     * <p>
     * The placeholder text is not read reliably by the screen reader. For accessibility reasons,
     * you need to associate the text to its JET form component using aria-describedby.
     * </p>
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     * @ojmetadata displayName "InputNumber"
     * @ojmetadata description "An input number allows the user to enter a number value."
     * @ojmetadata help "oj-c.InputNumber.html"
     * @ojmetadata main "oj-c/input-number"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-input-number"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/input-number",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-input-number",
     *     "uxSpecs": [
     *       "input-number"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "placeholder",
     *       "readonly",
     *       "required",
     *       "virtualKeyboard"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "14.0.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    const InputNumberImpl = ({ autocomplete = 'on', columnSpan = 1, converter = null, containerReadonly: propContainerReadonly, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, labelWrapping: propLabelWrapping, messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, stepperVariant = 'directional', textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, validators = validatorsDefault, virtualKeyboard = 'auto', value = null, ...otherProps }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const inputNumberRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc = 'InputNumber: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-input-number id=${id} is ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        // The UX design doesn't want implicit converter or validator hints, so I'm not passing the implicit converter
        // or validator out of the hook which is where they are created.
        // And currently the NumberRangeValidator has default hints, and there is no way to turn them off other
        // than extending the validator to return null from getHint.
        const { inputNumberProps, methods } = (0, useNumberInputTextPreact_1.useNumberInputTextPreact)({
            autocomplete,
            converter,
            disabled,
            displayOptions,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            stepperVariant,
            userAssistanceDensity: uadValue,
            validators,
            virtualKeyboard,
            value,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => inputNumberRef.current?.blur(),
            focus: () => inputNumberRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: inputNumberProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        // throw errors if step is negative, or if max < min
        // step is typed as step?: number. throw an error if it is negative.
        if (otherProps.step !== undefined && otherProps.step < 0) {
            throw new Error('step must be a positive number');
        }
        // min/max are typed as min?: number | null. throw an error if max < min
        if (otherProps.min != null && otherProps.max != null && otherProps.max < otherProps.min) {
            throw new Error('max cannot be less than min');
        }
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? otherProps.maxWidth : 'none',
            width: otherProps.width === 'md' || otherProps.width === 'sm' ? otherProps.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = otherProps.width === 'md' || otherProps.width === 'sm' ? undefined : otherProps.width;
        const maxWidthStyle = otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? undefined : otherProps.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return (
        // make sure to add the id on the Root element as it would have been removed
        // from there since it is from the ObservedGlobalProps
        // layoutSpanColumn style class needs to be applied to the root dom element,
        // otherwise the css grid will ignore it.
        (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_NumberInputText_1.NumberInputText, { ref: inputNumberRef, ...assistiveTextProps, ...inputNumberProps, columnSpan: columnSpan, variant: variant }) }) }));
    };
    exports.InputNumber = (0, ojvcomponent_1.registerCustomElement)('oj-c-input-number', (0, compat_1.forwardRef)(InputNumberImpl), "InputNumber", { "properties": { "autocomplete": { "type": "string" }, "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "converter": { "type": "object|null" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "converterHint": { "type": "string", "enumValues": ["none", "display"] }, "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "inputPrefix": { "type": "string" }, "inputSuffix": { "type": "string" }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "max": { "type": "number|null" }, "maxWidth": { "type": "number|string" }, "min": { "type": "number|null" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "numberRangeExactMessageDetail": { "type": "string" }, "numberRangeOverflowMessageDetail": { "type": "string" }, "numberRangeUnderflowMessageDetail": { "type": "string" }, "placeholder": { "type": "string" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "step": { "type": "number" }, "stepperVariant": { "type": "string", "enumValues": ["directional", "quantitative"] }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "number|null", "writeback": true }, "virtualKeyboard": { "type": "string", "enumValues": ["number", "auto", "text"] }, "width": { "type": "number|string" }, "rawValue": { "type": "string", "readOnly": true, "writeback": true }, "transientValue": { "type": "number|null", "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "transientValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "transientValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id", "autofocus"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "autocomplete": "on", "columnSpan": 1, "converter": null, "disabled": false, "displayOptions": { "converterHint": "display", "messages": "display", "validatorHint": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "stepperVariant": "directional", "validators": [], "virtualKeyboard": "auto", "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/input-number',["require", "exports", "oj-c/input-number/input-number"], function (require, exports, input_number_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputNumber = void 0;
    Object.defineProperty(exports, "InputNumber", { enumerable: true, get: function () { return input_number_1.InputNumber; } });
});

define('oj-c/input-password/useInputPasswordPreact',["require", "exports", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "oj-c/hooks/UNSAFE_useEditableValue/index"], function (require, exports, useComponentMessages_1, useDeferredValidators_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useInputPasswordPreact = useInputPasswordPreact;
    /**
     * This hook manages state and other related props to send to the Input Password
     * component. This hook will transform any properties as needed, like maskIcon to
     * hasRevealToggle.
     *
     * Usage:
     * const { inputPasswordProps } = useInputPasswordPreact(props);
     * <PreactInputPassword {...assistiveTextProps} {...inputPasswordProps} />
     */
    function useInputPasswordPreact({ autocomplete = 'on', autofocus, clearIcon = 'never', disabled, displayOptions, labelEdge, labelHint, labelStartWidth, maskIcon, messagesCustom, placeholder, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, textAlign, userAssistanceDensity, validators, value: propValue, onMessagesCustomChanged, onRawValueChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const { methods, textFieldProps: evTextFieldProps, value } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            defaultDisplayValue: '',
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onRawValueChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            // In corepack we are allowed to have null as validators, but useEV uses undefined
            // so we map null to undefined.
            validators: (0, index_1.treatNull)(validators, undefined),
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        const hasNoValue = value === null || (typeof value === 'string' && value === '');
        const hasClearIcon = clearIcon === 'conditional' ? 'conditionally' : clearIcon;
        // Map maskIcon's options to hasRevealToggle options (hidden->never and visible->always).
        // hasRevealToggle defaults to 'always' to align with the Redwood UX spec.
        const hasRevealToggle = maskIcon === 'hidden' ? 'never' : 'always';
        return {
            methods,
            inputPasswordProps: {
                autoComplete: autocomplete,
                autoFocus: autofocus,
                hasClearIcon: hasClearIcon,
                hasRevealToggle,
                isDisabled: disabled,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                label: labelHint,
                labelEdge: labelEdge,
                labelStartWidth,
                messages,
                placeholder,
                textAlign,
                userAssistanceDensity,
                ...textFieldProps
            }
        };
    }
});


define('oj-c/input-password/input-password',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/compat", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_InputPassword", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojcontext", "ojs/ojvcomponent", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "./useInputPasswordPreact", "css!oj-c/input-password/input-password-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, compat_1, hooks_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_InputPassword_1, useAssistiveText_1, Context, ojvcomponent_1, UNSAFE_classNames_1, FormControl_1, Layout_1, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1, useInputPasswordPreact_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputPassword = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        converterHint: 'display',
        messages: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    /**
     * @classdesc
     * <h3 id="inputPasswordOverview-section">
     *   JET InputPassword Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputPasswordOverview-section"></a>
     * </h3>
     *
     * <p>Description: The oj-c-input-password component enhances a browser input type="password" element.</p>
     * <p>
     * An input password displays a field that allows a user to enter a password that will be masked.
     * The user can reveal the password by clicking on the reveal toggle button. When the user
     * leaves the field, the password is automatically masked.
     * </p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-input-password label-hint="Input Password">&lt;/oj-c-input-password></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
    
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>The required and placeholder properties also can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * Placeholder is shown when the field is empty and has focus.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to input. Show user assistance text.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the input. Show user assistance text.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     * <p>
     * The placeholder text is not read reliably by the screen reader. For accessibility reasons,
     * you need to associate the text to its JET form component using aria-describedby.
     * </p>
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     *
     * @ojmetadata displayName "InputPassword"
     * @ojmetadata description "An input password allows the user to enter a password."
     * @ojmetadata help "oj-c.InputPassword.html"
     * @ojmetadata main "oj-c/input-password"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/input-password",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-text-input-password",
     *     "uxSpecs": [
     *       "input-password"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "placeholder",
     *       "readonly",
     *       "required"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "13.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-input-password"]
     *   }
     * ]
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    function InputPasswordImpl({ autocomplete = 'on', clearIcon = 'never', columnSpan = 1, containerReadonly: propContainerReadonly, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, labelWrapping: propLabelWrapping, maskIcon = 'visible', messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, validators = validatorsDefault, value = null, ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const inputPasswordRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-input-password id=${id}: ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        const { inputPasswordProps, methods } = (0, useInputPasswordPreact_1.useInputPasswordPreact)({
            autocomplete,
            clearIcon,
            disabled,
            displayOptions,
            maskIcon,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            validators,
            value,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => inputPasswordRef.current?.blur(),
            focus: () => inputPasswordRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: inputPasswordProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? otherProps.maxWidth : 'none',
            width: otherProps.width === 'md' || otherProps.width === 'sm' ? otherProps.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = otherProps.width === 'md' || otherProps.width === 'sm' ? undefined : otherProps.width;
        const maxWidthStyle = otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? undefined : otherProps.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return (
        // Even though we are handling the styling here, we pass the columnSpan property down to the
        // Preact component because it may be needed for other purposes, like calculating the start
        // label width.
        // The layoutSpanColumn style class needs to be applied to the root dom element,
        // otherwise the css grid will ignore it.
        (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_InputPassword_1.InputPassword, { ref: inputPasswordRef, ...assistiveTextProps, ...inputPasswordProps, columnSpan: columnSpan, variant: variant }) }) }));
    }
    exports.InputPassword = (0, ojvcomponent_1.registerCustomElement)('oj-c-input-password', (0, compat_1.forwardRef)(InputPasswordImpl), "InputPassword", { "properties": { "autocomplete": { "type": "string" }, "clearIcon": { "type": "string", "enumValues": ["conditional", "always", "never"] }, "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "converterHint": { "type": "string", "enumValues": ["none", "display"] }, "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "maskIcon": { "type": "string", "enumValues": ["hidden", "visible"] }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "placeholder": { "type": "string" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "string|null", "writeback": true }, "width": { "type": "number|string" }, "rawValue": { "type": "string", "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id", "autofocus"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "autocomplete": "on", "clearIcon": "never", "columnSpan": 1, "disabled": false, "displayOptions": { "converterHint": "display", "messages": "display", "validatorHint": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "maskIcon": "visible", "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "validators": [], "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/input-password',["require", "exports", "oj-c/input-password/input-password"], function (require, exports, input_password_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputPassword = void 0;
    Object.defineProperty(exports, "InputPassword", { enumerable: true, get: function () { return input_password_1.InputPassword; } });
});

define('oj-c/input-sensitive-text/useInputSensitiveTextPreact',["require", "exports", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "oj-c/hooks/UNSAFE_useEditableValue/index"], function (require, exports, useComponentMessages_1, useDeferredValidators_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useInputSensitiveTextPreact = useInputSensitiveTextPreact;
    /**
     * This hook manages state and other related props to send to the Input Sensitive Text
     * component. This hook will transform any properties as needed, like maskIcon to
     * hasRevealToggle.
     *
     * Usage:
     * const { inputSensitiveTextProps } = useInputSensitiveTextPreact(props);
     * <PreactInputSensitiveText {...assistiveTextProps} {...inputSensitiveTextProps} />
     */
    function useInputSensitiveTextPreact({ autofocus, clearIcon = 'never', disabled, displayOptions, labelEdge, labelHint, labelStartWidth, length, maskIcon, maskIconLabel, messagesCustom, placeholder, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, textAlign, userAssistanceDensity, validators, value: propValue, virtualKeyboard, onMessagesCustomChanged, onRawValueChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const { methods, textFieldProps: evTextFieldProps, value } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            defaultDisplayValue: '',
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onRawValueChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            // In corepack we are allowed to have null as validators, but useEV uses undefined, so we map null to undefined.
            validators: (0, index_1.treatNull)(validators, undefined),
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        const hasNoValue = value === null || (typeof value === 'string' && value === '');
        const hasClearIcon = clearIcon === 'conditional' ? 'conditionally' : clearIcon;
        // Map maskIcon's options to hasRevealToggle options (hidden->never and visible->always).
        // hasRevealToggle defaults to 'always' to align with the Redwood UX spec.
        const hasRevealToggle = maskIcon === 'hidden' ? 'never' : 'always';
        return {
            methods,
            inputSensitiveTextProps: {
                ...textFieldProps,
                autoFocus: autofocus,
                hasClearIcon,
                hasRevealToggle,
                isDisabled: disabled,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                label: labelHint,
                labelEdge,
                labelStartWidth,
                maxLength: (0, index_1.treatNull)(length?.max),
                maxLengthUnit: length?.countBy,
                messages,
                placeholder,
                revealToggleLabel: maskIconLabel,
                textAlign,
                userAssistanceDensity,
                virtualKeyboard
            }
        };
    }
});


define('oj-c/input-sensitive-text/input-sensitive-text',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/compat", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_InputSensitiveText", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojvcomponent", "ojs/ojcontext", "./useInputSensitiveTextPreact", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "css!oj-c/input-sensitive-text/input-sensitive-text-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, compat_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_InputSensitiveText_1, UNSAFE_classNames_1, FormControl_1, Layout_1, useAssistiveText_1, ojvcomponent_1, Context, useInputSensitiveTextPreact_1, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputSensitiveText = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    const lengthDefault = {
        countBy: 'codePoint',
        max: null
    };
    const FunctionalInputSensitiveText = (0, compat_1.forwardRef)(
    /**
     * @classdesc
     * <h3 id="InputSensitiveTextOverview-section">
     *   JET InputSensitiveText Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#InputSensitiveTextOverview-section"></a>
     * </h3>
     *
     * <p>Description: The oj-c-input-sensitive-text component is a text field that visibly masks the text.</p>
     * <p>
     * An Input Sensitive Text displays a field that allows a user to enter sensitive text that will be masked.
     * The user can reveal the sensitive text by clicking on the reveal toggle button. When the user
     * leaves the field, the sensitive text is automatically masked.
     * </p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-input-sensitive-text label-hint="Input Sensitive Text">&lt;/oj-c-input-sensitive-text></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
  
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>The required and placeholder properties also can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * Placeholder is shown when the field is empty and has focus.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to input. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Mask Icon</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>If available, tapping icon will toggle text masking.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the input. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Mask Icon</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>If available, set focus to the Mask Icon toggle.</td>
     *     </tr>
     *     <tr>
     *       <td>Mask Icon</td>
     *       <td><kbd>Enter or Space</kbd></td>
     *       <td>If available, hitting Enter or Space on the icon toggles text masking.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="cjk-section">
     *   CJK (Chinese, Japanese, or Korean) character support
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#cjk-section"></a>
     * </h3>
     *
     * <p>
     * The user is restricted to using an English keyboard when inputting characters into the
     * masked component. If they wish to enter CJK (Chinese, Japanese, or Korean) characters,
     * they must first unmask the field and then input the CJK value. Alternatively, they can
     * paste the CJK value into the field while the field is masked or unmasked.
     * </p>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     * <p>
     * The component will prevent screen readers from announcing sensitive text when the input is focused.
     * If users toggle the visibility to reveal the text, it will announce the text like a standard input.
     * </p>
     *
     * <p>
     * The placeholder text is not read reliably by the screen reader. For accessibility reasons,
     * you need to associate the text to its JET form component using aria-describedby.
     * </p>
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     * @typeparam V Type of the value
     *
     * @ojmetadata displayName "InputSensitiveText"
     * @ojmetadata description "An Input Sensitive Text displays a field that allows a user to enter sensitive text that will be masked."
     * @ojmetadata help "oj-c.InputSensitiveText.html"
     * @ojmetadata main "oj-c/input-sensitive-text"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/input-sensitive-text",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-text-input-password",
     *     "uxSpecs": [
     *       "input-text"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "placeholder",
     *       "readonly",
     *       "required"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "16.1.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    ({ clearIcon = 'never', columnSpan = 1, containerReadonly: propContainerReadonly, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, labelWrapping: propLabelWrapping, length = lengthDefault, maskIcon = 'visible', messagesCustom = messagesCustomDefault, maskIconLabel, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, validators = validatorsDefault, value = null, ...otherProps }, ref) => {
        const rootRef = (0, compat_1.useRef)();
        const inputSensitiveTextRef = (0, compat_1.useRef)();
        // create addBusyState
        const addBusyState = (0, compat_1.useCallback)((description) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-input-sensitive-text id=${id} is ${description}` })
                : () => { }; // if the component is not mounted return Noop
        }, []);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        const { inputSensitiveTextProps, methods } = (0, useInputSensitiveTextPreact_1.useInputSensitiveTextPreact)({
            clearIcon,
            columnSpan,
            disabled,
            displayOptions,
            help,
            helpHints,
            id,
            length,
            maskIcon,
            maskIconLabel,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            validators,
            value,
            ...otherProps
        }, addBusyState);
        (0, compat_1.useImperativeHandle)(ref, () => ({
            blur: () => inputSensitiveTextRef.current?.blur(),
            focus: () => inputSensitiveTextRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: inputSensitiveTextProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? otherProps.maxWidth : 'none',
            width: otherProps.width === 'md' || otherProps.width === 'sm' ? otherProps.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = otherProps.width === 'md' || otherProps.width === 'sm' ? undefined : otherProps.width;
        const maxWidthStyle = otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm'
            ? undefined
            : otherProps.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_InputSensitiveText_1.InputSensitiveText, { ref: inputSensitiveTextRef, ...assistiveTextProps, ...inputSensitiveTextProps, columnSpan: columnSpan, variant: variant }) }) }));
    });
    exports.InputSensitiveText = (0, ojvcomponent_1.registerCustomElement)('oj-c-input-sensitive-text', FunctionalInputSensitiveText, "InputSensitiveText", { "properties": { "clearIcon": { "type": "string", "enumValues": ["conditional", "always", "never"] }, "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "length": { "type": "object", "properties": { "countBy": { "type": "string", "enumValues": ["codePoint", "codeUnit"] }, "max": { "type": "number|null" } } }, "maskIcon": { "type": "string", "enumValues": ["hidden", "visible"] }, "maskIconLabel": { "type": "string" }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "placeholder": { "type": "string" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "string|null", "writeback": true }, "virtualKeyboard": { "type": "string", "enumValues": ["number", "search", "auto", "url", "text", "email", "tel"] }, "width": { "type": "number|string" }, "rawValue": { "type": "string", "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id", "autofocus"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "clearIcon": "never", "columnSpan": 1, "disabled": false, "displayOptions": { "messages": "display", "validatorHint": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "length": { "countBy": "codePoint", "max": null }, "maskIcon": "visible", "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "validators": [], "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/input-sensitive-text',["require", "exports", "oj-c/input-sensitive-text/input-sensitive-text"], function (require, exports, input_sensitive_text_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputSensitiveText = void 0;
    Object.defineProperty(exports, "InputSensitiveText", { enumerable: true, get: function () { return input_sensitive_text_1.InputSensitiveText; } });
});

define('oj-c/input-text/useInputTextPreact',["require", "exports", "preact/hooks", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "ojs/ojconverter-nativenumber"], function (require, exports, hooks_1, index_1, useComponentMessages_1, useDeferredValidators_1, UNSAFE_useTranslationBundle_1, ojconverter_nativenumber_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useInputTextPreact = useInputTextPreact;
    /**
     * This hook manages state and other related props for the Input Text
     * component.
     */
    function useInputTextPreact({ autocomplete = 'on', autofocus, clearIcon = 'never', converter, disabled, displayOptions, end, inputPrefix, inputSuffix, labelEdge, labelHint, labelStartWidth, length, messagesCustom, placeholder, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, start, textAlign, userAssistanceDensity, validators, value: propValue, virtualKeyboard, onMessagesCustomChanged, onRawValueChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const converterParseError = translations.inputNumber_converterParseError();
        const translateConverterParseError = (0, hooks_1.useCallback)((error) => {
            // JET-54847: Display a user-friendly localized message if the parse failure is due to
            // user input error from either NumberConverter or BigDecimalStringConverter.
            return error?.cause === ojconverter_nativenumber_1.USER_INPUT_ERROR
                ? { severity: 'error', detail: converterParseError }
                : undefined;
        }, [converterParseError]);
        // legacy converter takes V | null for formatting, and string for parsing.
        const { methods, textFieldProps: evTextFieldProps, value } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            // We are casting this because the legacy Converter's format returns V | null, but the useEV's converter format returns DV, which we set as string.
            // In useEV/converterUtils we make sure not to call format when the value is null and if format returns null we normalize it to
            // return the defaultDisplayValue, which is a string, so format never returns null;
            converter: converter,
            defaultDisplayValue: '',
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onRawValueChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            translateConverterParseError,
            // In corepack we are allowed to have null as validators, but useEV uses undefined, so we map null to undefined.
            validators: (0, index_1.treatNull)(validators, undefined),
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        const hasNoValue = value === null || (typeof value === 'string' && value === '');
        const hasClearIcon = clearIcon === 'conditional' ? 'conditionally' : clearIcon;
        const normalizedVirtualKeyboard = virtualKeyboard === 'auto' ? (0, index_1.getVirtualKeyboardHintFromConverter)(converter) : virtualKeyboard;
        return {
            methods,
            // Certain props will have null as default values, but we need them to be
            // undefined in the preact component.
            inputTextProps: {
                autoComplete: autocomplete,
                autoFocus: autofocus,
                hasClearIcon,
                endContent: end,
                isDisabled: disabled,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                label: labelHint,
                labelEdge,
                labelStartWidth,
                maxLength: (0, index_1.treatNull)(length?.max),
                maxLengthUnit: length?.countBy,
                messages,
                placeholder,
                prefix: inputPrefix,
                startContent: start,
                suffix: inputSuffix,
                textAlign,
                userAssistanceDensity,
                virtualKeyboard: normalizedVirtualKeyboard,
                ...textFieldProps
            }
        };
    }
});


define('oj-c/input-text/input-text',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/compat", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useAccessibleContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_InputText", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "@oracle/oraclejet-preact/UNSAFE_TextField", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojcontext", "ojs/ojvcomponent", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "./useInputTextPreact", "css!oj-c/input-text/input-text-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, compat_1, hooks_1, UNSAFE_useAccessibleContext_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_InputText_1, UNSAFE_useComponentTheme_1, UNSAFE_TextField_1, useAssistiveText_1, Context, ojvcomponent_1, UNSAFE_classNames_1, FormControl_1, Layout_1, useInputTextPreact_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputText = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        converterHint: 'display',
        messages: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const lengthDefault = {
        countBy: 'codePoint',
        max: null
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    /**
     * @classdesc
     * <h3 id="inputTextOverview-section">
     *   JET InputText Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#inputTextOverview-section"></a>
     * </h3>
     *
     * <p>Description: The oj-c-input-text component enhances a browser input type="text" element.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-input-text value="value text" label-hint="Input Text">&lt;/oj-c-input-text></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
      * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
    
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>The required and placeholder properties also can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * Placeholder is shown when the field is empty and has focus.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to input. Show user assistance text.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the input. Show user assistance text.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     * <p>
     * The placeholder text is not read reliably by the screen reader. For accessibility reasons,
     * you need to associate the text to its JET form component using aria-describedby.
     * </p>
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     * @ojmetadata displayName "InputText"
     * @ojmetadata description "An input text allows the user to enter a text value."
     * @ojmetadata help "oj-c.InputText.html"
     * @ojmetadata main "oj-c/input-text"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/input-text",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-text-input",
     *     "uxSpecs": [
     *       "input-text"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "clearIcon",
     *       "disabled",
     *       "labelHint",
     *       "placeholder",
     *       "readonly",
     *       "required",
     *       "virtualKeyboard"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "13.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-input-text"]
     *   }
     * ]
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    function InputTextImpl({ autocomplete = 'on', clearIcon = 'never', columnSpan = 1, containerReadonly: propContainerReadonly, converter = null, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, labelWrapping: propLabelWrapping, length = lengthDefault, maxWidth, messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, validators = validatorsDefault, value = null, virtualKeyboard = 'auto', width, ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const inputTextRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc = 'InputText: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-input-text id=${id} is ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        const { inputTextProps, methods } = (0, useInputTextPreact_1.useInputTextPreact)({
            autocomplete,
            clearIcon,
            converter,
            disabled,
            displayOptions,
            length,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            validators,
            value,
            virtualKeyboard,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => inputTextRef.current?.blur(),
            focus: () => {
                inputTextRef.current?.focus();
            },
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            converter,
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: inputTextProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        // JET-52089: temporarily add support for unsafe_labelledBy and pass it through context.
        const accessibleProps = {
            UNSAFE_ariaLabelledBy: otherProps.unsafe_labelledBy
        };
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: maxWidth === 'md' || maxWidth === 'sm' ? maxWidth : 'none',
            width: width === 'md' || width === 'sm' ? width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = width === 'md' || width === 'sm' ? undefined : width;
        const maxWidthStyle = maxWidth === 'md' || maxWidth === 'sm' ? undefined : maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return (
        // Even though we are handling the styling here, we pass the columnSpan property down to the
        // Preact component because it may be needed for other purposes, like calculating the start
        // label width.
        // The layoutSpanColumn style class needs to be applied to the root
        // dom element, otherwise the css grid will ignore it.
        (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_useAccessibleContext_1.AccessibleContext.Provider, { value: accessibleProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_InputText_1.InputText, { ref: inputTextRef, ...assistiveTextProps, ...inputTextProps, columnSpan: columnSpan, variant: variant }) }) }) }));
    }
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const InputTextWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-input-text', (0, compat_1.forwardRef)(InputTextImpl), "InputText", { "properties": { "autocomplete": { "type": "string" }, "clearIcon": { "type": "string", "enumValues": ["conditional", "always", "never"] }, "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "converter": { "type": "object|null" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "converterHint": { "type": "string", "enumValues": ["none", "display"] }, "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "inputPrefix": { "type": "string" }, "inputSuffix": { "type": "string" }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "length": { "type": "object", "properties": { "countBy": { "type": "string", "enumValues": ["codePoint", "codeUnit"] }, "max": { "type": "number|null" } } }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "placeholder": { "type": "string" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "unsafe_labelledBy": { "type": "string" }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "any", "writeback": true }, "virtualKeyboard": { "type": "string", "enumValues": ["number", "search", "auto", "url", "text", "email", "tel"] }, "width": { "type": "number|string" }, "rawValue": { "type": "string", "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "slots": { "end": {}, "start": {} }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id", "autofocus"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "autocomplete": "on", "clearIcon": "never", "columnSpan": 1, "converter": null, "disabled": false, "displayOptions": { "converterHint": "display", "messages": "display", "validatorHint": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "length": { "countBy": "codePoint", "max": null }, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "validators": [], "value": null, "virtualKeyboard": "auto" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
    exports.InputText = InputTextWithoutDefaultedGenerics;
});

define('oj-c/input-text',["require", "exports", "oj-c/input-text/input-text"], function (require, exports, input_text_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputText = void 0;
    Object.defineProperty(exports, "InputText", { enumerable: true, get: function () { return input_text_1.InputText; } });
});


define('oj-c/message-toast/message-toast',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_MessageToast", "@oracle/oraclejet-preact/hooks/UNSAFE_useMessagesContext", "oj-c/hooks/UNSAFE_useDataProvider/useDataProvider", "ojs/ojvcomponent", "preact/hooks", "ojs/ojcontext", "css!oj-c/message-toast/message-toast-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_MessageToast_1, UNSAFE_useMessagesContext_1, useDataProvider_1, ojvcomponent_1, hooks_1, Context) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageToast = void 0;
    /**
     * @classdesc
     * <h3 id="toastOverview-section">
     *   JET Message Toast
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#toastOverview-section"></a>
     * </h3>
     * <p>Description:</p>
     * <p>Message toasts are short, non-critical, auto-dismissible messages that communicate non-disruptive contextual messages.</p>
     * <p>
     *   Toast messages are used to:
     *   <ul>
     *    <li>Communicate messages that are relevant in the moment like the acknowledgement of an action.</li>
     *    <li>Allow user to take actions related to an event or process, such as: retry, undo, view.</li>
     *   </ul>
     * </p>
     *
     * <h4 id="messages-syntax-section">
     *  Syntax
     *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#messages-syntax-section"></a>
     * </h4>
     * Message Toast can be created with the following markup.</p>
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-message-toast data="[[messages]]">
     * &lt;/oj-c-message-toast>
     * </code></pre>
     *
     * <p>The Message Toast component will show messages based on the data provided keeping it as a single
     * source of truth. Applications should register a listener for the ojClose event to be notified
     * when one performs an action that requires a message to be closed. The application then should use the
     * event payload to identify and remove the corresponding row from the data which would then close the
     * message.</p>
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-message-toast data="[[messages]]" on-oj-close="[[handleClose]]">
     * &lt;/oj-c-message-toast>
     * </code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>The <code class="prettyprint">MessageToastItem["sound"]</code> property is an accessibility
     * feature for playing a sound when a message is opened. This property defaults to "none", and can
     * be enabled by setting it to "default" or by providing a URL to an audio file of a format that the
     * browser supports. An accessible application must provide a way for users to enable sound on a
     * settings or preferences page. Some browsers will have auto-play disabled by default, enabling
     * it may require adjusting the browser settings.</p>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan = "4">Focus within Messages</td>
     *       <td><kbd>Tab</kbd> or <kbd>Shift + Tab</kbd></td>
     *       <td>Navigate the content of the messages region.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>F6</kbd></td>
     *       <td>Cycles the focus through all the messages sections on the page starting from the most recent one.
     *           Then finally, moves the focus back to the last focused element outside the messages region.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Moves focus back to the last focused element outside the messages region and closes the current message if it is closable.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Activates the currently focused element in the message.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan = "1">Focus outside Messages</td>
     *       <td><kbd>F6</kbd></td>
     *       <td>Move focus to the first message within the more recently disclosed messages region.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="data-attributes-section">
     *   Custom Data Attributes
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-attributes-section"></a>
     * </h3>
     *
     * <p>MessageToast supports the following custom data attributes.
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Name</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>data-oj-as</kbd></td>
     *       <td><p>Provides an alias for a specific template instance and has the same subproperties as the $current variable.</p>
     *         <pre class="prettyprint"><code>&lt;oj-c-message-toast
     *   data="[[messages]]"
     *   detail-template-value="detailText">
     *   &lt;!-- Template for rendering custom detail text -->
     *   &lt;template slot="detailText" data-oj-as="message">
     *     &lt;!-- The detail text -->
     *     &lt;div>
     *       &lt;span>&lt;oj-bind-text value="[[message.data.detail]]">&lt;/oj-bind-text>&lt;/span>
     *     &lt;/div>
     *   &lt;/template>
     * &lt;/oj-c-message-toast></code></pre>
     *       </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @typeparam K Type of key of the dataprovider. It can either be a string or a number.
     * @typeparam D Type of the data from the dataprovider. It must extend the MessageToastItem type.
     * @ojmetadata displayName "MessageToast"
     * @ojmetadata description "Toast messages are short, noncritical, auto-dismissible messages that communicate non-disruptive contextual messages."
     * @ojmetadata help "oj-c.MessageToast.html"
     * @ojmetadata main "oj-c/message-toast"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "defaultColumns": 2,
     *     "minColumns": 1,
     *     "module": "oj-c/message-toast"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-messages",
     *     "uxSpecs": ["messages-toast-jet"]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data"
     *     ]
     *   }
     * ]
     * @ojmetadata since "14.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-messages"]
     *   }
     * ]
     */
    function MessageToastImpl({ data, detailTemplateValue, iconTemplateValue, messageTemplates, offset = 0, position = 'bottom', onOjClose }) {
        const uniqueId = (0, hooks_1.useRef)((0, ojvcomponent_1.getUniqueId)());
        const rootRef = (0, hooks_1.useRef)();
        const [prevData, setPrevData] = (0, hooks_1.useState)(data);
        const [dpKey, setDpKey] = (0, hooks_1.useState)(0);
        const addBusyState = (0, hooks_1.useCallback)((description = 'MessageToast: busyState') => {
            // if the component is not mounted, return a noop
            return rootRef.current
                ? Context.getContext(rootRef.current).getBusyContext().addBusyState({ description })
                : () => { };
        }, []);
        if (data != prevData) {
            setPrevData(data);
            setDpKey((dpKey) => dpKey + 1);
        }
        const { data: dataArr } = (0, useDataProvider_1.useDataProvider)({
            data,
            addBusyState
        });
        const UNSAFE_messagesLayerId = `messageToastLayer_${uniqueId.current}`;
        const messagesContext = (0, hooks_1.useMemo)(() => ({ addBusyState, UNSAFE_messagesLayerId }), [addBusyState, UNSAFE_messagesLayerId]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, "data-oj-messages-layer-id": UNSAFE_messagesLayerId, children: (0, jsx_runtime_1.jsx)(UNSAFE_useMessagesContext_1.MessagesContext.Provider, { value: messagesContext, children: (0, jsx_runtime_1.jsx)(UNSAFE_MessageToast_1.MessageToast
                // we need to completely rerender the component when the DP is changed
                // as that they message keys in the data array will not hold the same meaning.
                , { data: dataArr, detailRendererKey: detailTemplateValue, iconRendererKey: iconTemplateValue, offset: offset, onClose: onOjClose, position: position, renderers: messageTemplates }, dpKey) }) }));
    }
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const MessageToastWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-message-toast', MessageToastImpl, "MessageToast", { "properties": { "data": { "type": "DataProvider" }, "detailTemplateValue": { "type": "string|function" }, "iconTemplateValue": { "type": "string|function" }, "offset": { "type": "number|object" }, "position": { "type": "string", "enumValues": ["top", "bottom", "top-start", "top-end", "bottom-start", "bottom-end", "top-left", "top-right", "bottom-left", "bottom-right"] } }, "extension": { "_DYNAMIC_SLOT": { "prop": "messageTemplates", "isTemplate": 1 } }, "events": { "ojClose": {} } }, { "offset": 0, "position": "bottom" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
    exports.MessageToast = MessageToastWithoutDefaultedGenerics;
});

define('oj-c/message-toast',["require", "exports", "oj-c/message-toast/message-toast"], function (require, exports, message_toast_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageToast = void 0;
    Object.defineProperty(exports, "MessageToast", { enumerable: true, get: function () { return message_toast_1.MessageToast; } });
});

define('oj-c/text-area/useTextAreaAutosizePreact',["require", "exports", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators"], function (require, exports, index_1, useComponentMessages_1, useDeferredValidators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTextAreaAutosizePreact = useTextAreaAutosizePreact;
    /**
     * This hook manages state and other related props for the Input Text
     * component.
     */
    function useTextAreaAutosizePreact({ autocomplete = 'on', autofocus, converter, disabled, displayOptions, labelEdge, labelHint, labelStartWidth, length, maxRows, messagesCustom, placeholder, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, resizeBehavior, rows, textAlign, userAssistanceDensity, validators, value: propValue, onMessagesCustomChanged, onRawValueChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        // legacy converter takes V | null for formatting, and string for parsing.
        const { methods, textFieldProps: evTextFieldProps, value } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            // We are casting this because the legacy Converter's format returns V | null, but the useEV's converter format returns DV, which we set as string.
            // In useEV/converterUtils we make sure not to call format when the value is null and if format returns null we normalize it to
            // return the defaultDisplayValue, which is a string, so format never returns null;
            converter: converter,
            defaultDisplayValue: '',
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            readonly,
            // In corepack we are allowed to have null as validators, but useEV uses undefined, so we map null to undefined.
            validators: (0, index_1.treatNull)(validators, undefined),
            value: propValue,
            onMessagesCustomChanged,
            onRawValueChanged,
            onValidChanged,
            onValueChanged
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        const hasNoValue = value === null || (typeof value === 'string' && value === '');
        return {
            methods,
            textAreaProps: {
                autoComplete: autocomplete,
                autoFocus: autofocus,
                isDisabled: disabled,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                label: labelHint,
                labelEdge,
                labelStartWidth,
                maxLength: length?.max ? length.max : undefined, // coerce null to undefined
                maxLengthCounter: length?.counter,
                maxLengthUnit: length?.countBy,
                maxRows: maxRows === -1 ? undefined : maxRows,
                messages,
                minRows: rows,
                placeholder,
                resize: resizeBehavior,
                textAlign,
                userAssistanceDensity,
                ...textFieldProps
            }
        };
    }
});

define('oj-c/text-area/useTextAreaPreact',["require", "exports", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators"], function (require, exports, index_1, useComponentMessages_1, useDeferredValidators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useTextAreaPreact = useTextAreaPreact;
    /**
     * This hook manages state and other related props for the Input Text
     * component.
     */
    function useTextAreaPreact({ autocomplete = 'on', autofocus, converter, disabled, displayOptions, labelEdge, labelHint, labelStartWidth, length, messagesCustom, placeholder, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, resizeBehavior, rows, textAlign, userAssistanceDensity, validators, value: propValue, onMessagesCustomChanged, onRawValueChanged, onValueChanged, onValidChanged, ...otherProps }, addBusyState) {
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        // legacy converter takes V | null for formatting, and string for parsing.
        const { methods, textFieldProps: evTextFieldProps, value } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            // We are casting this because the legacy Converter's format returns V | null, but the useEV's converter format returns DV, which we set as string.
            // In useEV/converterUtils we make sure not to call format when the value is null and if format returns null we normalize it to
            // return the defaultDisplayValue, which is a string, so format never returns null;
            converter: converter,
            defaultDisplayValue: '',
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            readonly,
            // In corepack we are allowed to have null as validators, but useEV uses undefined, so we map null to undefined.
            validators: (0, index_1.treatNull)(validators, undefined),
            value: propValue,
            onMessagesCustomChanged,
            onRawValueChanged,
            onValidChanged,
            onValueChanged
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        const hasNoValue = value === null || (typeof value === 'string' && value === '');
        return {
            methods,
            textAreaProps: {
                autoComplete: autocomplete,
                autoFocus: autofocus,
                isDisabled: disabled,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                label: labelHint,
                labelEdge,
                labelStartWidth,
                maxLength: length?.max ? length.max : undefined, // coerce null to undefined
                maxLengthUnit: length?.countBy,
                maxLengthCounter: length?.counter,
                messages,
                resize: resizeBehavior != 'none' ? resizeBehavior : undefined,
                rows,
                placeholder,
                textAlign,
                userAssistanceDensity,
                ...textFieldProps
            }
        };
    }
});


define('oj-c/text-area/text-area',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_TextArea", "@oracle/oraclejet-preact/UNSAFE_TextAreaAutosize", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojcontext", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "./useTextAreaAutosizePreact", "./useTextAreaPreact", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "css!oj-c/text-area/text-area-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_TextArea_1, UNSAFE_TextAreaAutosize_1, useAssistiveText_1, Context, ojvcomponent_1, compat_1, hooks_1, useTextAreaAutosizePreact_1, useTextAreaPreact_1, UNSAFE_classNames_1, FormControl_1, Layout_1, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextArea = void 0;
    const displayOptionsDefault = {
        converterHint: 'display',
        messages: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const lengthDefault = {
        countBy: 'codePoint',
        counter: 'remaining',
        max: null
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    const FunctionalTextArea = (0, compat_1.forwardRef)((props, ref) => {
        const { addBusyState, converter, displayOptions, help, helpHints, validators } = props;
        const textAreaRef = (0, hooks_1.useRef)();
        const { textAreaProps, methods } = (0, useTextAreaPreact_1.useTextAreaPreact)(props, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => textAreaRef.current?.blur(),
            focus: () => textAreaRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            converter,
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: textAreaProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        return ((0, jsx_runtime_1.jsx)(UNSAFE_TextArea_1.TextArea, { ref: textAreaRef, ...assistiveTextProps, ...textAreaProps, columnSpan: props.columnSpan, variant: variant }));
    });
    const FunctionalTextAreaAutosize = (0, compat_1.forwardRef)((props, ref) => {
        const { addBusyState, converter, help, helpHints, validators } = props;
        const textAreaAutosizeRef = (0, hooks_1.useRef)();
        const { textAreaProps, methods } = (0, useTextAreaAutosizePreact_1.useTextAreaAutosizePreact)(props, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => textAreaAutosizeRef.current?.blur(),
            focus: () => textAreaAutosizeRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            converter,
            help,
            helpHints,
            userAssistanceDensity: textAreaProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        return ((0, jsx_runtime_1.jsx)(UNSAFE_TextAreaAutosize_1.TextAreaAutosize, { ref: textAreaAutosizeRef, ...assistiveTextProps, ...textAreaProps, columnSpan: props.columnSpan, variant: variant }));
    });
    /**
     * @classdesc
     * <h3 id="textAreaOverview-section">
     *   JET TextArea Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#textAreaOverview-section"></a>
     * </h3>
     *
     * <p>Description: The oj-c-text-area component enhances a browser textarea element.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-text-area value="value text">&lt;/oj-c-text-area></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>The required and placeholder properties also can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * Placeholder is shown when the field is empty and has focus.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to input. Show user assistance text.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the input. Show user assistance text.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     * <p>
     * The placeholder text is not read reliably by the screen reader. For accessibility reasons,
     * you need to associate the text to its JET form component using aria-describedby.
     * </p>
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     *
     * @ojmetadata displayName "TextArea"
     * @ojmetadata description "A text area allows the user to enter a multi-line text value."
     * @ojmetadata help "oj-c.TextArea.html"
     * @ojmetadata main "oj-c/text-area"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/text-area",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-text-input-area"
     *   }
     * }
     * @ojmetadata since "13.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-text-area"]
     *   }
     * ]
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    function TextAreaImpl({ autocomplete = 'on', columnSpan = 1, converter = null, containerReadonly: propContainerReadonly, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, labelWrapping: propLabelWrapping, length = lengthDefault, messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, resizeBehavior = 'none', textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, validators = validatorsDefault, value = null, ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const textAreaRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-text-area id=${id}: ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const FunctionalComp = otherProps.maxRows ? FunctionalTextAreaAutosize : FunctionalTextArea;
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => textAreaRef.current?.blur(),
            focus: () => textAreaRef.current?.focus(),
            reset: () => textAreaRef.current?.reset(),
            showMessages: () => textAreaRef.current?.showMessages(),
            validate: () => {
                return textAreaRef.current?.validate();
            }
        }), []);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        // Build the props bag we need to pass to FunctionalComp.
        const props = {
            addBusyState,
            autocomplete,
            converter,
            disabled,
            displayOptions,
            help,
            helpHints,
            length,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            resizeBehavior,
            userAssistanceDensity: uadValue,
            validators,
            value,
            ...otherProps
        };
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? otherProps.maxWidth : 'none',
            width: otherProps.width === 'md' || otherProps.width === 'sm' ? otherProps.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = otherProps.width === 'md' || otherProps.width === 'sm' ? undefined : otherProps.width;
        const maxWidthStyle = otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? undefined : otherProps.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        // Make sure to add the id on the Root element as it would have been removed
        // from there since it is from the ObservedGlobalProps.
        // layoutSpanColumn style class needs to be applied to the root dom element,
        // otherwise the css grid will ignore it.
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(FunctionalComp, { ref: textAreaRef, ...props, columnSpan: columnSpan }) }) }));
    }
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const TextAreaWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-text-area', (0, compat_1.forwardRef)(TextAreaImpl), "TextArea", { "properties": { "autocomplete": { "type": "string" }, "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "converter": { "type": "object|null" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "converterHint": { "type": "string", "enumValues": ["none", "display"] }, "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "length": { "type": "object", "properties": { "countBy": { "type": "string", "enumValues": ["codePoint", "codeUnit"] }, "counter": { "type": "string", "enumValues": ["none", "remaining"] }, "max": { "type": "number|null" } } }, "maxRows": { "type": "number" }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "placeholder": { "type": "string" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "resizeBehavior": { "type": "string", "enumValues": ["both", "none", "horizontal", "vertical"] }, "rows": { "type": "number" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "any", "writeback": true }, "width": { "type": "number|string" }, "rawValue": { "type": "string", "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id", "autofocus"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "autocomplete": "on", "columnSpan": 1, "converter": null, "disabled": false, "displayOptions": { "converterHint": "display", "messages": "display", "validatorHint": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "length": { "countBy": "codePoint", "counter": "remaining", "max": null }, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "resizeBehavior": "none", "validators": [], "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
    exports.TextArea = TextAreaWithoutDefaultedGenerics;
});

define('oj-c/text-area',["require", "exports", "oj-c/text-area/text-area"], function (require, exports, text_area_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextArea = void 0;
    Object.defineProperty(exports, "TextArea", { enumerable: true, get: function () { return text_area_1.TextArea; } });
});


define('oj-c/progress-bar/progress-bar',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_ProgressBar", "ojs/ojvcomponent", "css!oj-c/progress-bar/progress-bar-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_ProgressBar_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressBar = void 0;
    exports.ProgressBar = (0, ojvcomponent_1.registerCustomElement)('oj-c-progress-bar', 
    /**
     * @classdesc
     * <h3 id="progressBarOverview-section">
     *   JET Progress Bar
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#progressBarOverview-section"></a>
     * </h3>
     * The oj-c-progress-bar element allows a user to display progress of an operation in a rectangular horizontal meter.
     * If a developer does not wish to display the exact value, a value of '-1' can be passed in to display an indeterminate value.
     *
     * <pre class="prettyprint"><code>&lt;oj-c-progress-bar value='{{progressValue}}'>&lt;/oj-c-progress-bar></code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * To meet accessibility requirements, use one or more of the following ARIA attributes to provide meaningful text describing the purpose or status of the progress bar for assistive technologies:
     * </p>
     * <ul>
     *   <li>aria-label</li>
     *   <li>aria-labelledby</li>
     * </ul>
     *
     * <p>
     * These ARIA attributes help assistive technologies accurately convey loading status and context to users.
     * </p>
     *
     * <p>
     * If the progress bar is used to indicate the loading state of a specific region, the region element must have aria-describedby referencing the progress bars id. Include <code>aria-busy="true"</code> for the duration of the loading. Remove or set it to "false" once loading is complete.
     * </p>
     *
     * @ojmetadata description "A progress bar allows the user to visualize the progression of an extended computer operation."
     * @ojmetadata displayName "Progress Bar"
     * @ojmetadata help "oj-c.ProgressBar.html"
     * @ojmetadata main "oj-c/progress-bar"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-progress-bar"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/progress-bar"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-progress-linear",
     *     "uxSpecs": [
     *       "progress-bar"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "max"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "13.0.0"
     *
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     *
     */
    ({ max = 100, value = 0, edge = 'none', ...otherProps }) => {
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_ProgressBar_1.ProgressBar, { value: value === -1 ? 'indeterminate' : value, max: max, edge: edge, "aria-valuetext": otherProps['aria-valuetext'], "aria-label": otherProps['aria-label'], "aria-labelledby": otherProps['aria-labelledby'] }) }));
    }, "ProgressBar", { "properties": { "max": { "type": "number" }, "value": { "type": "number" }, "edge": { "type": "string", "enumValues": ["none", "top"] } }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["aria-valuetext", "aria-label", "aria-labelledby"] } }, { "max": 100, "value": 0, "edge": "none" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/progress-bar',["require", "exports", "oj-c/progress-bar/progress-bar"], function (require, exports, progress_bar_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressBar = void 0;
    Object.defineProperty(exports, "ProgressBar", { enumerable: true, get: function () { return progress_bar_1.ProgressBar; } });
});


define('oj-c/progress-circle/progress-circle',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_ProgressCircle", "ojs/ojvcomponent", "css!oj-c/progress-circle/progress-circle-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_ProgressCircle_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressCircle = void 0;
    exports.ProgressCircle = (0, ojvcomponent_1.registerCustomElement)('oj-c-progress-circle', 
    /**
     * @classdesc
     * <h3 id="progressCircleOverview-section">
     *   JET Progress Circle
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#progressCircleOverview-section"></a>
     * </h3>
     * The oj-c-progress-circle element allows a user to display progress of an operation with a circular meter.
     * If a developer does not wish to display the exact value, a value of '-1' can be passed in to display an indeterminate value.
     *
     * <pre class="prettyprint"><code>&lt;oj-c-progress-circle value='{{progressValue}}'>&lt;/oj-c-progress-circle></code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * To meet accessibility requirements, use one or more of the following ARIA attributes to provide meaningful text describing the purpose or status of the progress bar for assistive technologies:
     * </p>
     * <ul>
     *   <li>aria-label</li>
     *   <li>aria-labelledby</li>
     * </ul>
     *
     * <p>
     * These ARIA attributes help assistive technologies accurately convey loading status and context to users.
     * </p>
     *
     * <p>
     * If the progress circle is used to indicate the loading state of a specific region, the region element must have aria-describedby referencing the progress bars id. Include <code>aria-busy="true"</code> for the duration of the loading. Remove or set it to "false" once loading is complete.
     * </p>
     *
     * @ojmetadata description "A progress circle allows the user to visualize the progression of an extended computer operation."
     * @ojmetadata displayName "Progress Circle"
     * @ojmetadata help "oj-c.ProgressCircle.html"
     * @ojmetadata main "oj-c/progress-circle"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-progress-circle"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/progress-circle"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-circular-progress-7",
     *     "uxSpecs": [
     *       "progress-bar"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "max"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "13.0.0"
     *
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: [ "aria-label", "aria-labelledby"]
     *  }
     * ]
     *
     */
    ({ max = 100, value = 0, size = 'md', ...otherProps }) => {
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_ProgressCircle_1.ProgressCircle, { value: value === -1 ? 'indeterminate' : value, max: max, size: size, "aria-valuetext": otherProps['aria-valuetext'], "aria-label": otherProps['aria-label'], "aria-labelledby": otherProps['aria-labelledby'] }) }));
    }, "ProgressCircle", { "properties": { "max": { "type": "number" }, "value": { "type": "number" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg"] } }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["aria-valuetext", "aria-label", "aria-labelledby"] } }, { "max": 100, "value": 0, "size": "md" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/progress-circle',["require", "exports", "oj-c/progress-circle/progress-circle"], function (require, exports, progress_circle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressCircle = void 0;
    Object.defineProperty(exports, "ProgressCircle", { enumerable: true, get: function () { return progress_circle_1.ProgressCircle; } });
});


define('oj-c/avatar/avatar',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_Avatar", "ojs/ojvcomponent", "css!oj-c/avatar/avatar-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_Avatar_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Avatar = void 0;
    exports.Avatar = (0, ojvcomponent_1.registerCustomElement)('oj-c-avatar', 
    /**
     * @classdesc
     * <h3 id="avatarOverview-section">
     *   JET Avatar
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#avatarOverview-section"></a>
     * </h3>
     * <p>Description: Themeable, WAI-ARIA-compliant element that often represents a person.</p>
     * <p>An oj-c-avatar is an icon capable of displaying
     * a custom image, or initials, or a placeholder image.  The order of precedence for
     * what is displayed, in order from highest to lowest, is:</p>
     * <ol>
     *  <li>Icon specified through the "icon-class" attribute</li>
     *  <li>Custom image specified through the "src" attribute</li>
     *  <li>Initials specified through the "initials" attribute</li>
     *  <li>Default placeholder image</li>
     * </ol>
     * <pre class="prettyprint">
     * <code>//Avatar with initials
     * &lt;oj-c-avatar initials="AB">
     * &lt;/oj-c-avatar>
     *</code></pre>
     *  <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     *  </h3>
     *
     * <p>If any associated information (e.g. the name of the person represented by the oj-c-avatar) is already available to assistive technologies, for example by rendering the name in addition to the avatar as part of the page content, then setting the aria-label is optional.
     * Otherwise setting the aria-label is required by passing a descriptive text to the aria-label attribute. The component will then internally set role='img' if the aria-label is set.
     *
     * <p>JET Avatar does not have
     * any interaction with the application, therefore it is not keyboard navigable by default.
     * The aria-label will be picked up by the tabbable/focusable parent unless it is
     * overriden by the application.
     * The parent of the avatar is responsible for providing aria-* props and tooltip support if the avatar is informational or in
     * an actionable element
     *
     *
     * <p>In order to meet <a href="https://www.w3.org/TR/WCAG21/#contrast-minimum">accessibility requirements</a> for text, color contrast ratio
     * between the background color and text must be
     * greater than 4.5 for the two smallest avatars and 3.1 for the five larger avatars.
     * Avatar's default background satisfies the 4.5 color contrast ratio.  If colors are customized through theming, the
     * application is responsible for specifying colors that satisfy the contrast ratio requirements.
     *
     * <h3 id="image-section">
     *   Image
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#image-section"></a>
     *  </h3>
     *
     * <p>The avatar will display an icon if the iconClass is populated.  If it is not, then the avatar will display the image provided
     * from the src attribute if the src
     * attribute is populated.  If the src attribute is not provided and the initials have been,
     * the initials will be displayed.  If neither iconClass, src nor initials attributes are populated,
     * a single person placeholder image is shown.
     * Examples displaying each type of avatar:
     * <pre class="prettyprint">
     * <code>//Individual Placeholder
     * &lt;oj-c-avatar>
     *  &lt;/oj-c-avatar>
     * //Icon
     * &lt;oj-c-avatar icon-class="oj-ux-ico-contact-group">
     *  &lt;/oj-c-avatar>
     * //Initials
     *&lt;oj-c-avatar initials="AB">
     * &lt;/oj-c-avatar>
     * //Image
     *&lt;oj-c-avatar initials="AB" src="image.jpg">
     * &lt;/oj-c-avatar>
     *</code></pre>
     *
     *
     * @ojmetadata description "An avatar represents a person or entity as initials or an image."
     * @ojmetadata displayName "Avatar"
     * @ojmetadata help "oj-c.Avatar.html"
     * @ojmetadata main "oj-c/avatar"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-avatar"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/avatar"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-avatar",
     *     "uxSpecs": [
     *       "avatar"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "size",
     *       "background"
     *     ]
     *   }
     * ]
     * @ojmetadata since "13.0.0"
     */
    ({ src, iconClass, initials, shape = 'square', background = 'neutral', size = 'md', ...otherProps }) => {
        const icon = iconClass ? (0, jsx_runtime_1.jsx)("span", { class: iconClass }) : null;
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_Avatar_1.Avatar, { src: src ?? undefined, background: background, size: size, initials: initials ?? undefined, shape: shape, "aria-label": otherProps['aria-label'], children: icon }) }));
    }, "Avatar", { "properties": { "background": { "type": "string", "enumValues": ["blue", "gray", "green", "orange", "pink", "purple", "teal", "neutral", "slate", "lilac"] }, "initials": { "type": "string|null" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg", "xs", "2xs", "xl", "2xl"] }, "src": { "type": "string|null" }, "iconClass": { "type": "string" }, "shape": { "type": "string", "enumValues": ["square", "circle"] } }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["aria-label"] } }, { "shape": "square", "background": "neutral", "size": "md" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/avatar',["require", "exports", "oj-c/avatar/avatar"], function (require, exports, avatar_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Avatar = void 0;
    Object.defineProperty(exports, "Avatar", { enumerable: true, get: function () { return avatar_1.Avatar; } });
});


define('oj-c/button/button',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_Button", "@oracle/oraclejet-preact/UNSAFE_IconButton", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/hooks/UNSAFE_useTooltip", "@oracle/oraclejet-preact/utils/UNSAFE_mergeProps", "preact/hooks", "preact/compat", "css!oj-c/button/button-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_Button_1, UNSAFE_IconButton_1, UNSAFE_useTabbableMode_1, UNSAFE_useTooltip_1, UNSAFE_mergeProps_1, hooks_1, compat_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Button = void 0;
    /**
     * @classdesc
     * <h3 id="buttonOverview-section">
     *   JET Button
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonOverview-section"></a>
     * </h3>
     *
     * <p>Description: Themeable, WAI-ARIA-compliant push buttons, with appropriate styles for hover, active, and disabled.
     *
     * <pre class="prettyprint"><code>&lt;oj-c-button id="myButton" label="My Button">
     * &lt;/oj-c-button>
     * &lt;oj-c-button label="start icon">
     *   &lt;span slot='startIcon' class='myIconClass'>&lt;/span>
     * &lt;/oj-c-button>
     *  &lt;oj-c-button label="end icon">
     *   &lt;span slot='endIcon' class='myIconClass'>&lt;/span>
     * &lt;/oj-c-button>
     * </code></pre>
     *
     * <h3 id="pushButtons-section">
     *   Push Buttons
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pushButtons-section"></a>
     * </h3>
     *
     * <p>Push buttons are ordinary buttons that do not stay pressed in when clicked.
     * Push buttons are created from <code class="prettyprint">oj-c-button</code> elements.
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Push Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Push the button.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Push Button</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Push the button.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>For accessibility, it is not required to set an aria label on a JET button as it uses the label text to generate an aria label.
     * Therefore the label should be specified even if the button is <a href="#display">icon-only (display=icons)</a>. However,
     * you can override the default behavior by setting <code class="prettyprint">aria-label</code>.
     * The label can be hidden using the display attribute.
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "Buttons direct users to initiate or take actions and work with a single tap, click, or keystroke."
     * @ojmetadata displayName "Button"
     * @ojmetadata help "oj-c.Button.html"
     * @ojmetadata main "oj-c/button"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/button",
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-button",
     *     "uxSpecs": [
     *       "button"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "label",
     *       "tooltip",
     *       "display",
     *       "chroming",
     *       "size",
     *       "width",
     *       "edge",
     *       "disabled"
     *     ]
     *   }
     * ]
     * @ojmetadata since "13.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-button"]
     *   }
     * ]
     */
    function ButtonImpl({ chroming = 'outlined', disabled = false, size = 'md', display = 'all', endIcon, startIcon, edge = 'none', tooltip, width, label, onOjAction, 'aria-label': accessibleLabel, 'aria-describedby': ariaDescribedBy, ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const buttonRef = (0, hooks_1.useRef)(null);
        const isLabelButton = display != 'icons' ||
            (startIcon && endIcon && display == 'icons') ||
            (!startIcon && !endIcon && display == 'icons');
        const widthSize = { width: edge === 'bottom' ? '100%' : width };
        const widthProps = width || edge !== 'none' ? { style: widthSize } : {};
        const ariaProps = { 'aria-describedby': ariaDescribedBy, 'aria-label': accessibleLabel };
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => buttonRef.current?.blur(),
            focus: () => buttonRef.current?.focus(),
            click: () => buttonRef.current?.click()
        }), []);
        if (isLabelButton) {
            return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, ...widthProps, "aria-describedby": ariaDescribedBy, children: (0, jsx_runtime_1.jsx)(FunctionalButton, { ref: buttonRef, type: "submit", variant: chroming, tooltip: tooltip, isDisabled: disabled, width: '100%', onAction: onOjAction, startIcon: startIcon, endIcon: endIcon, size: size, label: display == 'icons' ? (!startIcon && !endIcon ? label : '') : label, display: display != 'icons' ? display : 'all', ...ariaProps, ...otherProps }) }));
        }
        else {
            return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, ...widthProps, "aria-describedby": ariaDescribedBy, children: (0, jsx_runtime_1.jsx)(UNSAFE_IconButton_1.IconButton, { width: '100%', ref: buttonRef, type: "submit", variant: chroming, isDisabled: disabled, tooltip: tooltip && tooltip !== '' ? tooltip : label, onAction: onOjAction, "aria-label": accessibleLabel && accessibleLabel !== '' ? accessibleLabel : label, "aria-describedby": ariaDescribedBy, size: size, ...otherProps, children: startIcon ?? endIcon }) }));
        }
    }
    exports.Button = (0, ojvcomponent_1.registerCustomElement)('oj-c-button', (0, compat_1.forwardRef)(ButtonImpl), "Button", { "properties": { "label": { "type": "string" }, "tooltip": { "type": "string" }, "disabled": { "type": "boolean" }, "width": { "type": "number|string" }, "display": { "type": "string", "enumValues": ["all", "label", "icons"] }, "size": { "type": "string", "enumValues": ["sm", "md", "lg", "xs"] }, "edge": { "type": "string", "enumValues": ["none", "bottom"] }, "chroming": { "type": "string", "enumValues": ["solid", "borderless", "outlined", "ghost", "callToAction", "danger"], "binding": { "consume": { "name": "containerChroming" } } } }, "slots": { "startIcon": {}, "endIcon": {} }, "events": { "ojAction": { "bubbles": true } }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "aria-label"] }, "methods": { "focus": {}, "blur": {}, "click": {} } }, { "chroming": "outlined", "disabled": false, "size": "md", "display": "all", "edge": "none" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const FunctionalButton = (0, compat_1.forwardRef)((props, ref) => {
        const { tooltipContent, tooltipProps } = (0, UNSAFE_useTooltip_1.useTooltip)({
            text: props.tooltip,
            isDisabled: props.isDisabled
        });
        return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(UNSAFE_Button_1.Button, { ref: ref, ...(0, UNSAFE_mergeProps_1.mergeProps)(props, tooltipProps) }), tooltipContent] }));
    });
});

define('oj-c/button',["require", "exports", "oj-c/button/button"], function (require, exports, button_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Button = void 0;
    Object.defineProperty(exports, "Button", { enumerable: true, get: function () { return button_1.Button; } });
});

define('oj-c/checkbox/useCheckboxPreact',["require", "exports", "preact/hooks", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/hooks/UNSAFE_useEditableValue/index", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle"], function (require, exports, hooks_1, useComponentMessages_1, index_1, UNSAFE_useTranslationBundle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCheckboxPreact = useCheckboxPreact;
    function useCheckboxPreact({ ['aria-describedby']: ariaDescribedBy, disabled, displayOptions, messagesCustom, readonly, readonlyUserAssistanceShown, requiredMessageDetail: propRequiredMessageDetail, required, userAssistanceDensity, value: propValue, onMessagesCustomChanged, onValidChanged, onValueChanged }, addBusyState) {
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const requiredMessageDetail = propRequiredMessageDetail || translations.checkbox_requiredMessageDetail();
        // Create a custom deferred validator since "false" is considered a value and
        // would pass the default validator returned by the useDeferredValidators hook.
        const deferredValidators = (0, hooks_1.useMemo)(() => {
            return [
                {
                    validate: (value) => {
                        if (required && value !== true) {
                            throw new Error(requiredMessageDetail);
                        }
                        return;
                    }
                }
            ];
        }, [requiredMessageDetail, required]);
        const { methods, onCommitValue, displayValue, refreshDisplayValue, textFieldProps } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy,
            defaultDisplayValue: false,
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            value: propValue
        });
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages: textFieldProps.messages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        // if the committed value is invalid (ie empty when required), we retain the last valid value
        // but give the internal Preact component a false display
        const onCommitHandler = (0, hooks_1.useCallback)(async ({ value }) => {
            // onCommitValue returns true if the value passes validation, otherwise it returns false.
            const commitSucceeded = await onCommitValue(value);
            const newValue = commitSucceeded ? value : false;
            refreshDisplayValue(newValue);
        }, [onCommitValue, refreshDisplayValue]);
        const checkboxProps = {
            'aria-describedby': textFieldProps['aria-describedby'],
            isRequired: required,
            isReadonly: readonly,
            isDisabled: disabled,
            messages,
            onCommit: onCommitHandler,
            userAssistanceDensity,
            value: displayValue
        };
        return {
            methods,
            checkboxProps
        };
    }
});


define('oj-c/checkbox/checkbox',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/hooks", "preact/compat", "ojs/ojcontext", "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_Checkbox", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "./useCheckboxPreact", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "css!oj-c/checkbox/checkbox-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, hooks_1, compat_1, Context, ojvcomponent_1, UNSAFE_Checkbox_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useTabbableMode_1, Layout_1, useAssistiveText_1, useCheckboxPreact_1, UNSAFE_classNames_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Checkbox = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const FunctionalCheckbox = (0, compat_1.forwardRef)(
    /**
     * @classdesc
     * <h3 id="checkboxOverview-section">
     *   JET Checkbox Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#checkboxOverview-section"></a>
     * </h3>
     *
     * Checkbox is a single standalone checkbox control. It represents a boolean value.
     *
     * <p>The Checkbox label is placed in the default slot and can be a short string or block of text
     * </p>
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-checkbox value="false">
     * I Agree
     * &lt;/oj-c-checkbox>
     * </code>
     * </pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
  
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="touch-section">
     * Touch End User Information
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *    <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Select/unselect the checkbox</td>
     *     </tr>
     *     <tr>
     *       <td>Checkbox's Label</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Select/unselect the corresponding checkbox</td>
     *    </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     * Keyboard End User Information
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus on the checkbox.
     *       Disabled checkboxes are not focusable.</td>
     *     </tr>
     *     <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Space</kbd></td>
     *       <td>Toggles the checkbox; If the checkbox is unselected, it will select it and vice versa.</td>
     *     </tr>
     *    <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Focus goes to the next focusable item after the oj-c-checkbox or help icon if present.</td>
     *     </tr>
     *    <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Shift+Tab</kbd></td>
     *       <td>Sets focus to the previous focusable item before the oj-c-checkbox.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     * Accessibility
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>Text as a label is required in the default slot to associate with the checkbox element</p>
     *
     *
     * @ojmetadata displayName "Checkbox"
     * @ojmetadata description "Checkbox is a single standalone checkbox control. It represents a boolean value."
     * @ojmetadata help "oj-c.Checkbox.html"
     * @ojmetadata main "oj-c/checkbox"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/checkbox",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-checkbox-on",
     *     "uxSpecs": [
     *       "checkbox"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "readonly",
     *       "required"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata requirements [
     *   {
     *     type: "anyOf",
     *     label: "accessibility",
     *     slots: [""]
     *   },
     *   {
     *     type: "not",
     *     label: "accessibility",
     *     properties: ["aria-label", "aria-labelledby"]
     *   }
     * ]
     * @ojmetadata since "16.0.0"
     */
    ({ ['aria-describedby']: ariaDescribedBy, children, columnSpan = 1, containerReadonly: propContainerReadonly, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, messagesCustom = messagesCustomDefault, onMessagesCustomChanged, onValidChanged, onValueChanged, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, requiredMessageDetail, userAssistanceDensity: propUserAssistanceDensity, value = false }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const checkboxRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((description) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-checkbox id=${id} is ${description}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping: undefined, // This component doesn't have labelWrapping
            propReadonly,
            propUserAssistanceDensity
        });
        const { checkboxProps, methods } = (0, useCheckboxPreact_1.useCheckboxPreact)({
            ['aria-describedby']: ariaDescribedBy,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onValidChanged,
            onValueChanged,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            requiredMessageDetail,
            userAssistanceDensity: uadValue,
            value
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => checkboxRef.current?.blur(),
            focus: () => checkboxRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: checkboxProps.userAssistanceDensity
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            containerProps.isFormLayout && 'in-form-layout'
        ]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_Checkbox_1.Checkbox, { ref: checkboxRef, ...assistiveTextProps, ...checkboxProps, columnSpan: columnSpan, children: children }) }) }));
    });
    const Checkbox = (0, ojvcomponent_1.registerCustomElement)('oj-c-checkbox', FunctionalCheckbox, "Checkbox", { "slots": { "": {} }, "properties": { "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "columnSpan": { "type": "number" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "requiredMessageDetail": { "type": "string" }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true }, "value": { "type": "boolean", "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "valid", "value"], "_READ_ONLY_PROPS": ["valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "columnSpan": 1, "disabled": false, "displayOptions": { "messages": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "value": false }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    exports.Checkbox = Checkbox;
});

define('oj-c/checkbox',["require", "exports", "oj-c/checkbox/checkbox"], function (require, exports, checkbox_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Checkbox = void 0;
    Object.defineProperty(exports, "Checkbox", { enumerable: true, get: function () { return checkbox_1.Checkbox; } });
});

define('oj-c/checkboxset/useCheckboxsetPreact',["require", "exports", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "preact/hooks", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators"], function (require, exports, UNSAFE_useTranslationBundle_1, index_1, useComponentMessages_1, hooks_1, useDeferredValidators_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCheckboxsetPreact = useCheckboxsetPreact;
    function useCheckboxsetPreact({ 'aria-describedby': ariaDescribedBy, disabled, displayOptions, labelEdge, labelHint, labelStartWidth, messagesCustom, readonly, readonlyUserAssistanceShown, requiredMessageDetail: propRequiredMessageDetail, required, userAssistanceDensity, value: propValue, onMessagesCustomChanged, onValidChanged, onValueChanged }, addBusyState) {
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const requiredMessageDetail = propRequiredMessageDetail || translations.checkboxSet_requiredMessageDetail();
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const { methods, displayValue, onCommitValue, refreshDisplayValue, textFieldProps } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy,
            defaultDisplayValue: null,
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            value: propValue
        });
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages: textFieldProps.messages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        // we want to normalize the value to an array
        // if the committed value is invalid (ie empty when required), we retain the last valid value
        // but give the internal Preact component an empty displayValue
        const onCommitHandler = (0, hooks_1.useCallback)(async ({ value }) => {
            const valueAsArray = value ? Array.from(value) : null;
            // onCommitValue returns true if the value passes validation, otherwise it returns false.
            const commitSuccessful = await onCommitValue(valueAsArray);
            const newValue = commitSuccessful ? valueAsArray : null;
            refreshDisplayValue(newValue);
        }, [onCommitValue, refreshDisplayValue]);
        return {
            methods,
            checkboxsetProps: {
                'aria-describedby': textFieldProps['aria-describedby'],
                isRequired: required,
                isReadonly: readonly,
                isDisabled: disabled,
                label: labelHint,
                labelEdge,
                labelStartWidth,
                messages,
                onCommit: onCommitHandler,
                userAssistanceDensity,
                value: displayValue
            }
        };
    }
});


define('oj-c/checkboxset/checkboxset',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/hooks", "preact/compat", "ojs/ojcontext", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_CheckboxSet", "@oracle/oraclejet-preact/UNSAFE_CheckboxItem", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "oj-c/hooks/UNSAFE_useDataProvider/useDataProvider", "./useCheckboxsetPreact", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "css!oj-c/checkboxset/checkboxset-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, hooks_1, compat_1, Context, Layout_1, ojvcomponent_1, UNSAFE_CheckboxSet_1, UNSAFE_CheckboxItem_1, UNSAFE_useFormContext_1, useMergedFormContext_1, UNSAFE_useTabbableMode_1, useAssistiveText_1, useDataProvider_1, useCheckboxsetPreact_1, UNSAFE_classNames_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Checkboxset = void 0;
    // TODO: refactor to a single util along with radioset 
    function isDataProvider(options) {
        return options && 'fetchFirst' in options;
    }
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    // Functional Component ------------------------------------------------------------- //
    const FunctionalCheckboxset = (0, compat_1.forwardRef)(
    /**
     *
     * @classdesc
     * <h3 id="checkboxsetOverview-section">
     *   JET Checkboxset Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#checkboxsetOverview-section"></a>
     * </h3>
     *
     * <p>
     * Description: A checkbox set enables the users to select one or multiple options in a set.
     * </p>
     *
     * <p>The options content can be configured via an array or a DataProvider.
     * It is recommended that a DataProvider should always be used for mutable data.
     * </p>
     *
     * <p>A JET Checkbox Set can be created with an array or DataProvider.</p>
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-checkboxset options="[[arrayOrDP]]">
     * &lt;/oj-c-checkboxset>
     * </code>
     * </pre>
     *
     * <p>
     *  You can enable and disable an oj-c-checkboxset,
     *  which will enable and disable all contained checkboxes.
     * </p>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
  
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline at the top of the checkboxset and is always displayed if there is any defined for the set.
     * See the user-assistance-density property for other ways the user assistance text can render. User assistance can also be provided at the
     * individual checkbox level which renders as a "?" icon and when clicked will display the assistive text in a pop-up.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction, and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then help-hints.definition shows;</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>
     * If the required property was set to true, this can also be used to guide the user.
     * In this case, the word Required will be rendered under the checkboxset when no value was set for the component.
     * </p>
     *
     * <h3 id="touch-section">
     * Touch End User Information
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *    <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Select/unselect the checkbox</td>
     *     </tr>
     *     <tr>
     *       <td>Checkbox's Label</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Select/unselect the corresponding checkbox</td>
     *    </tr>
     *     <tr>
     *       <td>Assistive help icon</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>If assistive text was setup for the checkbox, pop up the notewindow.</td>
     *    </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     * Keyboard End User Information
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Checkboxset</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the first focusable checkbox in the checkboxset.
     *       Disabled checkboxes are not focusable.</td>
     *     </tr>
     *     <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Space</kbd></td>
     *       <td>Toggles the checkbox; If the checkbox is unselected, it will select it and vice versa.</td>
     *     </tr>
     *    <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Sets focus to the next focusable checkbox in the checkboxset or help icon if it is present.
     *        Disabled checkboxes are not focusable. If focus is on the last focusable checkbox in the
     *        checkboxset, focus goes to the next focusable item after the oj-c-checkboxset.</td>
     *     </tr>
     *    <tr>
     *       <td>Checkbox</td>
     *       <td><kbd>Shift+Tab</kbd></td>
     *       <td>Sets focus to the previous focusable checkbox in the checkboxset.
     *        Disabled checkboxes are not focusable. If focus is on the first focusable checkbox in the
     *        checkboxset, focus goes to the previous focusable item before the oj-c-checkboxset.</td>
     *     </tr>
     *     <tr>
     *       <td>Assistive help icon</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>If the checkbox has assistive text, sets the focus on the icon. Hitting Enter or Space on the icon will launch a pop-up.
     *           Pressing F6 transfers the focus inside the popup and tabbing inside the popup will move focus to the link inside the popup, if one exists.
     *           Hitting Enter on the link will launch a new window with the url that was setup in the helpSourceLink property of the checkbox.
     *           See <a href="#CheckboxsetDataItem">CheckboxsetDataItem</a> for information on assistive properties of the checkbox.
     *       </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     * Accessibility
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>JET Checkboxset takes care of setting <code class="prettyprint">role="group"</code>.
     *
     * @ojmetadata displayName "Checkboxset"
     * @ojmetadata description "A checkbox set allows the user to select one or more options from a set."
     * @ojmetadata help "oj-c.Checkboxset.html"
     * @ojmetadata main "oj-c/checkboxset"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-checkboxset"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *  "vbdt": {
     *    "module": "oj-c/checkboxset",
     *    "defaultColumns": 6,
     *    "minColumns": 2
     *  },
     *  "oracle": {
     *    "icon": "oj-ux-ico-checkbox-on",
     *    "uxSpecs": [
     *    "checkboxset"
     *   ]
     *  }
     * }
     * @ojmetadata propertyLayout [
     * {
     *   "propertyGroup": "common",
     *   "items": [
     *   "disabled",
     *   "labelHint",
     *   "readonly",
     *   "required"
     *   ]
     * },
     * {
     *   "propertyGroup": "data",
     *   "items": [
     *   "value"
     *   ]
     * }
     * ]
     * @ojmetadata since "16.0.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint", "options"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    ({ id, options, containerReadonly: propContainerReadonly, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, disabled = false, direction = 'column', labelWrapping: propLabelWrapping, messagesCustom = messagesCustomDefault, columnSpan = 1, readonly: propReadonly, readonlyUserAssistanceShown = 'none', userAssistanceDensity: propUserAssistanceDensity, required = false, value = null, ...otherProps }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const checkboxsetRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((description = 'Checkboxset: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current).getBusyContext().addBusyState({ description })
                : () => { }; // if the component is not mounted return Noop
        }, []);
        const isFromDataProvider = isDataProvider(options);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity
        });
        const { checkboxsetProps, methods } = (0, useCheckboxsetPreact_1.useCheckboxsetPreact)({
            displayOptions,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            messagesCustom,
            disabled,
            value,
            userAssistanceDensity: uadValue,
            ...otherProps
        }, addBusyState);
        const { value: hookValue, ...checkboxsetRest } = checkboxsetProps;
        const { data } = (0, useDataProvider_1.useDataProvider)({
            data: isFromDataProvider ? options : undefined,
            addBusyState
        });
        const dataArr = (0, hooks_1.useMemo)(() => {
            // if the options are an array, we want to clone the prop
            const clonedOptions = !isFromDataProvider && options ? [...options] : [];
            return isFromDataProvider
                ? Array.isArray(data)
                    ? data.map((item) => ({ value: item.key, ...item.data }))
                    : []
                : clonedOptions;
        }, [data, isFromDataProvider, options]);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => checkboxsetRef.current?.blur(),
            focus: () => checkboxsetRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: uadValue
        });
        // ensure that the value is a Set type and memoize to prevent creating a new set with every rerender
        const memoizedSetValue = (0, hooks_1.useMemo)(() => (hookValue ? new Set(hookValue) : undefined), [hookValue]);
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            containerProps.isFormLayout && 'in-form-layout'
        ]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_CheckboxSet_1.CheckboxSet, { ref: checkboxsetRef, direction: direction, ...assistiveTextProps, ...checkboxsetRest, columnSpan: columnSpan, userAssistanceDensity: uadValue, value: memoizedSetValue, children: dataArr.map(({ assistiveText, helpSourceLink, helpSourceText, label, value }) => ((0, jsx_runtime_1.jsx)(UNSAFE_CheckboxItem_1.CheckboxItem, { assistiveText: assistiveText, helpSourceLink: helpSourceLink, helpSourceText: helpSourceText, value: value, children: label }, value))) }) }) }));
    });
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const CheckboxsetWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-checkboxset', FunctionalCheckboxset, "Checkboxset", { "properties": { "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "columnSpan": { "type": "number" }, "disabled": { "type": "boolean" }, "direction": { "type": "string", "enumValues": ["row", "column"] }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "options": { "type": "Array<object>|DataProvider" }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "requiredMessageDetail": { "type": "string" }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true }, "value": { "type": "Array<string|number>|null", "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "valid", "value"], "_READ_ONLY_PROPS": ["valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "displayOptions": { "messages": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "disabled": false, "direction": "column", "messagesCustom": [], "columnSpan": 1, "readonlyUserAssistanceShown": "none", "required": false, "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const Checkboxset = CheckboxsetWithoutDefaultedGenerics;
    exports.Checkboxset = Checkboxset;
});

define('oj-c/checkboxset',["require", "exports", "oj-c/checkboxset/checkboxset"], function (require, exports, checkboxset_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Checkboxset = void 0;
    Object.defineProperty(exports, "Checkboxset", { enumerable: true, get: function () { return checkboxset_1.Checkboxset; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/UNSAFE_meterUtils/meterUtils',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getThresholdColorByIndex = void 0;
    const THRESHOLD_COLORS = ['danger', 'warning', 'success'];
    const getThresholdColorByIndex = (threshold, index) => {
        if (threshold.color)
            return threshold.color;
        return THRESHOLD_COLORS[index % THRESHOLD_COLORS.length];
    };
    exports.getThresholdColorByIndex = getThresholdColorByIndex;
});


define('oj-c/rating-gauge/rating-gauge',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_RatingGauge", "ojs/ojvcomponent", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "../utils/UNSAFE_meterUtils/meterUtils", "@oracle/oraclejet-preact/utils/UNSAFE_stringUtils", "css!oj-c/rating-gauge/rating-gauge-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_RatingGauge_1, ojvcomponent_1, hooks_1, UNSAFE_useTabbableMode_1, meterUtils_1, UNSAFE_stringUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RatingGauge = void 0;
    exports.RatingGauge = (0, ojvcomponent_1.registerCustomElement)('oj-c-rating-gauge', 
    /**
     * @classdesc
     * <h3 id="ratingGaugeOverview-section">
     *   JET Rating Gauge
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#ratingGaugeOverview-section"></a>
     * </h3>
     * Rating gauges are typically used to display or accept user feedback on a product or service.
     * <pre class="prettyprint"><code>&lt;oj-c-rating-gauge value='4'>&lt;/oj-c-rating-gauge></code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     * The application is required to set one of the following attributes on the element with meaningful descriptors as the rating-gauge element does not provide a default descriptor.
     * </p>
     * <ul>
     *   <li>aria-label</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-describedby</li>
     * </ul>
     *
     * <p>
     * If the application is using readonly, thresholds or reference lines to provide additional context, they need to include such information for screender readers using either of the following methods:
     *  <ul>
     *   <li>aria-describedby</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-label</li>
     *   <li>datatip</li>
     *  </ul>
     * </p>
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * <h3 id="keyboardSection">
     *   Keyboard
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboardSection"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Submit the current value of the gauge.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Move focus to next element and submit the current value of the gauge.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>Move focus to previous element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>End</kbd></td>
     *       <td>Increase the gauge's transient value to max value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Home</kbd></td>
     *       <td>Decrease the gauge's transient value to zero. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Decrease the gauge's transient value in left-to-right locales. Increase the gauge's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Increase the gauge's transient value in left-to-right locales. Decrease the gauge's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="touch-section">
     * Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Drag</kbd></td>
     *       <td>Value change when <code class="prettyprint">readonly</code> or <code class="prettyprint">disabled</code> is <code class="prettyprint">false</code>.</td>
     *     </tr>
     *   </tbody>
     * </table>
     * <br>
     *
     * @ojmetadata description "Rating gauges are typically used to display or accept user feedback on a product or service."
     * @ojmetadata displayName "Rating Gauge"
     * @ojmetadata main "oj-c/rating-gauge"
     * @ojmetadata help "oj-c.RatingGauge.html"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-rating-gauge"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/rating-gauge"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-gauge-rating",
     *     "uxSpecs": [
     *       "gauge"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "style"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value",
     *       "max",
     *       "step"
     *     ]
     *   }
     * ]
     * @ojmetadata since "13.0.0"
     *
     * @ojmetadata requirements [
     *   {
     *     type: "anyOf",
     *     label: "accessibility",
     *     properties: ["aria-label", "aria-labelledby", "aria-describedby", "described-by", "labelled-by"]
     *   }
     * ]
     *
     */
    ({ max = 5, value = 0, size = 'md', color = 'neutral', step = 1, readonly = false, disabled = false, changed = false, ...otherProps }) => {
        const [hoveredVal, setHoveredVal] = (0, hooks_1.useState)();
        const inputHandler = (detail) => {
            setHoveredVal(detail.value);
            otherProps.onTransientValueChanged?.(detail.value);
        };
        const commitHandler = (detail) => {
            otherProps.onValueChanged?.(detail.value);
            if (!changed) {
                otherProps.onChangedChanged?.(true);
            }
        };
        const thresholds = otherProps.thresholds?.map((threshold, index) => {
            return {
                ...threshold,
                color: (0, meterUtils_1.getThresholdColorByIndex)(threshold, index)
            };
        });
        const preactRatingGaugeAriaLabelledBy = (0, UNSAFE_stringUtils_1.merge)([
            otherProps['aria-labelledby'],
            otherProps.labelledBy
        ]);
        const preactRatingGaugeAriaDescribedBy = (0, UNSAFE_stringUtils_1.merge)([
            otherProps['aria-describedby'],
            otherProps.describedBy
        ]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_RatingGauge_1.RatingGauge, { isReadonly: readonly, isDisabled: disabled, value: (hoveredVal != undefined ? hoveredVal : value), step: step, max: max, size: size, color: color, thresholds: thresholds, tooltip: otherProps.tooltip, datatip: otherProps.datatip?.({
                    value: hoveredVal != undefined ? hoveredVal : value
                }), onCommit: commitHandler, onInput: inputHandler, "aria-label": otherProps['aria-label'], "aria-labelledby": preactRatingGaugeAriaLabelledBy ?? undefined, "aria-describedby": preactRatingGaugeAriaDescribedBy ?? undefined }) }));
    }, "RatingGauge", { "properties": { "max": { "type": "number" }, "readonly": { "type": "boolean" }, "disabled": { "type": "boolean" }, "changed": { "type": "boolean", "writeback": true }, "value": { "type": "number|null", "writeback": true }, "step": { "type": "number" }, "describedBy": { "type": "string|null" }, "labelledBy": { "type": "string|null" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg"] }, "color": { "type": "string", "enumValues": ["gold", "neutral"] }, "thresholds": { "type": "Array<object>" }, "datatip": { "type": "function" }, "tooltip": { "type": "string" }, "transientValue": { "type": "number", "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["changed", "value", "transientValue"], "_READ_ONLY_PROPS": ["transientValue"], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby", "aria-describedby"] } }, { "max": 5, "value": 0, "size": "md", "color": "neutral", "step": 1, "readonly": false, "disabled": false, "changed": false }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/rating-gauge',["require", "exports", "oj-c/rating-gauge/rating-gauge"], function (require, exports, rating_gauge_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RatingGauge = void 0;
    Object.defineProperty(exports, "RatingGauge", { enumerable: true, get: function () { return rating_gauge_1.RatingGauge; } });
});

define('oj-c/select-common/utils/utils',["require", "exports", "ojs/ojdataprovider", "@oracle/oraclejet-preact/utils/UNSAFE_logger"], function (require, exports, ojdataprovider_1, UNSAFE_logger_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_VALUE_ITEMS = exports.DEFAULT_VALUE_ITEM = exports.DEFAULT_VALUE = exports.DEFAULT_ITEM_CONTEXT = void 0;
    exports.isEmpty = isEmpty;
    exports.isSetEqual = isSetEqual;
    exports.getFilterCriterion = getFilterCriterion;
    // default values
    exports.DEFAULT_ITEM_CONTEXT = null;
    exports.DEFAULT_VALUE = null;
    exports.DEFAULT_VALUE_ITEM = null;
    exports.DEFAULT_VALUE_ITEMS = null;
    // helpers
    /**
     * Checks if the provided value is empty
     *
     * @param value A single value or an array containing values
     * @returns result of the empty check
     */
    function isEmpty(value) {
        if (!value)
            return true;
        if (Array.isArray(value))
            return value.length === 0;
        if (value instanceof Set || value instanceof Map)
            return value.size === 0;
        return false;
    }
    /**
     * Checks whether the content of two sets are the same.
     *
     * @param a First Set
     * @param b Second Set
     * @returns Equality result
     */
    function isSetEqual(a, b) {
        if (a === b)
            return true;
        if (a?.size !== b?.size)
            return false;
        const aArray = Array.from(a);
        const bArray = Array.from(b);
        return aArray.every((value, index) => value === bArray[index]);
    }
    /**
     * Get the filter criterion to use for fetching data.
     * @param dataProvider The DataProvider to fetch data from
     * @param searchText User-typed search text
     * @param paramMatchBy Array of preferred strategies for matching the search text
     * @returns Filter criterion to use for fetching data
     */
    function getFilterCriterion(dataProvider, searchText, paramMatchBy) {
        const hasSearchText = searchText && searchText.length > 0;
        if (!hasSearchText) {
            return undefined;
        }
        // slightly modify the type of arMatchBy to allow null items so that we can initialize our
        // reducer function with null
        const arMatchBy = paramMatchBy;
        const hasMatchBy = arMatchBy && arMatchBy.length > 0;
        const filterCapability = dataProvider?.getCapability('filter');
        const hasTextFilterCapability = filterCapability && filterCapability.textFilter;
        if (dataProvider && hasSearchText && !hasTextFilterCapability) {
            (0, UNSAFE_logger_1.error)('Core Pack Select: DataProvider does not support text filter.  ' +
                'Filtering results in dropdown may not work correctly.');
        }
        // JET-66079 - Add option to specify the matchBy behavior of the text filter to Core Pack Selects
        // Find the first matchBy behavior in the array that the data provider supports.
        const matchBy = dataProvider && hasTextFilterCapability && hasSearchText && hasMatchBy
            ? arMatchBy.reduce((result, curr) => {
                // if we've already found a supported matchBy, use it
                if (result) {
                    return result;
                }
                // if we've encountered 'unknown' in the array, return it because it's always supported
                if (curr === 'unknown') {
                    return curr;
                }
                // if we haven't found a supported matchBy yet, see if the current one is supported and
                // return it if so; if not log a warning
                if (curr) {
                    if (filterCapability.textFilterMatching &&
                        filterCapability.textFilterMatching.matchBy &&
                        filterCapability.textFilterMatching.matchBy.indexOf(curr) > -1) {
                        return curr;
                    }
                    (0, UNSAFE_logger_1.warn)(`Core Pack Select: DataProvider does not support text filter "${curr}" matching.  ` +
                        'Filtering results in dropdown may not work as expected.');
                }
                // if we haven't found a supported matchBy yet, return undefined and go on
                return undefined;
            }, null)
            : undefined;
        // create filter using FilterFactory so that default local filtering will happen if
        // underlying DP doesn't support its own filtering
        const filterDef = matchBy ? { text: searchText, matchBy } : { text: searchText };
        const fc = ojdataprovider_1.FilterFactory.getFilter({ filterDef });
        return fc;
    }
});

define('oj-c/select-common/PRIVATE_useCache/useCache',["require", "exports", "preact/hooks", "../utils/utils"], function (require, exports, hooks_1, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCache = useCache;
    /**
     * A custom hook to cache individual properties in an object.
     */
    function useCache() {
        const cache = (0, hooks_1.useRef)(new Map());
        return (0, hooks_1.useCallback)((key, value, deps) => {
            // If the deps changed for the key, then update the cache and return the new value
            if (isChanged(cache.current, key, deps)) {
                cache.current.set(key, { value, deps });
                return value;
            }
            // otherwise return the value from the cache
            return cache.current.get(key).value;
        }, []);
    }
    const isChanged = (cache, key, deps) => {
        // if not found in cache, then we consider that as changed
        if (!cache.has(key))
            return true;
        // if found in cache, then check the deps
        const oldDeps = cache.get(key).deps;
        return (oldDeps.length !== deps.length || oldDeps.some((value, index) => !isEquals(value, deps[index])));
    };
    const isEquals = (value1, value2) => {
        if (value1 === value2)
            return true;
        // For time being we only care about Set and in the future we can add
        // support for more types.
        if (value1 instanceof Set && value2 instanceof Set) {
            return (0, utils_1.isSetEqual)(value1, value2);
        }
        // fallback to ===
        return value1 === value2;
    };
});

define('oj-c/select-common/PRIVATE_useCache/index',["require", "exports", "./useCache"], function (require, exports, useCache_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCache = void 0;
    Object.defineProperty(exports, "useCache", { enumerable: true, get: function () { return useCache_1.useCache; } });
});

define('oj-c/hooks/UNSAFE_useListData/useListData',["require", "exports", "ojs/ojabortreason", "ojs/ojdataproviderfactory", "preact/hooks"], function (require, exports, ojabortreason_1, ojdataproviderfactory_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEmptyState = exports.useListData = void 0;
    /**
     * initial state of the reducer
     */
    const initialState = Object.freeze({
        status: 'loading',
        data: null
    });
    const defaultOptions = {
        isInitialFetchDeferred: false
    };
    const DEFAULT_FETCH_SIZE = 25;
    //TODO: Eslint warning need to be solved due to calling hooks conditionally.JET-63985
    /**
     * A hook that takes a DataProvider and returns a DataService object and a loadMore function.
     * @param data the DataProvider
     * @param options the optional arguments used for fetchFirst
     */
    const useListData = (data, options = defaultOptions) => {
        const fetchNextRef = (0, hooks_1.useRef)(null);
        const totalSizeRef = (0, hooks_1.useRef)(0);
        const isDoneRef = (0, hooks_1.useRef)(false);
        const iteratorRef = (0, hooks_1.useRef)(null);
        const abortControllerRef = (0, hooks_1.useRef)(null);
        const fetchSize = options.fetchSize && options.fetchSize > 0 ? options.fetchSize : DEFAULT_FETCH_SIZE;
        // it should return the same instance as long as the DataProvider didn't change
        const dataProvider = (0, hooks_1.useMemo)(() => wrapData(data), [data]);
        const [state, dispatch] = (0, hooks_1.useReducer)(reducer, options.initialRowsFetched === 0 ? (0, exports.getEmptyState)('atLeast') : initialState);
        /**
         * Fetch the range from DataProvider.  The results should have already been cached.
         * @param range requested range
         */
        const fetchRange = (0, hooks_1.useCallback)(async (range, resultsCallback) => {
            if (dataProvider == null) {
                return;
            }
            const fetchOptions = {
                attributes: options.attributes,
                sortCriteria: options.sortCriteria,
                filterCriterion: options.filterCriterion,
                offset: range.offset,
                size: range.count
            };
            // don't use done from result as the impl is behaving differently between DataProviders
            // ex: fetchByOffset in ADP will set done to false if the range is within total size
            // ex: fetchByOffset in CachingDP will set done to true if cache is hit
            const sizePrecision = isDoneRef.current === true ? 'exact' : 'atLeast';
            if (range.count === 0) {
                // this could happen when inserting to an empty list
                // the mutation triggers re-rendering of the current range, which would be 0
                // the load more should then trigger to fetch the next set of data
                // (sizePrecision should be 'atLeast')
                dispatch({
                    status: 'success',
                    data: {
                        offset: range.offset,
                        data: [],
                        totalSize: totalSizeRef.current,
                        sizePrecision: sizePrecision
                    }
                });
                return;
            }
            try {
                const result = await dataProvider.fetchByOffset(fetchOptions);
                const results = result['results'];
                if (resultsCallback) {
                    resultsCallback(results);
                }
                dispatch({
                    status: 'success',
                    data: {
                        offset: range.offset,
                        data: results,
                        totalSize: totalSizeRef.current,
                        sizePrecision: sizePrecision
                    }
                });
            }
            catch (error) {
                dispatch({
                    status: 'error',
                    error: error
                });
            }
        }, [dataProvider, options.attributes, options.filterCriterion, options.sortCriteria]);
        /**
         * Initial load.  Invoke fetchFirst against DataProvider.
         */
        const loadInitial = (0, hooks_1.useCallback)(async () => {
            if (dataProvider == null) {
                return;
            }
            // abort an ongoing fetch request because we are issuing a new one and would ignore any
            // results from the existing one
            if (state.status === 'loading') {
                abortControllerRef.current?.abort((0, ojabortreason_1.getAbortReason)());
            }
            // put it back to loading status if it is not the case already
            dispatch({ status: 'loading', data: null });
            const controller = new AbortController();
            abortControllerRef.current = controller;
            // the fetch size is hard coded to the default value of 25 for now, could be something
            // configurable in the future
            const iterator = dataProvider
                .fetchFirst({
                attributes: options.attributes,
                sortCriteria: options.sortCriteria,
                filterCriterion: options.filterCriterion,
                size: fetchSize,
                signal: controller.signal
            })[Symbol.asyncIterator]();
            iteratorRef.current = iterator;
            try {
                const result = await iterator.next();
                // JET-58561 - typing multiple characters quickly doesn't always filter correctly
                // if this is not the most recent call to fetchFirst, simply ignore the results and return
                if (iterator !== iteratorRef.current) {
                    return;
                }
                const fetchParameters = result.value.fetchParameters;
                if (fetchParameters.signal && fetchParameters.signal.aborted) {
                    return;
                }
                totalSizeRef.current = result.value.data.length;
                if (result.done !== undefined) {
                    isDoneRef.current = result.done;
                }
                const initialFetchSize = options.initialRowsFetched && options.initialRowsFetched > 0
                    ? options.initialRowsFetched
                    : fetchSize;
                fetchRange({ offset: 0, count: Math.min(totalSizeRef.current, initialFetchSize) });
            }
            catch (error) {
                if (error instanceof DOMException && error.name === 'AbortError') {
                    // if this is due to abort from refresh, then we should not dispatch
                    // error since there is already another fetch started
                    return;
                }
                dispatch({
                    status: 'error',
                    error: error
                });
                iteratorRef.current = null;
            }
        }, [
            dataProvider,
            fetchRange,
            fetchSize,
            options.attributes,
            options.filterCriterion,
            options.initialRowsFetched,
            options.sortCriteria,
            options.fetchSize
        ]);
        // this particular implementation is tailored towards the incremental fetching
        // model, where it incrementally increases the totalSize and use 'atLeast' for
        // precision until data is exhausted.
        const loadRange = (0, hooks_1.useCallback)(async (range) => {
            // no iterator due to isInitialFetchDeferred set to true
            if (iteratorRef.current === null) {
                loadInitial();
            }
            else {
                const endIndex = range.offset + range.count;
                // if the requested range falls outside of what we have so far, we'll need to fetch
                // next set of result from iterator to populate the cache in CachedIteratingResultsDP
                if (endIndex > totalSizeRef.current) {
                    // this shouldn't happen, but if there is an on-going iterator.next() - i.e. currentFetchNext.current
                    // is non-null, we don't want to invoke iterator.next() again. Ignore this loadRange request as the
                    // on-going request should result in an updated DataState, and the component will request another
                    // loadRange in the case if the result does not satisfy the viewport
                    if (fetchNextRef.current == null) {
                        const promise = fetchNextUntilThresholdOrDone(iteratorRef, totalSizeRef.current, endIndex);
                        fetchNextRef.current = promise;
                        try {
                            const value = await promise;
                            if (value.done !== undefined) {
                                isDoneRef.current = value.done;
                            }
                            const total = value.total;
                            // when total is 0 and done is true, need to call fetchRange again to update sizePrecision to exact
                            if (total > 0 || (total === 0 && isDoneRef.current)) {
                                totalSizeRef.current = total;
                                // have to adjust the range otherwise fetchByOffset in CachedIteratingResultsDP will skip the cache
                                // and go directly against it's underlying DP
                                fetchRange({
                                    offset: range.offset,
                                    count: Math.min(totalSizeRef.current - range.offset, range.count)
                                });
                            }
                            fetchNextRef.current = null;
                        }
                        catch (error) {
                            dispatch({
                                status: 'error',
                                error: error
                            });
                            fetchNextRef.current = null;
                        }
                    }
                }
                else {
                    // within cache, invoke fetchByOffset against cached data
                    fetchRange(range);
                }
            }
        }, [loadInitial, fetchRange]);
        const resetAndLoad = (0, hooks_1.useCallback)(() => {
            // reset value of refs
            iteratorRef.current = null;
            fetchNextRef.current = null;
            totalSizeRef.current = 0;
            isDoneRef.current = false;
            if (options.initialRowsFetched === 0) {
                dispatch((0, exports.getEmptyState)('atLeast'));
            }
            else if (!options.isInitialFetchDeferred) {
                loadInitial();
            }
            else {
                dispatch({ status: 'loading', data: null });
            }
        }, [loadInitial, options.isInitialFetchDeferred, options.initialRowsFetched]);
        // runs on mounted and also if data or any of the options have changed, in which case we should do fetchFirst again
        (0, hooks_1.useEffect)(() => {
            if (dataProvider) {
                resetAndLoad();
            }
        }, [dataProvider, resetAndLoad]);
        const handleMutation = (0, hooks_1.useCallback)((event) => {
            if (state.status === 'success' && state.data) {
                const dataState = state.data;
                let count = dataState.data.length;
                let shouldUpdate = false;
                if (event.detail.add) {
                    const itemsInserted = handleAddRemoveMutation(event.detail.add, dataState, options, true);
                    totalSizeRef.current = totalSizeRef.current + itemsInserted;
                    count = count + itemsInserted;
                    // should update if items inserted within range or if the data is already exhausted
                    shouldUpdate = itemsInserted > 0 || dataState.sizePrecision === 'exact';
                    // if some inserted item is outside of range, then we should make sure we'll fetch them
                    // this is done by setting sizePrecision to 'atLeast' so that it will trigger the component
                    // to check viewport and fetch next set of items as needed
                    if (itemsInserted < event.detail.add.data.length) {
                        isDoneRef.current = false;
                    }
                }
                if (event.detail.remove) {
                    const itemsRemoved = handleAddRemoveMutation(event.detail.remove, dataState, options, false);
                    totalSizeRef.current = Math.max(0, totalSizeRef.current - itemsRemoved);
                    count = Math.max(0, count - itemsRemoved);
                    shouldUpdate = shouldUpdate || itemsRemoved > 0;
                }
                let callback;
                const updateDetail = event.detail.update;
                if (updateDetail) {
                    shouldUpdate = shouldUpdate || handleUpdateMutation(updateDetail, dataState, options);
                    callback = (results) => {
                        processDataAfterUpdate(updateDetail, dataState, results);
                    };
                }
                if (shouldUpdate) {
                    fetchRange({ offset: dataState.offset, count }, callback);
                }
            }
        }, [state, options, fetchRange]);
        const handleRefresh = (0, hooks_1.useCallback)((event) => {
            let adjustment = -1;
            const disregardAfterKey = event.detail?.disregardAfterKey;
            if (disregardAfterKey && state.status === 'success') {
                const index = state.data.data.findIndex((value) => {
                    return value.metadata.key === disregardAfterKey;
                });
                if (index > -1) {
                    // - 1 because the disregardAfterKey itself is included
                    adjustment = state.data.data.length - index - 1;
                }
                // disregardAfterKey is the last item in viewport, no need to fetch or re-render
                // the only case is if the range is smaller than viewport, for example, if disregardAfteRKey
                // is the last item of the entire data (we reached totalSize), then we'll want to fetch more
                if (adjustment === 0 && state.data.data.length >= fetchSize) {
                    return;
                }
            }
            if (adjustment > -1 && state.status === 'success') {
                totalSizeRef.current = totalSizeRef.current - adjustment;
                // this should caused next() to be called first
                loadRange({
                    offset: state.data.offset,
                    count: Math.max(state.data.data.length, fetchSize)
                });
            }
            else {
                // abort any current fetch request
                if (state.status === 'loading') {
                    abortControllerRef.current?.abort();
                }
                resetAndLoad();
            }
        }, [state, fetchSize, loadRange, resetAndLoad]);
        // handles refresh event from DataProvider
        (0, hooks_1.useEffect)(() => {
            if (dataProvider) {
                dataProvider.addEventListener('refresh', handleRefresh);
                dataProvider.addEventListener('mutate', handleMutation);
            }
            return () => {
                if (dataProvider) {
                    dataProvider.removeEventListener('refresh', handleRefresh);
                    dataProvider.removeEventListener('mutate', handleMutation);
                }
            };
        }, [dataProvider, resetAndLoad, handleMutation, handleRefresh]);
        // Consuming components, e.g. oj-c-select-multiple can legitimately pass a null dataProvider
        // ..short circuit in that case with a success, an empty dataset, and a no-op LoadRange.
        if (!data) {
            const emptyListState = (0, exports.getEmptyState)('exact');
            return [emptyListState, (_) => Promise.resolve()];
        }
        return [state, loadRange];
    };
    exports.useListData = useListData;
    // wraps the DataProvider with an enhance DataProvider that will provide caching
    const wrapData = (data) => {
        if (data == null) {
            return null;
        }
        const configuration = {
            fetchFirst: { caching: 'visitedByCurrentIterator', forceLocalCaching: 'enabled' }
        };
        return (0, ojdataproviderfactory_1.getEnhancedDataProvider)(data, configuration);
    };
    const reducer = (state, action) => {
        // avoid re-render if status is loading and hasn't change
        if (state.status === action.status && action.status === 'loading') {
            return state;
        }
        return action;
    };
    /**
     * Call next() until either threshold has been reached or there's no more data
     * @param iteratorRef ref object that contains the current iterator
     * @param current the current number of items fetched
     * @param threshold the threshold size to reach
     * @return promise that resolves to the updated current number of items fetched
     */
    const fetchNextUntilThresholdOrDone = async (iteratorRef, current, threshold) => {
        return await fetchNextRecursive(iteratorRef, current, threshold);
    };
    /**
     * Do the recursive work for fetchNextUntilThresholdOrDone
     * @param iteratorRef ref object that contains the current iterator
     * @param currentCount the current number of items fetched
     * @param threshold the threshold size to reach
     * @param resolve
     * @param reject
     */
    const fetchNextRecursive = async (iteratorRef, currentCount, threshold) => {
        const currentIterator = iteratorRef.current;
        if (currentIterator === null) {
            return { total: -1, done: undefined };
        }
        const result = await currentIterator.next();
        // must ensure the current iterator is still valid
        if (currentIterator === iteratorRef.current) {
            currentCount += result.value.data.length;
            if (currentCount >= threshold || result.done) {
                return { total: currentCount, done: result.done };
            }
            return fetchNextRecursive(iteratorRef, currentCount, threshold);
        }
        return { total: -1, done: undefined };
    };
    /**
     * Helper to create an empty DataState object
     * @param precision
     * @returns
     */
    const getEmptyState = (precision) => {
        return (precision === 'atLeast' ? emptyStateAtLeast : emptyStateExact);
    };
    exports.getEmptyState = getEmptyState;
    const emptyStateAtLeast = Object.freeze({
        status: 'success',
        data: {
            offset: 0,
            data: [],
            totalSize: 0,
            sizePrecision: 'atLeast'
        }
    });
    const emptyStateExact = Object.freeze({
        status: 'success',
        data: {
            offset: 0,
            data: [],
            totalSize: 0,
            sizePrecision: 'exact'
        }
    });
    /**
     * Helper to handle add and remove mutation events from DataProvider
     * @param detail
     * @param dataState
     * @param options
     * @returns the number of items that are inserted or removed before the fetched data
     */
    const handleAddRemoveMutation = (detail, dataState, options, isAdd) => {
        let itemCount = 0;
        // indexes cannot be used if there is a sort or filter criteria set on fetch since the indexes
        // is most likely (doesn't specified in the contract) relative to the global data vs. data in DataState is based on
        // sorted/filtered data
        if (isIndexesAvailable(detail, options)) {
            // for add, the indexes are index of the item AFTER mutation, so the range of fetched data will need to be adjusted
            // for each in range item.  In order to do that correctly, the indexes must be sorted so that we process the
            // item with smallest index first
            const indexes = isAdd ? detail.indexes?.sort((a, b) => a - b) : detail.indexes;
            // we use totalSize since useListData use the high watermark model, so totalSize should reflect how many it's been fetched so far
            let endIndex = dataState.totalSize - 1;
            indexes?.forEach((index) => {
                // if index is before what we have fetched already
                if (index <= endIndex) {
                    itemCount = itemCount += 1;
                    if (isAdd) {
                        endIndex = endIndex += 1;
                    }
                }
            });
        }
        else {
            if (isAdd) {
                // TODO: for add, handle case where indexes are not available, see JET-52923
            }
            else {
                // only remove the data that's already fetched
                const allKeys = dataState.data.map((d) => d.metadata.key);
                detail.keys.forEach((key) => {
                    if (allKeys.includes(key)) {
                        itemCount += 1;
                    }
                });
            }
        }
        return itemCount;
    };
    /**
     * Helper to handle update mutation events from DataProvider
     * @param detail
     * @param dataState
     * @param options
     * @returns true if update occurs in the current viewport, false otherwise
     */
    const handleUpdateMutation = (detail, dataState, options) => {
        if (isIndexesAvailable(detail, options)) {
            const indexes = detail.indexes ? detail.indexes : [];
            const startIndex = dataState.offset;
            const endIndex = startIndex + dataState.data.length;
            for (let i = 0; i < indexes.length; i++) {
                if (indexes[i] >= startIndex && indexes[i] < endIndex) {
                    return true;
                }
            }
        }
        else {
            // only update the data that's already fetched
            const detailKeys = Array.from(detail.keys);
            const allKeys = dataState.data.map((d) => d.metadata.key);
            for (let i = 0; i < detailKeys.length; i++) {
                const key = detailKeys[i];
                if (allKeys.includes(key)) {
                    return true;
                }
            }
        }
        return false;
    };
    /**
     * Perform any processing logic after results are fetched triggered by an update event
     * @param detail
     * @param dataState
     * @param results
     */
    const processDataAfterUpdate = (detail, dataState, results) => {
        detail.keys.forEach((key) => {
            const updatedData = results.find((item) => {
                return item.metadata.key == key;
            });
            const currentData = dataState.data.find((item) => {
                return item.metadata.key == key;
            });
            // we'll need to ensure that the updated data is not the same reference
            // as what's in DataState now.  If that is the case we must wrap the data
            // in a Proxy so that the reference is different and Collection will not
            // skip rendering as part of its optimization
            if (currentData && updatedData && currentData.data === updatedData.data) {
                updatedData.data = new Proxy(updatedData.data, {});
            }
        });
    };
    /**
     * Returns true if indexes can be used from the mutation event, false otherwise.
     * @param detail
     * @param options
     * @returns
     */
    const isIndexesAvailable = (detail, options) => {
        // indexes cannot be used if there is a sort or filter criteria set on fetch since the indexes
        // is most likely (doesn't specified in the contract) relative to the global data vs. data in DataState is based on
        // sorted/filtered data
        return detail.indexes && options.sortCriteria == null && options.filterCriterion == null;
    };
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-common/PRIVATE_DebouncingDataProviderView/Debouncer',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Debouncer = void 0;
    /**
     * Helper class for debouncing fetch requests.
     */
    class Debouncer {
        constructor() {
            // The algorithm will calculate the debounce time as follows:
            // debounceTime = (1 + (responseTime - 1.2 * requestTime) / responseTime) * 1.2 * requestTime
            //
            // Rewriting to solve for response time:
            // debounceTime = (2 - 1.2 * requestTime / responseTime) * 1.2 * requestTime
            // debounceTime * responseTime / (1.2 * requestTime) = 2 * responseTime - 1.2 * requestTime
            // responseTime = 1.2 * requestTime / (2 - debounceTime / (1.2 * requestTime))
            //
            // We want our default debounce times to start out higher for fewer characters typed and
            // decrease as the number of characters increases, so we will define our default
            // buckets of response times based on some of these example calculations.
            // (We don't want the default response time to be less than 1.2 * default requestTime (250),
            // because then the logic will use a debounce time of 0 because the response is expected to
            // return before the user types again.)
            // debounce | request | response
            // ---------|---------|---------
            //  500     | 250     | 900
            //  475     | 250     | 720
            //  450     | 250     | 600
            //  425     | 250     | 514
            //  400     | 250     | 450
            //  375     | 250     | 400
            //  350     | 250     | 360
            //  325     | 250     | 327
            //  300     | 250     | 300
            this._responseTimes = [
                { time: 900, count: 0 },
                { time: 720, count: 0 },
                { time: 600, count: 0 },
                { time: 450, count: 0 },
                { time: 360, count: 0 },
                { time: 300, count: 0 }
            ];
            this._requestTime = { time: 250, count: 0 };
            this._lastRequestTime = 0;
        }
        /**
         * Debounce a given function by the specified time.
         * @param callback function to debounce
         * @param filterTextLength text filter length
         * @returns debounced function
         */
        debounce(callback, filterTextLength) {
            const wait = this.GetDebounceTime(filterTextLength);
            return (...args) => {
                window.setTimeout(() => {
                    callback(...args);
                }, wait);
            };
        }
        /**
         * Record the time between a fetch request and response.
         * @param time fetch time in ms
         * @param filterTextLength length of the text filter for the fetch
         */
        recordResponseTime(time, filterTextLength) {
            const index = Math.min(filterTextLength, 5);
            const record = this._responseTimes[index];
            // if this is the first recorded time, overwrite our initial default;
            // otherwise calculate the new average
            if (record.count === 0) {
                record.time = time;
            }
            else {
                record.time = (record.time * record.count + time) / (record.count + 1);
            }
            record.count += 1;
        }
        /**
         * Record the time of a fetch request.
         */
        recordRequestTime() {
            const requestTime = Date.now();
            const lastRequestTime = this._lastRequestTime;
            this._lastRequestTime = requestTime;
            // we need two requests in order to record the time between them, so if this is the
            // very first request, just return
            if (lastRequestTime === 0) {
                return;
            }
            const time = requestTime - lastRequestTime;
            // assume that intervals greater than 1000ms are the start of a new search, so do not
            // factor into the average request time
            if (time > 1000) {
                return;
            }
            const record = this._requestTime;
            // if this is the first recorded time, overwrite our initial default;
            // otherwise calculate the new average
            if (record.count === 0) {
                record.time = time;
            }
            else {
                record.time = (record.time * record.count + time) / (record.count + 1);
            }
            record.count += 1;
        }
        /**
         * Get the average response time for a given text filter length.
         * @param filterTextLength length of the text filter
         * @returns average response time in ms
         */
        _getResponseTime(filterTextLength) {
            const index = Math.min(filterTextLength, 5);
            const record = this._responseTimes[index];
            return record.time;
        }
        /**
         * Get the average request time.
         * @returns average request time in ms
         */
        _getRequestTime() {
            return this._requestTime.time;
        }
        /**
         * Get the time to use for debouncing based on the text filter length, the average
         * time between requests, and the average response time.
         * @param filterTextLength text filter length
         * @returns debounce time in ms
         */
        GetDebounceTime(filterTextLength) {
            const responseTime = this._getResponseTime(filterTextLength);
            const requestTime = this._getRequestTime();
            // the request time is an average of how fast the user types, so assume any given time may
            // be a little longer than the average
            const paddedRequestTime = 1.2 * requestTime;
            // if the response is expected to come back before the user types another character, don't
            // debounce
            if (responseTime < paddedRequestTime) {
                return 0;
            }
            // if the response won't come back before the user types another character, wait between
            // 1 and 2 times the paddedRequestTime, depending on how much slower the response is expected
            // to be
            const factor = (responseTime - paddedRequestTime) / responseTime;
            const debounceTime = (1 + factor) * paddedRequestTime;
            return debounceTime;
        }
    }
    exports.Debouncer = Debouncer;
});

define('oj-c/select-common/PRIVATE_DebouncingDataProviderView/DebouncingDataProviderView',["require", "exports", "ojs/ojdataprovider", "./Debouncer"], function (require, exports, ojdataprovider_1, Debouncer_1) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DebouncingDataProviderView = void 0;
    class AsyncIteratorWrapper {
        constructor(dataProvider, debouncer, params) {
            this._isFirstNext = true;
            this.dataProvider = dataProvider;
            this.debouncer = debouncer;
            this.params = params;
        }
        next() {
            if (this._isFirstNext) {
                // record the request time with the debouncer
                this.debouncer.recordRequestTime();
                this._isFirstNext = false;
                const filterText = this.params?.filterCriterion?.text;
                const debounceCallback = (resolve, reject) => {
                    // if the request has been aborted, reject the promise with the abort error and return
                    if (this.params?.signal?.aborted) {
                        reject(this.params?.signal?.reason);
                        return;
                    }
                    const asyncIterable = this.dataProvider.fetchFirst(this.params);
                    this._asyncIterator = asyncIterable[Symbol.asyncIterator]();
                    const fetchStart = Date.now();
                    const iterPromise = this._asyncIterator.next();
                    iterPromise.then((result) => {
                        // record the response time with the debouncer
                        const fetchEnd = Date.now();
                        this.debouncer.recordResponseTime(fetchEnd - fetchStart, filterText ? filterText.length : 0);
                        resolve(result);
                    }, reject);
                };
                // the abort handler will pass its own promise resolve/reject functions into this callback
                const callback = (resolve, reject) => {
                    const promise = new Promise((pResolve, pReject) => {
                        this.debouncer.debounce(debounceCallback, filterText ? filterText.length : 0)(pResolve, pReject);
                    });
                    // when the debounce promise resolves, resolve the abort handling promise
                    return promise.then(resolve, reject);
                };
                return (0, ojdataprovider_1.wrapWithAbortHandling)(this.params?.signal, callback, false);
            }
            return this._asyncIterator.next();
        }
    }
    class AsyncIterableWrapper {
        constructor(dataProvider, debouncer, params) {
            this[_a] = () => {
                return new AsyncIteratorWrapper(this.dataProvider, this.debouncer, this.params);
            };
            this.dataProvider = dataProvider;
            this.debouncer = debouncer;
            this.params = params;
        }
    }
    _a = Symbol.asyncIterator;
    /**
     * A DataProvider wrapper that supports debouncing fetchFirst requests.
     * It is up to the calling code to abort stale requests and only process
     * the results for the most recent fetch.
     */
    class DebouncingDataProviderView {
        constructor(dataProvider) {
            this._debouncer = new Debouncer_1.Debouncer();
            this.dataProvider = dataProvider;
        }
        /**
         * Fetch the first block of data
         */
        fetchFirst(params) {
            return new AsyncIterableWrapper(this.dataProvider, this._debouncer, params);
        }
        /**
         * Fetch rows by keys
         */
        fetchByKeys(params) {
            return this.dataProvider.fetchByKeys(params);
        }
        /**
         * Check if rows are contained by keys
         */
        containsKeys(params) {
            return this.dataProvider.containsKeys(params);
        }
        /**
         * Fetch rows by offset
         */
        fetchByOffset(params) {
            return this.dataProvider.fetchByOffset(params);
        }
        /**
         * Returns the total size of the data
         */
        getTotalSize() {
            return this.dataProvider.getTotalSize();
        }
        /**
         * Returns a string that indicates if this data provider is empty.
         * Returns "unknown" if the dataProvider has not resolved yet.
         */
        isEmpty() {
            return this.dataProvider.isEmpty();
        }
        /**
         * Determines whether this DataProvider supports certain feature.
         */
        getCapability(capabilityName) {
            return this.dataProvider.getCapability(capabilityName);
        }
        /** start EVENT TARGET IMPLEMENTATION **/
        addEventListener(eventType, listener) {
            this.dataProvider.addEventListener(eventType, listener);
        }
        removeEventListener(eventType, listener) {
            this.dataProvider.removeEventListener(eventType, listener);
        }
        dispatchEvent(event) {
            return this.dataProvider.dispatchEvent(event);
        }
    }
    exports.DebouncingDataProviderView = DebouncingDataProviderView;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-common/UNSAFE_useWrapDataProvider/useWrapDataProvider',["require", "exports", "ojs/ojdataproviderfactory", "preact/hooks", "../PRIVATE_DebouncingDataProviderView/DebouncingDataProviderView"], function (require, exports, ojdataproviderfactory_1, hooks_1, DebouncingDataProviderView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useWrapDataProvider = useWrapDataProvider;
    function useWrapDataProvider(data) {
        const dataProvider = (0, hooks_1.useMemo)(() => {
            if (!data) {
                return data;
            }
            const enhancedDP = (0, ojdataproviderfactory_1.getEnhancedDataProvider)(data, {
                fetchFirst: { caching: 'visitedByCurrentIterator' }
                // dedup: { type: 'iterator' },
                // eventFiltering: { type: 'iterator' }
            });
            // JET-55290 - Select Single - Debounce (introducing delays)
            // If the DP is capable of returning fetches immediately, simply return the enhancedDP.
            // Otherwise wrap the enhancedDP in a debouncing wrapper to help reduce the number of
            // remote fetch requests that are actually made as the user types.
            const filterCapability = enhancedDP.getCapability('fetchFirst');
            const isImmediate = filterCapability?.iterationSpeed === 'immediate';
            return isImmediate ? enhancedDP : new DebouncingDataProviderView_1.DebouncingDataProviderView(enhancedDP);
        }, [data]);
        return dataProvider;
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-common/UNSAFE_useWrapDataProvider/index',["require", "exports", "./useWrapDataProvider"], function (require, exports, useWrapDataProvider_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useWrapDataProvider = void 0;
    Object.defineProperty(exports, "useWrapDataProvider", { enumerable: true, get: function () { return useWrapDataProvider_1.useWrapDataProvider; } });
});

define('oj-c/select-common/PRIVATE_useSelectData/CollectionTemplateDataProviderView',["require", "exports", "ojs/ojdataprovider"], function (require, exports, ojdataprovider_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CollectionTemplateDataProviderView = exports.SELECT_INTERNALS = void 0;
    // Key to store internal only information
    exports.SELECT_INTERNALS = Symbol('__SELECT_INTERNALS__');
    class CollectionTemplateDataProviderView {
        get currentDataProvider() {
            // If we are overriding the data return the override DP
            return this.overrideDataProvider ?? this.originalDataProvider;
        }
        /**
         * Sets the filter criterion that will be injected into the fetch calls.
         * @param filter The new filter
         */
        setFilterCriterion(filter) {
            const previousFilter = this.filterCriterion;
            this.filterCriterion = filter;
            if (!this.compareFilter(previousFilter, filter)) {
                // filter criterion changed, fire refresh event
                const event = new ojdataprovider_1.DataProviderRefreshEvent();
                // Add some additional private information to the event so that the Select components can ignore this event if it needs.
                // For example, it might not have to re-sync value & valueItems for this refresh event related to filtering.
                // Using Object.defineProperty to make this not enumerable and not configurable
                Object.defineProperty(event, exports.SELECT_INTERNALS, {
                    value: { cause: 'filterCriterionChanged' }
                });
                this.dispatchEvent(event);
                // We need to also notify Select that the filter is changed. This is needed because, if the previous fetch
                // resulted in no results, the select will not render the collection. So, the current filter & the refresh event will
                // not cause the collection to initiate a fetch as there is no collection rendered. This results in the component getting
                // stuck in a no results state.
                this.options.onRefresh?.();
            }
        }
        /**
         * Sets the override data for the data provider
         * @param dataStateOverride The override data
         */
        setDataStateOverride(dataStateOverride) {
            // for dataStateOverride, we check for reference equality
            if (this.dataStateOverride !== dataStateOverride) {
                this.dataStateOverride = dataStateOverride;
                // If override data is present, create a override DP otherwise clear the override DP
                this.overrideDataProvider =
                    this.dataStateOverride?.status === 'success'
                        ? new DataStateDataProviderView(this.dataStateOverride)
                        : undefined;
                // fire refresh event so that consuming collection can refetch the data
                const event = new ojdataprovider_1.DataProviderRefreshEvent();
                // Add some additional private information to the event so that the Select components can ignore this event if it needs.
                // For example, it might not have to re-sync value & valueItems for this refresh event related to filtering.
                // Using Object.defineProperty to make this not enumerable and not configurable
                Object.defineProperty(event, exports.SELECT_INTERNALS, {
                    value: { cause: 'dataOverrideChanged' }
                });
                this.dispatchEvent(event);
                // We need to also notify Select that the filter is changed. This is needed because, if the previous fetch
                // resulted in no results, the select will not render the collection. So, the current filter & the refresh event will
                // not cause the collection to initiate a fetch as there is no collection rendered. This results in the component getting
                // stuck in a no results state.
                this.options.onRefresh?.();
            }
        }
        /**
         * Compares two data filters.
         * @param fc1 first data filter
         * @param fc2 second data filter
         * @returns equality result
         */
        compareFilter(fc1, fc2) {
            if (fc1 === fc2)
                return true;
            if (fc1 === undefined || fc2 === undefined)
                return false;
            const keys1 = Object.keys(fc1);
            const keys2 = Object.keys(fc2);
            if (keys1.length !== keys2.length)
                return false;
            return keys1.every((key) => keys2.includes(key) && fc1[key] === fc2[key]);
        }
        constructor(dataProvider, options) {
            this.originalDataProvider = dataProvider;
            this.options = options;
            if (dataProvider.createOptimizedKeyMap)
                this.createOptimizedKeyMap = (initialMap) => dataProvider.createOptimizedKeyMap(initialMap);
            if (dataProvider.createOptimizedKeySet)
                this.createOptimizedKeySet = (initialMap) => dataProvider.createOptimizedKeySet(initialMap);
        }
        async fetchByOffset(parameters) {
            const overriddenParams = this.filterCriterion
                ? { ...parameters, filterCriterion: this.filterCriterion }
                : parameters;
            const results = await this.currentDataProvider.fetchByOffset(overriddenParams);
            this.options.onOffsetFetch?.({ results });
            return results;
        }
        fetchFirst(parameters) {
            const overriddenParams = this.filterCriterion
                ? { ...parameters, filterCriterion: this.filterCriterion }
                : parameters;
            const options = this.options;
            options.onInitializeFetch?.();
            const iterable = this.currentDataProvider.fetchFirst(overriddenParams);
            return {
                [Symbol.asyncIterator]() {
                    let offset = 0;
                    const iterator = iterable[Symbol.asyncIterator]();
                    return {
                        async next() {
                            const itResult = await iterator.next();
                            const { value: results, done = false } = itResult;
                            options.onNextIteration?.({ results, offset, done });
                            offset += results.data.length;
                            return itResult;
                        }
                    };
                }
            };
        }
        addEventListener(eventType, listener) {
            // we always add event listeners on the original DP
            return this.originalDataProvider.addEventListener(eventType, listener);
        }
        containsKeys(parameters) {
            return this.currentDataProvider.containsKeys(parameters);
        }
        dispatchEvent(event) {
            // We always dispatch events to the original DP
            return this.originalDataProvider.dispatchEvent(event);
        }
        fetchByKeys(parameters) {
            return this.currentDataProvider.fetchByKeys(parameters);
        }
        getCapability(capabilityName) {
            // We always reflect the original DP's capability
            return this.originalDataProvider.getCapability(capabilityName);
        }
        getTotalSize() {
            return this.currentDataProvider.getTotalSize();
        }
        isEmpty() {
            return this.currentDataProvider.isEmpty();
        }
        removeEventListener(eventType, listener) {
            // Since we added event listeners to the original DP, we always remove
            // them from the original DP as well.
            return this.originalDataProvider.removeEventListener(eventType, listener);
        }
    }
    exports.CollectionTemplateDataProviderView = CollectionTemplateDataProviderView;
    class DataStateDataProviderView {
        constructor(dataState) {
            this.dataState = dataState;
        }
        containsKeys(parameters) {
            const { keys } = parameters;
            const { data } = this.dataState;
            const foundKeys = new Set();
            data.data.forEach((item) => {
                if (keys.has(item.metadata.key)) {
                    foundKeys.add(item.metadata.key);
                }
            });
            return Promise.resolve({
                containsParameters: parameters,
                results: foundKeys
            });
        }
        fetchByKeys(parameters) {
            const { keys } = parameters;
            const { data } = this.dataState;
            const results = new Map();
            data.data.forEach((item) => {
                if (keys.has(item.metadata.key)) {
                    results.set(item.metadata.key, item);
                }
            });
            return Promise.resolve({
                fetchParameters: parameters,
                results
            });
        }
        fetchByOffset(parameters) {
            const { offset, size } = parameters;
            const { data } = this.dataState;
            // filter data based on offset and size
            const filteredData = data.data.slice(offset, size);
            const results = {
                fetchParameters: parameters ?? {},
                results: filteredData.map((item) => ({ data: item.data, metadata: item.metadata })),
                done: offset + (size ?? 0) >= data.totalSize
            };
            return Promise.resolve(results);
        }
        fetchFirst(parameters) {
            const { data } = this.dataState;
            return {
                [Symbol.asyncIterator]() {
                    let offset = 0;
                    const size = parameters?.size ?? 25; // ideally collection will always send a size
                    const totalSize = data.totalSize;
                    return {
                        async next() {
                            if (offset < totalSize) {
                                const filteredData = data.data.slice(offset, size);
                                const resultsOverride = filteredData.reduce((acc, value) => {
                                    acc.data.push(value.data);
                                    acc.metadata.push(value.metadata);
                                    return acc;
                                }, { data: [], metadata: [] });
                                const results = {
                                    ...resultsOverride,
                                    fetchParameters: parameters ?? {},
                                    totalFilteredRowCount: data.totalSize
                                };
                                // update the offset
                                const adjustedSize = Math.min(size, totalSize - offset);
                                offset += offset + adjustedSize;
                                return { value: results, done: false };
                            }
                            // iteration is over, so return empty results
                            const results = {
                                data: [],
                                metadata: [],
                                fetchParameters: parameters ?? {},
                                totalFilteredRowCount: data.totalSize
                            };
                            return { value: results, done: true };
                        }
                    };
                }
            };
        }
        getCapability() {
            // This DP View does not support any capability
            return null;
        }
        getTotalSize() {
            return Promise.resolve(this.dataState.data.totalSize);
        }
        isEmpty() {
            return this.dataState.data.totalSize === 0 ? 'yes' : 'no';
        }
        // This DP View does not support events
        addEventListener() { }
        dispatchEvent() {
            return false;
        }
        removeEventListener() { }
    }
});

define('oj-c/select-common/PRIVATE_useSelectData/useCollectionTemplateDataProviderView',["require", "exports", "oj-c/hooks/UNSAFE_useListData/useListData", "preact/hooks", "./CollectionTemplateDataProviderView"], function (require, exports, useListData_1, hooks_1, CollectionTemplateDataProviderView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCollectionTemplateDataProviderView = useCollectionTemplateDataProviderView;
    /**
     * A custom hook to wrap the DP in a CollectionTemplateDataProviderView.
     * @param param0 The props for the useCollectionTemplateDataProviderView
     * @returns hook result
     */
    function useCollectionTemplateDataProviderView({ dataProvider, options: { dataStateOverride, filterCriterion } }) {
        const [state, dispatch] = (0, hooks_1.useReducer)((reducer), {
            dataState: (0, useListData_1.getEmptyState)('atLeast')
        });
        const wrappedDP = (0, hooks_1.useMemo)(() => dataProvider == null
            ? dataProvider
            : new CollectionTemplateDataProviderView_1.CollectionTemplateDataProviderView(dataProvider, {
                onInitializeFetch() {
                    dispatch({ type: 'loading' });
                },
                onNextIteration({ results: { data, metadata, fetchParameters }, offset, done }) {
                    // if the fetch is aborted, do nothing
                    if (fetchParameters.signal?.aborted)
                        return;
                    const items = data.map((item, index) => ({
                        data: item,
                        metadata: metadata[index]
                    }));
                    dispatch({ type: 'append', payload: { items, offset, done } });
                },
                onOffsetFetch({ results: { results, done, fetchParameters } }) {
                    // If the fetch is aborted, do nothing
                    if (fetchParameters.signal?.aborted)
                        return;
                    dispatch({
                        type: 'update',
                        payload: { items: results, done, offset: fetchParameters.offset }
                    });
                },
                onRefresh() {
                    // if the previous fetch resulted in no results, the select will not render the collection. So, the current filter & the refresh event will
                    // not cause the collection to initiate a fetch as there is no collection rendered. This results in the component getting
                    // stuck in a no results state. To fix this, we will put the select in loading state, so the collection will be rendered and the collection
                    // will fetch the new data.
                    dispatch({ type: 'loading' });
                }
            }), [dataProvider]);
        // Update the wrappedDP filter if the filterCriterion is changed
        const prevFilterCriterionRef = (0, hooks_1.useRef)();
        if (prevFilterCriterionRef.current !== filterCriterion) {
            prevFilterCriterionRef.current = filterCriterion;
            wrappedDP?.setFilterCriterion(filterCriterion);
        }
        // Update the wrappedDP override data if the dataStateOverride is changed
        const prevDataStateOverride = (0, hooks_1.useRef)();
        if (prevDataStateOverride.current !== dataStateOverride) {
            prevDataStateOverride.current = dataStateOverride;
            wrappedDP?.setDataStateOverride(dataStateOverride);
        }
        return {
            dataState: state.dataState,
            dataProvider: wrappedDP
        };
    }
    const reducer = (state, { type, payload }) => {
        switch (type) {
            case 'append': {
                const { dataState } = state;
                const prevData = dataState.status === 'success' ? dataState.data : null;
                const { done, items } = payload;
                return {
                    ...state,
                    dataState: {
                        status: 'success',
                        data: {
                            data: [...(prevData?.data ?? []), ...items],
                            offset: prevData?.offset ?? 0,
                            sizePrecision: done ? 'exact' : 'atLeast',
                            totalSize: (prevData?.data.length ?? 0) + items.length
                        }
                    }
                };
            }
            case 'update': {
                return {
                    ...state,
                    dataState: {
                        status: 'success',
                        data: {
                            data: payload.items,
                            offset: payload.offset,
                            sizePrecision: payload.done ? 'exact' : 'atLeast',
                            totalSize: payload.items.length
                        }
                    }
                };
            }
            case 'loading': {
                return {
                    ...state,
                    dataState: {
                        status: 'loading',
                        data: null
                    }
                };
            }
            default:
                return state;
        }
    };
});

define('oj-c/select-common/PRIVATE_useSelectData/useSelectData',["require", "exports", "oj-c/hooks/UNSAFE_useListData/useListData", "preact/hooks", "../UNSAFE_useWrapDataProvider/index", "./useCollectionTemplateDataProviderView"], function (require, exports, useListData_1, hooks_1, index_1, useCollectionTemplateDataProviderView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSelectData = void 0;
    const noOp = () => { };
    /**
     * A custom hook for creating the data related properties for the select component.
     * @param param0 hook params
     * @returns hook result
     */
    const useSelectData = ({ data, dataStateOverride: propDataStateOverride, filterCriterion, hasCollectionTemplate }) => {
        const dataProvider = (0, index_1.useWrapDataProvider)(data);
        // pass initialRowsFetched: 0 so that no data is fetched until the collection calls onLoadRange
        // (i.e. when the dropdown is open and the collection needs to render)
        const [listDataState, onLoadRange] = (0, useListData_1.useListData)(dataProvider ?? null, {
            filterCriterion,
            initialRowsFetched: 0
        });
        const dataStateOverride = (0, hooks_1.useMemo)(() => (propDataStateOverride ? { status: 'success', data: propDataStateOverride } : undefined), [propDataStateOverride]);
        const { dataState: templateDataState, dataProvider: templateDataProvider } = (0, useCollectionTemplateDataProviderView_1.useCollectionTemplateDataProviderView)({
            dataProvider,
            options: { dataStateOverride, filterCriterion }
        });
        return {
            dataProvider: hasCollectionTemplate ? templateDataProvider : dataProvider,
            dataState: hasCollectionTemplate ? dataStateOverride ?? templateDataState : listDataState,
            // It is the default list on the preact side that calls onLoadRange to fetch data. But with
            // collectionTemplate/ collectionRenderer, the default list is not rendered on the preact side.
            // The collectionTemplate will render the list and it will be a core-pack collection that has
            // access to the DP. It then directly call the fetch methods on the DP to fetch the data. So,
            // we assign noOp to onLoadRange when rendering a collectionTemplate.
            onLoadRange: hasCollectionTemplate ? noOp : onLoadRange
        };
    };
    exports.useSelectData = useSelectData;
});

define('oj-c/select-common/PRIVATE_useSelectData/index',["require", "exports", "./useSelectData", "./CollectionTemplateDataProviderView"], function (require, exports, useSelectData_1, CollectionTemplateDataProviderView_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SELECT_INTERNALS = exports.useSelectData = void 0;
    Object.defineProperty(exports, "useSelectData", { enumerable: true, get: function () { return useSelectData_1.useSelectData; } });
    Object.defineProperty(exports, "SELECT_INTERNALS", { enumerable: true, get: function () { return CollectionTemplateDataProviderView_1.SELECT_INTERNALS; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-common/UNSAFE_useDataProviderListeners/useDataProviderListeners',["require", "exports", "@oracle/oraclejet-preact/utils/UNSAFE_logger", "preact/hooks", "../PRIVATE_useSelectData/index", "../utils/utils"], function (require, exports, UNSAFE_logger_1, hooks_1, index_1, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useDataProviderListeners = useDataProviderListeners;
    /**
     * Clones the value that is passed
     *
     * @param value The value to be cloned
     * @returns The cloned value
     */
    function cloneValue(value) {
        return value instanceof Set ? new Set(value.values()) : value;
    }
    /**
     * Clones the valueItem that is passed
     *
     * @param valueItem The valueItem to be cloned
     * @returns The cloned valueItem
     */
    function cloneValueItem(valueItem) {
        return valueItem instanceof Map ? new Map(valueItem.entries()) : Object.assign({}, valueItem);
    }
    /**
     * Checks if the value provided duck-types ItemContext
     * @param value The value to be checked
     * @returns True if the value duck-types ItemContext
     */
    function isItemContext(value) {
        if (value == null)
            return false;
        return typeof value === 'object' && ['key', 'data'].every((prop) => prop in value);
    }
    /**
     * Compare two sets' size or two values if neither of them are a set
     *
     * @param value The first value to compare
     * @param valueToCompare The second value to compare
     * @returns The result of the comparison
     */
    function compareValues(value, valueToCompare) {
        if ((value instanceof Set && valueToCompare instanceof Set) ||
            (value instanceof Map && valueToCompare instanceof Map)) {
            // per the requirement, in this case, it is sufficient to compare the size
            // to determine the equality. No need to check the actual values in the Set.
            return value.size === valueToCompare.size;
        }
        // if value & valueToCompare are objects that extend ItemContext, then compare their key prop
        if (isItemContext(value) && isItemContext(valueToCompare)) {
            return value.key === valueToCompare.key;
        }
        // as default, do normal `===` check
        return value === valueToCompare;
    }
    /**
     * Checks if the value contains the query, if it is a set or if the value
     * is the query otherwise
     *
     * @param value The value to be query
     * @param query The query item
     * @returns Result of the check
     */
    function containsValue(value, query) {
        return value instanceof Set ? value.has(query) : value != null && value === query;
    }
    /**
     * Deletes a value from a set of values or set the current value to null
     * if it the value to be deleted.
     *
     * @param value The current value
     * @param toDelete The value to be deleted
     * @returns The updated value
     */
    function deleteFromValue(value, toDelete) {
        if (value instanceof Set || value instanceof Map) {
            value.delete(toDelete);
            return value;
        }
        if (typeof value === 'number' || typeof value === 'string') {
            // in this case, we are comparing the `value` prop as only it can be a primitive, so use DEFAULT_VALUE
            if (value === toDelete) {
                return utils_1.DEFAULT_VALUE;
            }
            return value;
        }
        if (typeof value === 'object' && value.key === toDelete) {
            // in this case, we are comparing the `valueItem` prop as only it can be an object, so use DEFAULT_VALUE_ITEMS
            return utils_1.DEFAULT_VALUE_ITEMS;
        }
        return value;
    }
    function useDataProviderListeners({ dataProvider, setValue, setValueToSync, setValueItemsToSync, value, valueItems }) {
        // TODO: come up with a better way to do this (part of JET-54088)
        const isSelectMultiple = value instanceof Set;
        const handleRefresh = (0, hooks_1.useCallback)((event) => {
            // Check if we need to handle the event. In some cases where the event is initiated by the
            // Select component we can safely ignore the event. The cases include injecting the filterCriterion
            // or setting override data. If we determine it is one of those case, return without doing anything.
            if (!shouldHandleRefreshEvent(event))
                return;
            if (!(0, utils_1.isEmpty)(value)) {
                // need to fetch refreshed data for the existing selected keys again, so clear the
                // valueItemsToSync and clone the value so that it's a new instance that triggers a rerender
                setValueToSync(cloneValue(value));
                setValueItemsToSync(utils_1.DEFAULT_VALUE_ITEMS);
            }
        }, [setValueItemsToSync, setValueToSync, value]);
        const handleMutation = (0, hooks_1.useCallback)((event) => {
            if ((0, utils_1.isEmpty)(value)) {
                return;
            }
            let newVal = cloneValue(value);
            if (event.detail.remove != null) {
                const keys = event.detail.remove.keys;
                keys.forEach((key) => {
                    if (containsValue(newVal, key)) {
                        newVal = deleteFromValue(newVal, key);
                        (0, UNSAFE_logger_1.warn)(`
              ${isSelectMultiple ? 'SelectMultiple' : 'SelectSingle'}: selected value removed from data provider: ${key}`);
                    }
                });
                // set the new value if keys that were previously selected have been removed
                if (!compareValues(newVal, value)) {
                    setValue(!(0, utils_1.isEmpty)(newVal) ? newVal : utils_1.DEFAULT_VALUE);
                    // also set the valueToSync so that it's available in the next render instead of
                    // having to wait for the useEffect in the next render to update it for the
                    // subsequent render, because we may set it below to handle updates and then that
                    // subsequent render would overwrite it
                    setValueToSync(!(0, utils_1.isEmpty)(newVal) ? newVal : utils_1.DEFAULT_VALUE);
                }
            }
            // if all the selected keys have been removed, we don't need to process updates
            if ((0, utils_1.isEmpty)(newVal)) {
                return;
            }
            if (event.detail.update != null) {
                const keys = event.detail.update.keys;
                let newValueItems = (0, utils_1.isEmpty)(valueItems)
                    ? valueItems
                    : cloneValueItem(valueItems);
                keys.forEach((key) => {
                    if (containsValue(newVal, key)) {
                        newValueItems = deleteFromValue(newValueItems, key);
                    }
                });
                // sync the new valueItems if data for the selected keys has been updated
                if (!compareValues(newValueItems, valueItems)) {
                    setValueToSync(newVal);
                    setValueItemsToSync(!(0, utils_1.isEmpty)(newValueItems) ? newValueItems : utils_1.DEFAULT_VALUE_ITEMS);
                }
            }
        }, [isSelectMultiple, setValue, setValueItemsToSync, setValueToSync, value, valueItems]);
        (0, hooks_1.useEffect)(() => {
            dataProvider?.addEventListener('refresh', handleRefresh);
            dataProvider?.addEventListener('mutate', handleMutation);
            return () => {
                dataProvider?.removeEventListener('refresh', handleRefresh);
                dataProvider?.removeEventListener('mutate', handleMutation);
            };
        }, [dataProvider, handleMutation, handleRefresh]);
    }
    const shouldHandleRefreshEvent = (event) => {
        // get the select internals if it exists
        if (index_1.SELECT_INTERNALS in event) {
            const { cause = '' } = event[index_1.SELECT_INTERNALS];
            // if it is caused by filterCriterion/dataOverride change, then we can ignore the event
            return !['filterCriterionChanged', 'dataOverrideChanged'].includes(cause);
        }
        // if there is no select internals present in the event, then we need to handle it
        return true;
    };
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/PRIVATE_keyUtils/keySetUtils',["require", "exports", "ojs/ojkeyset"], function (require, exports, ojkeyset_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isEqual = exports.getFirstKey = exports.isEmpty = exports.keysToKeySet = exports.keySetToKeys = void 0;
    /**
     * Helper to convert Keyset (legacy) to Keys (preact).
     * @param keyset
     * @returns keys
     */
    const keySetToKeys = (keySet) => {
        if (!keySet) {
            return { all: false, keys: new Set() };
        }
        let keys = {};
        if (keySet.isAddAll()) {
            const deletedValues = new Set(keySet.deletedValues());
            keys = { all: true, deletedKeys: deletedValues };
        }
        else if (!keySet.isAddAll()) {
            const values = new Set(keySet.values());
            keys = { all: false, keys: values };
        }
        return keys;
    };
    exports.keySetToKeys = keySetToKeys;
    /**
     * Helper to convert Keys (preact) to ImmutableKeySet (core pack).
     * @param keys
     * @returns KeySet
     */
    const keysToKeySet = (keys) => {
        let keySet;
        if (keys.all) {
            keySet = new ojkeyset_1.AllKeySetImpl();
            keySet = keySet.delete(new Set(keys.deletedKeys.values()));
        }
        else if (!keys.all) {
            keySet = new ojkeyset_1.KeySetImpl(new Set(keys.keys.values()));
        }
        return keySet;
    };
    exports.keysToKeySet = keysToKeySet;
    const isEmpty = (keys) => {
        if (keys.all) {
            return false;
        }
        else {
            return keys.keys.size === 0;
        }
    };
    exports.isEmpty = isEmpty;
    const getFirstKey = (keys, data) => {
        if (keys.all === false && keys.keys.size > 0) {
            const [first] = keys.keys;
            return first;
        }
        else if (data.length > 0) {
            return data[0];
        }
        return null;
    };
    exports.getFirstKey = getFirstKey;
    const isEqual = (key1, key2) => {
        if (key1 === key2) {
            return true;
        }
        if (key1.keys.all !== key2.keys.all) {
            return false;
        }
        const arr1 = key1.keys.all === true
            ? Array.from(key1.keys.deletedKeys.values())
            : Array.from(key1.keys.keys.values());
        const arr2 = key2.keys.all === true
            ? Array.from(key2.keys.deletedKeys.values())
            : Array.from(key2.keys.keys.values());
        if (arr1.length !== arr2.length) {
            return false;
        }
        for (let i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) {
                return false;
            }
        }
        return true;
    };
    exports.isEqual = isEqual;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-multiple/useSyncValueAndValueItems',["require", "exports", "@oracle/oraclejet-preact/utils/UNSAFE_logger", "oj-c/select-common/utils/utils", "preact/hooks"], function (require, exports, UNSAFE_logger_1, utils_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSyncValueAndValueItems = useSyncValueAndValueItems;
    function useSyncValueAndValueItems({ addBusyState, dataProvider, setDisplayValue, setIsLoading, setValue, setValueItems, value, valueItems, validateValueOnExternalChange }) {
        const prevValueRef = (0, hooks_1.useRef)(value);
        const prevValueItemsRef = (0, hooks_1.useRef)(valueItems);
        const hasValue = value && value instanceof Set && value.size > 0;
        const hasValueItems = valueItems && valueItems.size > 0;
        // ref to determine whether we're processing the latest fetch
        const latestFetchRef = (0, hooks_1.useRef)(null);
        // TODO: change this to useEffectEvent because we don't want to add this function to the
        // dependency arrays of the useEffects where we call it
        const syncValueItemsToValue = (0, hooks_1.useCallback)(() => {
            // if the value was cleared, clear the valueItems
            if (!hasValue) {
                // only change the valueItems if the current valueItems does not represent a cleared state
                if (hasValueItems) {
                    setValueItems(utils_1.DEFAULT_VALUE_ITEMS);
                }
                return;
            }
            // determine if we need to fetch data for any values
            const arValues = Array.from(value.keys());
            const valuesToFetch = arValues.reduce((accum, currKey) => {
                if (!hasValueItems || !valueItems.has(currKey)) {
                    accum.push(currKey);
                }
                return accum;
            }, []);
            // if we don't need to fetch data, create new valueItems from existing valueItems
            if (valuesToFetch.length === 0) {
                const newValItems = new Map();
                value.forEach((currKey) => {
                    newValItems.set(currKey, valueItems.get(currKey));
                });
                // only set new valueItems if the length or order is different from the existing valueItems
                const newValItemsKeys = Array.from(newValItems.keys());
                const isOrderEqual = arValues.every((key, index) => key === newValItemsKeys[index]);
                if (valueItems?.size !== newValItems.size || !isOrderEqual) {
                    setValueItems(newValItems);
                }
                return;
            }
            // need to fetch data for keys not already in valueItems
            setIsLoading(true);
            const resolveBusyState = addBusyState('useSyncValueItems: calling fetchByKeys');
            // object to determine whether we're processing the latest fetch
            const latestFetch = {};
            latestFetchRef.current = latestFetch;
            // execute this function in both then and catch blocks of the fetch promise instead of
            // in a finally block, which executes asynchronously and results in additional render cycles
            const afterFetch = () => {
                // only toggle loading if we're processing the latest fetch
                if (latestFetch === latestFetchRef.current) {
                    setIsLoading(false);
                }
                resolveBusyState();
            };
            dataProvider
                .fetchByKeys({ keys: new Set(valuesToFetch) })
                .then((fbkResults) => {
                // only process the latest fetch
                if (latestFetch === latestFetchRef.current) {
                    const newValueItems = handleFetchByKeysResults(value, valueItems, fbkResults.results);
                    setValueItems(newValueItems);
                }
                // JET-73836 - REDWOOD AUTOMATION FLOW GETS STUCK UP AS BUSY STATE IS NOT RESOLVED
                // always run afterFetch to at least resolve busy states, even if this isn't the
                // latest fetch
                afterFetch();
            }, (reason) => {
                // only log an error if we're processing the latest fetch
                if (latestFetch === latestFetchRef.current) {
                    (0, UNSAFE_logger_1.error)(`SelectMultiple: fetchByKeys promise rejected: ${reason}`);
                }
                afterFetch();
            });
        }, [
            addBusyState,
            dataProvider,
            hasValue,
            hasValueItems,
            setIsLoading,
            setValueItems,
            value,
            valueItems
        ]);
        // TODO: change this to useEffectEvent because we don't want to add this function to the
        // dependency arrays of the useEffects where we call it
        const syncValueToValueItems = (0, hooks_1.useCallback)(() => {
            // JET-67789 - SelectSingle > clearing required select input doesn't make input invalid when set programmatically by valueItem
            // We reach here if the valueItems property is programmatically updated by the app and we need
            // to sync value to the valueItems. Even though the app updated the valueItems, we still need
            // to treat it as if it updated the value property. This will not be done by the useEV hook as it
            // has no knowledge of the app programmatically updating the valueItem property. So, we explicitly
            // perform the validation and other tasks which useEV would have done normally for value change.
            const updateValue = (nextValue) => {
                const validationSucceeded = validateValueOnExternalChange(nextValue);
                // Here the validateValueOnExternalChange always return VALID. This is because we always want to
                // set the value provided by the app even if it is invalid. We still do a check here for consistency.
                if (validationSucceeded) {
                    setValue(nextValue);
                    // We don't consume the displayValue for select components, but we need to keep them updated
                    // with the value for the useEV hook to perform tasks correctly.
                    setDisplayValue(nextValue);
                }
            };
            // if the valueItems were cleared, clear the value
            if (!hasValueItems) {
                // only change the value if the current value does not represent a cleared state
                if (hasValue) {
                    updateValue(utils_1.DEFAULT_VALUE);
                }
                return;
            }
            // if the sizes of the valueItems and value are different, sync the value
            const arValueItemsKeys = Array.from(valueItems.keys());
            const valueItemsKeys = new Set(arValueItemsKeys);
            if (!value || !(value instanceof Set) || value.size !== valueItemsKeys.size) {
                updateValue(valueItemsKeys);
                return;
            }
            // if the keys or order of the keys are different, sync the value
            const arValueKeys = Array.from(value.keys());
            const isDifferent = arValueItemsKeys.some((key, index) => key !== arValueKeys[index]);
            if (isDifferent) {
                updateValue(valueItemsKeys);
            }
        }, [
            hasValue,
            hasValueItems,
            setDisplayValue,
            setValue,
            validateValueOnExternalChange,
            value,
            valueItems
        ]);
        // on mount, need to update the valueItems if value is specified (because value takes
        // precedence), or update the value if valueItems is specified and value is not
        (0, hooks_1.useEffect)(() => {
            if (hasValue) {
                syncValueItemsToValue();
            }
            else if (hasValueItems) {
                syncValueToValueItems();
            }
            // we only want to run this effect on mount.
            // FIXME: Once we enable the eslint react-hooks rule, there will be a false positive linter error here.
            // We just need to ignore the linter error as we want an empty dep array to make the hook run only on mount.
            // We cannot disable the rule until it is enabled. Once the rule is enabled, remove the FIXME from below.
            // FIXME: eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);
        // detect whether value or valueItems was changed;
        // value takes precedence over valueItems
        (0, hooks_1.useEffect)(() => {
            if (value !== prevValueRef.current && valueItems !== prevValueItemsRef.current) {
                prevValueRef.current = value;
                prevValueItemsRef.current = valueItems;
                if (value) {
                    syncValueItemsToValue();
                }
                else {
                    syncValueToValueItems();
                }
            }
            else if (value !== prevValueRef.current) {
                prevValueRef.current = value;
                syncValueItemsToValue();
            }
            else if (valueItems !== prevValueItemsRef.current) {
                prevValueItemsRef.current = valueItems;
                syncValueToValueItems();
            }
        }, [syncValueItemsToValue, syncValueToValueItems, value, valueItems]);
    }
    function handleFetchByKeysResults(value, valueItems, fetchByKeysResults) {
        const arKeys = Array.from(value.keys());
        return arKeys.reduce((accumMap, currKey) => {
            // if the key is already in valueItems, use that data
            if (valueItems && valueItems.has(currKey)) {
                accumMap.set(currKey, valueItems.get(currKey));
                return accumMap;
            }
            // if the key is a new addition, get the data from the fetched results
            const item = fetchByKeysResults.get(currKey);
            // if there is no item for a key, throw an error
            if (!item) {
                throw new Error(`oj-c-select-multiple: could not fetch data for key ${currKey}`);
            }
            accumMap.set(currKey, {
                key: currKey,
                data: item.data,
                metadata: item.metadata ? item.metadata : { key: currKey }
            });
            return accumMap;
        }, new Map());
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-multiple/useValueItems',["require", "exports", "@oracle/oraclejet-preact/hooks/UNSAFE_useUncontrolledState", "preact/hooks"], function (require, exports, UNSAFE_useUncontrolledState_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useValueItems = useValueItems;
    function useValueItems(propValueItems, onValueItemsChanged) {
        // maintain uncontrolled state for valueItems, like useEditableValue hook does for value
        const [valueItems, setValueItems] = (0, UNSAFE_useUncontrolledState_1.useUncontrolledState)(propValueItems, onValueItemsChanged);
        const [prevPropValueItems, setPrevPropValueItems] = (0, hooks_1.useState)(propValueItems);
        // when the incoming propValueItems changes, update the valueItems state
        if (prevPropValueItems !== propValueItems && valueItems !== propValueItems) {
            setValueItems(propValueItems);
        }
        // convert the valueItems from the type supported by the custom element to the type supported
        // by the preact component
        // (use state instead of a memo because the memo seems to recalculate every time with a
        // dependency array containing only valueItems, resulting in many unnecessary renders)
        const [prevValueItems, setPrevValueItems] = (0, hooks_1.useState)(valueItems);
        const [preactValueItems, setPreactValueItems] = (0, hooks_1.useState)(valueItems ? Array.from(valueItems.values()) : undefined);
        if (prevValueItems !== valueItems) {
            setPreactValueItems(valueItems ? Array.from(valueItems.values()) : undefined);
        }
        if (prevPropValueItems !== propValueItems) {
            setPrevPropValueItems(propValueItems);
        }
        if (prevValueItems !== valueItems) {
            setPrevValueItems(valueItems);
        }
        return {
            valueItems,
            setValueItems,
            preactValueItems
        };
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-multiple/useSelectMultiplePreact',["require", "exports", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "oj-c/select-common/PRIVATE_useCache/index", "oj-c/select-common/PRIVATE_useSelectData/index", "oj-c/select-common/UNSAFE_useDataProviderListeners/useDataProviderListeners", "oj-c/select-common/utils/utils", "oj-c/utils/PRIVATE_keyUtils/keySetUtils", "ojs/ojkeyset", "preact/hooks", "./useSyncValueAndValueItems", "./useValueItems"], function (require, exports, UNSAFE_useTranslationBundle_1, useComponentMessages_1, index_1, useDeferredValidators_1, index_2, index_3, useDataProviderListeners_1, utils_1, keySetUtils_1, ojkeyset_1, hooks_1, useSyncValueAndValueItems_1, useValueItems_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSelectMultiplePreact = useSelectMultiplePreact;
    /**
     * This hook manages state and other related props for the Select Multiple component.
     */
    function useSelectMultiplePreact({ 
    // addToList,
    collectionTemplate, data, disabled, displayOptions, itemTemplate, itemText, labelEdge, labelHint, labelStartWidth, matchBy: propMatchBy, messagesCustom, placeholder, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail: propRequiredMessageDetail, textAlign, userAssistanceDensity, value: propValue, valueItems: propValueItems, virtualKeyboard, onMessagesCustomChanged, 
    // onOjAddToListAction,
    onValidChanged, onValueChanged, onValueItemsChanged, ...otherProps }, addBusyState) {
        const [filterCriterion, setFilterCriterion] = (0, hooks_1.useState)(undefined);
        // JET-54256 - inside label animates up on initial display with selected value
        // Initialize isLoading based on whether we will need to fetch data instead of waiting for
        // useSyncValueAndValueItems to set the flag in a useEffect, because the delay caused by the
        // useEffect will result in the label animating.
        const [isLoading, setIsLoading] = (0, hooks_1.useState)(data != null &&
            propValue != null &&
            propValue.size > 0 &&
            (propValueItems == null || propValueItems.size === 0));
        // JET-66079 - Add option to specify the matchBy behavior of the text filter to Core Pack Selects
        const matchBy = (0, hooks_1.useMemo)(() => {
            // Make a copy of the array to use internally so that the application can't mutate it;
            // they have to set a new array if they want to change it.
            return propMatchBy && propMatchBy.length > 0 ? [...propMatchBy] : undefined;
        }, [propMatchBy]);
        const { valueItems, setValueItems, preactValueItems: arItemContexts } = (0, useValueItems_1.useValueItems)(propValueItems, onValueItemsChanged);
        const [prevArItemContexts, setPrevArItemContexts] = (0, hooks_1.useState)(arItemContexts);
        const [preactValueItems, setPreactValueItems] = (0, hooks_1.useState)(arItemContexts);
        if (prevArItemContexts !== arItemContexts && preactValueItems !== arItemContexts) {
            setPreactValueItems(arItemContexts);
        }
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const requiredMessageDetail = propRequiredMessageDetail || translations.select_requiredMessageDetail();
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        // SelectMultiple doesn't directly use the display value from useEV. However, when display
        // value is updated during the component's lifecycle (such as by calling reset) then
        // we need to sync the preactValueItems to the arItemContexts.
        const onDisplayValueChanged = (0, hooks_1.useCallback)(() => {
            setPreactValueItems(arItemContexts);
        }, [arItemContexts]);
        const { methods, onCommitValue, setDisplayValue, setValue, textFieldProps: evTextFieldProps, value, validateValueOnExternalChange } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            defaultDisplayValue: null,
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onDisplayValueChanged,
            onMessagesCustomChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        const { 'aria-describedby': ariaDescribedBy } = textFieldProps;
        const hasNoValue = value === null || (value instanceof Set && value.size === 0);
        const [dataStateOverride, setDataStateOverride] = (0, hooks_1.useState)();
        const { dataProvider, dataState, onLoadRange } = (0, index_3.useSelectData)({
            data,
            dataStateOverride,
            filterCriterion,
            hasCollectionTemplate: collectionTemplate !== undefined
        });
        // maintain a separate valueToSync that we can pass to useSyncValueAndValueItems so that
        // we can change that state to force a sync without writing a different instance back to the
        // component value property
        const [valueToSync, setValueToSync] = (0, hooks_1.useState)(value);
        const [valueItemsToSync, setValueItemsToSync] = (0, hooks_1.useState)(valueItems);
        const [prevValue, setPrevValue] = (0, hooks_1.useState)(value);
        const [prevValueItems, setPrevValueItems] = (0, hooks_1.useState)(valueItems);
        if (prevValue !== value) {
            setValueToSync(value);
        }
        if (prevValueItems !== valueItems) {
            setValueItemsToSync(valueItems);
        }
        (0, useDataProviderListeners_1.useDataProviderListeners)({
            dataProvider,
            setValue: setValue,
            setValueToSync: setValueToSync,
            setValueItemsToSync,
            value: value,
            valueItems
        });
        (0, useSyncValueAndValueItems_1.useSyncValueAndValueItems)({
            addBusyState,
            dataProvider: dataProvider,
            // We don't consume the displayValue for select components, but we need to keep them updated
            // with the value for the useEV hook to perform tasks correctly. Since the setDisplayValue
            // expects a string and we do not have that, we simply cast it to any and pass our value to it.
            setDisplayValue: setDisplayValue,
            setIsLoading,
            setValue: setValue,
            setValueItems,
            value: valueToSync,
            valueItems: valueItemsToSync,
            validateValueOnExternalChange
        });
        const onCommit = (0, hooks_1.useCallback)(async ({ value }) => {
            const valueToCommit = (value && value.size > 0 ? value : utils_1.DEFAULT_VALUE);
            // JET-66618: In order for the validate method to run properly, which parses
            // and then validates the displayValue, we need to call setDisplayValue here.
            // This is normally done by useEditableValue's onCommit, which we are overriding.
            // Since this component has no converter, we can just set displayValue to value.
            // Note that we set it even if validation fails, i.e. if the value is cleared
            // in Preact but the component is required. This ensures if validation is re-run
            // it correctly uses the cleared displayValue and not the value, which is not
            // updated when validation fails.
            setDisplayValue(valueToCommit);
            const commitSucceeded = await onCommitValue(valueToCommit);
            if (!commitSucceeded) {
                setPreactValueItems(undefined);
            }
            else if (commitSucceeded) {
                if (value && value.size > 0 && arItemContexts?.length === value.size) {
                    const arKeys = Array.from(value);
                    const allValuesInItemContexts = arKeys.every((key, index) => {
                        return key === arItemContexts?.[index].key;
                    });
                    // JET-66957 - Select Single > Re-selected value is not displayed
                    // Since the valueItems itself isn't changing when the component is required and the
                    // user tried to clear the previous values, we may need to push the same valueItems
                    // back down to the preact component.
                    if (allValuesInItemContexts && preactValueItems !== arItemContexts) {
                        setPreactValueItems(arItemContexts);
                    }
                }
            }
        }, [arItemContexts, preactValueItems, onCommitValue, setDisplayValue]);
        const onFilter = (0, hooks_1.useCallback)(({ searchText }) => {
            const fc = (0, utils_1.getFilterCriterion)(dataProvider, searchText, matchBy);
            setFilterCriterion(fc);
        }, [dataProvider, matchBy]);
        const prevSelectedKeysRef = (0, hooks_1.useRef)((0, keySetUtils_1.keysToKeySet)({ all: false, keys: new Set() }));
        const itemRenderer = (0, hooks_1.useMemo)(() => {
            if (!itemTemplate)
                return undefined;
            return ({ data, metadata, searchText, selectedKeys: preactSelectedKeys, onSelectionChange: preactOnSelectionChange }) => {
                // Need to create selectedKeys only if the contents are different, otherwise use the
                // previous selectedKeys. Otherwise, the component will go in an infinite loop.
                const newPreactSelectedKeys = preactSelectedKeys ?? new Set();
                const prevPreactSelectedKeys = prevSelectedKeysRef.current.keys.keys ?? new Set();
                const selectedKeys = (0, utils_1.isSetEqual)(prevPreactSelectedKeys, newPreactSelectedKeys)
                    ? prevSelectedKeysRef.current
                    : (0, keySetUtils_1.keysToKeySet)({ all: false, keys: newPreactSelectedKeys });
                prevSelectedKeysRef.current = selectedKeys;
                const onSelectedKeysChanged = ((arg) => {
                    const immutableKeySet = (arg instanceof CustomEvent ? arg.detail.value : arg);
                    const immutableSet = immutableKeySet.keys.keys;
                    // If the selected keys are the same, do not call preactOnSelectionChange.
                    if (prevSelectedKeysRef.current === immutableKeySet)
                        return;
                    preactOnSelectionChange({
                        target: arg instanceof CustomEvent ? arg.target : null,
                        value: new Set(immutableSet?.values())
                    });
                });
                return itemTemplate({
                    selectedKeys,
                    onSelectedKeysChanged,
                    item: {
                        data: data,
                        metadata: metadata
                    },
                    searchText
                });
            };
        }, [itemTemplate]);
        const stableCollectionTemplateContextRef = (0, hooks_1.useRef)();
        const cache = (0, index_2.useCache)();
        const collectionRenderer = (0, hooks_1.useMemo)(() => {
            if (!collectionTemplate)
                return undefined;
            return ({ currentRowKeyOverride, onPersistCurrentRowKey, onSelectedChange, searchText, selected, selectedOnlyData }) => {
                // if the selectedOnlyData is changed, update the data override state
                if (dataStateOverride !== selectedOnlyData) {
                    setDataStateOverride(selectedOnlyData);
                }
                // Create the next collectionTemplate context
                // Note, the `cache` method takes 3 params:
                // 1. A string(key) to uniquely identify a property. This is used to store and compare previous
                //    value with the new value to determine changes.
                // 2. The computed value. This will be the new value to be used if not using the cached value.
                // 3. The dependency array. If any of the items in the dependency array is changed, then the
                //    new value provided as the second argument will be returned instead of the cached value.
                //    The cache is then updated with this value.
                const newCollectionTemplateContext = {
                    currentRowOverride: cache('currentRowOverride', currentRowKeyOverride ? { rowKey: currentRowKeyOverride } : undefined, 
                    // Here we want to include searchText as a dependency even if it is not directly
                    // used. This is needed for handling cases where the currentRowKeyOverride is the same
                    // for two filters. For example, we filter the dropdown, the first row is set as current row,
                    // then we navigate into the dropdown and navigate to a different row, thereby scrolling to a
                    // different position. Since currentRowKeyOverride is an uncontrolled prop, it will still
                    // point to the first row. Now, in this state, if we click back on the field, filter again, and we
                    // end up with the same row for the first entry, the collection component might not react to it
                    // if we send in the same object. We need to send a new object even for the same currentRowKeyOverride.
                    // So, we add searchText as a dependency here.
                    [currentRowKeyOverride, searchText]),
                    data: dataProvider,
                    onCurrentRowChanged: cache('onCurrentRowChanged', ({ rowKey }) => {
                        // Since we will not react to the onPersistCurrentRowKey call and only store
                        // the information for future use, we do not have to check if is called with the key
                        // same as the currentRowKeyOverride.
                        onPersistCurrentRowKey({ value: rowKey });
                    }, [onPersistCurrentRowKey]),
                    onSelectedChanged: cache('onSelectedChanged', (detail) => {
                        // Select component does not support select-all functionality
                        // So we only react to individual selection changes
                        if (detail.value?.keys.all === false) {
                            const immutableSet = detail.value.keys.keys;
                            // trigger onChange only if the sets are different
                            const current = selected ?? new Set();
                            const next = new Set(immutableSet.values());
                            if (!(0, utils_1.isSetEqual)(current, next))
                                onSelectedChange({ value: next });
                        }
                    }, [selected, onSelectedChange]),
                    searchText,
                    selected: cache('selected', new ojkeyset_1.KeySetImpl([...(selected?.values() ?? [])]), [selected])
                };
                // We need to maintain the context object's reference and only mutate it. This is not ideal in
                // preact, but this is essential in the knockout environment. In ko, the template is not recalculated.
                // So, if a new context object is passed, the nested template will not receive the updates as they will
                // be consuming the old context object. So, we mutate the old context whenever we want to make changes on
                // it. This way the nested templates will get the updates correctly.
                // Check if we have a stored output context instance, if not, store the current output and use for
                // future calls.
                if (!stableCollectionTemplateContextRef.current) {
                    stableCollectionTemplateContextRef.current = newCollectionTemplateContext;
                }
                else {
                    // If we already have a context object, then mutate its values using Object.assign
                    Object.assign(stableCollectionTemplateContextRef.current, newCollectionTemplateContext);
                }
                // Finally, call the collectionTemplate with the same context object.
                return collectionTemplate(stableCollectionTemplateContextRef.current);
            };
        }, [cache, collectionTemplate, dataProvider, dataStateOverride]);
        // JET-60647 - select multiple: webdriver core pack test adapter parity
        const _selectItemsByValue = (0, hooks_1.useCallback)(async (value) => {
            return onCommit({
                value: value ?? undefined,
                previousValue: propValue ?? undefined
            });
        }, [onCommit, propValue]);
        // preact component callback to fire the core pack component custom event
        // const onAddToListAction = useCallback(
        //   (detail: Parameters<NonNullable<PreactSelectMultipleProps['onAddToListAction']>>[0]) => {
        //     onOjAddToListAction?.(detail);
        //   },
        //   [onOjAddToListAction]
        // );
        // method to expose on the root HTML element for use by the webelement test adapter
        // const _doAddToListAction = useCallback(
        //   (searchText: string) => {
        //     onAddToListAction({ searchText });
        //   },
        //   [onAddToListAction]
        // );
        if (prevArItemContexts !== arItemContexts) {
            setPrevArItemContexts(arItemContexts);
        }
        if (prevValue !== value) {
            setPrevValue(value);
        }
        if (prevValueItems !== valueItems) {
            setPrevValueItems(valueItems);
        }
        return {
            // value,
            // setValue,
            methods,
            // Certain props will have null as default values, but we need them to be
            // undefined in the preact component.
            selectMultipleProps: {
                // addToList,
                'aria-describedby': ariaDescribedBy,
                collectionRenderer,
                data: dataState.status !== 'error' ? dataState.data : null,
                isDisabled: disabled,
                isLoading,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                itemRenderer: itemTemplate ? itemRenderer : undefined,
                itemText,
                label: labelHint,
                labelEdge,
                labelStartWidth,
                messages,
                // onAddToListAction,
                onCommit,
                onFilter,
                onLoadRange,
                placeholder,
                textAlign,
                userAssistanceDensity,
                valueItems: preactValueItems,
                virtualKeyboard
            },
            // _doAddToListAction,
            _selectItemsByValue
        };
    }
});


define('oj-c/select-multiple/select-multiple',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_SelectMultiple", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "./useSelectMultiplePreact", "ojs/ojcontext", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "css!oj-c/select-multiple/select-multiple-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_SelectMultiple_1, UNSAFE_useFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_classNames_1, FormControl_1, Layout_1, useAssistiveText_1, useMergedFormContext_1, ojvcomponent_1, compat_1, hooks_1, useSelectMultiplePreact_1, Context, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectMultiple = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    /**
     * @classdesc
     * <h3 id="selectMultipleOverview-section">
     *   JET Select Multiple
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selectMultipleOverview-section"></a>
     * </h3>
     * <p>Description: JET Select Multiple provides support for multi-select and search filtering.</p>
     *
     * <p>A JET Select Multiple can be created with the following markup.</p>
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-select-multiple data="[[dataProvider]]" item-text="label" label-hint="Select Multiple">
     * &lt;/oj-c-select-multiple>
     * </code></pre>
     *
     * <h4>Data</h4>
     * <p>The only way to provide data to JET Select Multiple is through a
     * <a href="DataProvider.html">DataProvider</a>. For cases with
     * a small set of fixed data, use an <a href="ArrayDataProvider.html">ArrayDataProvider</a>.</p>
     *
     * <h3 id="diff-section">
     *   Differences between Select and Combobox components
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#diff-section"></a>
     * </h3>
     *
     * <p>
     * oj-c-select-* components and oj-combobox-* components may look and feel similar,
     * but these components are different and are intended for very different use cases.
     * </p>
     *
     * <p>
     * While oj-c-select-* components allow a user to filter the data in the dropdown,
     * it is not possible to enter values that are not available in the data.
     * This makes oj-c-select-* components ideal for usecases where the user can only
     * select values that are available in the dropdown, but not provide custom
     * values of their own.
     * </p>
     *
     * <p>
     * In contrast, oj-combobox-* components allow a user to enter new values that are
     * not available in the data in addition to using the text field for filtering dropdown data.
     * This makes oj-combobox-* components ideal for usecases where the users can provide
     * custom values in addition to those that are already available in the dropdown data.
     * </p>
     *
     * <p>
     * Application developers should consider the above differences when choosing between
     * Select and Combobox components.
     * Additionally, applications are advised to use oj-c-select-multiple instead of oj-select-many.
     * </p>
     *
     * <h3 id="disableditems-section">
     *   Disabled Items
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#disableditems-section"></a>
     * </h3>
     *
     * <p>
     * Disabled items are not supported in oj-c-select-* components; items that aren't selectable
     * should be removed rather than shown as disabled. Keep in mind disabled items usually don't pass
     * contrast and therefore people with low vision can't see them, so for accessibility reasons
     * you can't use disabled for "meaningful content".
     * </p>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
    
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>The required and placeholder properties also can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * Placeholder is shown when the field is empty and has focus.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> If the dropdown is not open, expand the dropdown list.
     *       If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *     <tr>
     *       <td>Arrow button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> If the dropdown is not open, expand the dropdown list. Otherwise, close the dropdown list.</td>
     *     </tr>
     *     <tr>
     *       <td>Option item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Tap on an option item in the dropdown list to select.</td>
     *     </tr>
     *     <tr>
     *       <td>Selected values count</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Toggle the dropdown list between the full list of items and the list of only
     *       selected items. If the dropdown is not open, expand the dropdown list.</td>
     *     </tr>
     *     <tr>
     *       <td>Back button (Mobile dropdown)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Discard any changes made to the dropdown selection and close the dropdown.</td>
     *     </tr>
     *     <tr>
     *       <td>Apply button (Mobile dropdown)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Commit any changes made to the dropdown selection and close the dropdown.</td>
     *     </tr>
     *     <tr>
     *       <td>Clear button (Mobile dropdown)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Clear any selections made along with any search text. The changes will be committed only when the Apply button is pressed.</td>
     *     </tr>
     *     <tr>
     *       <td>Text tag's clear button (Mobile dropdown)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Remove the text tag and update the selections to reflect the removal. The changes will be committed only when the Apply button is pressed.</td>
     *     </tr>
     *     <tr>
     *       <td>Text tag's clear button (Tablet)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Remove the text tag and update the selections & the value of the component to reflect the removal.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Option item</td>
     *       <td><kbd>Space</kbd></td>
     *       <td> Select the highlighted choice from the dropdown.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td> Collapse the dropdown list. If the dropdown is already closed, do nothing.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>LeftArrow</kbd> or <kbd>RightArrow</kbd></td>
     *       <td> Moves the focus to the last text tag if the cursor is at the beginning of the input field and <kbd>LeftArrow</kbd> (in LTR)
     *       or <kdb>RightArrow</kbd> (in RTL) is pressed.</td>
     *     </tr>
     *     <tr>
     *       <td>Text tag</td>
     *       <td><kbd>LeftArrow</kbd> or <kbd>RightArrow</kbd></td>
     *       <td> Moves the focus through the text tags. If the focus is on the last text tag and <kbd>RightArrow</kbd> (in LTR)
     *       or <kdb>LeftArrow</kbd> (in RTL) is pressed, the focus will be put on the input field.</td>
     *     </tr>
     *     <tr>
     *       <td>Text tag</td>
     *       <td><kbd>Home</kbd></td>
     *       <td> Moves the focus to the first text tag.</td>
     *     </tr>
     *     <tr>
     *       <td>Text tag</td>
     *       <td><kbd>End</kbd></td>
     *       <td> Moves the focus to the last text tag.</td>
     *     </tr>
     *     <tr>
     *       <td>Text tag</td>
     *       <td><kbd>Ctrl + A</kbd> or <kbd>Command + A</kbd></td>
     *       <td> Selects all the text tags.</td>
     *     </tr>
     *     <tr>
     *       <td>Text tag</td>
     *       <td><kbd>Delete</kbd> or <kbd>Backspace</kbd></td>
     *       <td> Removes the current focused text tag and deselects the corresponding value. If all the tags are selected, removes all the tags and clears selection.
     *       The focus is then moved to the input field.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>UpArrow</kbd> or <kbd>DownArrow</kbd></td>
     *       <td> Highlight the option item on the dropdown list in the direction of the arrow.
     *         If the dropdown is not open, expand the dropdown list.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Shift+DownArrow</kbd></td>
     *       <td> If the dropdown is open, extend the selection to the item below.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Shift+UpArrow</kbd></td>
     *       <td> If the dropdown is open, extend the selection to the item above.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Shift+Space</kbd></td>
     *       <td> If the dropdown is open, select contiguous items from the last selected item to the current item.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Ctrl+Space</kbd></td>
     *       <td> If the dropdown is open, toggle to select or deselect the current item while maintaining previous selected items.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td> Collapse the dropdown list. If the dropdown is already closed, do nothing.</td>
     *     </tr>
     *     <tr>
     *       <td>Selected values count</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td> Toggle the dropdown list between the full list of items and the list of only
     *       selected items. If the dropdown is not open, expand the dropdown list.</td>
     *     </tr>
     *     <tr>
     *       <td>Selected values count</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td> Collapse the dropdown list. If the dropdown is already closed, do nothing.</td>
     *     </tr>
     *     <tr>
     *       <td>Select</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the Select. If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <h4>Page Load</h4>
     * <p>If there are initially selected values, setting the <a href="#valueItems">valueItems</a> attribute initially can improve page load performance because the element will not have to fetch the selected data from the data provider.</p>
     * <p>The dropdown data isn't fetched until the user opens the dropdown.</p>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     * <p>
     * The placeholder text is not read reliably by the screen reader. For accessibility reasons,
     * you need to associate the text to its JET form component using aria-describedby.
     * </p>
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     *
     * @ojmetadata displayName 'SelectMultiple'
     * @ojmetadata description 'A select multiple is a dropdown list that supports multiple selections and search filtering.'
     * @ojmetadata help "oj-c.SelectMultiple.html"
     * @ojmetadata main "oj-c/select-multiple"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/select-multiple",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-select",
     *     "uxSpecs": [
     *       "select-multiple-items"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "placeholder",
     *       "readonly",
     *       "required",
     *       "virtualKeyboard"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data",
     *       "itemText",
     *       "value",
     *       "valueItems"
     *     ]
     *   }
     * ]
     * @ojmetadata since "13.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-select-many"]
     *   }
     * ]
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    function SelectMultipleImpl({ 
    // addToList: 'off',
    columnSpan = 1, containerReadonly: propContainerReadonly, data = null, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, labelWrapping: propLabelWrapping, matchBy = null, messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, value = null, valueItems = null, virtualKeyboard = 'auto', ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const selectMultipleRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-select-multiple id=${id}: ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        const { selectMultipleProps, methods, /*_doAddToListAction,*/ _selectItemsByValue } = (0, useSelectMultiplePreact_1.useSelectMultiplePreact)({
            data,
            disabled,
            displayOptions,
            matchBy,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            value,
            valueItems,
            virtualKeyboard,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => selectMultipleRef.current?.blur(),
            focus: () => selectMultipleRef.current?.focus(),
            // _doAddToListAction,
            _selectItemsByValue,
            UNSAFE_focusAndOpenDropdown: () => {
                // JET-70461 - Add a new method for automatically disclosing select options
                // Dispatch mousedown on the SelectMultipleField container element. This will be the first child
                // of the custom element. The event handler that listens to the mouse down and opens the dropdown
                // is attached to this element. So, dispatching the mousedown on this element will focus the field
                // and also opens the dropdown at the same time.
                // We do not need to check for readonly/disabled, as we only add the mousedown event listener when
                // the component is enabled. So, in readonly/disabled this will be a no-op.
                if (rootRef.current) {
                    const rootElem = rootRef.current;
                    const run = () => rootElem.firstElementChild?.dispatchEvent(new MouseEvent('mousedown'));
                    const busyContext = Context.getContext(rootElem).getBusyContext();
                    busyContext.whenReady().then(run);
                }
            },
            ...methods
        }), [methods, /*_doAddToListAction,*/ _selectItemsByValue]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: selectMultipleProps.userAssistanceDensity
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? otherProps.maxWidth : 'none',
            width: otherProps.width === 'md' || otherProps.width === 'sm' ? otherProps.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = otherProps.width === 'md' || otherProps.width === 'sm' ? undefined : otherProps.width;
        const maxWidthStyle = otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? undefined : otherProps.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return (
        // Even though we are handling the styling here, we pass the columnSpan property down to the
        // Preact component because it may be needed for other purposes, like calculating the start
        // label width.
        // The layoutSpanColumn style class needs to be applied to the root
        // dom element, otherwise the css grid will ignore it.
        (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_SelectMultiple_1.SelectMultiple, { ref: selectMultipleRef, ...assistiveTextProps, ...selectMultipleProps, columnSpan: columnSpan, variant: variant }) }) }));
    }
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const SelectMultipleWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-select-multiple', (0, compat_1.forwardRef)(SelectMultipleImpl), "SelectMultiple", { "slots": { "collectionTemplate": { "data": {} }, "itemTemplate": { "data": {} } }, "properties": { "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "data": { "type": "DataProvider|null" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "itemText": { "type": "string|number|function" }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "matchBy": { "type": "Array<string>|null" }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "placeholder": { "type": "string" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "value": { "type": "object|null", "writeback": true }, "valueItems": { "type": "object|null", "writeback": true }, "virtualKeyboard": { "type": "string", "enumValues": ["number", "search", "auto", "url", "text", "email", "tel"] }, "width": { "type": "number|string" }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "valid", "value", "valueItems"], "_READ_ONLY_PROPS": ["valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {}, "_selectItemsByValue": {}, "UNSAFE_focusAndOpenDropdown": {} } }, { "columnSpan": 1, "data": null, "disabled": false, "displayOptions": { "messages": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "matchBy": null, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "value": null, "valueItems": null, "virtualKeyboard": "auto" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
    exports.SelectMultiple = SelectMultipleWithoutDefaultedGenerics;
});

define('oj-c/select-multiple',["require", "exports", "oj-c/select-multiple/select-multiple"], function (require, exports, select_multiple_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectMultiple = void 0;
    Object.defineProperty(exports, "SelectMultiple", { enumerable: true, get: function () { return select_multiple_1.SelectMultiple; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-single/useSyncValueAndValueItem',["require", "exports", "@oracle/oraclejet-preact/utils/UNSAFE_logger", "oj-c/editable-value/UNSAFE_useStaleIdentity/useStaleIdentity", "oj-c/select-common/utils/utils", "preact/hooks"], function (require, exports, UNSAFE_logger_1, useStaleIdentity_1, utils_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSyncValueAndValueItem = useSyncValueAndValueItem;
    function useSyncValueAndValueItem({ addBusyState, dataProvider, setDisplayValue, setIsLoading, setValue, setValueItem, value, valueItem, validateValueOnExternalChange }) {
        const prevValueRef = (0, hooks_1.useRef)(value);
        const prevValueItemsRef = (0, hooks_1.useRef)(valueItem);
        // to determine whether we're processing the latest fetch
        const { setStaleIdentity } = (0, useStaleIdentity_1.useStaleIdentity)();
        const hasValue = value != null;
        const hasValueItem = valueItem != null;
        const syncValueItemToValue = (0, hooks_1.useCallback)(async () => {
            // if the value was cleared, clear the valueItem
            if (!hasValue) {
                // only change the valueItem if the current valueItem does not represent a cleared state
                if (hasValueItem) {
                    setValueItem(utils_1.DEFAULT_VALUE_ITEM);
                }
                return;
            }
            // if we already have the data for the value, we do not need to fetch
            // the data. Instead, we just create a new valueItem from the existing
            // valueItem.
            if (value != null && valueItem != null && valueItem.key === value.value) {
                setValueItem(Object.assign({}, valueItem));
                return;
            }
            // noop when there is no dataprovider
            if (!dataProvider) {
                return;
            }
            // need to fetch data for keys not already in valueItem
            setIsLoading(true);
            const resolveBusyState = addBusyState('useSyncValueItem: calling fetchByKeys');
            const { isStale } = setStaleIdentity('useSyncValueItem:fetchByKeys');
            try {
                const fetchResults = await dataProvider.fetchByKeys({ keys: new Set([value.value]) });
                // only process the latest fetch
                if (!isStale()) {
                    const newValueItems = handleFetchByKeysResults(value.value, valueItem, fetchResults.results);
                    setValueItem(newValueItems);
                }
            }
            catch (reason) {
                // only log an error if we're processing the latest fetch
                if (!isStale()) {
                    (0, UNSAFE_logger_1.error)(`SelectMultiple: fetchByKeys promise rejected: ${reason}`);
                }
            }
            // only toggle loading if we're processing the latest fetch
            if (!isStale()) {
                setIsLoading(false);
            }
            resolveBusyState();
        }, [
            addBusyState,
            dataProvider,
            hasValue,
            hasValueItem,
            setIsLoading,
            setStaleIdentity,
            setValueItem,
            value,
            valueItem
        ]);
        const syncValueToValueItem = (0, hooks_1.useCallback)(() => {
            // JET-67789 - SelectSingle > clearing required select input doesn't make input invalid when set programmatically by valueItem
            // We reach here if the valueItem property is programmatically updated by the app and we need
            // to sync value to the valueItem. Even though the app updated the valueItem, we still need
            // to treat it as if it updated the value property. This will not be done by the useEV hook as it
            // has no knowledge of the app programmatically updating the valueItem property. So, we explicitly
            // perform the validation and other tasks which useEV would have done normally for value change.
            const updateValue = (nextValue) => {
                const validationSucceeded = validateValueOnExternalChange(nextValue);
                // Here the validateValueOnExternalChange always returns true. This is because we always want to
                // set the value provided by the app even if it is invalid. We still do a check here for consistency.
                if (validationSucceeded) {
                    setValue(nextValue);
                    // We don't consume the displayValue for select components, but we need to keep them updated
                    // with the value for the useEV hook to perform tasks correctly.
                    setDisplayValue(nextValue);
                }
            };
            // if the valueItem were cleared, clear the value
            if (!hasValueItem) {
                // only change the value if the current value does not represent a cleared state
                if (hasValue) {
                    updateValue(utils_1.DEFAULT_VALUE);
                }
                return;
            }
            // if the values of the valueItem and value are different, sync the value
            if (valueItem.key !== value?.value) {
                updateValue(valueItem.key);
                return;
            }
        }, [
            hasValue,
            hasValueItem,
            setDisplayValue,
            setValue,
            validateValueOnExternalChange,
            value,
            valueItem
        ]);
        // on mount, need to update the valueItem if value is specified (because value takes
        // precedence), or update the value if valueItem is specified and value is not
        (0, hooks_1.useEffect)(() => {
            if (hasValue) {
                syncValueItemToValue();
            }
            else if (hasValueItem) {
                syncValueToValueItem();
            }
            // we only want to run this effect on mount.
            // FIXME: Once we enable the eslint react-hooks rule, there will be a false positive linter error here.
            // We just need to ignore the linter error as we want an empty dep array to make the hook run only on mount.
            // We cannot disable the rule until it is enabled. Once the rule is enabled, remove the FIXME from below.
            // FIXME: eslint-disable-next-line react-hooks/exhaustive-deps
        }, []);
        // detect whether value or valueItem was changed;
        // value takes precedence over valueItem
        (0, hooks_1.useEffect)(() => {
            if (value !== prevValueRef.current && valueItem !== prevValueItemsRef.current) {
                prevValueRef.current = value;
                prevValueItemsRef.current = valueItem;
                if (value) {
                    syncValueItemToValue();
                }
                else {
                    syncValueToValueItem();
                }
            }
            else if (value !== prevValueRef.current) {
                prevValueRef.current = value;
                syncValueItemToValue();
            }
            else if (valueItem !== prevValueItemsRef.current) {
                prevValueItemsRef.current = valueItem;
                syncValueToValueItem();
            }
        }, [syncValueItemToValue, syncValueToValueItem, value, valueItem]);
    }
    function handleFetchByKeysResults(value, valueItem, fetchByKeysResults) {
        // if the key is already in valueItem, use that data
        if (valueItem && valueItem.key === value) {
            return valueItem;
        }
        // if the key is a new addition, get the data from the fetched results
        // if the key is a new addition, get the data from the fetched results
        const item = fetchByKeysResults.get(value);
        // if there is no item for a key, throw an error
        if (!item) {
            throw new Error(`oj-c-select-single: could not fetch data for key ${value}`);
        }
        return {
            key: value,
            data: item.data,
            metadata: item.metadata ? item.metadata : { key: value }
        };
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-single/useValueItem',["require", "exports", "@oracle/oraclejet-preact/hooks/UNSAFE_useUncontrolledState", "preact/hooks"], function (require, exports, UNSAFE_useUncontrolledState_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useValueItem = useValueItem;
    function useValueItem(propValueItem, onValueItemsChanged) {
        // maintain uncontrolled state for valueItem, like useEditableValue hook does for value
        const [valueItem, setValueItem] = (0, UNSAFE_useUncontrolledState_1.useUncontrolledState)(propValueItem, onValueItemsChanged);
        // when the incoming propValueItems changes, update the valueItem state
        (0, hooks_1.useEffect)(() => {
            if (valueItem !== propValueItem) {
                setValueItem(propValueItem);
            }
        }, [propValueItem]);
        return {
            valueItem,
            setValueItem
        };
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/select-single/useSelectSinglePreact',["require", "exports", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "oj-c/select-common/PRIVATE_useCache/index", "oj-c/select-common/PRIVATE_useSelectData/index", "oj-c/select-common/UNSAFE_useDataProviderListeners/useDataProviderListeners", "oj-c/select-common/utils/utils", "ojs/ojkeyset", "preact/hooks", "./useSyncValueAndValueItem", "./useValueItem"], function (require, exports, UNSAFE_useTranslationBundle_1, index_1, useComponentMessages_1, useDeferredValidators_1, index_2, index_3, useDataProviderListeners_1, utils_1, ojkeyset_1, hooks_1, useSyncValueAndValueItem_1, useValueItem_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSelectSinglePreact = useSelectSinglePreact;
    /**
     * This hook manages state and other related props for the Select Single component.
     */
    function useSelectSinglePreact({ 
    // addToList,
    advancedSearch, collectionTemplate, data, disabled, displayOptions, itemTemplate, itemText, labelEdge, labelHint, labelStartWidth, matchBy: propMatchBy, messagesCustom, placeholder, readonly, readonlyUserAssistanceShown, requiredMessageDetail: propRequiredMessageDetail, required, textAlign, userAssistanceDensity, value: propValue, valueItem: propValueItem, virtualKeyboard, onMessagesCustomChanged, 
    // onOjAddToListAction,
    onOjAdvancedSearchAction, onOjValueAction, onValidChanged, onValueChanged, onValueItemChanged, ...otherProps }, addBusyState) {
        const [filterCriterion, setFilterCriterion] = (0, hooks_1.useState)(undefined);
        // JET-54256 - inside label animates up on initial display with selected value
        // Initialize isLoading based on whether we will need to fetch data instead of waiting for
        // useSyncValueAndValueItems to set the flag in a useEffect, because the delay caused by the
        // useEffect will result in the label animating.
        const [isLoading, setIsLoading] = (0, hooks_1.useState)(data != null && propValue != null && propValueItem == null);
        // JET-66079 - Add option to specify the matchBy behavior of the text filter to Core Pack Selects
        const matchBy = (0, hooks_1.useMemo)(() => {
            // Make a copy of the array to use internally so that the application can't mutate it;
            // they have to set a new array if they want to change it.
            return propMatchBy && propMatchBy.length > 0 ? [...propMatchBy] : undefined;
        }, [propMatchBy]);
        const { valueItem, setValueItem } = (0, useValueItem_1.useValueItem)(propValueItem, onValueItemChanged);
        const [preactValueItem, setPreactValueItem] = (0, hooks_1.useState)(valueItem);
        (0, hooks_1.useEffect)(() => {
            setPreactValueItem(valueItem);
        }, [valueItem]);
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const requiredMessageDetail = propRequiredMessageDetail || translations.select_requiredMessageDetail();
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        // SelectSingle doesn't directly use the display value from useEV. However, when display
        // value is updated during the component's lifecycle (such as by calling reset) then
        // we need to sync the preactValueItem to the valueItem.
        const onDisplayValueChanged = (0, hooks_1.useCallback)(() => {
            setPreactValueItem(valueItem);
        }, [valueItem]);
        const { methods, onCommitValue, setDisplayValue, setValue, textFieldProps: evTextFieldProps, value, validateValueOnExternalChange } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            defaultDisplayValue: null,
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onDisplayValueChanged,
            onMessagesCustomChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        const { 'aria-describedby': ariaDescribedBy } = textFieldProps;
        const hasNoValue = value === null;
        const { dataProvider, dataState, onLoadRange } = (0, index_3.useSelectData)({
            data,
            filterCriterion,
            hasCollectionTemplate: collectionTemplate !== undefined
        });
        // maintain a separate valueToSync that we can pass to useSyncValueAndValueItems so that
        // we can change that state to force a sync without writing a different instance back to the
        // component value property
        // JET-72139 - Data list not getting updated on change of data on DP
        // Use an object type for valueToSync, so that we can force sync the value for the same key.
        const [valueToSync, _setValueToSync] = (0, hooks_1.useState)(value != null ? { value } : value);
        // We create a wrapper setValueToSync that does the wrapping. This way, we can keep this logic
        // separate to select-single.
        const setValueToSync = (0, hooks_1.useCallback)((value) => {
            if (typeof value === 'function') {
                _setValueToSync((prevValue) => {
                    const newValue = value(prevValue?.value);
                    return newValue != null ? { value: newValue } : newValue;
                });
                return;
            }
            _setValueToSync(value != null ? { value } : value);
        }, []);
        const [valueItemToSync, setValueItemToSync] = (0, hooks_1.useState)(valueItem);
        (0, hooks_1.useEffect)(() => {
            setValueToSync(value);
        }, [value]);
        (0, hooks_1.useEffect)(() => {
            setValueItemToSync(valueItem);
        }, [valueItem]);
        (0, useDataProviderListeners_1.useDataProviderListeners)({
            dataProvider,
            setValue,
            setValueToSync,
            setValueItemsToSync: setValueItemToSync,
            value,
            valueItems: valueItem
        });
        (0, useSyncValueAndValueItem_1.useSyncValueAndValueItem)({
            addBusyState,
            dataProvider: dataProvider,
            setDisplayValue,
            setIsLoading,
            setValue,
            setValueItem,
            value: valueToSync,
            valueItem: valueItemToSync,
            validateValueOnExternalChange
        });
        const onCommit = (0, hooks_1.useCallback)(async ({ previousValue, value }) => {
            const valueToCommit = value != null ? value : utils_1.DEFAULT_VALUE;
            // JET-66618: In order for the validate method to run properly, which parses
            // and then validates the displayValue, we need to call setDisplayValue here.
            // This is normally done by useEditableValue's onCommit, which we are overriding.
            // Since this component has no converter, we can just set displayValue to value.
            // Note that we set it even if validation fails, i.e. if the value is cleared
            // in Preact but the component is required. This ensures if validation is re-run
            // it correctly uses the cleared displayValue and not the value, which is not
            // updated when validation fails.
            setDisplayValue(valueToCommit);
            const commitSucceeded = await onCommitValue(valueToCommit);
            if (!commitSucceeded) {
                setPreactValueItem(undefined);
            }
            // If the validation is a success and we have dataState available
            // which it should, then trigger the valueAction.
            else if (commitSucceeded && dataState.status === 'success') {
                if (value == null) {
                    // no need to fetch itemContext when the value is cleared out
                    onOjValueAction?.({
                        itemContext: utils_1.DEFAULT_ITEM_CONTEXT,
                        previousValue: previousValue ?? utils_1.DEFAULT_VALUE,
                        value: utils_1.DEFAULT_VALUE
                    });
                }
                else if (value === valueItem?.key) {
                    // if the value is similar to the current valueItem, no need fetch again
                    onOjValueAction?.({
                        itemContext: valueItem,
                        previousValue: previousValue ?? utils_1.DEFAULT_VALUE,
                        value
                    });
                    // JET-66957 - Select Single > Re-selected value is not displayed
                    // Since the valueItem itself isn't changing when the component is required and the
                    // user tried to clear the previous value, we may need to push the same valueItem
                    // back down to the preact component.
                    if (preactValueItem !== valueItem) {
                        setPreactValueItem(valueItem);
                    }
                }
                else {
                    // check if the value is available in the current dataState
                    const data = dataState.data.data;
                    let item = data.find((item) => item.metadata.key === value);
                    if (item === undefined) {
                        // TODO: JET-54156 - Handle case where uses scrolls down and press Enter to select the value that is not in the DataState
                        // Need a better way to handle this
                        // TODO: handle the failure case (no dp or dp does not have the key), though we should not run into such a case
                        const fetchResults = await dataProvider.fetchByKeys({ keys: new Set([value]) });
                        item = fetchResults.results.get(value);
                    }
                    const itemContext = {
                        data: item.data,
                        key: item.metadata.key,
                        metadata: item.metadata
                    };
                    onOjValueAction?.({
                        itemContext: itemContext,
                        previousValue: previousValue ?? utils_1.DEFAULT_VALUE,
                        value: value ?? utils_1.DEFAULT_VALUE
                    });
                }
            }
        }, [
            dataProvider,
            dataState,
            preactValueItem,
            valueItem,
            onCommitValue,
            onOjValueAction,
            setDisplayValue
        ]);
        const onFilter = (0, hooks_1.useCallback)(({ searchText }) => {
            const fc = (0, utils_1.getFilterCriterion)(dataProvider, searchText, matchBy);
            setFilterCriterion(fc);
        }, [dataProvider, matchBy]);
        const itemRenderer = (0, hooks_1.useMemo)(() => {
            if (!itemTemplate)
                return undefined;
            return ({ data, metadata, searchText }) => {
                return itemTemplate({
                    item: {
                        data: data,
                        metadata: metadata
                    },
                    searchText
                });
            };
        }, [itemTemplate]);
        const stableCollectionTemplateContextRef = (0, hooks_1.useRef)();
        const cache = (0, index_2.useCache)();
        const collectionRenderer = (0, hooks_1.useMemo)(() => {
            if (!collectionTemplate)
                return undefined;
            return ({ currentRowKeyOverride, searchText, selected, onPersistCurrentRowKey, onRowAction }) => {
                // Create the next collectionTemplate context
                // Note, the `cache` method takes 3 params:
                // 1. A string(key) to uniquely identify a property. This is used to store and compare previous
                //    value with the new value to determine changes.
                // 2. The computed value. This will be the new value to be used if not using the cached value.
                // 3. The dependency array. If any of the items in the dependency array is changed, then the
                //    new value provided as the second argument will be returned instead of the cached value.
                //    The cache is then updated with this value.
                const newCollectionTemplateContext = {
                    currentRowOverride: cache('currentRowOverride', currentRowKeyOverride ? { rowKey: currentRowKeyOverride } : undefined, 
                    // Here we want to include searchText as a dependency even if it is not directly
                    // used. This is needed for handling cases where the currentRowKeyOverride is the same
                    // for two filters. For example, we filter the dropdown, the first row is set as current row,
                    // then we navigate into the dropdown and navigate to a different row, thereby scrolling to a
                    // different position. Since currentRowKeyOverride is an uncontrolled prop, it will still
                    // point to the first row. Now, in this state, if we click back on the field, filter again, and we
                    // end up with the same row for the first entry, the collection component might not react to it
                    // if we send in the same object. We need to send a new object even for the same currentRowKeyOverride.
                    // So, we add searchText as a dependency here.
                    [currentRowKeyOverride, searchText]),
                    data: dataProvider,
                    onCurrentRowChanged: cache('onCurrentRowChanged', ({ rowKey }) => {
                        // Since we will not react to the onPersistCurrentRowKey call and only store
                        // the information for future use, we do not have to check if is called with the key
                        // same as the currentRowKeyOverride.
                        onPersistCurrentRowKey({ value: rowKey });
                    }, [onPersistCurrentRowKey]),
                    onRowAction: cache('onRowAction', ({ item }) => {
                        onRowAction({
                            context: { data: item.data, key: item.metadata.key, metadata: item.metadata }
                        });
                    }, [onRowAction]),
                    searchText,
                    selected: cache('selected', new ojkeyset_1.KeySetImpl([...(selected?.values() ?? [])]), [selected])
                };
                // We need to maintain the context object's reference and only mutate it. This is not ideal in
                // preact, but this is essential in the knockout environment. In ko, the template is not recalculated.
                // So, if a new context object is passed, the nested template will not receive the updates as they will
                // be consuming the old context object. So, we mutate the old context whenever we want to make changes on
                // it. This way the nested templates will get the updates correctly.
                // Check if we have a stored output context instance, if not, store the current output and use for
                // future calls.
                if (!stableCollectionTemplateContextRef.current) {
                    stableCollectionTemplateContextRef.current = newCollectionTemplateContext;
                }
                else {
                    // If we already have a context object, then mutate its values using Object.assign
                    Object.assign(stableCollectionTemplateContextRef.current, newCollectionTemplateContext);
                }
                return collectionTemplate(stableCollectionTemplateContextRef.current);
            };
        }, [cache, collectionTemplate, dataProvider]);
        // JET-62033 - select single: webdriver core pack test adapter parity
        const _selectItemByValue = (0, hooks_1.useCallback)(async (value) => {
            return onCommit({
                value: value ?? undefined,
                previousValue: propValue ?? undefined
            });
        }, [onCommit, propValue]);
        // preact component callback to fire the core pack component custom event
        // const onAddToListAction = useCallback(
        //   (detail: Parameters<NonNullable<PreactSelectSingleProps['onAddToListAction']>>[0]) => {
        //     onOjAddToListAction?.(detail);
        //   },
        //   [onOjAddToListAction]
        // );
        // preact component callback to fire the core pack component custom event
        const onAdvancedSearchAction = (0, hooks_1.useCallback)((detail) => {
            onOjAdvancedSearchAction?.(detail);
        }, [onOjAdvancedSearchAction]);
        // method to expose on the root HTML element for use by the webelement test adapter
        // const _doAddToListAction = useCallback(
        //   (searchText: string) => {
        //     onAddToListAction({ searchText });
        //   },
        //   [onAddToListAction]
        // );
        // method to expose on the root HTML element for use by the webelement test adapter
        const _doAdvancedSearchAction = (0, hooks_1.useCallback)((searchText) => {
            onAdvancedSearchAction({ searchText });
        }, [onAdvancedSearchAction]);
        return {
            methods,
            // Certain props will have null as default values, but we need them to be
            // undefined in the preact component.
            selectSingleProps: {
                // addToList,
                advancedSearch,
                'aria-describedby': ariaDescribedBy,
                collectionRenderer,
                data: dataState.status !== 'error' ? dataState.data : null,
                isDisabled: disabled,
                isLoading,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                itemRenderer,
                itemText,
                label: labelHint,
                labelEdge,
                labelStartWidth,
                messages,
                // onAddToListAction,
                onAdvancedSearchAction,
                onCommit,
                onFilter,
                onLoadRange,
                placeholder,
                textAlign,
                userAssistanceDensity,
                valueItem: (0, index_1.treatNull)(preactValueItem, undefined),
                virtualKeyboard
            },
            // _doAddToListAction,
            _doAdvancedSearchAction,
            _selectItemByValue
        };
    }
});


define('oj-c/select-single/select-single',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_SelectSingle", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "./useSelectSinglePreact", "ojs/ojcontext", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "css!oj-c/select-single/select-single-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_SelectSingle_1, UNSAFE_useFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_classNames_1, FormControl_1, Layout_1, useAssistiveText_1, useMergedFormContext_1, ojvcomponent_1, compat_1, hooks_1, useSelectSinglePreact_1, Context, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectSingle = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    /**
     * @classdesc
     * <h3 id="selectSingleOverview-section">
     *   JET Select Single
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selectSingleOverview-section"></a>
     * </h3>
     * <p>Description: JET Select Single provides support for single-select and search filtering.</p>
     *
     * <p>A JET Select Single can be created with the following markup.</p>
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-select-single data="[[dataProvider]]" item-text="label" label-hint="Select Single">
     * &lt;/oj-c-select-single>
     * </code></pre>
     *
     * <h4>Data</h4>
     * <p>The only way to provide data to JET Select Single is through a
     * <a href="DataProvider.html">DataProvider</a>. For cases with
     * a small set of fixed data, use an <a href="ArrayDataProvider.html">ArrayDataProvider</a>.</p>
     *
     * <h3 id="diff-section">
     *   Differences between Select and Combobox components
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#diff-section"></a>
     * </h3>
     *
     * <p>
     * oj-c-select-* components and oj-combobox-* components may look and feel similar,
     * but these components are different and are intended for very different use cases.
     * </p>
     *
     * <p>
     * While oj-c-select-* components allow a user to filter the data in the dropdown,
     * it is not possible to enter values that are not available in the data.
     * This makes oj-c-select-* components ideal for usecases where the user can only
     * select values that are available in the dropdown, but not provide custom
     * values of their own.
     * </p>
     *
     * <p>
     * In contrast, oj-combobox-* components allow a user to enter new values that are
     * not available in the data in addition to using the text field for filtering dropdown data.
     * This makes oj-combobox-* components ideal for usecases where the users can provide
     * custom values in addition to those that are already available in the dropdown data.
     * </p>
     *
     * <p>
     * Application developers should consider the above differences when choosing between
     * Select and Combobox components.
     * Additionally, applications are advised to use oj-c-select-single instead of oj-select-single.
     * </p>
     *
     * <h3 id="disableditems-section">
     *   Disabled Items
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#disableditems-section"></a>
     * </h3>
     *
     * <p>
     * Disabled items are not supported in oj-c-select-* components; items that aren't selectable
     * should be removed rather than shown as disabled. Keep in mind disabled items usually don't pass
     * contrast and therefore people with low vision can't see them, so for accessibility reasons
     * you can't use disabled for "meaningful content".
     * </p>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     *
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>The required and placeholder properties also can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * Placeholder is shown when the field is empty and has focus.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> If the dropdown is not open, expand the dropdown list.
     *       If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *     <tr>
     *       <td>Arrow button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> If the dropdown is not open, expand the dropdown list. Otherwise, close the dropdown list.</td>
     *     </tr>
     *     <tr>
     *       <td>Option item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td> Tap on an option item in the dropdown list to select.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Option item</td>
     *       <td><kbd>Enter or Space</kbd></td>
     *       <td> Select the highlighted choice from the dropdown and close the dropdown.</td>
     *     </tr>
     *     <tr>
     *       <td>Option item</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td> Select the highlighted choice from the dropdown and transfer focus to the next
     *         tabbable element on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td> Collapse the dropdown list. If the dropdown is already closed, do nothing.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td> If the selected value text has been deleted, clear the value and close the dropdown.
     *         If filtering, select the highlighted choice from the dropdown and close the
     *         dropdown.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td> If the selected value text has been deleted, clear the value and transfer focus
     *         to the next tabbable element on the page. If filtering, select the highlighted choice
     *         from the dropdown and transfer focus to the next tabbable element on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>Input field</td>
     *       <td><kbd>UpArrow or DownArrow</kbd></td>
     *       <td> If the dropdown is not open, expand the dropdown list.  Otherwise, transfer
     *         focus into the dropdown list.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>UpArrow or DownArrow</kbd></td>
     *       <td> Highlight the option item in the dropdown list in the direction of the arrow.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td> Collapse the dropdown list.</td>
     *     </tr>
     *     <tr>
     *       <td>Select</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the Select. If hints, title or messages exist in a notewindow,
     *        pop up the notewindow.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <h4>Page Load</h4>
     * <p>If there is an initially selected value, setting the <a href="#valueItem">valueItem</a> attribute initially can improve page load performance because the element will not have to fetch the selected data from the data provider.</p>
     * <p>The dropdown data isn't fetched until the user opens the dropdown.</p>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     * <p>
     * The placeholder text is not read reliably by the screen reader. For accessibility reasons,
     * you need to associate the text to its JET form component using aria-describedby.
     * </p>
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     *
     * @ojmetadata displayName 'SelectSingle'
     * @ojmetadata description 'A select single is a dropdown list that supports single selection and search filtering.'
     * @ojmetadata help "oj-c.SelectSingle.html"
     * @ojmetadata main "oj-c/select-single"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "19.0.0",
     *     "value": ["oj-select-single"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/select-single",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-select",
     *     "uxSpecs": [
     *       "select-single-items"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "placeholder",
     *       "readonly",
     *       "required",
     *       "virtualKeyboard"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data",
     *       "itemText",
     *       "value",
     *       "valueItem"
     *     ]
     *   }
     * ]
     * @ojmetadata since "14.0.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    function SelectSingleImpl({ 
    // addToList: 'off',
    advancedSearch = 'off', columnSpan = 1, containerReadonly: propContainerReadonly, data = null, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, labelWrapping: propLabelWrapping, matchBy = null, messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, value = null, valueItem = null, virtualKeyboard = 'auto', ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const selectSingleRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-select-single id=${id}: ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        const { selectSingleProps, methods, 
        /*_doAddToListAction,*/ _doAdvancedSearchAction, _selectItemByValue } = (0, useSelectSinglePreact_1.useSelectSinglePreact)({
            advancedSearch,
            data,
            disabled,
            displayOptions,
            matchBy,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            value,
            valueItem,
            virtualKeyboard,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => selectSingleRef.current?.blur(),
            focus: () => selectSingleRef.current?.focus(),
            //_doAddToListAction,
            _doAdvancedSearchAction,
            _selectItemByValue,
            UNSAFE_focusAndOpenDropdown: () => {
                // JET-70461 - Add a new method for automatically disclosing select options
                // Dispatch mousedown on the SelectSingleField container element. This will be the first child
                // of the custom element. The event handler that listens to the mouse down and opens the dropdown
                // is attached to this element. So, dispatching the mousedown on this element will focus the field
                // and also opens the dropdown at the same time.
                // We do not need to check for readonly/disabled, as we only add the mousedown event listener when
                // the component is enabled. So, in readonly/disabled this will be a no-op.
                if (rootRef.current) {
                    const rootElem = rootRef.current;
                    const run = () => rootElem.firstElementChild?.dispatchEvent(new MouseEvent('mousedown'));
                    const busyContext = Context.getContext(rootElem).getBusyContext();
                    busyContext.whenReady().then(run);
                }
            },
            ...methods
        }), [methods, /*_doAddToListAction,*/ _doAdvancedSearchAction, _selectItemByValue]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: selectSingleProps.userAssistanceDensity
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? otherProps.maxWidth : 'none',
            width: otherProps.width === 'md' || otherProps.width === 'sm' ? otherProps.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = otherProps.width === 'md' || otherProps.width === 'sm' ? undefined : otherProps.width;
        const maxWidthStyle = otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? undefined : otherProps.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return (
        // Even though we are handling the styling here, we pass the columnSpan property down to the
        // Preact component because it may be needed for other purposes, like calculating the start
        // label width.
        // The layoutSpanColumn style class needs to be applied to the root dom element, otherwise the
        // css grid will ignore it.
        (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_SelectSingle_1.SelectSingle, { ref: selectSingleRef, ...assistiveTextProps, ...selectSingleProps, columnSpan: columnSpan, variant: variant }) }) }));
    }
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const SelectSingleWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-select-single', (0, compat_1.forwardRef)(SelectSingleImpl), "SelectSingle", { "properties": { "advancedSearch": { "type": "string", "enumValues": ["off", "on"] }, "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "data": { "type": "DataProvider|null" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "itemText": { "type": "string|number|function" }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "matchBy": { "type": "Array<string>|null" }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "placeholder": { "type": "string" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "value": { "type": "string|number|null", "writeback": true }, "valueItem": { "type": "object|null", "properties": { "data": { "type": "any" }, "key": { "type": "string|number" }, "metadata": { "type": "object", "properties": { "indexFromParent": { "type": "number" }, "isLeaf": { "type": "boolean" }, "key": { "type": "string|number" }, "message": { "type": "object", "properties": { "detail": { "type": "string" }, "severity": { "type": "string|number" }, "summary": { "type": "string" } } }, "parentKey": { "type": "string|number" }, "suggestion": { "type": "object" }, "treeDepth": { "type": "number" } } } }, "writeback": true }, "virtualKeyboard": { "type": "string", "enumValues": ["number", "search", "auto", "url", "text", "email", "tel"] }, "width": { "type": "number|string" }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "slots": { "collectionTemplate": { "data": {} }, "itemTemplate": { "data": {} } }, "events": { "ojAdvancedSearchAction": {}, "ojValueAction": {} }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "valid", "value", "valueItem"], "_READ_ONLY_PROPS": ["valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {}, "_doAdvancedSearchAction": {}, "_selectItemByValue": {}, "UNSAFE_focusAndOpenDropdown": {} } }, { "advancedSearch": "off", "columnSpan": 1, "data": null, "disabled": false, "displayOptions": { "messages": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "matchBy": null, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "value": null, "valueItem": null, "virtualKeyboard": "auto" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
    exports.SelectSingle = SelectSingleWithoutDefaultedGenerics;
});

define('oj-c/select-single',["require", "exports", "oj-c/select-single/select-single"], function (require, exports, select_single_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectSingle = void 0;
    Object.defineProperty(exports, "SelectSingle", { enumerable: true, get: function () { return select_single_1.SelectSingle; } });
});


define('oj-c/collapsible/collapsible',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_Collapsible", "ojs/ojvcomponent", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "ojs/ojcontext", "css!oj-c/collapsible/collapsible-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_Collapsible_1, ojvcomponent_1, hooks_1, UNSAFE_useTabbableMode_1, Context) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Collapsible = void 0;
    exports.Collapsible = (0, ojvcomponent_1.registerCustomElement)('oj-c-collapsible', 
    /**
     * @classdesc
     * <h3 id="collapsibleOverview-section">
     *   JET Collapsible
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#collapsibleOverview-section"></a>
     * </h3>
     *
     * <p>Description: A JET Collapsible displays a header that can be expanded to show additional content beneath it.
     * The child element of the oj-c-collapsible in the named <a href="#header">header</a> slot is displayed in the header, while the child element in the <a href="#Default">default</a> slot is displayed as the content.
     *
     * <p>Note for performance reasons, if the collapsible content is expensive to render, you should wrap it in an <code class="prettyprint">oj-defer</code> element to defer the rendering of that content.<br/>
     * See the Collapsible - Deferred Rendering demo for an example.</p>
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-collapsible>
     *   &lt;h3 slot='header'>Header 1&lt;/h3>
     *   &lt;p>Content 1&lt;/p>
     * &lt;/oj-c-collapsible>
     * </code></pre>
     *
     * <h3 id="data-attributes-section">
     *   Custom Data Attributes
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-attributes-section"></a>
     * </h3>
     *
     * <p>Collapsible supports the following custom data attributes.
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Name</th>
     *       <th>Description</th>
     *       <th>Example</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>data-oj-clickthrough</kbd></td>
     *       <td><p>Specify on any element inside the header where you want to control whether Collapsible should toggle disclosure by
     *           an event originating from the element or one of its descendants.</p>
     *           <p>For example, if you specify this attribute with a value of "disabled" on a button inside the header, then Collapsible
     *           will not trigger disclosure when user clicks on the button.</p>
     *       </td>
     *       <td>
     *         <pre class="prettyprint"><code>&lt;oj-c-collapsible>
     *   &lt;div slot="header">
     *     &lt;h3>Header 3&lt;/h3>
     *     &lt;oj-c-button data-oj-clickthrough="disabled">&lt;/oj-c-button
     *   &lt;/div>
     *   &lt;p>Content&lt;/p>
     * &lt;/oj-c-collapsible></code></pre>
     *       </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojmetadata description 'A collapsible displays a header that can be expanded to show its content.'
     * @ojmetadata displayName 'Collapsible'
     * @ojmetadata help 'oj-c.Collapsible.html'
     * @ojmetadata main 'oj-c/collapsible'
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Layout & Nav"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/collapsible"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-collapsible",
     *     "uxSpecs": [
     *       "collapsible"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "expanded",
     *       "iconPosition",
     *       "variant"
     *     ]
     *   }
     * ]
     * @ojmetadata since "14.0.0"
     */
    ({ id, children, header, disabled = false, expanded = false, iconPosition = 'start', variant = 'basic', ...props }) => {
        const rootRef = (0, hooks_1.useRef)(null);
        const didMountRef = (0, hooks_1.useRef)(false);
        const hasBeenExpanded = (0, hooks_1.useRef)(expanded);
        const resolveBusyState = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return Context.getContext(rootRef.current)
                .getBusyContext()
                ?.addBusyState({
                description: `oj-c-collapsible: id='${id}' is ${desc}.`
            });
        }, [id]);
        (0, hooks_1.useEffect)(() => {
            // The busy state is not added on the first render, but on each subsequent toggle
            if (!didMountRef.current) {
                didMountRef.current = true;
                return;
            }
            if (expanded) {
                hasBeenExpanded.current = true;
            }
            // Resolve current busy state is transition is already in progress
            if (resolveBusyState.current) {
                resolveBusyState.current();
            }
            resolveBusyState.current = addBusyState('animating');
        }, [expanded, addBusyState]);
        const toggleHandler = async (event) => {
            let target = event.target;
            for (; target && target !== rootRef?.current; target = target.parentElement) {
                if (target.getAttribute('data-oj-clickthrough') === 'disabled') {
                    return;
                }
            }
            const beforeProp = event.value ? props.onOjBeforeExpand : props.onOjBeforeCollapse;
            try {
                await beforeProp?.(event);
                props.onExpandedChanged?.(event.value);
            }
            catch (_) {
                // The expansion change was canceled so nothing to do here
            }
        };
        const transitionEndHandler = (event) => {
            const expandedProp = event.value ? props.onOjExpand : props.onOjCollapse;
            expandedProp?.(event);
            if (resolveBusyState.current) {
                resolveBusyState.current();
                resolveBusyState.current = undefined;
            }
        };
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, children: (0, jsx_runtime_1.jsx)(UNSAFE_Collapsible_1.Collapsible, { header: header, iconPosition: iconPosition, variant: variant, isExpanded: expanded, isDisabled: disabled, onToggle: toggleHandler, onTransitionEnd: transitionEndHandler, "aria-label": props['aria-label'], "aria-labelledby": props['aria-labelledby'], children: (expanded || hasBeenExpanded.current) && children }) }));
    }, "Collapsible", { "slots": { "": {}, "header": {} }, "properties": { "disabled": { "type": "boolean" }, "expanded": { "type": "boolean", "writeback": true }, "iconPosition": { "type": "string", "enumValues": ["end", "start"] }, "variant": { "type": "string", "enumValues": ["basic", "horizontal-rule"] } }, "events": { "ojBeforeCollapse": { "cancelable": true }, "ojBeforeExpand": { "cancelable": true }, "ojCollapse": {}, "ojExpand": {} }, "extension": { "_WRITEBACK_PROPS": ["expanded"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby", "id"] } }, { "disabled": false, "expanded": false, "iconPosition": "start", "variant": "basic" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/collapsible',["require", "exports", "oj-c/collapsible/collapsible"], function (require, exports, collapsible_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Collapsible = void 0;
    Object.defineProperty(exports, "Collapsible", { enumerable: true, get: function () { return collapsible_1.Collapsible; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/UNSAFE_focusTabUtils/focusUtils',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFirstTabStop = exports.focusFirstTabStop = void 0;
    /**
     * Helper to find the first tabbable element inside the given element.
     * @param {HTMLElement|null} element
     * @returns focusElement
     */
    const focusFirstTabStop = (element) => {
        if (!element)
            return;
        const focusElement = (0, exports.getFirstTabStop)(element);
        if (focusElement) {
            focusElement.focus();
        }
        return focusElement;
    };
    exports.focusFirstTabStop = focusFirstTabStop;
    /**
     * Get the first tabbable element inside the given element
     * @param {HTMLElement} element Return first tabbable element inside this element
     * @returns {HTMLElement|null} The first tabbable element inside the given element.
     */
    const getFirstTabStop = (element) => {
        const tabbable = element.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
        if (tabbable && tabbable.length > 0) {
            return tabbable[0];
        }
        return null;
    };
    exports.getFirstTabStop = getFirstTabStop;
});


define('oj-c/file-picker/file-picker',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_FilePicker", "preact/hooks", "preact/compat", "ojs/ojvcomponent", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "../utils/UNSAFE_focusTabUtils/focusUtils", "css!oj-c/file-picker/file-picker-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_FilePicker_1, hooks_1, compat_1, ojvcomponent_1, UNSAFE_useTabbableMode_1, focusUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilePicker = void 0;
    const getPrimaryText = (primaryText) => {
        if (typeof primaryText === 'function') {
            return primaryText();
        }
        return primaryText;
    };
    const getSecondaryText = (secondaryText, selectionMode) => {
        if (typeof secondaryText === 'function') {
            return secondaryText({ selectionMode: selectionMode });
        }
        return secondaryText;
    };
    exports.FilePicker = (0, ojvcomponent_1.registerCustomElement)('oj-c-file-picker', (0, compat_1.forwardRef)(
    /**
     * @classdesc
     * <h3 id="filePickerOverview-section">
     *   JET File Picker
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#filePickerOverview-section"></a>
     * </h3>
     * <p>Description:</p>
     * <p>By default the file picker shows a clickable dropzone for selecting files for upload. However, it can be replaced with any clickable element like a button. After the files are selected, the FilePicker fires a "select" event with the selected files. Application has to specify the listener in order to do the actual upload.  The types of files accepted are controlled by the accept attribute.  Additional custom validation can be done through the ojBeforeSelect event.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-file-picker >&lt;/oj-c-file-picker></code></pre>
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     * </p>
     *
     * <h3 id="touch-section">
     * Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *      <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Clickable element</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Launch the browser's file picker.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Clickable element</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Launch the browser's file picker.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     *
     * @ojmetadata description "A file picker displays a clickable dropzone for selecting files from the device storage."
     * @ojmetadata displayName "File Picker"
     * @ojmetadata help "oj-c.FilePicker.html"
     * @ojmetadata main "oj-c/file-picker"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-file-picker"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/file-picker"
     *   },
     *   "oracle": {
     *    "icon": "oj-ux-ico-file-image",
     *     "uxSpecs": [
     *       "file-picker"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "accept",
     *       "selectionMode",
     *       "disabled",
     *       "primaryText",
     *       "secondaryText"
     *     ]
     *   }
     * ]
     * @ojmetadata since "14.0.0"
     */
    ({ capture = 'none', disabled = false, selectionMode = 'multiple', trigger, accept, primaryText, secondaryText, onOjBeforeSelect, onOjSelect, onOjInvalidSelect, ...otherProps }, ref) => {
        // this promise is used by the doSelectHelper to tell the webelement test file has been selected/rejected
        const elementPromiseResolverRef = (0, hooks_1.useRef)(null);
        const resolveTestPromise = (0, hooks_1.useCallback)(() => {
            if (elementPromiseResolverRef.current) {
                elementPromiseResolverRef.current();
                elementPromiseResolverRef.current = null;
            }
        }, []);
        const onCommit = (0, hooks_1.useCallback)((event) => {
            onOjBeforeSelect?.({ files: event.files }).then(() => {
                resolveTestPromise();
                onOjSelect?.({ files: event.files });
            }, (messages) => {
                resolveTestPromise();
                onOjInvalidSelect?.({ messages: messages, until: null });
            });
        }, [onOjBeforeSelect, onOjSelect, onOjInvalidSelect, resolveTestPromise]);
        const onReject = (0, hooks_1.useCallback)((event) => {
            resolveTestPromise();
            onOjInvalidSelect?.(event);
        }, [onOjInvalidSelect, resolveTestPromise]);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            focus: () => (0, focusUtils_1.focusFirstTabStop)(rootRef.current),
            blur: () => {
                const focusElement = document.activeElement;
                if (rootRef.current?.contains(focusElement)) {
                    focusElement.blur();
                }
            }
        }));
        const rootRef = (0, hooks_1.useRef)(null);
        const preactRef = (0, hooks_1.useRef)(null);
        const BaseFilePicker = UNSAFE_FilePicker_1.FilePicker;
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, class: trigger ? 'oj-c-file-picker-with-trigger' : undefined, children: (0, jsx_runtime_1.jsx)(BaseFilePicker, { __testHandlerSymbol: preactRef, capture: capture === null ? undefined : capture, isDisabled: disabled, selectionMode: selectionMode, onCommit: onCommit, onReject: onReject, accept: accept === null ? undefined : accept, primaryText: getPrimaryText(primaryText), secondaryText: getSecondaryText(secondaryText, selectionMode), "aria-label": otherProps['aria-label'], width: "100%", children: trigger }) }));
    }), "FilePicker", { "properties": { "accept": { "type": "Array<string>|null" }, "capture": { "type": "string|null", "enumValues": ["none", "environment", "user", "implementation"] }, "disabled": { "type": "boolean" }, "primaryText": { "type": "string|function" }, "secondaryText": { "type": "string|function" }, "selectionMode": { "type": "string", "enumValues": ["multiple", "single"] } }, "slots": { "trigger": {} }, "events": { "ojBeforeSelect": { "cancelable": true }, "ojInvalidSelect": {}, "ojSelect": {} }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["aria-label"] }, "methods": { "focus": {}, "blur": {} } }, { "capture": "none", "disabled": false, "selectionMode": "multiple" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/file-picker',["require", "exports", "oj-c/file-picker/file-picker"], function (require, exports, file_picker_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilePicker = void 0;
    Object.defineProperty(exports, "FilePicker", { enumerable: true, get: function () { return file_picker_1.FilePicker; } });
});


define('oj-c/meter-bar/meter-bar',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_MeterBar", "ojs/ojvcomponent", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "../utils/UNSAFE_meterUtils/meterUtils", "@oracle/oraclejet-preact/utils/UNSAFE_stringUtils", "css!oj-c/meter-bar/meter-bar-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_MeterBar_1, ojvcomponent_1, hooks_1, UNSAFE_useTabbableMode_1, meterUtils_1, UNSAFE_stringUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeterBar = void 0;
    exports.MeterBar = (0, ojvcomponent_1.registerCustomElement)('oj-c-meter-bar', 
    /**
     * @classdesc
     * <h3 id="meterBarOverview-section">
     *   JET meter bar
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#meterBarOverview-section"></a>
     * </h3>
     * A meter bar is typically used to display or accept user feedback on a product or service.
     * <pre class="prettyprint"><code>&lt;oj-c-meter-bar value='4'>&lt;/oj-c-meter-bar></code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     * The application is required to set one of the following attributes on the element with meaningful descriptors as the oj-c-meter-bar element does not provide a default descriptor.
     * </p>
     * <ul>
     *   <li>aria-label</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-describedby</li>
     * </ul>
     *
     * <p>
     * If the application is using readonly, thresholds or reference lines to provide additional context, they need to include such information for screender readers using either of the following methods:
     *  <ul>
     *   <li>aria-describedby</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-label</li>
     *   <li>datatip</li>
     *  </ul>
     * </p>
     * <p>
     * If you are using indicatorColor, applications are responsible for making sure that the color meets the
     * <a href="https://www.w3.org/TR/WCAG21/#contrast-minimum">minimum contrast ratio</a>.
     * </p>
     *
     * <h3 id="keyboardSection">
     *   Keyboard
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboardSection"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Submit the current value of the meter bar.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Move focus to next element and submit the current value of the meter bar.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>Move focus to previous element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>End</kbd></td>
     *       <td>Increase the meter bar's transient value to max value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Home</kbd></td>
     *       <td>Decrease the meter bar's transient value to zero. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Increase the meter bar's transient value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Decrease the meter bar's transient value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Decrease the meter bar's transient value in left-to-right locales. Increase the meter bar's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Increase the meter bar's transient value in left-to-right locales. Decrease the meter bar's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="touch-section">
     * Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Drag</kbd></td>
     *       <td>Value change when <code class="prettyprint">readonly</code> is <code class="prettyprint">false</code>.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojmetadata description "A Meter bar displays information graphically in a rectangular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds."
     * @ojmetadata displayName "Meter Bar"
     * @ojmetadata main "oj-c/meter-bar"
     * @ojmetadata help "oj-c.MeterBar.html"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-status-meter-gauge"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/meter-bar"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-linear-status",
     *     "uxSpecs": [
     *       "meter-bar"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "orientation",
     *       "thresholdDisplay",
     *       "plotArea.rendered",
     *       "color",
     *       "style"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value",
     *       "min",
     *       "max",
     *       "step",
     *       "thresholds",
     *       "referenceLines"
     *     ]
     *   }
     * ]
     * @ojmetadata since "14.0.0"
     *
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby", "aria-describedby", "described-by", "labelled-by"]
     *  }
     * ]
     *
     */
    ({ max = 100, value = 0, min = 0, size = 'md', orientation = 'horizontal', step = 1, indicatorSize = 1, readonly = false, thresholdDisplay = 'indicator', baseline, ...props }) => {
        const rootRef = (0, hooks_1.useRef)(null);
        const [hoveredVal, setHoveredVal] = (0, hooks_1.useState)();
        const inputHandler = (detail) => {
            setHoveredVal(detail.value);
            props.onTransientValueChanged?.(detail.value);
        };
        const commitHandler = (detail) => {
            props.onValueChanged?.(detail.value);
        };
        const thresholds = props.thresholds?.map((threshold, index) => {
            return {
                ...threshold,
                color: (0, meterUtils_1.getThresholdColorByIndex)(threshold, index)
            };
        });
        const preactMeterBarAriaLabelledBy = (0, UNSAFE_stringUtils_1.merge)([props['aria-labelledby'], props.labelledBy]);
        const preactMeterBarAriaDescribedBy = (0, UNSAFE_stringUtils_1.merge)([props['aria-describedby'], props.describedBy]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, class: `oj-c-meter-bar-${orientation}${size === 'fit' ? '-fit' : ''}`, children: (0, jsx_runtime_1.jsx)(UNSAFE_MeterBar_1.MeterBar, { isReadonly: readonly, value: (hoveredVal != undefined ? hoveredVal : value), step: step, max: max, min: min, size: size, orientation: orientation, indicatorSize: indicatorSize, baseline: baseline, datatip: props.datatip
                    ? props.datatip({
                        value: hoveredVal != undefined ? hoveredVal : value
                    })
                    : props.datatip, onCommit: readonly ? undefined : commitHandler, onInput: readonly ? undefined : inputHandler, length: '100%', thresholds: thresholds, referenceLines: props.referenceLines, thresholdDisplay: thresholdDisplay === 'plotArea' ? 'track' : thresholdDisplay, indicatorColor: props.color, trackColor: props.plotArea?.color, isTrackRendered: props.plotArea?.rendered !== 'off', "aria-label": props['aria-label'], "aria-labelledby": preactMeterBarAriaLabelledBy ?? undefined, "aria-describedby": preactMeterBarAriaDescribedBy ?? undefined }) }));
    }, "MeterBar", { "properties": { "max": { "type": "number" }, "min": { "type": "number" }, "readonly": { "type": "boolean" }, "value": { "type": "number|null", "writeback": true }, "baseline": { "type": "number" }, "step": { "type": "number" }, "color": { "type": "string" }, "indicatorSize": { "type": "number" }, "plotArea": { "type": "object", "properties": { "color": { "type": "string" }, "rendered": { "type": "string", "enumValues": ["off", "on"] } } }, "orientation": { "type": "string", "enumValues": ["horizontal", "vertical"] }, "referenceLines": { "type": "Array<object>" }, "thresholdDisplay": { "type": "string", "enumValues": ["all", "plotArea", "indicator"] }, "thresholds": { "type": "Array<object>" }, "describedBy": { "type": "string|null" }, "labelledBy": { "type": "string|null" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg", "fit"] }, "datatip": { "type": "function" }, "transientValue": { "type": "number", "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["value", "transientValue"], "_READ_ONLY_PROPS": ["transientValue"], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby", "aria-describedby"] } }, { "max": 100, "value": 0, "min": 0, "size": "md", "orientation": "horizontal", "step": 1, "indicatorSize": 1, "readonly": false, "thresholdDisplay": "indicator" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/meter-bar',["require", "exports", "oj-c/meter-bar/meter-bar"], function (require, exports, meter_bar_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeterBar = void 0;
    Object.defineProperty(exports, "MeterBar", { enumerable: true, get: function () { return meter_bar_1.MeterBar; } });
});


define('oj-c/meter-circle/meter-circle',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_MeterCircle", "ojs/ojvcomponent", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "../utils/UNSAFE_meterUtils/meterUtils", "@oracle/oraclejet-preact/utils/UNSAFE_stringUtils", "css!oj-c/meter-circle/meter-circle-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_MeterCircle_1, ojvcomponent_1, hooks_1, UNSAFE_useTabbableMode_1, meterUtils_1, UNSAFE_stringUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeterCircle = void 0;
    exports.MeterCircle = (0, ojvcomponent_1.registerCustomElement)('oj-c-meter-circle', 
    /**
     * @classdesc
     * <h3 id="meterCircleOverview-section">
     *   JET meter circle
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#meterCircleOverview-section"></a>
     * </h3>
     * A meter circle displays information graphically in a circular bar, highlighting a specific metric value's progress in relation to its min, max and thresholds.
     * <pre class="prettyprint"><code>&lt;oj-c-meter-circle value='4'>&lt;/oj-c-meter-circle></code></pre>
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     * The application is required to set one of the following attributes on the element with meaningful descriptors as the oj-c-meter-circle element does not provide a default descriptor.
     * </p>
     * <ul>
     *   <li>aria-label</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-describedby</li>
     * </ul>
     *
     * <p>
     * If the application is using readonly, thresholds or reference lines to provide additional context, they need to include such information for screender readers using either of the following methods:
     *  <ul>
     *   <li>aria-describedby</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-label</li>
     *   <li>datatip</li>
     *  </ul>
     * </p>
     * <p>
     * If you are using indicatorColor, applications are responsible for making sure that the color meets the
     * <a href="https://www.w3.org/TR/WCAG21/#contrast-minimum">minimum contrast ratio</a>.
     * </p>
     *
     * <h3 id="keyboardSection">
     *   Keyboard
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboardSection"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Submit the current value of the meter circle.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Move focus to next element and submit the current value of the meter circle.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>Move focus to previous element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>End</kbd></td>
     *       <td>Increase the meter circle's transient value to max value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Home</kbd></td>
     *       <td>Decrease the meter circle's transient value to zero. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Increase the meter circle's transient value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Decrease the meter circle's transient value. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Decrease the meter circle's transient value in left-to-right locales. Increase the meter circle's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Increase the meter circle's transient value in left-to-right locales. Decrease the meter circle's transient value in right-to-left locales. Value is set after using <kbd>Enter</kbd> or <kbd>Tab</kbd> to submit.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="touch-section">
     * Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Drag</kbd></td>
     *       <td>Value change when <code class="prettyprint">readonly</code> is <code class="prettyprint">false</code>.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojmetadata description "A Meter circle displays information graphically in a circular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds."
     * @ojmetadata displayName "Meter circle"
     * @ojmetadata main "oj-c/meter-circle"
     * @ojmetadata help "oj-c.Metercircle.html"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "15.0.0",
     *     "value": ["oj-status-meter-gauge"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/meter-circle"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-circular-progress-7",
     *     "uxSpecs": [
     *       "meter-circle"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "thresholdDisplay",
     *       "plotArea.rendered",
     *       "color",
     *       "style"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "value",
     *       "min",
     *       "max",
     *       "step",
     *       "thresholds",
     *       "referenceLines"
     *     ]
     *   }
     * ]
     * @ojmetadata since "14.0.0"
     *
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby", "aria-describedby", "described-by", "labelled-by"]
     *  }
     * ]
     *
     */
    ({ max = 100, value = 0, min = 0, size = 'md', step = 1, readonly = false, startAngle = 90, indicatorSize = 1, angleExtent = 360, thresholdDisplay = 'indicator', ...props }) => {
        const rootRef = (0, hooks_1.useRef)(null);
        const [hoveredVal, setHoveredVal] = (0, hooks_1.useState)();
        const inputHandler = (detail) => {
            setHoveredVal(detail.value);
            props.onTransientValueChanged?.(detail.value);
        };
        const commitHandler = (detail) => {
            props.onValueChanged?.(detail.value);
        };
        const thresholds = props.thresholds?.map((threshold, index) => {
            return {
                ...threshold,
                color: (0, meterUtils_1.getThresholdColorByIndex)(threshold, index)
            };
        });
        const preactMeterCircleAriaLabelledBy = (0, UNSAFE_stringUtils_1.merge)([props['aria-labelledby'], props.labelledBy]);
        const preactMeterCircleAriaDescribedBy = (0, UNSAFE_stringUtils_1.merge)([props['aria-describedby'], props.describedBy]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, class: size === 'fit' ? 'oj-c-meter-circle-fit' : undefined, children: (0, jsx_runtime_1.jsx)(UNSAFE_MeterCircle_1.MeterCircle, { isReadonly: readonly, value: (hoveredVal != undefined ? hoveredVal : value), step: step, max: max, min: min, size: size, angleExtent: angleExtent, startAngle: startAngle, indicatorSize: indicatorSize, innerRadius: props.innerRadius, datatip: props.datatip
                    ? props.datatip({
                        value: hoveredVal != undefined ? hoveredVal : value
                    })
                    : props.datatip, onCommit: readonly ? undefined : commitHandler, onInput: readonly ? undefined : inputHandler, thresholds: thresholds, trackColor: props.plotArea?.color, indicatorColor: props.color, isTrackRendered: props.plotArea?.rendered !== 'off', referenceLines: props.referenceLines, thresholdDisplay: thresholdDisplay === 'plotArea' ? 'track' : thresholdDisplay, "aria-label": props['aria-label'], "aria-labelledby": preactMeterCircleAriaLabelledBy ?? undefined, "aria-describedby": preactMeterCircleAriaDescribedBy ?? undefined, children: (context) => {
                    return props.centerTemplate?.({ value, ...context });
                } }) }));
    }, "MeterCircle", { "properties": { "max": { "type": "number" }, "min": { "type": "number" }, "readonly": { "type": "boolean" }, "value": { "type": "number|null", "writeback": true }, "step": { "type": "number" }, "color": { "type": "string" }, "indicatorSize": { "type": "number" }, "innerRadius": { "type": "number" }, "plotArea": { "type": "object", "properties": { "color": { "type": "string" }, "rendered": { "type": "string", "enumValues": ["off", "on"] } } }, "angleExtent": { "type": "number" }, "startAngle": { "type": "number" }, "referenceLines": { "type": "Array<object>" }, "thresholdDisplay": { "type": "string", "enumValues": ["all", "plotArea", "indicator"] }, "thresholds": { "type": "Array<object>" }, "describedBy": { "type": "string|null" }, "labelledBy": { "type": "string|null" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg", "fit"] }, "datatip": { "type": "function" }, "transientValue": { "type": "number", "readOnly": true, "writeback": true } }, "slots": { "centerTemplate": { "data": {} } }, "extension": { "_WRITEBACK_PROPS": ["value", "transientValue"], "_READ_ONLY_PROPS": ["transientValue"], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby", "aria-describedby"] } }, { "max": 100, "value": 0, "min": 0, "size": "md", "step": 1, "readonly": false, "startAngle": 90, "indicatorSize": 1, "angleExtent": 360, "thresholdDisplay": "indicator" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/meter-circle',["require", "exports", "oj-c/meter-circle/meter-circle"], function (require, exports, meter_circle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MeterCircle = void 0;
    Object.defineProperty(exports, "MeterCircle", { enumerable: true, get: function () { return meter_circle_1.MeterCircle; } });
});


define('oj-c/line-chart/line-chart',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useBusyStateContext", "@oracle/oraclejet-preact/UNSAFE_VisProgressiveLoader", "@oracle/oraclejet-preact/UNSAFE_LineAreaChart", "@oracle/oraclejet-preact/UNSAFE_VisStatusMessage", "@oracle/oraclejet-preact/hooks/UNSAFE_useLegendPreferredSize", "@oracle/oraclejet-preact/UNSAFE_TrackResizeContainer", "ojs/ojvcomponent", "../hooks/UNSAFE_useChartData/useChartData", "../utils/PRIVATE_chartUtils/events", "../utils/PRIVATE_chartUtils/legendUtils", "../hooks/UNSAFE_useVizCategories/useVizCategories", "@oracle/oraclejet-preact/UNSAFE_Legend", "@oracle/oraclejet-preact/UNSAFE_ChartWithLegend", "../utils/PRIVATE_chartUtils/lineAreaUtils", "oj-c/utils/PRIVATE_chartUtils/plotAreaUtils", "../utils/PRIVATE_chartUtils/axisUtils", "oj-c/hooks/PRIVATE_useVisContextMenu/useVisContextMenu", "css!oj-c/line-chart/line-chart-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, hooks_1, UNSAFE_useBusyStateContext_1, UNSAFE_VisProgressiveLoader_1, UNSAFE_LineAreaChart_1, UNSAFE_VisStatusMessage_1, UNSAFE_useLegendPreferredSize_1, UNSAFE_TrackResizeContainer_1, ojvcomponent_1, useChartData_1, events_1, legendUtils_1, useVizCategories_1, UNSAFE_Legend_1, UNSAFE_ChartWithLegend_1, lineAreaUtils_1, plotAreaUtils_1, axisUtils_1, useVisContextMenu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineChart = void 0;
    const HIGHLIGHTED_DEFAULT = [];
    const SELECTION_DEFAULT = [];
    const HIDDEN_DEFAULT = [];
    const LEGEND_DEFAULT = { rendered: 'on', position: 'auto' };
    /**
     * @classdesc
     * <h3 id="lineChartOverview-section">
     *   JET Line Chart
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#lineChartOverview-section"></a>
     * </h3>
     *
     * <p>A line chart displays information graphically using data points connected by straight or curved lines, making relationships among the data easier to understand.</p>
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-line-chart
     *   data="[[dataProvider]]">
     * &lt;/oj-c-line-chart>
     * </code>
     * </pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * To make your component accessible, the application is required to include contextual information for screender readers using one or more the following methods as appropriate:
     *  <ul>
     *   <li>aria-describedby</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-label</li>
     *   <li>short-desc property of your items</li>
     *  </ul>
     * <p>
     *  If your application has custom keyboard and touch shortcuts implemented for the component, these shortcuts can conflict with those of the component. It is the application's responsibility to disclose these custom shortcuts, possibly via a datatip or help popup.
     * </p>
     * <p>
     *  When setting color, applications are responsible for making sure that the color meets the <a target="_blank" href="https://www.w3.org/TR/WCAG21/#contrast-minimum">minimum contrast requirements</a>.
     * </p>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Move focus to next element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>Move focus to previous element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Move focus and selection to previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Move focus and selection to next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Move focus and selection to previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Move focus and selection to next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + UpArrow</kbd></td>
     *       <td>Move focus and multi-select previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + DownArrow</kbd></td>
     *       <td>Move focus and multi-select next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + LeftArrow</kbd></td>
     *       <td>Move focus and multi-select previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + RightArrow</kbd></td>
     *       <td>Move focus and multi-select next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + UpArrow</kbd></td>
     *       <td>Move focus to previous data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + DownArrow</kbd></td>
     *       <td>Move focus to next data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + LeftArrow</kbd></td>
     *       <td>Move focus to previous data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + RightArrow</kbd></td>
     *       <td>Move focus to next data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + Spacebar</kbd></td>
     *       <td>Multi-select data item with focus.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>= or +</kbd></td>
     *       <td>Zoom in one level if zooming is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>- or _</kbd></td>
     *       <td>Zoom out one level if zooming is enabled.</td>
     *     </tr>
     *      <tr>
     *       <td><kbd>PageUp or Shift + PageUp</kbd></td>
     *       <td>Pan left in left-to-right locales. Pan right in right-to-left locales.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>PageDown or Shift + PageDown</kbd></td>
     *       <td>Pan right in left-to-right locales. Pan left in right-to-left locales.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Drill on data item, categorical axis label, or legend item when <code class="prettyprint">drilling</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+F10</kbd></td>
     *       <td>Launch the context menu if there is one associated with the current item.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <h4>Data Set Size</h4>
     * <p>As a rule of thumb, it's recommended that applications only set usable data densities on the chart. For example,
     *    it's not recommended to show more than 500 lines on a 500 pixel wide chart, since the  lines will be unusably thin.
     *    While there are several optimizations within the chart to deal with large data sets, it's always more efficient to
     *    reduce the data set size as early as possible. Future optimizations will focus on improving end user experience as
     *    well as developer productivity for common use cases.
     * </p>
     *
     * <h4>Styling</h4>
     * <p>Use the highest level property available. For example, consider setting styling properties on
     *    <code class="prettyprint">styleDefaults</code> or <code class="prettyprint">series</code>, instead of styling properties
     *    on the individual data items. The chart can take advantage of these higher level properties to apply the style properties on
     *    containers, saving expensive DOM calls.
     * </p>
     *
     *
     * <h3 id="touch-section">
     * Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="5">Data Item</td>
     *       <td rowspan="2"><kbd>Tap</kbd></td>
     *       <td>Select when <code class="prettyprint">selectionMode</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td>Drill when <code class="prettyprint">drilling</code> is enabled and <code class="prettyprint">selectionMode</code> is <code class="prettyprint">none</code>.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Double Tap</kbd></td>
     *       <td>Drill when <code class="prettyprint">drilling</code> is enabled and <code class="prettyprint">selectionMode</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2"><kbd>Press & Hold</kbd></td>
     *       <td>Display tooltip.</td>
     *     </tr>
     *     <tr>
     *       <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2">Categorical Axis Item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Drill when <code class="prettyprint">drilling</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2">Legend Item</td>
     *       <td rowspan="2"><kbd>Tap</kbd></td>
     *       <td>Drill when <code class="prettyprint">drilling</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td>Filter when <code class="prettyprint">hideAndShowBehavior</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="5">Plot Area</td>
     *       <td rowspan="2"><kbd>Drag</kbd></td>
     *       <td>Pan when panning is enabled and toggled into that mode.</td>
     *     </tr>
     *     <tr>
     *       <td>Marquee select when <code class="prettyprint">selectionMode</code> is <code class="prettyprint">multiple</code> and toggled into that mode.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Pinch-close</kbd></td>
     *       <td>Zoom out when zooming is enabled.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Spread-open</kbd></td>
     *       <td>Zoom in when zooming is enabled.</td>
     *     </tr>
     *     <tr>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *        <td>Series Line</td>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *        <td>Axis Title</td>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojmetadata description "A line chart displays information graphically using data points connected by straight or curved lines, making relationships among the data easier to understand."
     * @ojmetadata displayName "Line Chart"
     * @ojmetadata main "oj-c/line-chart"
     * @ojmetadata help "oj-c.LineChart.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/line-chart",
     *       "defaultColumns": 6,
     *         "minColumns": 1
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-line-chart",
     *     "uxSpecs": [
     *       "line-chart"
     *     ]
     *   }
     * }
     *
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *        "orientation",
     *        "legend.position",
     *        "legend.rendered",
     *        "stack",
     *        "xAxis.title",
     *        "yAxis.title",
     *        "style"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data"
     *     ]
     *   }
     * ]
     * @ojmetadata since "16.0.0"
     *
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby", "aria-describedby"]
     *  }
     * ]
     *
     */
    function LineChartComp({ data, hideAndShowBehavior = 'none', orientation = 'vertical', xAxis, yAxis, y2Axis, hoverBehavior = 'none', valueFormats, plotArea, zoomAndScroll, itemTemplate, seriesTemplate, groupTemplate, seriesComparator, groupComparator, drilling = 'off', hiddenCategories = HIDDEN_DEFAULT, timeAxisType, highlightedCategories = HIGHLIGHTED_DEFAULT, highlightMatch = 'any', selection = SELECTION_DEFAULT, selectionMode = 'none', stack = 'off', legend = LEGEND_DEFAULT, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, splitterPosition = 0.5, splitDualY = 'off', ...props }) {
        const rootRef = (0, hooks_1.useRef)(null);
        const busyStateContext = (0, hooks_1.useContext)(UNSAFE_useBusyStateContext_1.BusyStateContext);
        const { series, groups, getDataItem, isLoading, idToDPItemMap, createGroupContext } = (0, useChartData_1.useChartData)(data, busyStateContext.addBusyState, itemTemplate, seriesTemplate, groupTemplate, 'oj-c-line-chart-item', 'oj-c-line-chart-series', 'oj-c-line-chart-group', seriesComparator, groupComparator);
        const { majorTick: xMajorTick, ...xAxisRest } = xAxis ?? {};
        const { majorTick: yMajorTick, minorTick: yMinorTick, ...yAxisRest } = yAxis ?? {};
        const { majorTick: y2MajorTick, minorTick: y2MinorTick, ...y2AxisRest } = y2Axis ?? {};
        const { seriesDrillHandler, itemDrillHandler, groupDrillHandler } = (0, events_1.getChartEventsHandler)(series, groups, drilling, props.onOjItemDrill, props.onOjGroupDrill, props.onOjSeriesDrill, createGroupContext);
        const selectionChangeHandler = (detail) => {
            props.onSelectionChanged?.(detail.ids);
        };
        const categoriesItems = (0, legendUtils_1.getBLACCategoriesItems)(series, groups, getDataItem, hoverBehavior, hideAndShowBehavior);
        const { hiddenIds, updateHidden, highlightedIds, updateHighlighted } = (0, useVizCategories_1.useVizCategories)(categoriesItems, (item) => item.categories, hiddenCategories, highlightedCategories, 'any', highlightMatch, props.onHiddenCategoriesChanged, props.onHighlightedCategoriesChanged);
        const onItemInput = (0, hooks_1.useCallback)((detail) => {
            if (hoverBehavior === 'none')
                return;
            const id = (0, events_1.getIdFromDetail)(detail, series, getDataItem);
            updateHighlighted(id);
        }, [hoverBehavior, updateHighlighted, getDataItem, series]);
        const legendData = (0, legendUtils_1.getLegendData)(series);
        const isLegendRendered = (legend.rendered || legendUtils_1.LegendDefaults.rendered) != 'off';
        const isLegendInteractive = hideAndShowBehavior != 'none' ||
            hoverBehavior != 'none' ||
            drilling === 'on' ||
            drilling === 'seriesOnly';
        const legendItemActionHandler = (detail) => {
            if (hideAndShowBehavior != 'none') {
                updateHidden(detail.itemId);
                return;
            }
            seriesDrillHandler(detail);
        };
        const legendItemInputHandler = (detail) => {
            if (hoverBehavior != 'none') {
                updateHighlighted(detail.itemId);
            }
        };
        const { preactContextMenuConfig } = (0, useVisContextMenu_1.useVisContextMenu)(idToDPItemMap, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection);
        const renderLegend = (0, legendUtils_1.shouldRenderLegend)(series.length, legend.rendered);
        const legendSizeRef = (0, hooks_1.useRef)(null);
        const [isGetPreferredSizeReady, setIsGetPreferredSizeReady] = (0, hooks_1.useState)(false);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, children: (0, jsx_runtime_1.jsx)(UNSAFE_TrackResizeContainer_1.TrackResizeContainer, { width: "100%", height: "100%", children: (_width, _height) => {
                    const legendPreferredSize = isGetPreferredSizeReady
                        ? legendSizeRef.current._getPreferredSize(_width, _height)
                        : undefined;
                    const legendPosition = (0, legendUtils_1.getLegendPosition)(legend.position, _width, _height);
                    const isLegendDimsResolved = !renderLegend || (renderLegend && legendPreferredSize);
                    const legendGap = (0, legendUtils_1.getLegendGap)(_width, _height);
                    const { width: preactChartWidth, height: preactChartHeight } = (0, legendUtils_1.getPreactChartDimensions)(_width, _height, legendPosition, legendPreferredSize);
                    const chart = series.length > 0 && groups.length > 0 && isLegendDimsResolved ? ((0, jsx_runtime_1.jsx)(UNSAFE_LineAreaChart_1.LineAreaChart, { type: "line", width: preactChartWidth, height: preactChartHeight, series: series, groups: groups, getDataItem: getDataItem, onItemHover: onItemInput, onItemFocus: onItemInput, drilling: drilling === 'seriesOnly' ? 'off' : drilling, dragMode: props.dragMode, onItemDrill: itemDrillHandler, onGroupDrill: groupDrillHandler, onSelectionChange: selectionChangeHandler, selectionMode: selectionMode, selectedIds: selectionMode === 'none' ? undefined : selection, orientation: orientation, xAxis: (0, axisUtils_1.getPreactAxisProps)({ ...xAxisRest, timeAxisType }, props.styleDefaults), yAxis: (0, axisUtils_1.getPreactAxisProps)(yAxisRest), y2Axis: {
                            ...(0, axisUtils_1.getPreactAxisProps)(y2AxisRest),
                            split: splitDualY === 'on' ? 1 - splitterPosition : 'off'
                        }, highlightedIds: highlightedIds.length === 0 ? undefined : highlightedIds, hiddenIds: hiddenIds, plotArea: (0, plotAreaUtils_1.getPlotArea)(plotArea, yMajorTick, yMinorTick, xMajorTick, y2MajorTick, y2MinorTick), hideAndShowBehavior: hideAndShowBehavior, hoverBehavior: hoverBehavior, isStacked: stack === 'on', valueFormats: (0, lineAreaUtils_1.transformValueFormats)(valueFormats), "aria-label": props['aria-label'], "aria-describedBy": props['aria-describedby'], "aria-labelledBy": props['aria-labelledby'], 
                        // @ts-ignore
                        contextMenuConfig: contextMenuConfig ? preactContextMenuConfig : undefined })) : (!isLoading && ((0, jsx_runtime_1.jsx)(UNSAFE_VisStatusMessage_1.VisNoData, { "aria-label": props['aria-label'], "aria-describedby": props['aria-describedby'], "aria-labelledby": props['aria-labelledby'] })));
                    const legendMaxWidth = legendPosition === 'start' || legendPosition === 'end'
                        ? (legendPreferredSize?.width || _width * legendUtils_1.LEGENDMAXSIZE) + legendGap.width
                        : _width;
                    const legendMaxHeight = legendPosition === 'top' || legendPosition === 'bottom'
                        ? (legendPreferredSize?.height || _height * legendUtils_1.LEGENDMAXSIZE) + legendGap.height
                        : _height;
                    const chartLegend = isLegendRendered && legendData.length > 0 ? (
                    // TODO: replace with sectional legend when implementing
                    // reference line. Currently sectional legend does not render properly
                    // for top and bottom legend position.
                    (0, jsx_runtime_1.jsx)(UNSAFE_useLegendPreferredSize_1.LegendRenderedContext.Provider, { value: {
                            isGetPreferredSizeReady: !isGetPreferredSizeReady
                                ? setIsGetPreferredSizeReady
                                : undefined,
                            width: legendMaxWidth,
                            height: legendMaxHeight
                        }, children: (0, jsx_runtime_1.jsx)(UNSAFE_Legend_1.Legend, { items: legendData, ref: legendSizeRef, orientation: legendPosition === 'start' || legendPosition === 'end'
                                ? 'vertical'
                                : 'horizontal', halign: "center", valign: "center", hideAndShowBehavior: hideAndShowBehavior === 'none' ? 'off' : 'on', hoverBehavior: hoverBehavior, isReadOnly: !isLegendInteractive, highlightedIds: highlightedIds.length === 0 ? undefined : highlightedIds, hiddenIds: hiddenIds.length === 0 ? undefined : hiddenIds, symbolHeight: legend.symbolHeight, symbolWidth: legend.symbolWidth, onItemAction: legendItemActionHandler, onItemHover: legendItemInputHandler, onItemFocus: legendItemInputHandler }) })) : undefined;
                    return ((0, jsx_runtime_1.jsx)(UNSAFE_VisProgressiveLoader_1.VisProgressiveLoader, { isLoading: isLoading, type: "area", "aria-label": props['aria-label'], "aria-describedBy": props['aria-describedby'], "aria-labelledBy": props['aria-labelledby'], children: (0, jsx_runtime_1.jsx)(UNSAFE_ChartWithLegend_1.ChartWithLegend, { chart: chart, position: legendPosition, isRtl: false, legend: chartLegend }) }));
                } }) }));
    }
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const LineChartWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-line-chart', LineChartComp, "LineChart", { "properties": { "groupComparator": { "type": "function" }, "stack": { "type": "string", "enumValues": ["off", "on"] }, "drilling": { "type": "string", "enumValues": ["off", "on", "groupsOnly", "seriesOnly"] }, "orientation": { "type": "string", "enumValues": ["horizontal", "vertical"] }, "splitDualY": { "type": "string", "enumValues": ["off", "on"] }, "splitterPosition": { "type": "number" }, "timeAxisType": { "type": "string", "enumValues": ["enabled", "mixedFrequency", "skipGaps"] }, "yAxis": { "type": "object", "properties": { "dataMax": { "type": "number" }, "dataMin": { "type": "number" }, "max": { "type": "number" }, "min": { "type": "number" }, "majorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "minorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "tickLabel": { "type": "object", "properties": { "converter": { "type": "object" }, "rendered": { "type": "string", "enumValues": ["off", "on"] }, "style": { "type": "object" } } }, "viewportMin": { "type": "number" }, "viewportMax": { "type": "number" }, "step": { "type": "number" }, "size": { "type": "number" }, "scale": { "type": "string", "enumValues": ["linear", "log"] }, "title": { "type": "string" }, "titleStyle": { "type": "object" } } }, "y2Axis": { "type": "object", "properties": { "dataMax": { "type": "number" }, "dataMin": { "type": "number" }, "max": { "type": "number" }, "min": { "type": "number" }, "majorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "minorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "tickLabel": { "type": "object", "properties": { "converter": { "type": "object" }, "rendered": { "type": "string", "enumValues": ["off", "on"] }, "style": { "type": "object" } } }, "viewportMin": { "type": "number" }, "viewportMax": { "type": "number" }, "step": { "type": "number" }, "size": { "type": "number" }, "scale": { "type": "string", "enumValues": ["linear", "log"] }, "title": { "type": "string" }, "titleStyle": { "type": "object" } } }, "xAxis": { "type": "object", "properties": { "majorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "minorTick": { "type": "object", "properties": { "lineColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] } } }, "tickLabel": { "type": "object", "properties": { "converter": { "type": "object|Array<object>" }, "rendered": { "type": "string", "enumValues": ["off", "on"] }, "rotation": { "type": "string", "enumValues": ["auto", "none"] }, "style": { "type": "object" } } }, "viewportMin": { "type": "number" }, "viewportMax": { "type": "number" }, "step": { "type": "number" }, "size": { "type": "number" }, "scale": { "type": "string", "enumValues": ["linear", "log"] }, "title": { "type": "string" }, "titleStyle": { "type": "object" } } }, "plotArea": { "type": "object", "properties": { "backgroundColor": { "type": "string" } } }, "zoomAndScroll": { "type": "string", "enumValues": ["off", "live"] }, "valueFormats": { "type": "object", "properties": { "group": { "type": "object", "properties": { "tooltipLabel": { "type": "string" }, "tooltipDisplay": { "type": "string", "enumValues": ["auto", "off"] } } }, "series": { "type": "object", "properties": { "tooltipLabel": { "type": "string" }, "tooltipDisplay": { "type": "string", "enumValues": ["auto", "off"] } } }, "value": { "type": "object", "properties": { "converter": { "type": "object" }, "tooltipLabel": { "type": "string" }, "tooltipDisplay": { "type": "string", "enumValues": ["auto", "off"] } } } } }, "styleDefaults": { "type": "object", "properties": { "groupSeparators": { "type": "object", "properties": { "rendered": { "type": "string", "enumValues": ["auto", "off"] }, "color": { "type": "string" } } } } }, "seriesComparator": { "type": "function" }, "data": { "type": "DataProvider|null" }, "selectionMode": { "type": "string", "enumValues": ["none", "multiple", "single"] }, "selection": { "type": "Array<string|number>", "writeback": true }, "dragMode": { "type": "string", "enumValues": ["pan", "zoom", "select", "off", "user"] }, "hiddenCategories": { "type": "Array<string>", "writeback": true }, "highlightedCategories": { "type": "Array<string>", "writeback": true }, "hideAndShowBehavior": { "type": "string", "enumValues": ["none", "withoutRescale", "withRescale"] }, "hoverBehavior": { "type": "string", "enumValues": ["none", "dim"] }, "highlightMatch": { "type": "string", "enumValues": ["all", "any"] }, "legend": { "type": "object", "properties": { "position": { "type": "string", "enumValues": ["auto", "end", "start", "top", "bottom"] }, "rendered": { "type": "string", "enumValues": ["auto", "off", "on"] }, "maxSize": { "type": "number|string" }, "size": { "type": "number|string" }, "symbolHeight": { "type": "number" }, "symbolWidth": { "type": "number" } } }, "contextMenuConfig": { "type": "object", "properties": { "accessibleLabel": { "type": "string" }, "items": { "type": "function" } } } }, "slots": { "itemTemplate": { "data": {} }, "seriesTemplate": { "data": {} }, "groupTemplate": { "data": {} } }, "events": { "ojItemDrill": {}, "ojSeriesDrill": {}, "ojGroupDrill": {}, "ojViewportChange": {}, "ojContextMenuAction": { "bubbles": true }, "ojContextMenuSelection": { "bubbles": true } }, "extension": { "_WRITEBACK_PROPS": ["selection", "hiddenCategories", "highlightedCategories"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-describedby", "aria-labelledby"] } }, { "hideAndShowBehavior": "none", "orientation": "vertical", "hoverBehavior": "none", "drilling": "off", "hiddenCategories": [], "highlightedCategories": [], "highlightMatch": "any", "selection": [], "selectionMode": "none", "stack": "off", "legend": { "rendered": "on", "position": "auto" }, "splitterPosition": 0.5, "splitDualY": "off" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
    exports.LineChart = LineChartWithoutDefaultedGenerics;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/line-chart',["require", "exports", "oj-c/line-chart/line-chart"], function (require, exports, line_chart_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineChart = void 0;
    Object.defineProperty(exports, "LineChart", { enumerable: true, get: function () { return line_chart_1.LineChart; } });
});

define('oj-c/line-chart-item/line-chart-item',["require", "exports", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent"], function (require, exports, translationBundle_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineChartItem = void 0;
    exports.LineChartItem = (0, ojvcomponent_1.registerCustomElement)('oj-c-line-chart-item', 
    /**
     *@classdesc
     *<h3 id="lineChartItemOverview-section">
     *   JET Line Chart Item
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#lineChartItemOverview-section"></a>
     * </h3>
     *
     * <p>The oj-c-line-chart-item element is used to declare item properties. See the Help documentation for more information.</p>
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-line-chart data="[[dataProvider]]">
     *  &lt;template slot='itemTemplate'>
     *    &lt;oj-c-line-chart-item
     *      value="[[$current.data.value]]"
     *      series-id="[[$current.data.productName]]"
     *      group-id="[[ [$current.data.year] ]]">
     *    &lt;/oj-c-line-chart-item>
     *  &lt;/template>
     * &lt;/oj-c-line-chart>
     * </code>
     * </pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     *  Read the <a target="_blank" href="oj-c.LineChart.html#a11y-section">Accessibility Section</a> of the oj-c-line-chart component for details about making this component accessible.
     * </p>
     *
     * @ojmetadata subcomponentType "data"
     * @ojmetadata description "The oj-c-line-chart-item element is used to declare item properties"
     * @ojmetadata displayName "LineChartItem"
     * @ojmetadata main "oj-c/line-chart-item"
     * @ojmetadata help "oj-c.LineChartItem.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   }
     * }
     * @ojmetadata since "16.0.0"
     */
    ({}) => {
        return null;
    }, "LineChartItem", { "properties": { "seriesId": { "type": "string" }, "groupId": { "type": "Array<string>" }, "value": { "type": "number" }, "x": { "type": "string" }, "color": { "type": "string" }, "markerDisplayed": { "type": "string", "enumValues": ["auto", "off", "on"] }, "markerShape": { "type": "string", "enumValues": ["auto", "square", "circle", "diamond", "human", "plus", "star", "triangleDown", "triangleUp"] }, "markerSize": { "type": "number" }, "categories": { "type": "Array<string>" }, "drilling": { "type": "string", "enumValues": ["inherit", "off", "on"] }, "shortDesc": { "type": "string" } } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/line-chart-item',["require", "exports", "oj-c/line-chart-item/line-chart-item"], function (require, exports, line_chart_item_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineChartItem = void 0;
    Object.defineProperty(exports, "LineChartItem", { enumerable: true, get: function () { return line_chart_item_1.LineChartItem; } });
});

define('oj-c/line-chart-series/line-chart-series',["require", "exports", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent"], function (require, exports, translationBundle_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineChartSeries = exports.LineChartSeriesDefaults = void 0;
    exports.LineChartSeriesDefaults = {
        drilling: 'inherit'
    };
    exports.LineChartSeries = (0, ojvcomponent_1.registerCustomElement)('oj-c-line-chart-series', 
    /**
     *@classdesc
     *<h3 id="lineChartSeriesOverview-section">
     *   JET Line Chart Series
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#lineChartSeriesOverview-section"></a>
     * </h3>
     *
     * <p>The oj-c-line-chart-series element is used to declare series properties. See the Help documentation for more information</p>
     *
     *<pre class="prettyprint">
     * <code>
     * &lt;oj-c-line-chart data="[[dataProvider]]">
     *  &lt;template slot='seriesTemplate'>
     *    &lt;oj-c-line-chart-series
     *      drilling='on'
     *      marker-shape='[[ $current.id == "Series 1" ? "square" : "circle" ]]'>
     *    &lt;/oj-c-line-chart-series>
     *  &lt;/template>
     * &lt;/oj-c-line-chart>
     * </code>
     * </pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     *  Read the <a target="_blank" href="oj-c.LineChart.html#a11y-section">Accessibility Section</a> of the oj-c-line-chart component for details about making this component accessible.
     * </p>
     *
     * @ojmetadata subcomponentType "data"
     * @ojmetadata description "The oj-c-line-chart-series element is used to declare series properties in the seriesTemplate"
     * @ojmetadata displayName "LineChartSeries"
     * @ojmetadata main "oj-c/line-chart-series"
     * @ojmetadata help "oj-c.LineChartSeries.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   }
     * }
     * @ojmetadata since "16.0.0"
     */
    ({ drilling = exports.LineChartSeriesDefaults.drilling, 
    /* @ts-ignore */
    ...props }) => {
        return null;
    }, "LineChartSeries", { "properties": { "assignedToY2": { "type": "string", "enumValues": ["off", "on"] }, "categories": { "type": "Array<string>" }, "color": { "type": "string" }, "drilling": { "type": "string", "enumValues": ["inherit", "off", "on"] }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineType": { "type": "string", "enumValues": ["curved", "straight"] }, "lineWidth": { "type": "number" }, "markerShape": { "type": "string", "enumValues": ["auto", "square", "circle", "diamond", "human", "plus", "star", "triangleDown", "triangleUp"] }, "markerColor": { "type": "string" }, "markerDisplayed": { "type": "string" }, "markerSize": { "type": "number" }, "name": { "type": "string" }, "shortDesc": { "type": "string" } } }, { "drilling": "inherit" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/line-chart-series',["require", "exports", "oj-c/line-chart-series/line-chart-series"], function (require, exports, line_chart_series_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineChartSeries = void 0;
    Object.defineProperty(exports, "LineChartSeries", { enumerable: true, get: function () { return line_chart_series_1.LineChartSeries; } });
});

define('oj-c/line-chart-group/line-chart-group',["require", "exports", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent"], function (require, exports, translationBundle_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineChartGroup = exports.LineChartGroupDefaults = void 0;
    exports.LineChartGroupDefaults = {
        drilling: 'inherit'
    };
    exports.LineChartGroup = (0, ojvcomponent_1.registerCustomElement)('oj-c-line-chart-group', 
    /**
     *@classdesc
     *<h3 id="lineChartGroupOverview-section">
     *   JET Line Chart Group
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#lineChartGroupOverview-section"></a>
     * </h3>
     *
     * <p>The oj-c-line-chart-group element is used to declare group properties. See the Help documentation for more information.</p>
     *
     *<pre class="prettyprint">
     * <code>
     * &lt;oj-c-line-chart data="[[dataProvider]]">
     *  &lt;template slot='groupTemplate'>
     *    &lt;oj-c-line-chart-group
     *      drilling='on'
     *      label-style='[[$current.depth == 1 ? {"fontWeight":"bold"} : {"fontStyle":"italic"}]]'>
     *    &lt;/oj-c-line-chart-group>
     *  &lt;/template>
     * &lt;/oj-c-line-chart>
     * </code>
     * </pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     *  Read the <a target="_blank" href="oj-c.LineChart.html#a11y-section">Accessibility Section</a> of the oj-c-line-chart component for details about making this component accessible.
     * </p>
     *
     * @ojmetadata subcomponentType "data"
     * @ojmetadata description "The oj-c-line-chart-group element is used to declare group properties in the groupTemplate"
     * @ojmetadata displayName "LineChartGroup"
     * @ojmetadata main "oj-c/line-chart-group"
     * @ojmetadata help "oj-c.LineChartGroup.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   }
     * }
     * @ojmetadata since "16.0.0"
     */
    ({ drilling = exports.LineChartGroupDefaults.drilling, 
    /* @ts-ignore */
    ...props }) => {
        return null;
    }, "LineChartGroup", { "properties": { "drilling": { "type": "string", "enumValues": ["inherit", "off", "on"] }, "name": { "type": "string" }, "shortDesc": { "type": "string" } } }, { "drilling": "inherit" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/line-chart-group',["require", "exports", "oj-c/line-chart-group/line-chart-group"], function (require, exports, line_chart_group_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineChartGroup = void 0;
    Object.defineProperty(exports, "LineChartGroup", { enumerable: true, get: function () { return line_chart_group_1.LineChartGroup; } });
});


define('oj-c/list-item-layout/list-item-layout',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_ListItemLayout", "@oracle/oraclejet-preact/UNSAFE_Inset", "@oracle/oraclejet-preact/hooks/UNSAFE_useCollectionInteractionContext", "ojs/ojvcomponent", "css!oj-c/list-item-layout/list-item-layout-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_ListItemLayout_1, UNSAFE_Inset_1, UNSAFE_useCollectionInteractionContext_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListItemLayout = void 0;
    exports.ListItemLayout = (0, ojvcomponent_1.registerCustomElement)('oj-c-list-item-layout', 
    /**
     * @classdesc
     * <h3 id="listItemLayoutOverview-section">
     *   JET List Item Layout
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#listItemLayoutOverview-section"></a>
     * </h3>
     * The oj-c-list-item-layout helps application teams to easily layout their content into different slots.
     *
     * <pre class="prettyprint"><code>//ListItemLayout with text
     * &lt;oj-list-view id="listview1" aria-label="list layout within list view" data="[[dataProvider]]" style="width: 450px;"
     *                  selected="{{selectorSelectedItems}}" selection-mode="multiple">
     *    &lt;template slot="itemTemplate" data-oj-as="item">
     *       &lt;li>
     *          &lt;oj-c-list-item-layout>
     *             &lt;oj-selector slot='selector' selected-keys='{{selectorSelectedItems}}' key='[[item.data.id]]'>
     *             &lt;/oj-selector>
     *             &lt;div>
     *                &lt;oj-bind-text value="default">&lt;/oj-bind-text>
     *             &lt;/div>
     *          &lt;/oj-c-list-item-layout>
     *       &lt;/li>
     *    &lt;/template>
     * &lt;/oj-list-view>
     * </code>
     *
     * @ojmetadata description "A List Item Layout represents layout used for list view item elements."
     * @ojmetadata displayName "List Item Layout"
     * @ojmetadata main "oj-c/list-item-layout"
     * @ojmetadata help "oj-c.ListItemLayout.html"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "14.0.0",
     *     "value": ["oj-list-item-layout"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Collections"
     *   },
     *   "oracle": {
     *     "uxSpecs": ["list-item-layout"],
     *     "icon": "oj-ux-ico-list-item-layout"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/list-item-layout",
     *     "defaultColumns": 12,
     *     "minColumns": 2
     *   }
     * }
     * @ojmetadata since "14.0.0"
     *
     * @ojmetadata extension {
     *   "webelement": {
     *     "exceptionStatus": [
     *       {
     *         "type": "deprecated",
     *         "since": "16.0.0",
     *         "description": "Not accessible to WebDriverJS."
     *       }
     *     ]
     *   }
     * }
     */
    ({ children, ...otherProps }) => {
        const primary = children;
        const actionSlot = otherProps.action ? ((0, jsx_runtime_1.jsx)("div", { "data-oj-clickthrough": "disabled", children: otherProps.action })) : undefined;
        const navSlot = otherProps.navigation ? ((0, jsx_runtime_1.jsx)("div", { "data-oj-clickthrough": "disabled", children: otherProps.navigation })) : undefined;
        const layout = otherProps.inset === 'none' ? ((0, jsx_runtime_1.jsx)(UNSAFE_ListItemLayout_1.ListItemLayout, { verticalAlignment: otherProps.verticalAlignment, primary: primary, overline: otherProps.overline, selector: otherProps.selector, leading: otherProps.leading, secondary: otherProps.secondary, tertiary: otherProps.tertiary, metadata: otherProps.metadata, trailing: otherProps.trailing, action: actionSlot, quaternary: otherProps.quaternary, navigation: navSlot })) : ((0, jsx_runtime_1.jsx)(UNSAFE_Inset_1.Inset, { variant: "listview", children: (0, jsx_runtime_1.jsx)(UNSAFE_ListItemLayout_1.ListItemLayout, { verticalAlignment: otherProps.verticalAlignment, primary: primary, overline: otherProps.overline, selector: otherProps.selector, leading: otherProps.leading, secondary: otherProps.secondary, tertiary: otherProps.tertiary, metadata: otherProps.metadata, trailing: otherProps.trailing, action: actionSlot, quaternary: otherProps.quaternary, navigation: navSlot }) }));
        return (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: layout });
    }, "ListItemLayout", { "slots": { "": {}, "overline": {}, "selector": {}, "leading": {}, "secondary": {}, "tertiary": {}, "metadata": {}, "trailing": {}, "action": {}, "quaternary": {}, "navigation": {} }, "properties": { "inset": { "type": "string", "enumValues": ["none", "listInset"] }, "verticalAlignment": { "type": "string", "enumValues": ["top", "middle"] } }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["aria-label"] } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useCollectionInteractionContext_1.CollectionInteractionContext] });
});

define('oj-c/list-item-layout',["require", "exports", "oj-c/list-item-layout/list-item-layout"], function (require, exports, list_item_layout_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListItemLayout = void 0;
    Object.defineProperty(exports, "ListItemLayout", { enumerable: true, get: function () { return list_item_layout_1.ListItemLayout; } });
});

define('oj-c/list-view/useHandleRemoveCurrentKey',["require", "exports", "preact/hooks"], function (require, exports, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useHandleRemoveCurrentKey = useHandleRemoveCurrentKey;
    /**
     * Hook to detect and handle when the current key has been removed
     * and try to find the next available current key.
     * TODO: put in its own private module as we should be able to share
     * between other Collection components.
     * @param dataState
     * @param updateCurrentKey
     */
    function useHandleRemoveCurrentKey(dataState, updateCurrentKey) {
        const prevDataState = (0, hooks_1.useRef)();
        const currentKeyRef = (0, hooks_1.useRef)();
        const notifyCurrentKeyChanged = (detail) => {
            currentKeyRef.current = detail.value;
        };
        (0, hooks_1.useEffect)(() => {
            const oldDataState = prevDataState.current;
            if (currentKeyRef.current &&
                oldDataState &&
                dataState &&
                oldDataState.offset === dataState.offset &&
                oldDataState !== dataState) {
                const newKeys = dataState.data.map((dataMetadata) => {
                    return dataMetadata.metadata.key;
                });
                // first check if currentKey exists in new data, if it is then we
                // don't need to do anything
                if (newKeys.indexOf(currentKeyRef.current) === -1) {
                    const oldKeys = oldDataState?.data.map((dataMetadata) => {
                        return dataMetadata.metadata.key;
                    });
                    // figure out what the new currentKey should be
                    let index = oldKeys.indexOf(currentKeyRef.current);
                    if (index > -1) {
                        const backward = index === oldKeys.length - 1;
                        while (index >= 0 && index < oldKeys.length) {
                            index = backward ? index - 1 : index + 1;
                            const newCurrentKey = oldKeys[index];
                            if (newKeys.indexOf(newCurrentKey) > -1) {
                                updateCurrentKey(newCurrentKey);
                                break;
                            }
                        }
                    }
                }
            }
            // update previous DataState
            prevDataState.current = dataState;
        }, [dataState, updateCurrentKey]);
        return {
            notifyCurrentKeyChanged
        };
    }
});

define('oj-c/list-view/useCurrentItemOverride',["require", "exports", "preact/hooks"], function (require, exports, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCurrentItemOverride = void 0;
    /**
     * This hook handles the currentItemOverride passing to preact layer.
     *
     * If the app provided new value for 'currentItemOverride', we pass that down to preact layer;
     * otherwise, we will pass down the value of internal override, which would be the value
     * updated by useHandleRemoveCurrentKey hook
     *
     * @param currentItemOverride
     */
    const useCurrentItemOverride = (currentItemOverride) => {
        // the override that will be passed down to preact layer
        const preactOverrideRef = (0, hooks_1.useRef)();
        // track the internal override updated by useHandleRemoveCurrentKey hook
        const [, setInternalOverride] = (0, hooks_1.useState)();
        const updateCurrentItemOverride = (0, hooks_1.useCallback)((key) => {
            setInternalOverride({ rowKey: key });
            preactOverrideRef.current = { rowKey: key };
        }, []);
        // track the currentItemOverride attribute set by app
        const appOverrideRef = (0, hooks_1.useRef)();
        if (appOverrideRef.current !== currentItemOverride) {
            appOverrideRef.current = currentItemOverride;
            preactOverrideRef.current = currentItemOverride;
        }
        return {
            preactCurrentItemOverride: preactOverrideRef.current,
            updateCurrentItemOverride
        };
    };
    exports.useCurrentItemOverride = useCurrentItemOverride;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/utils/PRIVATE_collectionUtils/collectionUtils',["require", "exports", "../PRIVATE_keyUtils/keySetUtils"], function (require, exports, keySetUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleOnSelectionChanged = exports.getSelectedKeys = void 0;
    /**
     * A helper function to get the selectedKeys to use when selection mode is singleRequired
     */
    const getSelectedKeys = (selected, listData, selectionMode, onSelectedChanged) => {
        const numOfSelectedItems = !selected?.keys?.all
            ? selected?.keys.keys?.size
            : listData?.data.length;
        let selectedKeys;
        if (listData &&
            listData.data.length > 0 &&
            selectionMode === 'singleRequired' &&
            numOfSelectedItems === 0) {
            selectedKeys = { all: false, keys: new Set([listData.data[0].metadata.key]) };
            onSelectedChanged && onSelectedChanged((0, keySetUtils_1.keysToKeySet)(selectedKeys));
        }
        else {
            selectedKeys = (0, keySetUtils_1.keySetToKeys)(selected);
        }
        return selectedKeys;
    };
    exports.getSelectedKeys = getSelectedKeys;
    const handleOnSelectionChanged = (selectionMode, detail, onSelectedChanged, isClickthroughDisabled) => {
        if (selectionMode !== 'singleRequired' || detail.value.keys?.size !== 0) {
            onSelectedChanged &&
                !isClickthroughDisabled(detail.target) &&
                onSelectedChanged((0, keySetUtils_1.keysToKeySet)(detail.value));
        }
    };
    exports.handleOnSelectionChanged = handleOnSelectionChanged;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/list-view/useListViewPreact',["require", "exports", "preact/hooks", "../utils/PRIVATE_keyUtils/keySetUtils", "../hooks/UNSAFE_useListData/useListData", "./useHandleRemoveCurrentKey", "./useCurrentItemOverride", "ojs/ojlogger", "../utils/PRIVATE_collectionUtils/collectionUtils"], function (require, exports, hooks_1, keySetUtils_1, useListData_1, useHandleRemoveCurrentKey_1, useCurrentItemOverride_1, Logger, collectionUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useListViewPreact = void 0;
    // we don't want to spread all props, so we need to explicitly include the props we plan to pass-through
    const useListViewPreact = ({ 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, 'aria-describedby': ariaDescribedBy, data: propData, gridlines, currentItemOverride, onCurrentItemChanged, selectionMode, selected, scrollPolicyOptions, onSelectedChanged, onOjItemAction, onOjFirstSelectedItem, reorderable, onOjReorder, item, skeletonTemplate }, addBusyState, isClickthroughDisabled) => {
        const currentPromiseRef = (0, hooks_1.useRef)();
        const resolveBusyState = (0, hooks_1.useRef)();
        const [listDataState, onLoadRange] = (0, useListData_1.useListData)(propData, {
            fetchSize: scrollPolicyOptions?.fetchSize
        });
        const listData = listDataState.status !== 'error' ? listDataState.data : null;
        const { preactCurrentItemOverride, updateCurrentItemOverride } = (0, useCurrentItemOverride_1.useCurrentItemOverride)(currentItemOverride);
        const firstSelectedItemRef = (0, hooks_1.useRef)();
        const selectedKeys = (0, collectionUtils_1.getSelectedKeys)(selected, listData, selectionMode, onSelectedChanged);
        // set and resolve busy state based on listDataState
        (0, hooks_1.useEffect)(() => {
            if (listDataState.status === 'loading') {
                resolveBusyState.current = addBusyState('list data is in fetch state');
            }
            else {
                if (resolveBusyState.current) {
                    resolveBusyState.current();
                    resolveBusyState.current = undefined;
                }
            }
        }, [listDataState.status, addBusyState]);
        // when the component is unmount, we should clear busy state also
        (0, hooks_1.useEffect)(() => {
            return () => {
                if (resolveBusyState.current) {
                    resolveBusyState.current();
                    resolveBusyState.current = undefined;
                }
            };
        }, []);
        const handleOnOjFirstSelectedItem = (0, hooks_1.useCallback)((data) => {
            if (selected && onOjFirstSelectedItem && propData) {
                const selectedKeys = (0, keySetUtils_1.keySetToKeys)(selected);
                if (!(0, keySetUtils_1.isEmpty)(selectedKeys)) {
                    const firstSelectedKey = (0, keySetUtils_1.getFirstKey)(selectedKeys, data);
                    const firstSelectedItem = data.find((listItem) => firstSelectedKey === listItem.metadata.key);
                    if (firstSelectedItem) {
                        const data = firstSelectedItem.data;
                        if (firstSelectedItemRef.current === undefined ||
                            data !== firstSelectedItemRef.current.data) {
                            const detail = { key: firstSelectedKey, data };
                            firstSelectedItemRef.current = { ...detail };
                            onOjFirstSelectedItem(detail);
                        }
                    }
                    else {
                        const initialPromise = propData.fetchByKeys({
                            keys: new Set([firstSelectedKey])
                        });
                        currentPromiseRef.current = initialPromise;
                        initialPromise.then((value) => {
                            if (initialPromise === currentPromiseRef.current) {
                                const item = value.results.get(firstSelectedKey);
                                if (item === undefined) {
                                    Logger.warn(`Item with '${firstSelectedKey}' key couldn't be found `);
                                }
                                else {
                                    const detail = { key: firstSelectedKey, data: item.data };
                                    firstSelectedItemRef.current = { ...detail };
                                    onOjFirstSelectedItem(detail);
                                }
                            }
                        });
                    }
                }
            }
        }, [selected, onOjFirstSelectedItem, propData, listData]);
        (0, hooks_1.useEffect)(() => {
            if (selectionMode === 'singleRequired' && listData && listData.data.length > 0) {
                handleOnOjFirstSelectedItem(listData.data);
            }
        }, [selectionMode, listData, handleOnOjFirstSelectedItem]);
        const handleOnSelectionChange = (detail) => {
            (0, collectionUtils_1.handleOnSelectionChanged)(selectionMode, detail, onSelectedChanged, isClickthroughDisabled);
        };
        (0, hooks_1.useEffect)(() => {
            const _listener = (event) => {
                if (onOjFirstSelectedItem && event.detail.update && firstSelectedItemRef.current) {
                    const detail = event.detail.update;
                    const index = Array.from(detail.keys).indexOf(firstSelectedItemRef.current.key);
                    if (index > -1 && detail.data && index < detail.data.length) {
                        const newData = detail.data[index];
                        if (firstSelectedItemRef.current.data !== newData) {
                            firstSelectedItemRef.current.data = newData;
                            const detail = { ...firstSelectedItemRef.current };
                            onOjFirstSelectedItem(detail);
                        }
                    }
                }
            };
            if (propData) {
                propData.addEventListener('mutate', _listener);
            }
            return () => {
                if (propData) {
                    propData.removeEventListener('mutate', _listener);
                }
            };
        }, [propData, onOjFirstSelectedItem]);
        // find out whether the current key was there before in prev render
        // and adjust current key as needed. This should be run before other
        // useEffect(s) that could also alter current key.
        const dataState = listDataState.status === 'error' ? null : listDataState.data;
        const { notifyCurrentKeyChanged } = (0, useHandleRemoveCurrentKey_1.useHandleRemoveCurrentKey)(dataState, updateCurrentItemOverride);
        const preactOnPersistCurrentItem = (detail) => {
            onCurrentItemChanged?.(detail.value);
            notifyCurrentKeyChanged(detail);
        };
        const viewportConfig = scrollPolicyOptions?.scroller
            ? {
                scroller: () => {
                    if (scrollPolicyOptions.scroller) {
                        return document.querySelector(scrollPolicyOptions.scroller);
                    }
                    return null;
                }
            }
            : undefined;
        const suggestions = (0, hooks_1.useMemo)(() => getSuggestionsInfo(listDataState), [listDataState]);
        const getRowKey = (data) => {
            return data.metadata.key;
        };
        const onLoadMore = (0, hooks_1.useCallback)(() => {
            if (listData) {
                const fetchSize = scrollPolicyOptions && scrollPolicyOptions.fetchSize ? scrollPolicyOptions.fetchSize : 25;
                onLoadRange({ offset: 0, count: listData.data.length + fetchSize });
            }
        }, [scrollPolicyOptions, onLoadRange, listData]);
        return {
            status: listDataState.status,
            listViewProps: {
                'aria-label': ariaLabel,
                'aria-labelledby': ariaLabelledBy,
                'aria-describedby': ariaDescribedBy,
                data: listData ? listData.data : null,
                currentItemOverride: preactCurrentItemOverride,
                getRowKey,
                gridlines,
                onPersistCurrentItem: preactOnPersistCurrentItem,
                hasMore: listData ? listData.sizePrecision === 'atLeast' : false,
                onLoadMore,
                onSelectionChange: handleOnSelectionChange,
                selectedKeys,
                selectionMode: selectionMode === 'singleRequired' ? 'single' : selectionMode,
                promotedSection: suggestions,
                // in preact layer, the data is a type of Item in ItemActionDetail
                onItemAction: (detail) => {
                    const item = detail.context.data;
                    const itemActionDetail = { context: { item, data: item.data } };
                    onOjItemAction &&
                        !isClickthroughDisabled(detail.target) &&
                        onOjItemAction(itemActionDetail);
                },
                onReorder: reorderable?.items === 'enabled'
                    ? (detail) => {
                        onOjReorder && onOjReorder(detail);
                    }
                    : null,
                viewportConfig,
                itemPadding: item?.padding,
                itemEnterKeyFocusBehavior: item?.enterKeyFocusBehavior,
                skeletonRenderer: skeletonTemplate
            }
        };
    };
    exports.useListViewPreact = useListViewPreact;
    function getSuggestionsInfo(listDataState) {
        if (listDataState.status !== 'success') {
            return { count: 0 };
        }
        const data = listDataState.data.data;
        let count = 0;
        for (let i = 0; i < data.length; i++) {
            if (data[i].metadata.suggestion == null) {
                break;
            }
            count += 1;
        }
        return { count };
    }
});

define('oj-c/list-view/DataFetchLiveRegion',["require", "exports", "preact/jsx-runtime", "preact/hooks", "@oracle/oraclejet-preact/UNSAFE_LiveRegion", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle"], function (require, exports, jsx_runtime_1, hooks_1, UNSAFE_LiveRegion_1, UNSAFE_useTranslationBundle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataFetchLiveRegion = void 0;
    const MSG_DELAY = 50;
    const DataFetchLiveRegion = (props) => {
        const [isFetchingMsgRendered, setFetchingMsgRendered] = (0, hooks_1.useState)(false);
        (0, hooks_1.useEffect)(() => {
            let timeoutId;
            if (props.isFetching) {
                timeoutId = setTimeout(() => {
                    // check if we are still fetching after the delay
                    // if it is then we should render the data finish fetching
                    // message when isFetching becomes false
                    if (props.isFetching) {
                        setFetchingMsgRendered(true);
                    }
                }, MSG_DELAY);
            }
            return () => {
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
            };
        }, [props.isFetching]);
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        if (props.isFetching) {
            return (0, jsx_runtime_1.jsx)(UNSAFE_LiveRegion_1.LiveRegion, { timeout: MSG_DELAY, children: translations.list_msgFetchingData() });
        }
        return isFetchingMsgRendered ? ((0, jsx_runtime_1.jsx)(UNSAFE_LiveRegion_1.LiveRegion, { timeout: 0, children: translations.list_msgFetchCompleted() })) : ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, {}));
    };
    exports.DataFetchLiveRegion = DataFetchLiveRegion;
});

define('oj-c/hooks/PRIVATE_useSelectionContext/ItemKeyContext',["require", "exports", "preact"], function (require, exports, preact_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemKeyContext = void 0;
    exports.ItemKeyContext = (0, preact_1.createContext)(undefined);
});

define('oj-c/list-view/listViewItem',["require", "exports", "preact/jsx-runtime", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "../hooks/PRIVATE_useSelectionContext/ItemKeyContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle"], function (require, exports, jsx_runtime_1, UNSAFE_useTabbableMode_1, ItemKeyContext_1, UNSAFE_useTranslationBundle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListItem = void 0;
    const ListItem = ({ context, itemTemplate }) => {
        const tabbableModeInfo = (0, UNSAFE_useTabbableMode_1.useTabbableMode)();
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        // context.data is Item<K, D> from DataProvider
        const itemContext = {
            isTabbable: tabbableModeInfo.isTabbable,
            data: context.data.data,
            item: context.data
        };
        return ((0, jsx_runtime_1.jsx)(ItemKeyContext_1.ItemKeyContext.Provider, { value: context.metadata.key, children: (0, jsx_runtime_1.jsxs)(UNSAFE_useTabbableMode_1.TabbableModeContext.Provider, { value: tabbableModeInfo, children: [itemTemplate && itemTemplate(itemContext), itemContext.item.metadata?.suggestion && ((0, jsx_runtime_1.jsx)("span", { class: "oj-helper-hidden-accessible", children: translations.list_suggestion() }))] }) }));
    };
    exports.ListItem = ListItem;
});

define('oj-c/hooks/PRIVATE_useSelectionContext/SelectionContext',["require", "exports", "preact"], function (require, exports, preact_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionContext = void 0;
    exports.SelectionContext = (0, preact_1.createContext)(undefined);
});


define('oj-c/list-view/list-view',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojcontext", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "@oracle/oraclejet-preact/UNSAFE_EmptyList", "@oracle/oraclejet-preact/UNSAFE_ListView", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "@oracle/oraclejet-preact/hooks/UNSAFE_useCollectionInteractionContext", "./useListViewPreact", "./DataFetchLiveRegion", "./listViewItem", "../utils/PRIVATE_ItemsMenu/items-menu", "../hooks/PRIVATE_useSelectionContext/SelectionContext", "css!oj-c/list-view/list-view-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, Context, ojvcomponent_1, compat_1, hooks_1, UNSAFE_EmptyList_1, UNSAFE_ListView_1, UNSAFE_useTranslationBundle_1, UNSAFE_useCollectionInteractionContext_1, useListViewPreact_1, DataFetchLiveRegion_1, listViewItem_1, items_menu_1, SelectionContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListView = void 0;
    const ListViewPreactWrapper = ({ listviewRef, addBusyState, isClickthroughDisabled, itemTemplate, noData, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, ...rest }) => {
        const { status, listViewProps } = (0, useListViewPreact_1.useListViewPreact)(rest, addBusyState, isClickthroughDisabled);
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const itemsRenderer = (0, hooks_1.useCallback)((context) => {
            const item = context.data;
            const itemDetail = { item, data: item.data };
            const items = contextMenuConfig?.items(itemDetail);
            return ((0, jsx_runtime_1.jsx)(items_menu_1.ItemsMenu, { items: items, onOjMenuAction: ({ key }) => {
                    onOjContextMenuAction?.({
                        menuItemKey: key,
                        contextMenuContext: itemDetail
                    });
                }, onOjMenuSelection: ({ value, menuSelectionGroupKey }) => {
                    onOjContextMenuSelection?.({
                        value,
                        menuSelectionGroupKey,
                        contextMenuContext: itemDetail
                    });
                } }));
        }, [contextMenuConfig?.items, onOjContextMenuAction, onOjContextMenuSelection]);
        const preactContextMenuConfig = (0, hooks_1.useMemo)(() => {
            return {
                itemsRenderer,
                accessibleLabel: contextMenuConfig?.accessibleLabel
            };
        }, [contextMenuConfig?.accessibleLabel, itemsRenderer]);
        if (status === 'success' && !listViewProps.hasMore && listViewProps.data?.length === 0) {
            if (noData) {
                return ((0, jsx_runtime_1.jsx)(UNSAFE_EmptyList_1.EmptyList, { "aria-label": listViewProps['aria-label'], "aria-labelledby": listViewProps['aria-labelledby'], children: noData(compat_1.Children) }));
            }
            else {
                const noDataContent = translations.noData_message();
                return ((0, jsx_runtime_1.jsx)(UNSAFE_EmptyList_1.EmptyList, { "aria-label": listViewProps['aria-label'], "aria-labelledby": listViewProps['aria-labelledby'], children: noDataContent }));
            }
        }
        const selectInfo = {
            selected: rest.selected,
            selectionMode: listViewProps.selectionMode === 'multipleToggle' ? 'multiple' : listViewProps.selectionMode,
            onSelectedChange: rest.onSelectedChanged
        };
        return ((0, jsx_runtime_1.jsxs)(SelectionContext_1.SelectionContext.Provider, { value: selectInfo, children: [(0, jsx_runtime_1.jsx)(UNSAFE_ListView_1.ListView, { ref: listviewRef, ...listViewProps, ...(contextMenuConfig && {
                        contextMenuConfig: preactContextMenuConfig
                    }), children: (0, hooks_1.useCallback)((context) => {
                        return (0, jsx_runtime_1.jsx)(listViewItem_1.ListItem, { context: context, itemTemplate: itemTemplate });
                    }, [itemTemplate]) }), (0, jsx_runtime_1.jsx)(DataFetchLiveRegion_1.DataFetchLiveRegion, { isFetching: status === 'loading' })] }));
    };
    const ListViewImpl = (0, compat_1.forwardRef)(
    /**
     * @classdesc
     * <h3 id="listViewOverview-section">
     *   JET ListView Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#listViewOverview-section"></a>
     * </h3>
     *
     * <p>Description: The JET ListView enhances a HTML list element into a themable, WAI-ARIA compliant, mobile friendly component with advance interactive features.
     * The child content can be configured via a DataProvider which should be used for mutable data.</p>
     *
     * <p>For migration information from <code>oj-list-view</code> refer to the <a href="https://jet.oraclecorp.com/trunk/jsdocs/oj.ojListView.html#styling-section">migration section</a> in the API docs.
     *
     * <h3 id="data-section">
     *   Data
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
     * </h3>
     * <p>The JET ListView gets its data from a DataProvider.</p>
     *
     * <p><b>ArrayDataProvider</b> - Use this when the underlying data is an array object or an observableArray.  In the observableArray case, ListView will automatically react
     * when items are added or removed from the array.  See the documentation for ArrayDataProvider for more details on the available options.</p>
     *
     * <p>Example of data provider content</p>
     * <pre class="prettyprint"><code>
     *   &lt;oj-c-list-view aria-label="Accessible Summary" data="[[dataProvider]]">
     *   &lt;/oj-c-list-view>
     * </code></pre>
     *
     * <p>Check out the Listview Basic demo</a>
     *
     * <h3 id="keyboard-section">
     *   Coming Features
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#coming-features-section"></a>
     * </h3>
     *
     * <p>These features will be the domain of new, specialized components</p>
     * <ul>
     *    <li>Cards in grid layout</li>
     *    <li>Cards in waterfall layout</li>
     *    <li>Grouped list</li>
     *    <li>Expandable list</li>
     * </ul>
     *
     * <p>These features will be available in forthcoming versions</p>
     * <ul>
     *    <li>Drag and drop between components</li>
     *    <li>Managing scroll position</li>
     * </ul>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan = "20" nowrap>List Item</td>
     *       <td><kbd>F2</kbd></td>
     *       <td>Enters tabbable mode.  This enables keyboard action on elements inside the item, including navigate between focusable elements inside the item.  It can also be used to exit tabbable mode if already in tabbable mode.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Enters tabbable mode if <a href="#item">enterKeyFocusBehavior</a> is "focusWithin" (default).  This enables keyboard action on elements inside the item, including navigate between focusable elements inside the item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Exits tabbable mode.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>When in tabbable mode, navigates to next focusable element within the item.  If the last focusable element is reached, shift focus back to the first focusable element.
     *           When not in tabbable mode, navigates to next focusable element on page (outside ListView).</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Tab</kbd></td>
     *       <td>When in tabbable mode, navigates to previous focusable element within the item.  If the first focusable element is reached, shift focus back to the last focusable element.
     *           When not in tabbable mode, navigates to previous focusable element on page (outside ListView).</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Move focus to the item below.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Move focus to the item above.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+DownArrow</kbd></td>
     *       <td>Extend the selection to the item below.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+UpArrow</kbd></td>
     *       <td>Extend the selection to the item above.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Space</kbd></td>
     *       <td>Toggles to select and deselect the current item while maintaining previously selected items.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Space</kbd></td>
     *       <td>Toggles to select and deselect the current item while maintaining previously selected items.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Cmd/Ctrl+UpArrow</kbd></td>
     *       <td>Reorder the current item up.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Cmd/Ctrl+DownArrow</kbd></td>
     *       <td>Reorder the current item down.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl+Space</kbd></td>
     *       <td>Toggles to select and deselect the current item while maintaining previously selected items.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>Application should specify a value for the aria-label attribute with a meaningful description of the purpose of this list.</p>
     * <p>Note that ListView uses the grid role and follows the <a href="https://www.w3.org/TR/wai-aria-practices/examples/grid/LayoutGrids.html">Layout Grid</a> design as outlined in the <a href="https://www.w3.org/TR/wai-aria-practices/#grid">grid design pattern</a></p>
     * <p>Nesting collection components such as ListView, Table, TreeView, and ListView inside of ListView is not supported.</p>
     * <p>When reorder feature is enabled, application should specify a live region which contains an announcement to notify assistive technologies that the item reordering happens.</p>
     *
     * <h4>Custom Colours</h4>
     * <p>Using colors, including background and text colors, is not accessible if it is the only way information is conveyed.
     * Low vision users may not be able to see the different colors, and in high contrast mode the colors are removed.
     * The Redwood approved way to show status is to use badge.</p>
     *
     * <h3 id="context-section">
     *   Item Context
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#context-section"></a>
     * </h3>
     *
     * <p>For all item options, developers can specify a function as the return value.  The function takes a single argument, which is an object that contains contextual information about the particular item.  This gives developers the flexibility to return different value depending on the context.</p>
     *
     * <p>The context parameter contains the following keys:</p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>data</kbd></td>
     *       <td>The data of the item.  Note this is made available primarily to ease migration.
     *           Applications should get the data from the item property instead.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>item</kbd></td>
     *       <td>An object that contains the data and metadata for the item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>isTabbable</kbd></td>
     *       <td>A boolean indicating whether the item is in tabbable mode or not.
     *          This should be used to implement conditional behavior for all tabbable elements, this avoids creating a keyboard trap when tabbing through a List.<br/>
     *          This can be implemented as a conditional tabindex, for example <code>tabindex="[[!item.isTabbable && '-1']]"</code>.<br/>
     *          When composing with core pack components, this is not needed, as they are tabbable mode aware.
     *         </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>The following keys are not currently supported:</p>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>componentElement</kbd></td>
     *       <td>A reference to the root element of ListView.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>datasource</kbd></td>
     *       <td>A reference to the data source object.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>index</kbd></td>
     *       <td>The index of the item, where 0 is the index of the first item.  In the hierarchical case the index is relative to its parent.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>key</kbd></td>
     *       <td>The key of the item (this duplicates item.metadata.key and has been deprecated)</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>metadata</kbd></td>
     *       <td>The metadata of the item (this is instead available in item)</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>parentElement</kbd></td>
     *       <td>This will be supported by the Hierarchical list component and no longer applies to list view..</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="data-attributes-section">
     *   Custom Data Attributes
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-attributes-section"></a>
     * </h3>
     *
     * <p>ListView supports the following custom data attributes.
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Name</th>
     *       <th>Description</th>
     *       <th>Example</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>data-oj-as</kbd></td>
     *       <td>Provides an alias for a specific template instance and has the same subproperties as the $current variable.</td>
     *       <td>
     *         <pre class="prettyprint"><code>&lt;oj-c-list-view id="listView">
     *   &lt;template slot="itemTemplate" data-oj-as="item">
     *   &lt;/template>
     * &lt;/oj-c-list-view></code></pre>
     *       </td>
     *     </tr>
     *     <tr>
     *       <td><kbd>data-oj-clickthrough</kbd></td>
     *       <td><p>Specify on any element inside an item where you want to control whether ListView should perform actions triggered by
     *           a click event originating from the element or one of its descendants.</p>
     *           <p>For example, if you specify this attribute with a value of "disabled" on a link inside an item, then ListView
     *           will not select or trigger itemAction event to be fired when user clicks on the link.</p>
     *           <p>Note that the currentItem will still be updated to the item that the user clicked on.</p>
     *           <p>Also note you do not need to set this attribute on core pack components such as oj-c-button, as it natively supports
     *              disabling clickthrough.</p>
     *       </td>
     *       <td>
     *         <pre class="prettyprint"><code>&lt;oj-c-list-view id="listView">
     *   &lt;template slot="itemTemplate">
     *     &lt;a href="#" data-oj-clickthrough="disabled">&lt;/a>
     *   &lt;/template>
     * &lt;/oj-c-list-view></code></pre>
     *       </td>
     *     </tr>
     *     <tr>
     *       <td><kbd>data-oj-manage-tabs</kbd></td>
     *       <td><p>ListView does not manipulate the tabindex of the item content.  Applications should set the tabIndex of any focusable
     *          element based on the isTabbableMode property from the context pass to the itemTemplate.</p>
     *          <p>However, there will be cases where you can't control the tabindex of the content, for example, if you are using components from another team.</p>
     *          <p>In that case, applications can specify this attribute on the element or one of its ancestors so that when the itemTemplate is processed,
     *          it will scan and manipulate the tabindex of any focusable elements.</p>
     *       </td>
     *       <td>
     *         <pre class="prettyprint"><code>&lt;oj-c-list-view id="listView">
     *   &lt;template slot="itemTemplate">
     *     &lt;some-component-with-focusable-elements data-oj-manage-tabs>&lt;/some-component-with-focusable-elements>
     *   &lt;/template>
     * &lt;/oj-c-list-view></code></pre>
     *       </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="suggestion-items-section">
     *   Suggestion Items
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#suggestion-items-section"></a>
     * </h3>
     *
     * <p>If <a href="ItemMetadata.html">ItemMetadata</a> returned by the DataProvider contains suggestion field, ListView will apply special visual to those
     *    items. The DataProvider must ensure the suggestion items are the first items returned by the initial fetchFirst call.</p>
     *
     * @ojmetadata displayName "List View"
     * @ojmetadata description "A list view displays data items as a list or a grid with highly interactive features."
     * @ojmetadata help "oj-c.ListView.html"
     * @ojmetadata main "oj-c/list-view"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Collections"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/list-view",
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-list",
     *     "uxSpecs": [
     *       "list-view"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "selectionMode"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data",
     *       "selected"
     *     ]
     *   }
     * ]
     * @ojmetadata since "15.0.0"
     */
    ({ selectionMode = 'none', reorderable = { items: 'disabled' }, item = { padding: 'disabled', enterKeyFocusBehavior: 'focusWithin' }, ...rest }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const listviewRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({
                    description: `oj-c-list-view: ${desc}`
                })
                : () => { };
        }, []);
        const isClickthroughDisabled = (0, hooks_1.useCallback)((target) => {
            if (target === null || rootRef.current === undefined) {
                return false;
            }
            return isEventClickthroughDisabled({ target }, rootRef.current);
        }, []);
        const props = {
            selectionMode,
            reorderable,
            item,
            ...rest
        };
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            focus: () => {
                listviewRef.current?.focus();
            }
        }), []);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: props.id, ref: rootRef, children: (0, jsx_runtime_1.jsx)(ListViewPreactWrapper, { listviewRef: listviewRef, addBusyState: addBusyState, isClickthroughDisabled: isClickthroughDisabled, ...props }) }));
    });
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const ListViewWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-list-view', ListViewImpl, "ListView", { "properties": { "currentItem": { "type": "string|number", "readOnly": true, "writeback": true }, "currentItemOverride": { "type": "object", "properties": { "rowKey": { "type": "string|number" } } }, "data": { "type": "DataProvider|null" }, "gridlines": { "type": "object", "properties": { "item": { "type": "string", "enumValues": ["hidden", "visible"] }, "top": { "type": "string", "enumValues": ["hidden", "visible"] }, "bottom": { "type": "string", "enumValues": ["hidden", "visible"] } } }, "scrollPolicyOptions": { "type": "object", "properties": { "fetchSize": { "type": "number" }, "scroller": { "type": "string" } } }, "selected": { "type": "object", "writeback": true }, "selectionMode": { "type": "string", "enumValues": ["none", "multiple", "single", "singleRequired", "multipleToggle"] }, "contextMenuConfig": { "type": "object", "properties": { "accessibleLabel": { "type": "string" }, "items": { "type": "function" } } }, "reorderable": { "type": "object", "properties": { "items": { "type": "string", "enumValues": ["disabled", "enabled"] } } }, "item": { "type": "object", "properties": { "padding": { "type": "string|object" }, "enterKeyFocusBehavior": { "type": "string", "enumValues": ["none", "focusWithin"] } } } }, "slots": { "itemTemplate": { "data": {} }, "noData": { "data": {} }, "skeletonTemplate": { "data": {} } }, "events": { "ojItemAction": {}, "ojFirstSelectedItem": {}, "ojContextMenuAction": { "bubbles": true }, "ojContextMenuSelection": { "bubbles": true }, "ojReorder": {} }, "extension": { "_WRITEBACK_PROPS": ["currentItem", "selected"], "_READ_ONLY_PROPS": ["currentItem"], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby", "aria-describedby", "id"] }, "methods": { "focus": {} } }, { "selectionMode": "none", "reorderable": { "items": "disabled" }, "item": { "padding": "disabled", "enterKeyFocusBehavior": "focusWithin" } }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useCollectionInteractionContext_1.CollectionInteractionContext] });
    exports.ListView = ListViewWithoutDefaultedGenerics;
    // copied from DataCollectionUtils
    const isEventClickthroughDisabled = function (event, rootElement) {
        let node = event.target;
        while (node != null && node !== rootElement) {
            if (isClickthroughDisabled(node)) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    // copied from DataCollectionUtils
    const isClickthroughDisabled = function (element) {
        return element.dataset['ojClickthrough'] === 'disabled';
    };
});

define('oj-c/list-view',["require", "exports", "oj-c/list-view/list-view"], function (require, exports, list_view_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ListView = void 0;
    Object.defineProperty(exports, "ListView", { enumerable: true, get: function () { return list_view_1.ListView; } });
});

define('oj-c/radioset/useRadiosetPreact',["require", "exports", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "oj-c/hooks/UNSAFE_useEditableValue/index", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle"], function (require, exports, useComponentMessages_1, useDeferredValidators_1, index_1, UNSAFE_useTranslationBundle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useRadiosetPreact = useRadiosetPreact;
    function useRadiosetPreact({ direction, disabled, displayOptions, labelEdge, labelHint, labelStartWidth, messagesCustom, readonly, readonlyUserAssistanceShown, requiredMessageDetail: propRequiredMessageDetail, required, userAssistanceDensity, value: propValue, onMessagesCustomChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const requiredMessageDetail = propRequiredMessageDetail || translations.radio_requiredMessageDetail();
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const { value, methods, textFieldProps } = (0, index_1.useEditableValue)({
            ariaDescribedBy: otherProps['aria-describedby'],
            deferredValidators,
            defaultDisplayValue: null,
            disabled,
            displayOptions,
            messagesCustom,
            readonly,
            value: propValue,
            addBusyState,
            onMessagesCustomChanged,
            onValidChanged,
            onValueChanged
        });
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages: textFieldProps.messages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        return {
            methods,
            radiosetProps: {
                'aria-describedby': textFieldProps['aria-describedby'],
                isRequired: required,
                isReadonly: readonly,
                isDisabled: disabled,
                label: labelHint,
                labelEdge,
                labelStartWidth,
                messages,
                onCommit: textFieldProps['onCommit'],
                userAssistanceDensity,
                value
            }
        };
    }
});


define('oj-c/radioset/radioset',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_RadioItem", "@oracle/oraclejet-preact/UNSAFE_RadioSet", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojvcomponent", "preact/hooks", "preact/compat", "oj-c/hooks/UNSAFE_useDataProvider/useDataProvider", "./useRadiosetPreact", "ojs/ojcontext", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "css!oj-c/radioset/radioset-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_RadioItem_1, UNSAFE_RadioSet_1, UNSAFE_useTabbableMode_1, UNSAFE_useFormContext_1, useMergedFormContext_1, useAssistiveText_1, ojvcomponent_1, hooks_1, compat_1, useDataProvider_1, useRadiosetPreact_1, Context, Layout_1, UNSAFE_classNames_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Radioset = void 0;
    function isDataProvider(options) {
        return options && 'fetchFirst' in options;
    }
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const FunctionalRadioset = (0, compat_1.forwardRef)(
    /**
     * @classdesc
     * <h3 id="radiosetOverview-section">
     *   JET Radioset Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#radiosetOverview-section"></a>
     * </h3>
     * <p>
     * Description: The oj-c-radioset component allows the user to select one option from a set of mutually exclusive options.
     * </p>
     * <p>
     * To use an oj-c-radioset, set the options attribute to an array of data items or to a DataProvider.
     *  <pre class="prettyprint"><code>&lt;oj-c-radioset
     *    value="current value"
     *    label-hint="Radioset"
     *    options="[[data]]">&lt;/oj-c-radioset></code></pre>
     *
     * It is recommended that the array option should only be used for static data and the DataProvider should always be used for mutable data.
     * </p>
     * <p>
     *  You can enable and disable an oj-c-radioset, which will enable and disable all contained radio items.
     * </p>
     * <p>
     *  You can also set an oj-c-radioset to readonly, which will make all the radio items readonly while making the selected radio option visually distinctive.
     * </p>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
  
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline at the top of the radioset and is always displayed if there is any defined for the set.
     * See the user-assistance-density property for other ways the user assistance text can render. User assistance can also be provided at the
     * individual radio item level which renders as a "?" icon and when clicked will display the assistive text in a pop-up.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction, and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then help-hints.definition shows;</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>
     * If the required property was set to true, this can also be used to guide the user.
     * In this case, the word Required will be rendered under the radioset when no value was set for the component.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Radio button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Select the radio button.</td>
     *     </tr>
     *     <tr>
     *       <td>Radio button's label</td>
     *       <td><kbd>Tap</kbd></td>
     *      <td>Select the corresponding radio button.</td>
     *     </tr>
     *     <tr>
     *       <td>Assistive help icon</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>If assistive text was setup for the radio button, pop up the notewindow.</td>
     *    </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="2">Input</td>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Select the previous radio button in the group.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Select the next radio button in the group.</td>
     *     </tr>
     *     <tr>
     *       <td>Radioset</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>If the radioset has help-hints.source, sets the focus on the link, otherwise sets the focus on the
     *        checked radio button. If no button was selected, sets the focus on the first radio button.</td>
     *     </tr>
     *     <tr>
     *       <td>Assistive help icon</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>If the radio item has assistive text, sets the focus on the icon. Hitting Enter or Space on the icon will launch a pop-up.
     *           Pressing F6 transfers the focus inside the popup and tabbing inside the popup will move focus to the link inside the popup, if one exists.
     *           Hitting Enter on the link will launch a new window with the url that was setup in the helpSourceLink property of the radio item.
     *           See <a href="#RadiosetDataItem">RadiosetDataItem</a> for information on assistive properties of the radio item.
     *       </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>JET oj-c-radioset takes care of setting
     * <code class="prettyprint">role="radiogroup"</code> on the oj-c-radioset element.
     *
     * <p>
     * <p>
     * For accessibility, set the label-hint property.
     * If the desire is to not have a visible label, then to make this accessible to screen reader users,
     * set label-hint to a value and the label-edge to 'none' which renders an aria-label with the label-hint text.
     * </p>
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     * </p>
     * @ojmetadata description "A radio set allows the user to select one option from a set of mutually exclusive options."
     * @ojmetadata displayName "Radioset"
     * @ojmetadata help "oj-c.Radioset.html"
     * @ojmetadata main "oj-c/radioset"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-radioset"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/radioset"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-radioset",
     *     "uxSpecs": [
     *       "radioset"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "direction",
     *       "placeholder",
     *       "readonly",
     *       "required",
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "options",
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "16.0.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint", "options"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    ({ containerReadonly: propContainerReadonly, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, labelWrapping: propLabelWrapping, columnSpan = 1, disabled = false, direction = 'column', messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, userAssistanceDensity: propUserAssistanceDensity, value = null, ...otherProps }, ref) => {
        const { options } = otherProps;
        const rootRef = (0, hooks_1.useRef)();
        const radiosetRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((desc = 'Radioset: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-radioset id=${otherProps.id} is ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [otherProps.id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity
        });
        const { radiosetProps, methods } = (0, useRadiosetPreact_1.useRadiosetPreact)({
            direction,
            disabled,
            displayOptions,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            value,
            ...otherProps
        }, addBusyState);
        let dataArr = [];
        const { data } = (0, useDataProvider_1.useDataProvider)({
            data: isDataProvider(options) ? options : undefined,
            addBusyState
        });
        dataArr = (0, hooks_1.useMemo)(() => {
            let retDataArr = [];
            if (isDataProvider(options)) {
                if (Array.isArray(data)) {
                    retDataArr = data.map((item) => {
                        return { value: item.key, ...item.data };
                    });
                }
            }
            else if (options) {
                retDataArr = [...options];
            }
            return retDataArr;
        }, [options, data]);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => radiosetRef.current?.blur(),
            focus: () => radiosetRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: radiosetProps.userAssistanceDensity
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            containerProps.isFormLayout && 'in-form-layout'
        ]);
        // layoutSpanColumn style class needs to be applied to the root dom element,
        // otherwise the css grid will ignore it.
        // Even though we are handling the styling here, we pass the columnSpan property down to the
        // Preact component because it may be needed for other purposes, like calculating the start
        // label width.
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: otherProps.id, ref: rootRef, class: rootClasses, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_RadioSet_1.RadioSet, { ref: radiosetRef, direction: direction, ...assistiveTextProps, ...radiosetProps, columnSpan: columnSpan, children: dataArr.map((radioItem) => ((0, jsx_runtime_1.jsx)(UNSAFE_RadioItem_1.RadioItem, { assistiveText: radioItem.assistiveText, helpSourceLink: radioItem.helpSourceLink, helpSourceText: radioItem.helpSourceText, value: radioItem.value, children: radioItem.label }, radioItem.value))) }) }) }));
    });
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const RadiosetWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-radioset', FunctionalRadioset, "Radioset", { "properties": { "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "columnSpan": { "type": "number" }, "direction": { "type": "string", "enumValues": ["row", "column"] }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelHint": { "type": "string" }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "options": { "type": "Array<object>|DataProvider" }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "value": { "type": "string|number|null", "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "valid", "value"], "_READ_ONLY_PROPS": ["valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "displayOptions": { "messages": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "columnSpan": 1, "disabled": false, "direction": "column", "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    exports.Radioset = RadiosetWithoutDefaultedGenerics;
});

define('oj-c/radioset',["require", "exports", "oj-c/radioset/radioset"], function (require, exports, radioset_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Radioset = void 0;
    Object.defineProperty(exports, "Radioset", { enumerable: true, get: function () { return radioset_1.Radioset; } });
});


define('oj-c/split-menu-button/split-menu-button',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_SplitMenuButton", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/hooks/UNSAFE_useTooltip", "@oracle/oraclejet-preact/utils/UNSAFE_mergeProps", "../utils/PRIVATE_ItemsMenu/items-menu", "preact/hooks", "preact/compat", "css!oj-c/split-menu-button/split-menu-button-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_SplitMenuButton_1, UNSAFE_useTabbableMode_1, UNSAFE_useTooltip_1, UNSAFE_mergeProps_1, items_menu_1, hooks_1, compat_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SplitMenuButton = void 0;
    /**
     * @classdesc
     * <h3 id="splitMenuButtonOverview-section">
     *   JET Split Menu Button
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonOverview-section"></a>
     * </h3>
     *
     * <p>Description: A Split Menu Button combines a push button and menu button.
     *
     * <pre class="prettyprint"><code>&lt;oj-c-split-menu-button label="Copy" onAction="[[action]]" items="[[items]]">
     * &lt;/oj-c-split-menu-button>
     * </code></pre>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Button</td>
     *       <td><kbd>Tap on action side</kbd></td>
     *       <td>Invoke the action.</td>
     *     </tr>
     *     <tr>
     *       <td>Button</td>
     *       <td><kbd>Tap on menu side</kbd></td>
     *       <td>Invoke the menu.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Split Menu Button</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Invoke the Button action.</td>
     *     </tr>
     *     <tr>
     *       <td>Split Menu Button</td>
     *       <td><kbd>Down Arrow</kbd></td>
     *       <td>Invoke the Button menu.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>For accessibility, the label is used as the accessible aria label.  This is required
     * as persistent split menu buttons modify the label depending on the last menu item selection.
     *
     * <p>oj-c-split-menu-button follows the ARIA Authoring Practices Guide patterns for
     * <a href="https://www.w3.org/WAI/ARIA/apg/patterns/menubar/">menu</a> and
     * <a href="https://www.w3.org/WAI/ARIA/apg/patterns/menu-button/">menu button</a>.
     * Note that this is an implementation detail that may change in the future.
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "A Split Menu Button combines a push button and menu button."
     * @ojmetadata displayName "Split Menu Button"
     * @ojmetadata help "oj-c.SplitMenuButton.html"
     * @ojmetadata main "oj-c/split-menu-button"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/split-menu-button",
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-menu-button",
     *     "uxSpecs": [
     *       "menu-button"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "label",
     *       "tooltip",
     *       "display",
     *       "chroming",
     *       "size",
     *       "width",
     *       "disabled"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "items"
     *     ]
     *   }
     * ]
     * @ojmetadata since "14.0.0"
     */
    function SplitMenuButtonImpl({ label, chroming = 'outlined', disabled = false, size = 'md', items = [], width, tooltip, onOjMenuAction, onOjAction, 'aria-describedby': ariaDescribedBy, ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const buttonRef = (0, hooks_1.useRef)(null);
        const widthSize = width ? { width: width } : {};
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => buttonRef.current?.blur(),
            focus: () => buttonRef.current?.focus(),
            click: () => buttonRef.current?.click()
        }), [buttonRef]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { style: widthSize, ref: rootRef, children: (0, jsx_runtime_1.jsx)(FunctionalSplitMenuButton, { tooltip: tooltip, label: label, ref: buttonRef, variant: chroming, size: size, width: '100%', "aria-describedby": ariaDescribedBy, isDisabled: disabled, onAction: onOjAction, ...otherProps, children: (0, jsx_runtime_1.jsx)(items_menu_1.ItemsMenu, { isSplitMenu: true, items: items, onOjMenuAction: onOjMenuAction }) }) }));
    }
    exports.SplitMenuButton = (0, ojvcomponent_1.registerCustomElement)('oj-c-split-menu-button', (0, compat_1.forwardRef)(SplitMenuButtonImpl), "SplitMenuButton", { "properties": { "label": { "type": "string" }, "items": { "type": "Array<object>" }, "tooltip": { "type": "string" }, "disabled": { "type": "boolean" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg"] }, "width": { "type": "number|string" }, "chroming": { "type": "string", "enumValues": ["solid", "outlined", "callToAction"], "binding": { "consume": { "name": "containerChroming" } } } }, "events": { "ojMenuAction": { "bubbles": true }, "ojAction": { "bubbles": true } }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["aria-describedby"] }, "methods": { "focus": {}, "blur": {}, "click": {} } }, { "chroming": "outlined", "disabled": false, "size": "md", "items": [] }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const FunctionalSplitMenuButton = (0, compat_1.forwardRef)((props, ref) => {
        const { tooltipContent, tooltipProps } = (0, UNSAFE_useTooltip_1.useTooltip)({
            text: props.tooltip,
            isDisabled: props.isDisabled
        });
        return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(UNSAFE_SplitMenuButton_1.SplitMenuButton, { ref: ref, ...(0, UNSAFE_mergeProps_1.mergeProps)(props, tooltipProps) }), tooltipContent] }));
    });
});

define('oj-c/split-menu-button',["require", "exports", "oj-c/split-menu-button/split-menu-button"], function (require, exports, split_menu_button_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SplitMenuButton = void 0;
    Object.defineProperty(exports, "SplitMenuButton", { enumerable: true, get: function () { return split_menu_button_1.SplitMenuButton; } });
});

define('oj-c/hooks/PRIVATE_useSelectionContext/useSelectionContext',["require", "exports", "preact/hooks", "./SelectionContext"], function (require, exports, hooks_1, SelectionContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSelectionContext = useSelectionContext;
    /**
     * Utility hook for consuming the SelectionContext
     *
     * @returns The value of the closest SelectionContext provider
     */
    function useSelectionContext() {
        return (0, hooks_1.useContext)(SelectionContext_1.SelectionContext);
    }
});

define('oj-c/hooks/PRIVATE_useSelectionContext/useItemKeyContext',["require", "exports", "preact/hooks", "./ItemKeyContext"], function (require, exports, hooks_1, ItemKeyContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useItemKeyContext = useItemKeyContext;
    /**
     * Utility hook for consuming the ItemKeyContext
     *
     * @returns The value of the closest ItemKeyContext provider
     */
    function useItemKeyContext() {
        return (0, hooks_1.useContext)(ItemKeyContext_1.ItemKeyContext);
    }
});

define('oj-c/selector/selector',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_Selector", "preact/hooks", "ojs/ojvcomponent", "../utils/PRIVATE_keyUtils/keySetUtils", "@oracle/oraclejet-preact/hooks/UNSAFE_useCollectionInteractionContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "../hooks/PRIVATE_useSelectionContext/useSelectionContext", "../hooks/PRIVATE_useSelectionContext/SelectionContext", "../hooks/PRIVATE_useSelectionContext/useItemKeyContext", "../hooks/PRIVATE_useSelectionContext/ItemKeyContext"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_Selector_1, hooks_1, ojvcomponent_1, keySetUtils_1, UNSAFE_useCollectionInteractionContext_1, UNSAFE_useTabbableMode_1, useSelectionContext_1, SelectionContext_1, useItemKeyContext_1, ItemKeyContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Selector = void 0;
    /**
     * @classdesc
     * <h3 id="selectorOverview-section">
     *   JET Selector
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selectorOverview-section"></a>
     * </h3>
     * <p>Description: A checkbox to support selection in Collection Components</p>
     * <p>The oj-c-selector is a component that may be placed within a template for Table, ListView.
     * It presents as a checkbox when the Collection Component is configured for multi-selection.
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-list-view
     *    id="listview"
     *    data="[[dataProvider]]"
     *    selected="{{selectedItems}}"
     *    selection-mode="[[selectedSelectionMode]]">
     *  &lt;template slot="itemTemplate" data-oj-as="item">
     *    &lt;oj-c-list-item-layout>
     *      &lt;oj-c-selector
     *        slot="selector">
     *      &lt;/oj-c-selector>
     *      &lt;span>
     *        &lt;oj-bind-text value="[[item.data.name]]">&lt;/oj-bind-text>
     *      &lt;/span>
     *    &lt;/oj-c-list-item-layout>
     *  &lt;/template>
     * &lt;/oj-c-list-view>
     * </code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>Application must specify a value for the aria-label attribute with a meaningful description of the purpose of this selector in order for this to be accessible.</p>
     *
     * @typeparam K Type of key
     * @ojmetadata description "The selector component renders checkboxes in collections to support selection."
     * @ojmetadata displayName "Selector"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Collections"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/selector"
     *   }
     * }
     * @ojmetadata help "oj-c.Selector.html"
     * @ojmetadata since "15.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-selector"]
     *   }
     * ]
     */
    const SelectorImpl = ({ rowKey, selectedKeys, indeterminate = false, selectionMode, onSelectedKeysChanged, ...otherProps }) => {
        const itemKey = (0, useItemKeyContext_1.useItemKeyContext)();
        if (itemKey !== undefined) {
            rowKey = itemKey;
        }
        const selectionInfo = (0, useSelectionContext_1.useSelectionContext)();
        let keys = selectedKeys;
        let mode = selectionMode;
        let selectedListener;
        if (selectionInfo) {
            if (selectionInfo.selected) {
                keys = selectionInfo.selected;
            }
            if (selectionInfo.selectionMode !== 'none') {
                mode = selectionInfo.selectionMode;
            }
            selectedListener = selectionInfo.onSelectedChange;
        }
        (0, hooks_1.useLayoutEffect)(() => {
            if (onSelectedKeysChanged &&
                selectedKeys &&
                selectionInfo &&
                selectionInfo.selected &&
                !(0, keySetUtils_1.isEqual)(selectionInfo.selected, selectedKeys)) {
                onSelectedKeysChanged(selectionInfo.selected);
            }
        }, [onSelectedKeysChanged, selectionInfo, selectedKeys]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_Selector_1.Selector, { isPartial: indeterminate, rowKey: rowKey, selectedKeys: (0, keySetUtils_1.keySetToKeys)(keys), selectionMode: mode == null ? 'multiple' : mode, "aria-label": otherProps['aria-label'], onChange: (0, hooks_1.useCallback)((detail) => {
                    const keySet = (0, keySetUtils_1.keysToKeySet)(detail.value);
                    selectedListener?.(keySet);
                    onSelectedKeysChanged?.(keySet);
                }, [selectedListener, onSelectedKeysChanged]) }, rowKey) }));
    };
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const SelectorWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-selector', SelectorImpl, "Selector", { "properties": { "rowKey": { "type": "string|number" }, "selectedKeys": { "type": "object", "writeback": true }, "indeterminate": { "type": "boolean" }, "selectionMode": { "type": "string", "enumValues": ["multiple", "single"] } }, "extension": { "_WRITEBACK_PROPS": ["selectedKeys"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby", "aria-describedby"] } }, { "indeterminate": false }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, {
        consume: [UNSAFE_useCollectionInteractionContext_1.CollectionInteractionContext, UNSAFE_useTabbableMode_1.TabbableModeContext, SelectionContext_1.SelectionContext, ItemKeyContext_1.ItemKeyContext]
    });
    exports.Selector = SelectorWithoutDefaultedGenerics;
});

define('oj-c/selector',["require", "exports", "oj-c/selector/selector"], function (require, exports, selector_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Selector = void 0;
    Object.defineProperty(exports, "Selector", { enumerable: true, get: function () { return selector_1.Selector; } });
});

define('oj-c/selector-all/selector-all',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_SelectorAll", "ojs/ojvcomponent", "../utils/PRIVATE_keyUtils/keySetUtils"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_SelectorAll_1, ojvcomponent_1, keySetUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectorAll = void 0;
    /**
     * @classdesc
     * <h3 id="selectorAllOverview-section">
     *   JET SelectorAll
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#selectorAllOverview-section"></a>
     * </h3>
     * <p>Description: A checkbox to support select all functionality in Collection Components</p>
     * <p>The oj-c-selector-all is a component that may be placed above Table, ListView. It presents as a checkbox
     * when the Collection Component is configured for select all.</p>
     * <p>Note that if the application wants to explicitly update the visual state of the component (e.g. to have
     * it checked when every item in the associatedListView is selected), it will need to update the selectedKeys
     * attribute with an AllKeySetImpl (with empty deletedKeys) to have it checked, or a KeySetImpl (with empty keys)
     * to have it unchecked.Partial state will be shown if either an AllKeySetImpl with non-empty deletedKeys or a
     * KeySetImpl with non-empty keys is specified.</p>
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;div class="oj-flex oj-sm-align-items-center">
     *   &lt;oj-c-selector-all
     *     id="selectAll"
     *     selected-keys="{{selectedItems}}">
     *   &lt;/oj-c-selector-all>
     *   &lt;span>Select All</span>
     * &lt;/div>
     * &lt;oj-c-list-view
     *   id="listview"
     *   data="[[dataProvider]]"
     *   selected="{{selectedItems}}"
     *   selection-mode="multiple">
     *  &lt;template slot="itemTemplate" data-oj-as="item">
     *    &lt;oj-c-list-item-layout>
     *      &lt;oj-c-selector
     *        selected-keys="{{selectedItems}}"
     *        selection-mode="multiple"
     *        row-key="[[item.data.id]]"
     *        slot="selector">
     *      &lt;/oj-c-selector>
     *      &lt;span>
     *        &lt;oj-bind-text value="[[item.data.name]]">&lt;/oj-bind-text>
     *      &lt;/span>
     *     &lt;/oj-c-list-item-layout>
     *   &lt;/template>
     * &lt;/oj-c-list-view>
     * </code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>Application must specify a value for the aria-label attribute with a meaningful description of the purpose of this selector in order for this to be accessible.</p>
     *
     * @typeparam K Type of key
     * @ojmetadata description "The selector all component renders a checkbox in collections to support selection."
     * @ojmetadata displayName "SelectorAll"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Collections"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/selectorAll"
     *   }
     * }
     * @ojmetadata help "oj-c.SelectorAll.html"
     * @ojmetadata since "15.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-selector"]
     *   }
     * ]
     */
    const SelectorAllImpl = ({ selectedKeys, onSelectedKeysChanged, showTooltip, ...otherProps }) => {
        const keys = selectedKeys.keys;
        const selected = (keys.all
            ? keys.deletedKeys.size > 0
                ? 'partial'
                : 'all'
            : keys.keys.size > 0
                ? 'partial'
                : 'none');
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_SelectorAll_1.SelectorAll, { selected: selected, onChange: (detail) => {
                    onSelectedKeysChanged?.((0, keySetUtils_1.keysToKeySet)(detail.value));
                }, showTooltip: showTooltip, ...otherProps }) }));
    };
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const SelectorAllWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-selector-all', SelectorAllImpl, "SelectorAll", { "properties": { "selectedKeys": { "type": "object", "writeback": true }, "showTooltip": { "type": "string", "enumValues": ["disabled", "enabled"] } }, "extension": { "_WRITEBACK_PROPS": ["selectedKeys"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby", "aria-describedby"] } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
    exports.SelectorAll = SelectorAllWithoutDefaultedGenerics;
});

define('oj-c/selector-all',["require", "exports", "oj-c/selector-all/selector-all"], function (require, exports, selector_all_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectorAll = void 0;
    Object.defineProperty(exports, "SelectorAll", { enumerable: true, get: function () { return selector_all_1.SelectorAll; } });
});

define('oj-c/legend-item/legend-item',["require", "exports", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent"], function (require, exports, translationBundle_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegendItem = exports.LegendItemDefaults = void 0;
    exports.LegendItemDefaults = {
        markerShape: 'square',
        symbolType: 'marker',
        borderColor: '',
        categories: [],
        lineStyle: 'solid',
        drilling: 'inherit'
    };
    exports.LegendItem = (0, ojvcomponent_1.registerCustomElement)('oj-c-legend-item', 
    /**
     *@classdesc
     * <h3 id="overview">
     *   JET Legend Item
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
     * </h3>
     *
     * <p>
     *  The oj-c-legend-item element is used to declare properties for legend items and is only valid as the
     *  child of a template element for the <a target="_blank" href="oj-c.Legend.html#itemTemplate">itemTemplate</a>
     *  slot of oj-c-legend.
     * </p>
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-legend data='[[dataProvider]]'>
     *  &lt;template slot='itemTemplate'>
     *    &lt;oj-c-legend-item  text='[[$current.data.text]]' color='[[$current.data.color]]'>
     *    &lt;/oj-c-legend-item>
     *  &lt;/template>
     * &lt;/oj-c-legend>
     * </code>
     * </pre>
     *
     * <h3 id="a11y-section">
     *  Accessibility
     *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     *  Read the <a target="_blank" href="oj-c.Legend.html#a11y-section">Accessibility Section</a> of the oj-c-legend component for details about making this component accessible.
     * </p>
     * @ojmetadata subcomponentType "data"
     * @ojmetadata description "The oj-c-legend-item element is used to declare properties for legend items."
     * @ojmetadata displayName "LegendItem"
     * @ojmetadata main "oj-c/legend-item"
     * @ojmetadata help "oj-c.LegendItem.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   }
     * }
     * @ojmetadata since "15.0.0"
     */
    ({ markerShape = exports.LegendItemDefaults.markerShape, symbolType = exports.LegendItemDefaults.symbolType, borderColor = exports.LegendItemDefaults.borderColor, categories = exports.LegendItemDefaults.categories, lineStyle = exports.LegendItemDefaults.lineStyle, drilling = exports.LegendItemDefaults.drilling, 
    /* @ts-ignore */
    ...props }) => {
        return null;
    }, "LegendItem", { "properties": { "text": { "type": "string" }, "categories": { "type": "Array<string>" }, "symbolType": { "type": "string", "enumValues": ["marker", "image", "line", "lineWithMarker"] }, "source": { "type": "string" }, "color": { "type": "string" }, "borderColor": { "type": "string" }, "lineStyle": { "type": "string", "enumValues": ["dashed", "solid", "dotted"] }, "lineWidth": { "type": "number" }, "markerShape": { "type": "string", "enumValues": ["square", "circle", "ellipse", "diamond", "human", "plus", "star", "triangleDown", "triangleUp", "rectangle"] }, "markerColor": { "type": "string" }, "shortDesc": { "type": "string" }, "drilling": { "type": "string", "enumValues": ["inherit", "off", "on"] } } }, { "markerShape": "square", "symbolType": "marker", "borderColor": "", "categories": [], "lineStyle": "solid", "drilling": "inherit" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/legend-section/legend-section',["require", "exports", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent"], function (require, exports, translationBundle_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegendSection = exports.LegendSectionDefaults = void 0;
    exports.LegendSectionDefaults = {
        text: ''
    };
    exports.LegendSection = (0, ojvcomponent_1.registerCustomElement)('oj-c-legend-section', 
    /**
     * @classdesc
     * <h3 id="overview">
     *   JET Legend Section
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#overview"></a>
     * </h3>
     *
     * <p>
     *  The oj-c-legend-section element is used to declare properties for legend sections and is only valid as the
     *  child of a template element for the <a target="_blank" href="oj-c.Legend.html#sectionTemplate">sectionTemplate</a>
     *  slot of oj-c-legend.
     * </p>
     * @ojmetadata subcomponentType "data"
     * @ojmetadata description "The oj-c-legend-section element is used to declare properties for legend sections."
     * @ojmetadata displayName "LegendSection"
     * @ojmetadata main "oj-c/legend-section"
     * @ojmetadata help "oj-c.LegendSection.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *        "text"
     *     ]
     *   }
     * ]
     * @ojmetadata since "15.0.0"
     */
    ({ text = exports.LegendSectionDefaults.text, 
    /* @ts-ignore */
    ...props }) => {
        return null;
    }, "LegendSection", { "properties": { "text": { "type": "string" } } }, { "text": "" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/legend/utils',["require", "exports", "../legend-item/legend-item", "../legend-section/legend-section"], function (require, exports, legend_item_1, legend_section_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultSymbolDims = void 0;
    exports.getTextStyles = getTextStyles;
    exports.getSectionStyles = getSectionStyles;
    exports.isLegendInteractive = isLegendInteractive;
    exports.parseItemIdx = parseItemIdx;
    exports.transformItem = transformItem;
    exports.transformSection = transformSection;
    exports.isTreeDataProvider = isTreeDataProvider;
    exports.isLegendItemDrillable = isLegendItemDrillable;
    /**
     * Returns the text styles for linear and sectional legend.
     */
    function getTextStyles(styles) {
        return {
            textFontStyle: styles?.fontStyle,
            textFontSize: styles?.fontSize,
            textFontColor: styles?.color,
            textFontWeight: styles?.fontWeight,
            textDecoration: styles?.textDecoration,
            textFontFamily: styles?.fontFamily
        };
    }
    /**
     * Return the styles for the sectional legend titles.
     */
    function getSectionStyles(styles) {
        return {
            sectionTitleColor: styles?.color,
            sectionTitleFontFamily: styles?.fontFamily,
            sectionTitleFontSize: styles?.fontSize,
            sectionTitleFontStyle: styles?.fontStyle,
            sectionTitleFontWeight: styles?.fontWeight,
            sectionTitleTextDecoration: styles?.textDecoration
        };
    }
    /**
     * Checks if the legend is interactive.
     */
    function isLegendInteractive(drilling, hideAndShowBehavior, hoverBehavior, hasDrillableItem, isContextMenuEnabled) {
        return (drilling === 'on' ||
            hideAndShowBehavior === 'on' ||
            hoverBehavior === 'dim' ||
            hasDrillableItem ||
            isContextMenuEnabled);
    }
    /**
     * Parses preact id to corepack id.
     */
    function parseItemIdx(id) {
        return id.split(';').map((i) => parseInt(i, 10));
    }
    /**
     * Transforms the corepack legend item to preact legend item.
     * @param item The legend item
     * @param ariaLabelSuffix The suffix to add in the legend item aria label.
     * @returns
     */
    function transformItem(dataItem, sectionIndex, itemIndex, ariaLabelSuffix, drilling, hideAndShowBehavior, isContextMenuEnabled) {
        const item = { ...legend_item_1.LegendItemDefaults, ...dataItem };
        return {
            borderColor: item.borderColor,
            lineWidth: item.lineWidth,
            markerColor: item.markerColor || item.color || undefined, // preact default
            lineColor: item.color || undefined,
            markerShape: item.symbolType !== 'line' ? item.markerShape : 'none',
            lineStyle: item.symbolType !== 'marker' ? item.lineStyle : 'none',
            'aria-label': [item.shortDesc, ariaLabelSuffix].filter(Boolean).join(' ') || undefined,
            datatip: item.shortDesc,
            source: item.source,
            text: item.text,
            actionable: hideAndShowBehavior === 'on' || isContextMenuEnabled
                ? 'inherit'
                : isLegendItemDrillable(drilling, item.drilling),
            // ignore corepack ids as it can be string, int, even [undefined] depending on
            // dataprovider keyAttributes, childAttribute. Instead, we create simple string ids for preact.
            id: `${sectionIndex};${itemIndex}`
        };
    }
    /**
     * Transforms the corepack legend sections to the preact legend sections.
     * @param section The legend section
     * @param ariaLabelSuffix The suffix to add in the legend item aria-label.
     * @returns
     */
    function transformSection(dataSection, ariaLabelSuffix, sectionIndex, drilling) {
        const section = { ...legend_section_1.LegendSectionDefaults, ...dataSection };
        return {
            items: section.items.map((item, itemIndex) => transformItem(item, sectionIndex, itemIndex, ariaLabelSuffix, drilling)),
            title: section.text || section.title,
            id: `${sectionIndex}`
        };
    }
    /**
     * Checks if the given dataprovider is a treedataprovider.
     * @param dataprovider
     * @returns
     */
    function isTreeDataProvider(dataprovider) {
        if (dataprovider && dataprovider['getChildDataProvider']) {
            return true;
        }
        return false;
    }
    /**
     * Returns the symbolWidth and symbolHeight for the preact legend.
     */
    const getDefaultSymbolDims = (symbolHeight, symbolWidth) => {
        // if both are zero, default to preact dims
        if (!symbolHeight && !symbolWidth) {
            return { width: undefined, height: undefined };
        }
        if (!symbolHeight) {
            return { width: symbolWidth, height: symbolWidth };
        }
        if (!symbolWidth) {
            return { width: symbolHeight, height: symbolHeight };
        }
        return { width: symbolWidth, height: symbolHeight };
    };
    exports.getDefaultSymbolDims = getDefaultSymbolDims;
    function isLegendItemDrillable(drilling, itemDrilling) {
        let actionable = 'inherit';
        if (itemDrilling === 'on') {
            return actionable;
        }
        else if (itemDrilling === 'off') {
            actionable = 'off';
        }
        else {
            if (drilling === 'on') {
                actionable = 'inherit';
            }
            else if (drilling === 'off') {
                actionable = 'off';
            }
        }
        return actionable;
    }
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/legend/events',["require", "exports", "./utils"], function (require, exports, utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLegendEventsHandler = void 0;
    const getLegendEventsHandler = (isHideShowOn, isHighlightOn, updateHidden, updateHighlighted, getDrillDetail, drilling = 'off', getItemDrilling, onOjDrill) => {
        const itemActionHandler = (detail) => {
            // Preact supports id as number or string while corepack processes ids into strings. see transformItem and transformSection in utils.ts
            if (typeof detail.itemId === 'string' && isHideShowOn) {
                updateHidden(detail.itemId);
            }
            const [sectionIdx, itemIdx] = (0, utils_1.parseItemIdx)(detail.itemId); //note: Corepack legend processes ids into strings
            if ((0, utils_1.isLegendItemDrillable)(drilling, getItemDrilling(itemIdx, sectionIdx)) !== 'off') {
                onOjDrill?.({ id: getDrillDetail([sectionIdx, itemIdx]) });
            }
        };
        const inputHandler = (detail) => {
            // Preact supports id as number or string while corepack processes ids into strings. see transformItem and transformSection in utils.ts
            if (typeof detail.itemId === 'string' && isHighlightOn) {
                updateHighlighted(detail.itemId);
            }
        };
        return {
            itemActionHandler,
            inputHandler
        };
    };
    exports.getLegendEventsHandler = getLegendEventsHandler;
});

define('oj-c/legend/useSectionData',["require", "exports", "preact/compat", "../utils/UNSAFE_vizUtils/TemplateHandler", "../hooks/UNSAFE_useDataProvider/useDataProvider", "ojs/ojflattenedtreedataproviderview", "ojs/ojkeyset"], function (require, exports, compat_1, TemplateHandler_1, useDataProvider_1, FlattenedTreeDataProviderView, ojkeyset_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSectionData = useSectionData;
    /**
     * Hook that returns the processed sectional legend data.
     * TODO: JET-59089 replace with proper useTreeDataProvider
     * @returns
     */
    function useSectionData(dataProvider, addBusyState, sectionTemplate, itemTemplate) {
        const dpRef = (0, compat_1.useRef)(dataProvider);
        const flatDpRef = (0, compat_1.useRef)(new FlattenedTreeDataProviderView(dataProvider, {
            expanded: new ojkeyset_1.AllKeySetImpl()
        }));
        if (dpRef.current != dataProvider) {
            dpRef.current = dataProvider;
            flatDpRef.current = new FlattenedTreeDataProviderView(dpRef.current, {
                expanded: new ojkeyset_1.AllKeySetImpl()
            });
        }
        const { data } = (0, useDataProvider_1.useDataProvider)({
            data: flatDpRef.current,
            addBusyState
        });
        const sections = [];
        if (data.length > 0) {
            let currentSection;
            for (const item of data) {
                const context = {
                    key: item.metadata?.key,
                    data: item.data,
                    index: item.metadata.indexFromParent
                };
                const isSection = item?.metadata?.treeDepth === 0;
                if (isSection) {
                    currentSection = item;
                    let sectionData = item.data;
                    const items = [];
                    if (sectionTemplate) {
                        sectionData = (0, TemplateHandler_1.processNodeTemplate)(item, sectionTemplate, context, 'oj-c-legend-section');
                    }
                    sections.push({ ...sectionData, items });
                }
                else {
                    const itemContext = {
                        ...context,
                        parentKey: item.metadata?.parentKey,
                        parentData: currentSection?.data
                    };
                    const processedItem = itemTemplate
                        ? (0, TemplateHandler_1.processNodeTemplate)(item, itemTemplate, itemContext, 'oj-c-legend-item')
                        : item.data;
                    sections[sections.length - 1]['items'].push({
                        key: item.metadata?.key,
                        ...processedItem
                    });
                }
            }
        }
        const idToDPItemMap = new Map(data.map((item) => [item.key, item.data]));
        return {
            sections,
            idToDPItemMap
        };
    }
});


define('oj-c/legend/legend',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/hooks", "preact/compat", "@oracle/oraclejet-preact/UNSAFE_Legend", "@oracle/oraclejet-preact/hooks/UNSAFE_useBusyStateContext", "@oracle/oraclejet-preact/UNSAFE_SectionalLegend", "ojs/ojvcomponent", "./utils", "../hooks/UNSAFE_useDataProvider/useDataProvider", "../utils/UNSAFE_vizUtils/TemplateHandler", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "preact/compat", "../hooks/UNSAFE_useVizCategories/useVizCategories", "./events", "./useSectionData", "oj-c/hooks/PRIVATE_useVisContextMenu/useVisContextMenu", "css!oj-c/legend/legend-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, hooks_1, compat_1, UNSAFE_Legend_1, UNSAFE_useBusyStateContext_1, UNSAFE_SectionalLegend_1, ojvcomponent_1, utils_1, useDataProvider_1, TemplateHandler_1, UNSAFE_useTranslationBundle_1, compat_2, useVizCategories_1, events_1, useSectionData_1, useVisContextMenu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SectionalLegend = exports.LinearLegend = exports.Legend = void 0;
    const HIGHLIGHTED_DEFAULT = [];
    const HIDDEN_DEFAULT = [];
    const TEXTSTYLE_DEFAULT = {};
    const SECTION_TITLE_DEFAULT = {};
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const LegendWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-legend', (0, compat_1.forwardRef)(
    /**
     * @classdesc
     * <h3 id="legendOverview-section">
     *   JET Legend
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#legendOverview-section"></a>
     * </h3>
     * A legend displays an interactive description of symbols, colors, etc used in graphical information representations.
     * <pre class="prettyprint"><code>&lt;oj-c-legend orientation='vertical' data='[[dataProvider]]'>&lt;/oj-c-legend></code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * To make your component accessible, the application is required to include contextual information for screender readers using one or more the following methods as appropriate:
     *  <ul>
     *   <li>aria-describedby</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-label</li>
     *   <li>short-desc property of your items</li>
     *  </ul>
     * <p>
     *  When setting color, applications are responsible for making sure that the color meets the
     * <a href="https://www.w3.org/TR/WCAG21/#non-text-contrast">minimum contrast ratio</a>
     * </p>
     * <p>
     *  If your application has custom keyboard and touch shortcuts implemented for the component, these shortcuts can conflict with those of the component. It is the application's responsibility to disclose these custom shortcuts, possibly via a datatip or help popup.
     * </p>
     * <p>
     *  In the case of the text truncating, applications should provide the untruncated string or contextual text to the datatip to make the component accessible.
     * </p>
     *
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <h4>Shaped Data</h4>
     * <p>As a rule of thumb, it's recommended that applications use <a href="https://jet.oraclecorp.com/trunk/jetCookbook.html?component=legendCorepack&demo=shapedData">shaped data</a> if possible for performance gains.</p>
     *
     * <h3 id="keyboardSection">
     *   Keyboard
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboardSection"></a>
     * </h3>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Move focus to next element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>Move focus to previous element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Move focus to previous item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Move focus to next item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Move focus to previous item (on left).</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Move focus to next item (on right).</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Enter or Space</kbd></td>
     *       <td>Hides or unhides the data associated with the current item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+F10</kbd></td>
     *       <td>Launch the context menu if there is one associated with the current item.</td>
     *     </tr>
     *   </tbody>
     * </table>
     * <h3 id="touch-section">
     * Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="2">Legend Item</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Filter when <code class="prettyprint">hideAndShowBehavior</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *        <td>Background</td>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojmetadata description "A legend displays an interactive description of symbols, colors, etc., used in graphical information representations."
     * @ojmetadata displayName "Legend"
     * @ojmetadata main "oj-c/legend"
     * @ojmetadata help "oj-c.Legend.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/legend",
     *       "defaultColumns": 2,
     *         "minColumns": 1
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-legend",
     *     "uxSpecs": [
     *       "legend"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "orientation",
     *       "halign",
     *       "valign",
     *       "hoverBehavior",
     *       "style"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data"
     *     ]
     *   }
     * ]
     * @ojmetadata since "15.0.0"
     *
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby", "aria-describedby"]
     *  }
     * ]
     *
     */
    ({ data = null, drilling = 'off', halign = 'start', valign = 'top', hiddenCategories = HIDDEN_DEFAULT, hideAndShowBehavior = 'off', highlightedCategories = HIGHLIGHTED_DEFAULT, hoverBehavior = 'none', orientation = 'vertical', symbolHeight = 0, symbolWidth = 0, textStyle = TEXTSTYLE_DEFAULT, sectionTitleStyle = SECTION_TITLE_DEFAULT, sectionTitleHalign = 'start', contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, itemTemplate, sectionTemplate, onOjDrill, ...props }, ref) => {
        const rootRef = (0, hooks_1.useRef)(null);
        const busyStateContext = (0, hooks_1.useContext)(UNSAFE_useBusyStateContext_1.BusyStateContext);
        const legendRef = (0, hooks_1.useRef)(null);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            _getPreferredSize: (_width, _height) => {
                return legendRef.current._getPreferredSize(_width, _height);
            }
        }));
        const isTreeData = (0, utils_1.isTreeDataProvider)(data);
        const { width: symWidth, height: symHeight } = (0, utils_1.getDefaultSymbolDims)(symbolHeight, symbolWidth);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, children: isTreeData ? ((0, jsx_runtime_1.jsx)(exports.SectionalLegend, { ...props, onOjDrill: onOjDrill, data: data, halign: halign, valign: valign, sectionTemplate: sectionTemplate, itemTemplate: itemTemplate, addBusyState: busyStateContext.addBusyState, drilling: drilling, hiddenCategories: hiddenCategories, hideAndShowBehavior: hideAndShowBehavior, highlightedCategories: highlightedCategories, hoverBehavior: hoverBehavior, orientation: orientation, symbolHeight: symHeight, symbolWidth: symWidth, textStyle: textStyle, sectionTitleStyle: sectionTitleStyle, sectionTitleHalign: sectionTitleHalign, sectionalLegendRef: legendRef, contextMenuConfig: contextMenuConfig, onOjContextMenuAction: onOjContextMenuAction, onOjContextMenuSelection: onOjContextMenuSelection })) : ((0, jsx_runtime_1.jsx)(exports.LinearLegend, { ...props, onOjDrill: onOjDrill, data: data, valign: valign, halign: halign, itemTemplate: itemTemplate, drilling: drilling, hiddenCategories: hiddenCategories, hideAndShowBehavior: hideAndShowBehavior, highlightedCategories: highlightedCategories, hoverBehavior: hoverBehavior, orientation: orientation, symbolHeight: symHeight, symbolWidth: symHeight, addBusyState: busyStateContext.addBusyState, textStyle: textStyle, linearLegendRef: legendRef, contextMenuConfig: contextMenuConfig, onOjContextMenuAction: onOjContextMenuAction, onOjContextMenuSelection: onOjContextMenuSelection })) }));
    }), "Legend", { "properties": { "data": { "type": "DataProvider|null" }, "drilling": { "type": "string", "enumValues": ["off", "on"] }, "halign": { "type": "string", "enumValues": ["center", "end", "start"] }, "hiddenCategories": { "type": "Array<string>", "writeback": true }, "hideAndShowBehavior": { "type": "string", "enumValues": ["off", "on"] }, "highlightedCategories": { "type": "Array<string>", "writeback": true }, "hoverBehavior": { "type": "string", "enumValues": ["none", "dim"] }, "orientation": { "type": "string", "enumValues": ["horizontal", "vertical"] }, "symbolHeight": { "type": "number" }, "symbolWidth": { "type": "number" }, "textStyle": { "type": "object", "properties": { "color": { "type": "string" }, "fontFamily": { "type": "string" }, "fontSize": { "type": "string" }, "fontStyle": { "type": "string" }, "fontWeight": { "type": "string" }, "textDecoration": { "type": "string" } } }, "valign": { "type": "string", "enumValues": ["top", "bottom", "middle"] }, "sectionTitleStyle": { "type": "object", "properties": { "color": { "type": "string" }, "fontFamily": { "type": "string" }, "fontSize": { "type": "string" }, "fontStyle": { "type": "string" }, "fontWeight": { "type": "string" }, "textDecoration": { "type": "string" } } }, "sectionTitleHalign": { "type": "string", "enumValues": ["center", "end", "start"] }, "contextMenuConfig": { "type": "object", "properties": { "accessibleLabel": { "type": "string" }, "items": { "type": "function" } } } }, "slots": { "itemTemplate": { "data": {} }, "sectionTemplate": { "data": {} } }, "events": { "ojDrill": {}, "ojContextMenuAction": { "bubbles": true }, "ojContextMenuSelection": { "bubbles": true } }, "extension": { "_WRITEBACK_PROPS": ["hiddenCategories", "highlightedCategories"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-describedby", "aria-labelledby"] }, "methods": { "_getPreferredSize": {} } }, { "data": null, "drilling": "off", "halign": "start", "valign": "top", "hiddenCategories": [], "hideAndShowBehavior": "off", "highlightedCategories": [], "hoverBehavior": "none", "orientation": "vertical", "symbolHeight": 0, "symbolWidth": 0, "textStyle": {}, "sectionTitleStyle": {}, "sectionTitleHalign": "start" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [] });
    exports.Legend = LegendWithoutDefaultedGenerics;
    /**
     * The wrapper for the liner legend.
     */
    const LinearLegend = ({ hoverBehavior, hideAndShowBehavior, hiddenCategories, highlightedCategories, onHiddenCategoriesChanged, onHighlightedCategoriesChanged, drilling, itemTemplate, sectionTemplate, textStyle, orientation, symbolHeight, symbolWidth, valign, halign, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, ...props }) => {
        const { data } = (0, useDataProvider_1.useDataProvider)({
            data: props.data ? props.data : undefined,
            addBusyState: props.addBusyState
        });
        const idToDPItemMap = new Map(data.map((item) => [item.key, item.data]));
        const isHighlightOn = hoverBehavior === 'dim';
        const isHideShowOn = hideAndShowBehavior === 'on';
        const getItemContext = (context, index) => {
            return {
                data: context.data,
                key: context.key,
                index
            };
        };
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const items = (itemTemplate
            ? (0, TemplateHandler_1.processTemplate)(data, itemTemplate, getItemContext, 'oj-c-legend-item')
            : data.map((item) => item.data));
        const hasDrillableItem = (0, compat_2.useMemo)(() => {
            return items.some((value) => value.drilling === 'on');
        }, [items]);
        const isContextMenuEnabled = !!contextMenuConfig;
        const preactItems = (0, compat_2.useMemo)(() => {
            return items.map((value, itemIndex) => {
                return (0, utils_1.transformItem)(value, 0, itemIndex, (drilling === 'on' && value.drilling !== 'off') || value.drilling === 'on'
                    ? translations.vis_drillable()
                    : '', drilling, hideAndShowBehavior, isContextMenuEnabled);
            });
        }, [items, drilling, translations]);
        const isInteractive = (0, utils_1.isLegendInteractive)(drilling, hideAndShowBehavior, hoverBehavior, hasDrillableItem, isContextMenuEnabled);
        // TODO: JET-59090 could prevent this after useCategories support getIdFromItem
        const categoriesItems = (0, compat_2.useMemo)(() => {
            const categoriesItems = [];
            if (isHideShowOn || isHighlightOn) {
                items.forEach((item, itemIndex) => {
                    categoriesItems.push({
                        id: preactItems[itemIndex].id,
                        categories: item.categories || []
                    });
                });
            }
            return categoriesItems;
        }, [preactItems, items, isHideShowOn, isHighlightOn]);
        const { hiddenIds, updateHidden, highlightedIds, updateHighlighted } = (0, useVizCategories_1.useVizCategories)(categoriesItems, (item) => item.categories, hiddenCategories, highlightedCategories, 'any', 'any', onHiddenCategoriesChanged, onHighlightedCategoriesChanged);
        const getDrillDetail = (id) => {
            const [_, itemIdx] = id;
            const item = items[itemIdx];
            if ((item.categories || []).length > 0)
                return item.categories; //legacy behavior
            return data[itemIdx].metadata?.key;
        };
        const getItemDrilling = (itemIdx) => {
            const item = items[itemIdx];
            return item?.drilling || 'inherit';
        };
        const { itemActionHandler, inputHandler } = (0, events_1.getLegendEventsHandler)(isHideShowOn, isHighlightOn, updateHidden, updateHighlighted, getDrillDetail, drilling, getItemDrilling, props.onOjDrill);
        const textStyles = (0, utils_1.getTextStyles)(textStyle);
        const transformContext = (context) => {
            if (context.type !== 'item')
                return context;
            const id = context.data.id;
            const [_, itemIdx] = (0, utils_1.parseItemIdx)(id);
            const corepackItemData = idToDPItemMap.get(data[itemIdx].metadata?.key);
            const corepackData = { ...preactItems[itemIdx], id: data[itemIdx].metadata?.key };
            return {
                data: corepackData,
                itemData: corepackItemData,
                itemIndexPath: [itemIdx],
                type: 'item'
            };
        };
        const { preactContextMenuConfig } = (0, useVisContextMenu_1.useVisContextMenu)(idToDPItemMap, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, transformContext);
        const { data: _data, ...otherProps } = props;
        const vAlign = valign === 'middle' ? 'center' : valign;
        return preactItems.length !== 0 ? ((0, jsx_runtime_1.jsx)(UNSAFE_Legend_1.Legend, { ref: props.linearLegendRef, orientation: orientation, symbolHeight: symbolHeight, valign: vAlign, halign: halign, symbolWidth: symbolWidth, isReadOnly: !isInteractive, hideAndShowBehavior: hideAndShowBehavior, hoverBehavior: hoverBehavior, hiddenIds: isHideShowOn ? hiddenIds : undefined, highlightedIds: isHighlightOn ? highlightedIds : undefined, items: preactItems, onItemAction: itemActionHandler, onItemHover: inputHandler, onItemFocus: inputHandler, 
            //@ts-ignore
            contextMenuConfig: contextMenuConfig ? preactContextMenuConfig : undefined, ...otherProps, ...textStyles })) : null;
    };
    exports.LinearLegend = LinearLegend;
    /**
     * The wrapper for sectional legend.
     */
    const SectionalLegend = ({ hoverBehavior, hideAndShowBehavior, hiddenCategories, highlightedCategories, onHiddenCategoriesChanged, onHighlightedCategoriesChanged, drilling, itemTemplate, sectionTemplate, textStyle, sectionTitleStyle, orientation, symbolHeight, symbolWidth, valign, halign, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, ...props }) => {
        const isHighlightOn = hoverBehavior === 'dim';
        const isHideShowOn = hideAndShowBehavior === 'on';
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const { sections: s, idToDPItemMap } = (0, useSectionData_1.useSectionData)(props.data, props.addBusyState, sectionTemplate, itemTemplate);
        const sections = s;
        const hasDrillableItem = (0, compat_2.useMemo)(() => {
            return sections.some((section) => section.items.some((item) => item.drilling === 'on'));
        }, [sections]);
        const preactSections = (0, compat_2.useMemo)(() => {
            const preactSections = sections.map((section, sectionIdx) => (0, utils_1.transformSection)(section, drilling === 'on' ? translations.vis_drillable() : '', sectionIdx));
            return preactSections;
        }, [sections, drilling, translations]);
        const isContextMenuEnabled = !!contextMenuConfig;
        const isInteractive = (0, utils_1.isLegendInteractive)(drilling, hideAndShowBehavior, hoverBehavior, hasDrillableItem, isContextMenuEnabled);
        // TODO: JET-59090 could prevent this after useCategories support getIdFromItem
        const categoriesItems = (0, compat_2.useMemo)(() => {
            const categoriesItems = [];
            if (isHideShowOn || isHighlightOn) {
                sections.forEach((section, sectionIndex) => {
                    section.items.forEach((item, itemIndex) => {
                        categoriesItems.push({
                            id: preactSections[sectionIndex].items[itemIndex].id,
                            categories: item.categories || []
                        });
                    });
                });
            }
            return categoriesItems;
        }, [sections, isHideShowOn, isHighlightOn, preactSections]);
        const { hiddenIds, updateHidden, highlightedIds, updateHighlighted } = (0, useVizCategories_1.useVizCategories)(categoriesItems, (item) => item.categories, hiddenCategories, highlightedCategories, 'any', 'any', onHiddenCategoriesChanged, onHighlightedCategoriesChanged);
        const getDrillDetail = (id) => {
            const [sectionIdx, itemIdx] = id;
            const item = sections[sectionIdx].items[itemIdx];
            if (item.categories)
                return item.categories; //legacy behavior
            return item.key;
        };
        const getItemDrilling = (itemIdx, sectionIdx) => {
            const item = sections[sectionIdx].items[itemIdx];
            return item?.drilling || 'inherit';
        };
        const { itemActionHandler, inputHandler } = (0, events_1.getLegendEventsHandler)(isHideShowOn, isHighlightOn, updateHidden, updateHighlighted, getDrillDetail, drilling, getItemDrilling, props.onOjDrill);
        const transformContext = (context) => {
            if (context.type !== 'item')
                return context;
            const id = context.data.id;
            const [sectionIdx, itemIdx] = (0, utils_1.parseItemIdx)(id);
            const corepackItemData = idToDPItemMap.get(sections[sectionIdx].items[itemIdx].key);
            const corepackData = {
                ...preactSections[sectionIdx].items[itemIdx],
                id: sections[sectionIdx].items[itemIdx].key
            };
            return {
                data: corepackData,
                itemData: corepackItemData,
                itemIndexPath: [sectionIdx, itemIdx],
                type: 'item'
            };
        };
        const { preactContextMenuConfig } = (0, useVisContextMenu_1.useVisContextMenu)(idToDPItemMap, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, transformContext);
        const textStyles = (0, utils_1.getTextStyles)(textStyle);
        const sectionTitleStyles = (0, utils_1.getSectionStyles)(sectionTitleStyle);
        const vAlign = valign === 'middle' ? 'center' : valign;
        return preactSections.length !== 0 ? ((0, jsx_runtime_1.jsx)(UNSAFE_SectionalLegend_1.SectionalLegend, { ref: props.sectionalLegendRef, sections: preactSections, orientation: orientation, sectionTitleHAlign: props.sectionTitleHalign, symbolHeight: symbolHeight, symbolWidth: symbolWidth, isReadOnly: !isInteractive, valign: vAlign, halign: halign, hideAndShowBehavior: hideAndShowBehavior, hoverBehavior: hoverBehavior, "aria-label": props['aria-label'], "aria-describedBy": props['aria-describedby'], "aria-labelledBy": props['aria-labelledby'], hiddenIds: isHideShowOn ? hiddenIds : undefined, highlightedIds: isHighlightOn ? highlightedIds : undefined, onItemAction: itemActionHandler, onItemHover: inputHandler, onItemFocus: inputHandler, 
            //@ts-ignore
            contextMenuConfig: contextMenuConfig ? preactContextMenuConfig : undefined, ...textStyles, ...sectionTitleStyles })) : null;
    };
    exports.SectionalLegend = SectionalLegend;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/legend',["require", "exports", "oj-c/legend/legend"], function (require, exports, legend_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Legend = void 0;
    Object.defineProperty(exports, "Legend", { enumerable: true, get: function () { return legend_1.Legend; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/legend-item',["require", "exports", "oj-c/legend-item/legend-item"], function (require, exports, legend_item_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegendItem = void 0;
    Object.defineProperty(exports, "LegendItem", { enumerable: true, get: function () { return legend_item_1.LegendItem; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/legend-section',["require", "exports", "oj-c/legend-section/legend-section"], function (require, exports, legend_section_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LegendSection = void 0;
    Object.defineProperty(exports, "LegendSection", { enumerable: true, get: function () { return legend_section_1.LegendSection; } });
});

define('oj-c/tag-cloud-item/tag-cloud-item',["require", "exports", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent"], function (require, exports, translationBundle_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TagCloudItem = exports.TagCloudItemDefaults = void 0;
    exports.TagCloudItemDefaults = {
        categories: []
    };
    exports.TagCloudItem = (0, ojvcomponent_1.registerCustomElement)('oj-c-tag-cloud-item', 
    /**
     *@classdesc
     *<h3 id="tagCloudItemOverview-section">
     *   JET Tag Cloud Item
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#tagCloudItemOverview-section"></a>
     * </h3>
     *
     * <p>The oj-c-tag-cloud-item element is used to declare properties for tag cloud items and is only valid as the
     *  child of a template element for the <a target="_blank" href="oj-c.TagCloud.html#itemTemplate">itemTemplate</a> slot of oj-c-tag-cloud.</p>
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-tag-cloud data='[[dataProvider]]'>
     *  &lt;template slot='itemTemplate' data-oj-as='item'>
     *    &lt;oj-c-tag-cloud-item  label='[[item.data.id]]' value='[[item.data.total]]'>&lt;/oj-c-tag-cloud-item>
     *  &lt;/template>
     * &lt;/oj-c-tag-cloud>
     * </code>
     * </pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * <p>
     *  Read the <a target="_blank" href="oj-c.TagCloud.html#a11y-section">Accessibility Section</a> of the oj-c-tagcloud component for details about making this component accessible.
     * </p>
     *
     * @ojmetadata subcomponentType "data"
     * @ojmetadata description "The oj-c-tag-cloud-item element is used to declare properties for tag cloud items"
     * @ojmetadata displayName "TagCloudItem"
     * @ojmetadata main "oj-c/tag-cloud-item"
     * @ojmetadata help "oj-c.TagCloudItem.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   }
     * }
     * @ojmetadata since "15.0.0"
     */
    ({ categories = exports.TagCloudItemDefaults.categories, 
    /* @ts-ignore */
    ...props }) => {
        return null;
    }, "TagCloudItem", { "properties": { "categories": { "type": "Array<string>" }, "color": { "type": "string" }, "label": { "type": "string" }, "value": { "type": "number|null" }, "url": { "type": "string" }, "shortDesc": { "type": "string" } } }, { "categories": [] }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/tag-cloud/utils',["require", "exports", "../tag-cloud-item/tag-cloud-item"], function (require, exports, tag_cloud_item_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.transformItem = transformItem;
    exports.executeLink = executeLink;
    /**
     * Transforms the corepack tagcloud item to preact tagcloud item.
     * @param item
     * @param index
     * @returns
     */
    function transformItem(dataItem) {
        const item = { ...tag_cloud_item_1.TagCloudItemDefaults, ...dataItem };
        return {
            color: item.color,
            accessibleLabel: item.shortDesc,
            value: item.value,
            label: item.label,
            id: item.key != null ? item?.key : item.id,
            role: (item.url ? 'link' : undefined)
        };
    }
    /**
     * Get a pseudo link callback that loads a document into the existing or a new window.
     * @param {string} dest a URL to be loaded for the link
     */
    function executeLink(dest) {
        const newWindow = window.open(dest, '_blank');
        if (newWindow)
            newWindow.focus();
    }
});


define('oj-c/tag-cloud/tag-cloud',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/hooks", "preact/compat", "@oracle/oraclejet-preact/UNSAFE_TagCloud", "@oracle/oraclejet-preact/hooks/UNSAFE_useBusyStateContext", "./utils", "@oracle/oraclejet-preact/UNSAFE_VisStatusMessage", "../hooks/UNSAFE_useVizCategories/useVizCategories", "ojs/ojvcomponent", "./utils", "../hooks/UNSAFE_useDataProvider/useDataProvider", "../utils/UNSAFE_vizUtils/TemplateHandler", "oj-c/hooks/PRIVATE_useVisContextMenu/useVisContextMenu", "css!oj-c/tag-cloud/tag-cloud-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, hooks_1, compat_1, UNSAFE_TagCloud_1, UNSAFE_useBusyStateContext_1, utils_1, UNSAFE_VisStatusMessage_1, useVizCategories_1, ojvcomponent_1, utils_2, useDataProvider_1, TemplateHandler_1, useVisContextMenu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TagCloud = void 0;
    const HIGHLIGHTED_DEFAULT = [];
    const SELECTION_DEFAULT = [];
    const HIDDEN_DEFAULT = [];
    /**
     * @classdesc
     * <h3 id="tagCloudOverview-section">
     *   JET Tag Cloud
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#tagCloudOverview-section"></a>
     * </h3>
     * *
     * <p>Tag clouds are used to display text data with
     * the importance of each tag shown with font size or color.</p>
     *
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-tag-cloud
     *   data="[[dataProvider]]">
     * &lt;/oj-c-tag-cloud>
     * </code>
     * </pre>
     *
     *
     * <p>When using font colors as a data dimension for tag clouds, the application
     * needs to ensure that they meet minimum contrast requirements. Not all colors
     * in the default value ramp provided by oj.ColorAttributeGroupHandler
     * will meet minimum contrast requirements.</p>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Move focus to next element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + Tab</kbd></td>
     *       <td>Move focus to previous element.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Move focus and selection to previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Move focus and selection to next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Move focus and selection to previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Move focus and selection to next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + UpArrow</kbd></td>
     *       <td>Move focus and multi-select previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + DownArrow</kbd></td>
     *       <td>Move focus and multi-select next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + LeftArrow</kbd></td>
     *       <td>Move focus and multi-select previous data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift + RightArrow</kbd></td>
     *       <td>Move focus and multi-select next data item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + UpArrow</kbd></td>
     *       <td>Move focus to previous data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + DownArrow</kbd></td>
     *       <td>Move focus to next data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + LeftArrow</kbd></td>
     *       <td>Move focus to previous data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + RightArrow</kbd></td>
     *       <td>Move focus to next data item, without changing the current selection.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Ctrl + Spacebar</kbd></td>
     *       <td>Multi-select data item with focus.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Open a link when the <code class="prettyprint">url</code> for a data item is set.</td>
     *     </tr>
     *      <tr>
     *       <td><kbd>Shift+F10</kbd></td>
     *       <td>Launch the context menu if there is one associated with the current item.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * To make your component accessible, the application is required to include contextual information for screender readers using one or more the following methods as appropriate:
     *  <ul>
     *   <li>aria-describedby</li>
     *   <li>aria-labelledby</li>
     *   <li>aria-label</li>
     *   <li>short-desc property of your items</li>
     *  </ul>
     * <p>
     *  If your application has custom keyboard and touch shortcuts implemented for the component, these shortcuts can conflict with those of the component. It is the application's responsibility to disclose these custom shortcuts, possibly via a datatip or help popup.
     * </p>
     * <p>
     *  When using colors as a data dimension for tag clouds, the application needs to ensure that they meet <a target="_blank" href="https://www.w3.org/TR/WCAG21/#contrast-minimum">minimum contrast requirements</a>.
     * </p>
     *
     * <h3 id="perf-section">
     *   Performance
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#perf-section"></a>
     * </h3>
     *
     * <h4>Shaped Data</h4>
     * <p>As a rule of thumb, it's recommended that applications use <a href="https://jet.oraclecorp.com/trunk/jetCookbook.html?component=tagCloudCorepack&demo=shapedData">shaped data</a> if possible for performance gains.</p>
     *
     * <h4>Layout</h4>
     * <p>Rectangular layouts are faster than cloud layouts and are recommended for larger data sets.
     * </p>
     *
     *
     * <h3 id="touch-section">
     * Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="3">Data Item</td>
     *       <td rowspan="2"><kbd>Tap</kbd></td>
     *       <td>Select when <code class="prettyprint">selectionMode</code> is enabled.</td>
     *     </tr>
     *     <tr>
     *        <td>Open a link when the <code class="prettyprint">url</code> for a data item is set.</td>
     *     </tr>
     *     <tr>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *     <tr>
     *        <td>Background</td>
     *        <td><kbd>Press & Hold</kbd></td>
     *        <td>Display context menu on release.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojmetadata description "A tag cloud is an interactive data visualization of textual data, where the importance of each tagged word or phrase is represented by font size or color."
     * @ojmetadata displayName "Tag Cloud"
     * @ojmetadata main "oj-c/tag-cloud"
     * @ojmetadata help "oj-c.TagCloud.html"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Visualizations"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/tag-cloud",
     *       "defaultColumns": 12,
     *         "minColumns": 6
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-cloud-tag",
     *     "uxSpecs": [
     *       "tag-cloud"
     *     ]
     *   }
     * }
     *
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "layout",
     *       "style"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data",
     *       "selection"
     *     ]
     *   }
     * ]
     * @ojmetadata since "15.0.0"
     *
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby", "aria-describedby"]
     *  }
     * ]
     *
     */
    function TagCloudComp({ hiddenCategories = HIDDEN_DEFAULT, data = null, highlightedCategories = HIGHLIGHTED_DEFAULT, hoverBehavior = 'none', layout = 'rectangular', selection = SELECTION_DEFAULT, selectionMode = 'none', highlightMatch = 'all', contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection, ...props }) {
        const rootRef = (0, hooks_1.useRef)(null);
        const busyStateContext = (0, hooks_1.useContext)(UNSAFE_useBusyStateContext_1.BusyStateContext);
        const { data: compData } = (0, useDataProvider_1.useDataProvider)({
            data: data ? data : undefined,
            addBusyState: busyStateContext.addBusyState
        });
        const isHighlightOn = hoverBehavior === 'dim';
        const getItemContext = (0, hooks_1.useCallback)((context, index) => {
            return {
                data: context.data,
                key: context.key,
                index
            };
        }, []);
        const idToDPItemMap = new Map(compData.map((item) => [item.key, item.data]));
        const items = (0, compat_1.useMemo)(() => {
            const items = props.itemTemplate
                ? (0, TemplateHandler_1.processTemplate)(compData, props.itemTemplate, getItemContext, 'oj-c-tag-cloud-item')
                : compData.map((item) => item.data);
            return items;
        }, [props.itemTemplate, compData, getItemContext]);
        const [idItemMap, preactItems] = (0, compat_1.useMemo)(() => {
            const idItemMap = new Map();
            const preactItems = items.map((item) => {
                if (item.id != null || item.key != null)
                    idItemMap.set(item.id || item.key, item);
                return (0, utils_2.transformItem)(item);
            });
            return [idItemMap, preactItems];
        }, [items]);
        // TODO: JET-59090 could prevent this after useCategories support getIdFromItem
        // always create categoriesItems since we don't know when hidden categories will change
        const [hasUrl, categoriesItems] = (0, compat_1.useMemo)(() => {
            let hasUrl = false;
            const categories = items.map((item, itemIndex) => {
                hasUrl = hasUrl || item.url != null;
                return { id: preactItems[itemIndex].id, categories: item.categories || [] };
            });
            return [hasUrl, categories];
        }, [preactItems, items]);
        const { hiddenIds, highlightedIds, updateHighlighted } = (0, useVizCategories_1.useVizCategories)(categoriesItems, (item) => item.categories, hiddenCategories, highlightedCategories, 'any', highlightMatch, props.onHiddenCategoriesChanged, props.onHighlightedCategoriesChanged);
        const itemActionHandler = (detail) => {
            const item = idItemMap.get(detail.id);
            if (item?.url) {
                (0, utils_1.executeLink)(item.url);
            }
        };
        const selectionChangeHandler = (detail) => {
            props.onSelectionChanged?.(detail.ids);
        };
        const inputHandler = (detail) => {
            if (isHighlightOn)
                updateHighlighted(detail.id);
        };
        //corepack api isn't changed for now.
        const datatip = props.datatip != undefined
            ? (d) => {
                return {
                    content: props.datatip?.({ id: d.data.id }),
                    borderColor: undefined
                };
            }
            : undefined;
        const { preactContextMenuConfig } = (0, useVisContextMenu_1.useVisContextMenu)(idToDPItemMap, contextMenuConfig, onOjContextMenuAction, onOjContextMenuSelection);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, children: !data || items.length === 0 ? ((0, jsx_runtime_1.jsx)(UNSAFE_VisStatusMessage_1.VisNoData, { "aria-label": props['aria-label'], "aria-describedby": props['aria-describedby'], "aria-labelledby": props['aria-labelledby'] })) : ((0, jsx_runtime_1.jsx)(UNSAFE_TagCloud_1.TagCloud, { layout: layout, datatip: datatip, highlightedIds: isHighlightOn ? highlightedIds : undefined, accessibleLabel: props['aria-label'], "aria-describedBy": props['aria-describedby'], "aria-labelledBy": props['aria-labelledby'], items: preactItems.filter((i) => !hiddenIds?.includes(i.id)), selectionMode: selectionMode, onSelectionChange: selectionChangeHandler, onItemAction: hasUrl ? itemActionHandler : undefined, onItemFocus: inputHandler, onItemHover: inputHandler, selectedIds: selectionMode === 'none' ? undefined : selection, width: "100%", height: "100%", contextMenuConfig: contextMenuConfig ? preactContextMenuConfig : undefined })) }));
    }
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const TagCloudWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-tag-cloud', TagCloudComp, "TagCloud", { "properties": { "data": { "type": "DataProvider|null" }, "datatip": { "type": "function" }, "hiddenCategories": { "type": "Array<string>", "writeback": true }, "touchResponse": { "type": "string", "enumValues": ["auto", "touchStart"] }, "highlightMatch": { "type": "string", "enumValues": ["all", "any"] }, "highlightedCategories": { "type": "Array<string>", "writeback": true }, "hoverBehavior": { "type": "string", "enumValues": ["none", "dim"] }, "layout": { "type": "string", "enumValues": ["cloud", "rectangular"] }, "selectionMode": { "type": "string", "enumValues": ["none", "multiple", "single"] }, "selection": { "type": "Array<string|number>", "writeback": true }, "contextMenuConfig": { "type": "object", "properties": { "accessibleLabel": { "type": "string" }, "items": { "type": "function" } } } }, "slots": { "itemTemplate": { "data": {} } }, "events": { "ojContextMenuAction": { "bubbles": true }, "ojContextMenuSelection": { "bubbles": true } }, "extension": { "_WRITEBACK_PROPS": ["hiddenCategories", "highlightedCategories", "selection"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-describedby", "aria-labelledby"] } }, { "hiddenCategories": [], "data": null, "highlightedCategories": [], "hoverBehavior": "none", "layout": "rectangular", "selection": [], "selectionMode": "none", "highlightMatch": "all" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
    exports.TagCloud = TagCloudWithoutDefaultedGenerics;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/tag-cloud',["require", "exports", "oj-c/tag-cloud/tag-cloud"], function (require, exports, tag_cloud_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TagCloud = void 0;
    Object.defineProperty(exports, "TagCloud", { enumerable: true, get: function () { return tag_cloud_1.TagCloud; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/tag-cloud-item',["require", "exports", "oj-c/tag-cloud-item/tag-cloud-item"], function (require, exports, tag_cloud_item_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TagCloudItem = void 0;
    Object.defineProperty(exports, "TagCloudItem", { enumerable: true, get: function () { return tag_cloud_item_1.TagCloudItem; } });
});


define('oj-c/message-banner/message-banner',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_MessageBanner", "@oracle/oraclejet-preact/hooks/UNSAFE_useMessagesContext", "ojs/ojvcomponent", "preact/hooks", "../hooks/UNSAFE_useDataProvider/useDataProvider", "ojs/ojcontext", "css!oj-c/message-banner/message-banner-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_MessageBanner_1, UNSAFE_useMessagesContext_1, ojvcomponent_1, hooks_1, useDataProvider_1, Context) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageBanner = void 0;
    const severityOrder = {
        error: 0,
        warning: 1,
        info: 2,
        confirmation: 3,
        none: 4
    };
    const severityLevels = Object.keys(severityOrder).length;
    /**
     * Compares two message items and sort them based on the following order:
     * 1. Descending order of severity - error > warning > info > confirmation > none
     * 2. Then reverse chronological order based on timestamp property
     * 3. For same severity and same or missing timestamp, both items are treated as equal and the
     *    order will be determined by the order they appear in the original data.
     * @param param0 First message item to compare
     * @param param1 Second message item to compare
     * @returns The comparison result
     */
    const severitySort = ({ data: dataA }, { data: dataB }) => {
        // If severity is undefined, set to the highest value
        const severityA = dataA.severity ? severityOrder[dataA.severity] : severityLevels;
        const severityB = dataB.severity ? severityOrder[dataB.severity] : severityLevels;
        if (severityA !== severityB) {
            return severityA - severityB;
        }
        // If severity is the same, compare timestamp
        if (dataA.timestamp && dataB.timestamp) {
            const valueA = new Date(dataA.timestamp).valueOf();
            const valueB = new Date(dataB.timestamp).valueOf();
            return valueB - valueA;
        }
        // return 0 if severity is the same and timestamp(s) are missing
        return 0;
    };
    /**
     * @classdesc
     * <h3 id="bannerOverview-section">
     *   JET Message Banner
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#bannerOverview-section"></a>
     * </h3>
     * <p>Description:</p>
     * <p>Message banners are brief, moderately disruptive, semi-permanent messages that help communicate
     * relevant and useful information in the context of the current page or actions in progress,
     * without blocking the interaction on that page.</p>
     *
     * <h4 id="messages-syntax-section">
     *  Syntax
     *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#messages-syntax-section"></a>
     * </h4>
     * Message Banner can be created with the following markup.</p>
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-message-banner data="[[messages]]" type="page">
     * &lt;/oj-c-message-banner>
     * </code></pre>
     *
     * <p>The Message Banner component will show messages based on the data provided keeping it as a single
     * source of truth. Applications should register a listener for the ojClose event to be notified
     * when one performs an action that requires a message to be closed. The application then should use the
     * event payload to identify and remove the corresponding row from the data which would then close the
     * message.</p>
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-message-banner data="[[messages]]" type="page" on-oj-close="[[handleClose]]">
     * &lt;/oj-c-message-banner>
     * </code></pre>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>The <code class="prettyprint">MessageBannerItem["sound"]</code> property is an accessibility
     * feature for playing a sound when a message is opened. This property defaults to "none", and can
     * be enabled by setting it to "default" or by providing a URL to an audio file of a format that the
     * browser supports. An accessible application must provide a way for users to enable sound on a
     * settings or preferences page. Some browsers will have auto-play disabled by default, enabling
     * it may require adjusting the browser settings.</p>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="4">Focus within Messages</td>
     *       <td><kbd>Tab</kbd> or <kbd>Shift + Tab</kbd></td>
     *       <td>Navigate the content of the messages region.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>F6</kbd></td>
     *       <td>Cycles the focus through all the messages sections on the page starting from the most recent one.
     *           Then finally, moves the focus back to the last focused element outside the messages region.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Moves focus back to the last focused element outside the messages region and closes the current message if it is closable.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Activates the currently focused element in the message.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan = "1">Focus outside Messages</td>
     *       <td><kbd>F6</kbd></td>
     *       <td>Move focus to the first message within the more recently disclosed messages region.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="data-attributes-section">
     *   Custom Data Attributes
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-attributes-section"></a>
     * </h3>
     *
     * <p>MessageBanner supports the following custom data attributes.
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Name</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>data-oj-as</kbd></td>
     *       <td><p>Provides an alias for a specific template instance and has the same subproperties as the $current variable.</p>
     *         <pre class="prettyprint"><code>&lt;oj-c-message-banner
     *   data="[[messages]]"
     *   type="page"
     *   detail-template-value="detailText">
     *   &lt;!-- Template for rendering custom detail text -->
     *   &lt;template slot="detailText" data-oj-as="message">
     *     &lt;!-- The detail text -->
     *     &lt;div>
     *       &lt;span>&lt;oj-bind-text value="[[message.data.detail]]">&lt;/oj-bind-text>&lt;/span>
     *     &lt;/div>
     *   &lt;/template>
     * &lt;/oj-c-message-banner></code></pre>
     *       </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @typeparam K Type of key of the dataprovider. It can either be a string or a number.
     * @typeparam D Type of the data from the dataprovider. It must extend the MessageBannerItem type.
     * @ojmetadata description "Message Banners are brief, moderately disruptive, semi-permanent messages that help communicate relevant and useful information."
     * @ojmetadata displayName "Message Banner"
     * @ojmetadata main "oj-c/message-banner"
     * @ojmetadata help "oj-c.MessageBanner.html"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-message-banner",
     *     "uxSpecs": ["bannerMessages"]
     *   },
     *   "vbdt": {
     *     "defaultColumns": 2,
     *     "minColumns": 1,
     *     "module": "oj-c/message-banner"
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "type"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data"
     *     ]
     *   }
     * ]
     * @ojmetadata since "16.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-messages", "oj-message-banner"]
     *   }
     * ]
     */
    function MessageBannerImpl({ data, detailTemplateValue, messageTemplates, type = 'section', sorting = 'severity', onOjClose }) {
        const prevData = (0, hooks_1.useRef)(data);
        const rootRef = (0, hooks_1.useRef)();
        const [dpKey, setDpKey] = (0, hooks_1.useState)(0);
        const addBusyState = (0, hooks_1.useCallback)((description = 'MessageBanner: busyState') => {
            // if the component is not mounted, return a noop
            return rootRef.current
                ? Context.getContext(rootRef.current).getBusyContext().addBusyState({ description })
                : () => { };
        }, []);
        const messagesContext = (0, hooks_1.useMemo)(() => ({ addBusyState }), [addBusyState]);
        if (data != prevData.current) {
            setDpKey((dpKey) => dpKey + 1);
            prevData.current = data;
        }
        const { data: dataArr } = (0, useDataProvider_1.useDataProvider)({
            data,
            addBusyState
        });
        // Sort the data based on the 'sorting' property
        const sortedData = (0, hooks_1.useMemo)(() => {
            // if sorting is off, return the original array
            if (sorting === 'off')
                return dataArr;
            const dataCopy = [...dataArr];
            // sort based on severity as this is the only other supported value
            return dataCopy.sort(severitySort);
        }, [dataArr, sorting]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, children: (0, jsx_runtime_1.jsx)(UNSAFE_useMessagesContext_1.MessagesContext.Provider, { value: messagesContext, children: (0, jsx_runtime_1.jsx)(UNSAFE_MessageBanner_1.MessageBanner
                // we need to completely rerender the component when the DP is changed
                // as that they message keys in the data array will not hold the same meaning.
                , { data: sortedData, detailRendererKey: detailTemplateValue, renderers: messageTemplates, variant: type, onClose: onOjClose }, `dp-${dpKey}`) }) }));
    }
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const MessageBannerWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-message-banner', MessageBannerImpl, "MessageBanner", { "properties": { "data": { "type": "DataProvider" }, "type": { "type": "string", "enumValues": ["page", "section"] }, "detailTemplateValue": { "type": "string|function" }, "sorting": { "type": "string", "enumValues": ["off", "severity"] } }, "extension": { "_DYNAMIC_SLOT": { "prop": "messageTemplates", "isTemplate": 1 } }, "events": { "ojClose": {} } }, { "type": "section", "sorting": "severity" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
    exports.MessageBanner = MessageBannerWithoutDefaultedGenerics;
});

define('oj-c/message-banner',["require", "exports", "oj-c/message-banner/message-banner"], function (require, exports, message_banner_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessageBanner = void 0;
    Object.defineProperty(exports, "MessageBanner", { enumerable: true, get: function () { return message_banner_1.MessageBanner; } });
});


var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
define('oj-c/action-card/action-card',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_ActionCard", "preact", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "css!oj-c/action-card/action-card-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_ActionCard_1, preact_1, ojvcomponent_1, compat_1, hooks_1, UNSAFE_useTabbableMode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionCard = void 0;
    /**
     * @classdesc
     * <h3 id="ActionCardOverview-section">
     *   JET Action
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#CardOverview-section"></a>
     * </h3>
     * <p>Description: Themeable, WAI-ARIA-compliant element that represents a card.</p>
     * <p>Action Card provides a styled rectangular area with hover/focus/active state rendering,
     * along with an ojAction event.
     *
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-action-card onAction="[[actionHandler]]">
     *   Sample Text
     * &lt;/oj-c-action-card>
     *
     * </code></pre>
     *
     * <h3 id="diff-section">
     *   Differences between Cards in JET
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#diff-section"></a>
     * </h3>
     *
     * <p>
     * There are several different options for creating cards in JET applications.
     * </p>
     * <ul>
     * <li><strong>oj-c-action-card:</strong> ActionCard fires action events and is supported for use stand alone or in oj-c-card-view. For accessibility reasons nothing interactive (for example links or buttons) can be put in an action card.</li>
     * <li><strong>oj-c-selection-card:</strong> SelectionCard is supported for use in oj-c-card-view, with single or multiple selection.</li>
     * <li><strong>oj-panel CSS class:</strong> For simple cases with no associated action or selection. Panel is supported for use in standalone or in oj-c-card-view.</li>
     * </ul>
     *
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>A clarification in a11y rules states that any element with role of ActionCard should not have interactive elements inside: https://www.w3.org/TR/html-aria/#allowed-descendants-of-aria-roles </p>
     *
     * @ojmetadata description "An Action Card is an actionable container rendering related information"
     * @ojmetadata displayName "Action Card"
     * @ojmetadata help "oj-c.ActionCard.html"
     * @ojmetadata main "oj-c/action-card"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Layout & Nav"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-object-card",
     *     "uxSpecs": ["card"]
     *   },
     *   "vbdt": {
     *     "module": "oj-c/action-card",
     *     "defaultColumns": 1,
     *     "minColumns": 1
     *   }
     * }
     * @ojmetadata since "16.0.0"
     */
    let ActionCard = class ActionCard extends preact_1.Component {
        constructor() {
            super(...arguments);
            this.actionCardRef = (0, preact_1.createRef)();
        }
        render({ children, onOjAction }) {
            return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(FunctionalActionCard, { ref: this.actionCardRef, onAction: onOjAction, width: "100%", height: "100%", children: children }) }));
        }
        /**
         * blurs the card
         * @ignore
         */
        click() {
            this.actionCardRef.current?.click();
        }
        /**
         * blurs the card
         * @ignore
         */
        blur() {
            this.actionCardRef.current?.blur();
        }
        /**
         * focuses the card
         * @ignore
         */
        focus() {
            this.actionCardRef.current?.focus();
        }
    };
    exports.ActionCard = ActionCard;
    ActionCard._metadata = { "slots": { "": {} }, "events": { "ojAction": { "bubbles": true } }, "methods": { "click": {}, "blur": {}, "focus": {} } };
    ActionCard._translationBundleMap = {
        '@oracle/oraclejet-preact': translationBundle_1.default
    };
    ActionCard._consumedContexts = [UNSAFE_useTabbableMode_1.TabbableModeContext];
    exports.ActionCard = ActionCard = __decorate([
        (0, ojvcomponent_1.customElement)('oj-c-action-card')
    ], ActionCard);
    const FunctionalActionCard = (0, compat_1.forwardRef)((props, ref) => {
        const actionCardRef = (0, hooks_1.useRef)();
        // We need to support methods on the custom-element layer which can only
        // be done using a class-based component. So, we will wrap this
        // functionality-packed functional component in a class-based component.
        // But, the class-based component will still need a way to pass through
        // method calls, so we will be using useImperativeHandle to add these
        // methods to this functional component's ref which can then be called
        // by the wrapping class-based component.
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            focus: () => actionCardRef.current?.focus(),
            blur: () => actionCardRef.current?.blur(),
            click: () => actionCardRef.current?.click()
        }), []);
        return (0, jsx_runtime_1.jsx)(UNSAFE_ActionCard_1.ActionCard, { ref: actionCardRef, ...props });
    });
});

define('oj-c/action-card',["require", "exports", "oj-c/action-card/action-card"], function (require, exports, action_card_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionCard = void 0;
    Object.defineProperty(exports, "ActionCard", { enumerable: true, get: function () { return action_card_1.ActionCard; } });
});


define('oj-c/selection-card/selection-card',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_SelectionCard", "ojs/ojvcomponent", "css!oj-c/selection-card/selection-card-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_SelectionCard_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionCard = void 0;
    exports.SelectionCard = (0, ojvcomponent_1.registerCustomElement)('oj-c-selection-card', 
    /**
     * @classdesc
     * <h3 id="SelectionCardOverview-section">
     *   JET Selection
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#SelectionCardOverview-section"></a>
     * </h3>
     * <p>Description: Themeable, WAI-ARIA-compliant element that represents a card.</p>
     * <p>Selection Card provides a styled rectangular area for use in collections.
     *
     *
     * <pre class="prettyprint">
     * <code>
     *&lt;oj-c-selection-card" selected="[[isSelected]]">
     *   Sample Text
     * &lt;/oj-c-selection-card>
     *
     *</code></pre>
     *
     * <h3 id="diff-section">
     *   Differences between Cards in JET
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#diff-section"></a>
     * </h3>
     *
     * <p>
     * There are several different options for creating cards in JET applications.
     * </p>
     * <ul>
     * <li><strong>oj-c-action-card:</strong> ActionCard fires action events and is supported for use stand alone or in oj-c-card-view. For accessibility reasons nothing interactive (for example links or buttons) can be put in an action card.</li>
     * <li><strong>oj-c-selection-card:</strong> SelectionCard is supported for use in oj-c-card-view, with single or multiple selection.</li>
     * <li><strong>oj-panel CSS class:</strong> For simple cases with no associated action or selection. Panel is supported for use in standalone or in oj-c-card-view.</li>
     * </ul>
     *
     *
     * @ojmetadata description "A Selection Card is a container that can be set as selected with a collection"
     * @ojmetadata displayName "Selection Card"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "19.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Collections"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-object-card",
     *     "uxSpecs": ["card"]
     *   },
     *   "vbdt": {
     *     "module": "oj-c/selection-card",
     *     "defaultColumns": 1,
     *     "minColumns": 1
     *   }
     * }
     * @ojmetadata since "16.0.0"
     */
    ({ children, selected }) => {
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_SelectionCard_1.SelectionCard, { isSelected: selected, width: "100%", height: "100%", children: children }) }));
    }, "SelectionCard", { "slots": { "": {} }, "properties": { "selected": { "type": "boolean" } } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/selection-card',["require", "exports", "oj-c/selection-card/selection-card"], function (require, exports, selection_card_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionCard = void 0;
    Object.defineProperty(exports, "SelectionCard", { enumerable: true, get: function () { return selection_card_1.SelectionCard; } });
});


define('oj-c/popup/popup',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "preact/hooks", "@oracle/oraclejet-preact/UNSAFE_Popup", "@oracle/oraclejet-preact/UNSAFE_Layer", "ojs/ojcontext", "css!oj-c/popup/popup-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, hooks_1, UNSAFE_Popup_1, UNSAFE_Layer_1, Context) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Popup = void 0;
    const LAYER_CONTENT = Symbol.for('__oj_c_layer_content');
    exports.Popup = (0, ojvcomponent_1.registerCustomElement)('oj-c-popup', 
    /**
     * @classdesc
     * <h3 id="popupOverview-section">
     *   JET Popup
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#popupOverview-section"></a>
     * </h3>
     * <p>Description: A popup temporarily 'pops up' content in the foreground.</p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-popup>
     *    Popup content
     * &lt;/oj-c-popup>
     *
     * &lt;oj-c-popup opened="true">
     *    Opened Popup
     * &lt;/oj-c-popup>
     *
     * &lt;oj-c-popup placement="bottom">
     *    Popup positioned at the bottom of the anchor
     * &lt;/oj-c-popup>
     *
     * Main section content
     * </code></pre>
     *
     * <p id="popup-section">A popup temporarily 'pops up' content in the foreground.</p>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     * <table class="keyboard-table">
     *  <thead>
     *    <tr>
     *      <th>Target</th>
     *      <th>Key</th>
     *      <th>Action</th>
     *    </tr>
     *  </thead>
     *  <tbody>
     *    <tr>
     *       <td rowspan = "3">Focus within Popup</td>
     *       <td><kbd>Tab</kbd> or <kbd>Shift + Tab</kbd></td>
     *       <td>Navigate the content of the popup.</td>
     *    </tr>
     *    <tr>
     *      <td><kbd>F6</kbd></td>
     *      <td>Move focus to the launcher for a popup with modeless modality.</td>
     *    </tr>
     *    <tr>
     *      <td><kbd>Esc</kbd></td>
     *      <td>Close the open popup.</td>
     *    </tr>
     *    <tr>
     *      <td rowspan = "1">Popup Launcher</td>
     *      <td><kbd>F6</kbd></td>
     *      <td>Move focus to the first tab stop within the open popup. If there is not a tab stop
     *          within the content, focus is established on the popup.</td>
     *     </tr>
     *  </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>For WAI-ARIA compliance, JET automatically adds
     * <code class="prettyprint">role="dialog"</code> to the popup root dom element, if not
     * already specificed. This is not a component property but rather the standard html
     * <a href="https://www.w3.org/WAI/PF/aria/roles">role</a> attribute. Depending on how the
     * popup is used in the page, the page developer should choose from the following:
     * <ul>
     *   <li>"tooltip" defines contextual popup that displays a description for an element.
     *       It should only be used for popups that include simple textual content and no interactive
     *       elements. The "tooltip" role should never be used with modal popups.</li>
     *   <li>"dialog" defines an application window that is designed to interrupt the current
     *       processing of an application in order to prompt the user to enter information or
     *       require a response. It is the default role for popups.</li>
     *   <li>"alertdialog" defines type of popup that contains an alert message, where initial focus
     *       goes to an element within the popup.</li>
     * </ul>
     * </p>
     * <p>
     *  The page developer should consider adding the aria-haspopup="dialog" to the launcher element.
     * </p>
     * <p>
     * Depending on the aria role and popup content, the page developer may also need to
     * set the <code class="prettyprint">aria-labelledby</code> and (optionally)
     * <code class="prettyprint">aria-describedby</code> attributes on the oj-popup
     * element in order to make the popup and its content accessible.
     * </p>
     *
     * <p>One point often overlooked is making the gestures that launch a popup accessible.
     *   There are no constraints to what events a page developer might choose to trigger opening a
     *   popup.  The choice should be accessible for screen reader users.  Page
     *   developers should take care when using mouse events to trigger opening of a popup.
     *   This is especially important if the content of the popup can't be derived from other
     *   visible areas on the page. In cases that mouseover, mouseout, mouseenter, mouseleave and
     *   hover events are used to launch popups, there needs to be a keyboard functional equivalency.
     * </p>
     *
     * <h3 id="reparenting-section">
     *   Reparenting
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#reparenting-section"></a>
     * </h3>
     * <p id="reparenting-strategy">
     *    When popups are open, they will be reparented in the document and reparented back when
     *    closed. When open, the location of the popup within the document will be in context of
     *    how it's used. Popups open from other popups will be relocated in the document into the
     *    nearest parent popup's layer. The popups layer defines its z-index weight "stacking
     *    context".  The ojPopup's layer is marked with the "oj-popup-layer" style.
     *    The context of opening is defined by the launcher argument passed to the open method.  If
     *    not open from another popup, the popup will be reparented to a container in the document
     *    body. Popups of the same type are assigned the same z-index values.  The layering between
     *    peer popups reflect the opening order.
     * </p>
     * <p>
     *     There are known caveats with this design. However, these scenarios are considered "bad use"
     *     based on our JET popup strategy.
     *  </p>
     *  <ol>
     *    <li>Events raised within the popup will not bubble up to the popup's original ancestors.
     *        Instead, listeners for popup events should be applied to either the popup's root
     *        element, or the document.</li>
     *    <li>Likewise, developers should not use CSS descendant selectors, or similar logic, that
     *        assumes that the popup will remain a child of its original parent.</li>
     *    <li>Popups containing iframes are problematic.  The iframe elements "may" fire a HTTP GET
     *        request for its src attribute each time the iframe is reparented in the document.</li>
     *    <li>If an iframe is added to the popup's content, it must not be the first or last tab stop
     *        within the popup or keyboard and VoiceOver navigation will not remain within the popup.</li>
     *    <li>In some browsers, reparenting a popup that contains elements having overflow, will cause
     *        these overflow elements to reset their scrollTop.</li>
     *  </ol>
     *
     * <h3 id="eventHandling-section">
     *   Event Handling
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#eventHandling-section"></a>
     * </h3>
     * <ul>
     *  <li>ojBeforeClose(event) - Triggered before a popup closes. Event can prevent closing the
     *      popup; However, there are cases the framework must veto, such as when the popup is
     *      destroyed.</li>
     *  <li>ojClose(event) - Triggered after the popup has closed.</li>
     *  <li>ojFocus(event) - Triggered when initial focus is established on opening, depending on
     *      the value of the initalFocus property, or <kbd>F6</kbd> focus toggle from the associated
     *      launcher.</li>
     *  <li>ojOpen(event) - Triggered after the popup has been made visible.</li>
     * </ul>
     *
     * <h3 id="rtl-section">
     *   Reading direction
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
     * </h3>
     *
     * <p> Setting the reading direction (LTR or RTL) is supported by setting the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> element of the page. As with any JET component, in the unusual case that the reading direction
     * is changed post-init, the page must be reloaded.
     *
     * @ojmetadata description 'A popup temporarily 'pops up' content in the foreground.'
     * @ojmetadata displayName 'Popup'
     * @ojmetadata help 'oj-c.Popup.html'
     * @ojmetadata main 'oj-c/popup'
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "19.0.0",
     *     "value": ["oj-popup"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Layout & Nav"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/popup"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-popup",
     *     "uxSpecs": [
     *       "popup"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "opened",
     *       "anchor",
     *       "launcher",
     *       "placement",
     *       "collision",
     *       "modality",
     *       "offset",
     *       "initialFocus",
     *       "autoDismiss",
     *       "tail",
     *       "onOpenedChanged",
     *       "onOjOpen",
     *       "onOjBeforeClose",
     *       "onOjClose",
     *       "onOjFocus",
     *       "width",
     *       "minWidth",
     *       "maxWidth",
     *       "height",
     *       "minHeight",
     *       "maxHeight"
     *     ]
     *   }
     * ]
     * @ojmetadata since "17.0.0"
     */
    ({ id, opened = false, children, anchor, launcher, placement, collision = 'fit', modality = 'modeless', offset, initialFocus = 'auto', autoDismiss = 'focusLoss', tail = 'none', variant = 'standard', onOpenedChanged, onOjOpen, onOjBeforeClose, onOjClose, onOjFocus, width, minWidth, maxWidth = 'calc(100vw - 3rem)', height, minHeight, maxHeight = 'calc(100vh - 3rem)', ...otherProps }) => {
        const rootRef = (0, hooks_1.useRef)(null);
        let defaultPlacement = placement;
        const anchorRef = (0, hooks_1.useRef)(null);
        const launcherRef = (0, hooks_1.useRef)(null);
        const resolveBusyState = (0, hooks_1.useRef)();
        const didMountRef = (0, hooks_1.useRef)(false);
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-popup id='${id}' is ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const preactRef = (0, hooks_1.useCallback)((elem) => {
            if (rootRef.current) {
                if (elem) {
                    const layerElem = elem;
                    layerElem[UNSAFE_Layer_1.LOGICAL_PARENT] = rootRef.current;
                    rootRef.current[LAYER_CONTENT] = elem;
                }
                else {
                    if (rootRef.current[LAYER_CONTENT]) {
                        const layerElem = rootRef.current[LAYER_CONTENT];
                        delete layerElem[UNSAFE_Layer_1.LOGICAL_PARENT];
                        delete rootRef.current[LAYER_CONTENT];
                    }
                }
            }
        }, []);
        (0, hooks_1.useEffect)(() => {
            return () => {
                // Resolve current busy state on unmount
                if (resolveBusyState.current) {
                    resolveBusyState.current();
                }
            };
        }, []);
        (0, hooks_1.useEffect)(() => {
            // The busy state is not added on the first render, but on each subsequent toggle
            if (!didMountRef.current) {
                didMountRef.current = true;
                return;
            }
            // Resolve current busy state is transition is already in progress
            if (resolveBusyState.current) {
                resolveBusyState.current();
            }
            resolveBusyState.current = addBusyState('animating');
        }, [opened, addBusyState]);
        // Resolve launcher to pass launcherRef to Preact Popup.
        // As anchor defaults to launcher in some cases, we resolve launcher first.
        // In legacy, there's no launcher attribute. There's open() method that supports
        // launcher parameter, which can be of type 'string | Element'.
        // Hence, the launcher attribute is designed similarly
        // In theory, launcher can remain undefined (launcherRef.current === undefined).
        // This corner case is handled in Preact Popup.
        let localLauncher;
        if (typeof launcher === 'string') {
            const launcherEl = document.querySelector(launcher);
            if (launcherEl) {
                localLauncher = launcherEl;
            }
        }
        else if (launcher instanceof HTMLElement) {
            if (document.body.contains(launcher)) {
                localLauncher = launcher;
            }
        }
        else {
            localLauncher = document.activeElement;
        }
        const isObject = (value) => {
            return typeof value === 'object' && !Array.isArray(value) && value !== null;
        };
        // Resolve anchor to pass anchorRef to Preact Popup.
        // Similarly to launcher (see above) we allow 'string | Element' for anchor here.
        // In theory, anchor can remain undefined (anchorRef.current === undefined). This corner
        // case should be handled in Preact Popup.
        //
        // Note:
        // Core Popup: if anchor is not defined, we default to launcher to match legacy popup
        // Preact Popup: if anchorRef || anchorRef.current is not defined, it defaults to 'window'
        let localAnchor;
        if (!anchor) {
            localAnchor = localLauncher;
        }
        else if (anchor instanceof Window || anchor === 'window') {
            localAnchor = 'window';
        }
        else if (typeof anchor === 'string') {
            // 2a. Custom anchor (string)
            const queriedAnchor = document.querySelector(anchor);
            localAnchor = queriedAnchor || localLauncher;
        }
        else if (anchor instanceof Element) {
            // 2b. Custom anchor (Element) or default to 'launcher'
            localAnchor = document.body.contains(anchor) ? anchor : localLauncher;
        }
        else if (isObject(anchor)) {
            if (typeof anchor.x === 'number' && typeof anchor.y === 'number') {
                // Coord type, (unlike Offset, x and y are mandatory in Coord)
                localAnchor = anchor;
            }
            else {
                localAnchor = localLauncher;
            }
        }
        if (!placement) {
            if (localAnchor === 'window') {
                defaultPlacement = 'center';
            }
            else {
                defaultPlacement = 'bottom-start';
            }
        }
        // To allow collision handling
        const flipOptions = { mainAxis: true, crossAxis: true };
        const shiftOptions = { mainAxis: false, crossAxis: false };
        switch (collision) {
            case 'none': {
                flipOptions.mainAxis = false;
                flipOptions.crossAxis = false;
                break;
            }
            case 'fit': {
                flipOptions.mainAxis = false;
                flipOptions.crossAxis = false;
                shiftOptions.mainAxis = true;
                shiftOptions.crossAxis = true;
                break;
            }
            case 'flipcenter':
            case 'flipfit': {
                shiftOptions.mainAxis = true;
                shiftOptions.crossAxis = true;
                break;
            }
            // Flip is collision default
            default:
            case 'flip': {
                break;
            }
        }
        const isMainAxisVertical = (placement) => {
            return ['top', 'bottom'].indexOf(placement.split('-')[0]) > -1;
        };
        const verticalMainAxis = placement ? isMainAxisVertical(placement) : true;
        const preactOffset = {};
        if (offset) {
            if (verticalMainAxis) {
                if (offset.y) {
                    preactOffset.mainAxis = offset.y;
                }
                if (offset.x) {
                    preactOffset.crossAxis = offset.x;
                }
            }
            else {
                if (offset.x) {
                    preactOffset.mainAxis = offset.x;
                }
                if (offset.y) {
                    preactOffset.crossAxis = offset.y;
                }
            }
        }
        const handleOnClickOutside = async () => {
            // Closing with outside click
            if (autoDismiss === 'focusLoss') {
                return dispatchBeforeClose({ reason: 'outsideClick' });
            }
        };
        const handleOnClose = async (detail) => {
            // Closing with ESC
            if (detail.reason === 'escapeKey') {
                return dispatchBeforeClose(detail);
            }
            // Closing with Close SkipLink
            if (detail.reason === 'closeSkipLink') {
                onOpenedChanged?.(false);
            }
        };
        const dispatchBeforeClose = async (detail) => {
            // Allow veto by triggering onOjBeforeClose.
            // AutoDismiss controls closing using an outside click.
            // Closing with ESC key can be vetoed but no property control is available
            // This setting matches legacy Popup
            try {
                // Cancelable ojBeforeClose event
                await onOjBeforeClose?.(detail);
                onOpenedChanged?.(false);
            }
            catch (_) {
                // Closing was canceled so short circuit out here
            }
        };
        const handleOnTransitionEnd = async (value) => {
            // Resolve and reset busy state
            if (resolveBusyState.current) {
                resolveBusyState.current();
                resolveBusyState.current = undefined;
            }
            if (value) {
                // Popup's opening gets finished
                onOjOpen?.();
            }
            else {
                // Popup's closing gets finished
                onOjClose?.();
            }
        };
        const handleOnFocus = () => {
            onOjFocus?.();
        };
        // Set refs for Pract API
        anchorRef.current = localAnchor;
        launcherRef.current = localLauncher;
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, id: id, children: (0, jsx_runtime_1.jsx)(UNSAFE_Popup_1.Popup, { ref: preactRef, isOpen: opened, anchorRef: anchorRef.current === 'window' ? undefined : anchorRef, launcherRef: launcherRef, placement: placement ?? defaultPlacement, offset: offset ? preactOffset : undefined, flipOptions: flipOptions, shiftOptions: shiftOptions, modality: modality, initialFocus: initialFocus, tail: tail, variant: variant, onClose: handleOnClose, onClickOutside: handleOnClickOutside, onTransitionEnd: handleOnTransitionEnd, onFocusSet: handleOnFocus, width: width, minWidth: minWidth, maxWidth: maxWidth, height: height, minHeight: minHeight, maxHeight: maxHeight, role: otherProps['role'], backgroundColor: otherProps.backgroundColor, "aria-describedby": otherProps['aria-describedby'], "aria-label": otherProps['aria-label'], "aria-labelledby": otherProps['aria-labelledby'], children: children }) }));
    }, "Popup", { "slots": { "": {} }, "properties": { "opened": { "type": "boolean", "writeback": true }, "launcher": { "type": "string|Element" }, "anchor": { "type": "string|Element|object" }, "placement": { "type": "string", "enumValues": ["center", "end", "start", "top", "bottom", "top-start", "top-end", "top-start-corner", "top-end-corner", "start-top", "start-bottom", "start-top-corner", "start-bottom-corner", "bottom-start", "bottom-end", "bottom-start-corner", "bottom-end-corner", "end-top", "end-bottom", "end-top-corner", "end-bottom-corner"] }, "modality": { "type": "string", "enumValues": ["modal", "modeless"] }, "autoDismiss": { "type": "string", "enumValues": ["none", "focusLoss"] }, "tail": { "type": "string", "enumValues": ["none", "simple"] }, "variant": { "type": "string", "enumValues": ["standard", "unstyled"] }, "initialFocus": { "type": "string", "enumValues": ["auto", "none", "popup", "firstFocusable"] }, "offset": { "type": "object", "properties": { "x": { "type": "number" }, "y": { "type": "number" } } }, "collision": { "type": "string", "enumValues": ["none", "flip", "fit", "flipfit", "flipcenter"] }, "width": { "type": "number|string" }, "minWidth": { "type": "number|string" }, "maxWidth": { "type": "number|string" }, "height": { "type": "number|string" }, "minHeight": { "type": "number|string" }, "maxHeight": { "type": "number|string" }, "backgroundColor": { "type": "string" } }, "events": { "ojOpen": {}, "ojBeforeClose": { "cancelable": true }, "ojClose": {}, "ojFocus": {} }, "extension": { "_WRITEBACK_PROPS": ["opened"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "aria-label", "aria-labelledby", "id", "role"] } }, { "opened": false, "collision": "fit", "modality": "modeless", "initialFocus": "auto", "autoDismiss": "focusLoss", "tail": "none", "variant": "standard", "maxWidth": "calc(100vw - 3rem)", "maxHeight": "calc(100vh - 3rem)" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/popup',["require", "exports", "oj-c/popup/popup"], function (require, exports, popup_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Popup = void 0;
    Object.defineProperty(exports, "Popup", { enumerable: true, get: function () { return popup_1.Popup; } });
});
/*
declare global {
namespace preact.JSX {
      interface IntrinsicElements {
      'oj-c-popup': any;
      }
    }
  }
*/
;

define('oj-c/drawer-popup/drawer-popup',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_DrawerPopup", "ojs/ojvcomponent", "preact/hooks", "@oracle/oraclejet-preact/UNSAFE_Layer", "ojs/ojcontext", "css!oj-c/drawer-popup/drawer-popup-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_DrawerPopup_1, ojvcomponent_1, hooks_1, UNSAFE_Layer_1, Context) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DrawerPopup = void 0;
    const LAYER_CONTENT = Symbol.for('__oj_c_layer_content');
    exports.DrawerPopup = (0, ojvcomponent_1.registerCustomElement)('oj-c-drawer-popup', 
    /**
     * @classdesc
     * <h3 id="drawerPopupOverview-section">
     *   JET Drawer Popup
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#drawerPopupOverview-section"></a>
     * </h3>
     * <p>Description: Drawer Popup adds a single slide-in side content alongside some primary content to an application window. It can be placed at 'start', 'end' or 'bottom' edge and it always overlays the page.</p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-drawer-popup>
     *    Start drawer content
     * &lt;/oj-c-drawer-popup>
     *
     * &lt;oj-c-drawer-popup edge="end" opened="true">
     *    End drawer content
     * &lt;/oj-c-drawer-popup>
     *
     * &lt;oj-c-drawer-popup edge="bottom">
     *    Bottom drawer content
     * &lt;/oj-c-drawer-popup>
     *
     * Main section content
     * </code></pre>
     *
     * <p id="drawer-popup-layout-section">JET Drawer Popup and Drawer Layout look similar, but are intended to be used
     * for different purposes.</p>
     * <p>Use Drawer Popup</p>
     * <ul>
     *   <li>If you need to display overlay drawers attached to the edge of the viewport that stretch over the full viewport height or width.</li>
     *   <li>If you need modality.</li>
     * </ul>
     * <p>Use Drawer Layout</p>
     * <ul>
     *   <li>If you need to switch between the reflow display mode (big screens) and overlay (small screens).</li>
     *   <li>If the drawer should only fill a specific part of the viewport rather than take its full height (start/end) or full width (bottom).</li>
     *   <li>If modality is not required.</li>
     * </ul>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     * <table class="keyboard-table">
     *  <thead>
     *    <tr>
     *      <th>Target</th>
     *      <th>Key</th>
     *      <th>Action</th>
     *    </tr>
     *  </thead>
     *  <tbody>
     *    <tr>
     *      <td>Drawer element</td>
     *      <td><kbd>Esc</kbd></td>
     *      <td>Close the drawer</td>
     *    </tr>
     *  </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <h4>role</h4>
     * <p>Drawer Popup always has the 'dialog' role.</p>
     *
     * <p>However, adding <code class="prettyprint">role="dialog"</code> alone is not sufficient to make a drawer accessible.
     * It must be properly labeled. It is developers responsibility to define respective aria properties to meet accessibility requirements.</p>
     *
     * <h4>aria-labelledby, aria-label</h4>
     * If a drawer already has a visible title bar, the text inside that bar can be used to label the dialog itself.
     * Set the value of the <code class="prettyprint">aria-labelledby</code> attribute to be the id of the element used to title the drawer.
     * If there isn't appropriate text visible in the DOM that could be referenced with <code class="prettyprint">aria-labelledby</code>
     * use the <code class="prettyprint">aria-label</code> attribute to define the accessible name of an element.
     *
     * <h4>aria-describedby</h4>
     * If the drawer contains additional descriptive text besides the drawer title,
     * this text can be associated with the drawer using the <code class="prettyprint">aria-describedby</code> attribute.
     *
     * <h3 id="rtl-section">
     *   Reading direction
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
     * </h3>
     *
     * <p> Setting the reading direction (LTR or RTL) is supported by setting the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> element of the page. As with any JET component, in the unusual case that the reading direction
     * is changed post-init, the page must be reloaded.</p>
     *
     * <h3 id="sizing">
     *   Sizing
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sizing"></a>
     * </h3>
     *
     * <p>Side drawers always stretch to viewport's height and the bottom one to its width.
     * The other axis dimension is not predefined. This dimension's size is determined by its content.
     * If you want to set a custom size you can use units like px, rem, etc.
     * However because there is no fixed-size parent percentages (%) wont work,
     * but you can use vw (viewport width) or vh (viewport height) units to achieve a similar effect.</p>
     * <ul>
     *   <li>Note the built-in minimal and maximal width of side drawers.</li>
     *   <li>Note that DrawerPopup animates opening and closing. However, it is app developer's responsibility to add animations for custom runtime changes to a drawer size. See the 'Sizing' cookbook demo for an example.</li>
     * </ul>
     *
     * @ojmetadata description 'A Drawer Popup is a panel that slides into the viewport.'
     * @ojmetadata displayName 'Drawer Popup'
     * @ojmetadata help 'oj-c.DrawerPopup.html'
     * @ojmetadata main 'oj-c/drawer-popup'
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "17.0.0",
     *     "value": ["oj-drawer-popup"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Layout & Nav"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/drawer-popup",
     *     "pi": {
     *       "layouts": {
     *         "general": {
     *           "customizers": [
     *             {
     *               "propertyName": "closeGesture",
     *               "type": "enumeration"
     *             },
     *             {
     *               "propertyName": "autoDismiss",
     *               "type": "enumeration"
     *             },
     *             {
     *               "propertyName": "edge",
     *               "type": "enumeration"
     *             },
     *             {
     *               "propertyName": "modality",
     *               "type": "enumeration"
     *             },
     *             {
     *               "propertyName": "opened"
     *             }
     *           ]
     *         }
     *       }
     *     }
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-drawer",
     *     "uxSpecs": [
     *       "drawer"
     *     ]
     *   }
     * }
     * @ojmetadata since "16.0.0"
     */
    ({ id, children, opened = false, edge = 'start', modality = 'modal', autoDismiss = 'focus-loss', closeGesture = 'swipe', onOjBeforeClose, onOjClose, onOpenedChanged, backgroundColor, ...otherProps }) => {
        const rootRef = (0, hooks_1.useRef)(null);
        const resolveBusyState = (0, hooks_1.useRef)();
        const didMountRef = (0, hooks_1.useRef)(false);
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-drawer-popup id='${id}' is ${desc}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const preactRef = (0, hooks_1.useCallback)((elem) => {
            if (rootRef.current) {
                if (elem) {
                    const layerElem = elem;
                    layerElem[UNSAFE_Layer_1.LOGICAL_PARENT] = rootRef.current;
                    rootRef.current[LAYER_CONTENT] = elem;
                }
                else {
                    if (rootRef.current[LAYER_CONTENT]) {
                        const layerElem = rootRef.current[LAYER_CONTENT];
                        delete layerElem[UNSAFE_Layer_1.LOGICAL_PARENT];
                        delete rootRef.current[LAYER_CONTENT];
                    }
                }
            }
        }, []);
        (0, hooks_1.useEffect)(() => {
            return () => {
                // Resolve current busy state on unmount
                if (resolveBusyState.current) {
                    resolveBusyState.current();
                }
            };
        }, []);
        (0, hooks_1.useEffect)(() => {
            // The busy state is not added on the first render, but on each subsequent toggle
            if (!didMountRef.current) {
                didMountRef.current = true;
                return;
            }
            // Resolve current busy state is transition is already in progress
            if (resolveBusyState.current) {
                resolveBusyState.current();
            }
            resolveBusyState.current = addBusyState('animating');
        }, [opened, addBusyState]);
        const onOjBeforeCloseHandler = async (detail) => {
            if ((detail.reason === 'outsideClick' && autoDismiss === 'focus-loss') ||
                (detail.reason === 'swipe' && closeGesture === 'swipe') ||
                detail.reason === 'escapeKey') {
                // Allow veto by triggering onOjBeforeClose.
                // AutoDismiss controls closing using an outside click.
                // CloseGesture controls closing with a swipe gesture.
                // Closing with ESC key can be vetoed but no property control is available
                // This setting matches legacy Drawer Popup
                try {
                    // Cancelable ojBeforeClose event
                    await onOjBeforeClose?.(detail);
                    onOpenedChanged?.(false);
                }
                catch (_) {
                    // Closing was canceled so short circuit out here
                }
            }
        };
        const transitionEndHandler = async (value) => {
            // PreactDrawer TransitionEndDetail callback is triggered on both
            // when drawer opening ends and when drawer closing ends
            // In Core pack DrawerPopup, for legacy compatability reasons,
            // we trigger ojClose only when drawer closes. In legacy, there's no 'afterOpen' event.
            // Resolve and reset busy state
            if (resolveBusyState.current) {
                resolveBusyState.current();
                resolveBusyState.current = undefined;
            }
            if (value === false) {
                // Trigger onOjClose.
                onOjClose?.();
            }
        };
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, id: id, children: (0, jsx_runtime_1.jsx)(UNSAFE_DrawerPopup_1.DrawerPopup, { ref: preactRef, isOpen: opened, placement: edge, modality: modality, onClose: onOjBeforeCloseHandler, onTransitionEnd: transitionEndHandler, backgroundColor: backgroundColor, "aria-describedby": otherProps['aria-describedby'], "aria-label": otherProps['aria-label'], "aria-labelledby": otherProps['aria-labelledby'], children: children }) }));
    }, "DrawerPopup", { "slots": { "": {} }, "properties": { "opened": { "type": "boolean", "writeback": true }, "modality": { "type": "string", "enumValues": ["modal", "modeless"] }, "edge": { "type": "string", "enumValues": ["end", "start", "bottom"] }, "autoDismiss": { "type": "string", "enumValues": ["none", "focus-loss"] }, "closeGesture": { "type": "string", "enumValues": ["none", "swipe"] }, "backgroundColor": { "type": "string" } }, "events": { "ojBeforeClose": { "cancelable": true }, "ojClose": {} }, "extension": { "_WRITEBACK_PROPS": ["opened"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "aria-label", "aria-labelledby", "id"] } }, { "opened": false, "edge": "start", "modality": "modal", "autoDismiss": "focus-loss", "closeGesture": "swipe" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/drawer-popup',["require", "exports", "oj-c/drawer-popup/drawer-popup"], function (require, exports, drawer_popup_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DrawerPopup = void 0;
    Object.defineProperty(exports, "DrawerPopup", { enumerable: true, get: function () { return drawer_popup_1.DrawerPopup; } });
});
// declare global {
//   namespace preact.JSX {
//     interface IntrinsicElements {
//       'oj-c-drawer-popup': any;
//     }
//   }
// }
;

define('oj-c/drawer-layout/drawer-layout',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_DrawerLayout", "ojs/ojvcomponent", "css!oj-c/drawer-layout/drawer-layout-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_DrawerLayout_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DrawerLayout = void 0;
    exports.DrawerLayout = (0, ojvcomponent_1.registerCustomElement)('oj-c-drawer-layout', 
    /**
     * @classdesc
     * <h3 id="drawerLayoutOverview-section">
     *   JET Drawer Layout
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#drawerLayoutOverview-section"></a>
     * </h3>
     * <p>Description: A Drawer Layout adds expandable side contents (drawers) alongside some primary content.
     * These drawers automatically swap 'reflow' and 'overlay' display mode based on width of the page and can be placed at the 'start', 'end' or 'bottom' edge.
     * </p>
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-drawer-layout end-opened="true">
     *
     *    &lt;div slot="start">Start drawer content &lt;/div>
     *    &lt;div slot="end">End drawer content &lt;/div>
     *
     *    Main section content
     *
     * &lt;/oj-drawer-layout>
     * </code></pre>
     *
     * <p id="drawer-layout-popup-section">JET Drawer Popup and Drawer Layout look similar, but are intended to be used
     * for different purposes.</p>
     * <p>Use Drawer Layout</p>
     * <ul>
     *   <li>If you need to switch between the reflow display mode (big screens) and overlay (small screens).</li>
     *   <li>If the drawer should only fill a specific part of the viewport rather than take its full height (start/end) or full width (bottom).</li>
     *   <li>If modality is not required.</li>
     * </ul>
     * <p>Use Drawer Popup</p>
     * <ul>
     *   <li>If you need to display overlay drawers attached to the edge of the viewport that stretch over the full viewport height or width.</li>
     *   <li>If you need modality.</li>
     * </ul>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     * <table class="keyboard-table">
     *  <thead>
     *    <tr>
     *      <th>Target</th>
     *      <th>Key</th>
     *      <th>Action</th>
     *    </tr>
     *  </thead>
     *  <tbody>
     *    <tr>
     *      <td>Drawer element</td>
     *      <td><kbd>Esc</kbd></td>
     *      <td>Close the drawer</td>
     *    </tr>
     *  </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *  Accessibility
     *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     * It is developers responsibility to define respective aria properties to meet accessibility requirements.
     * Use <code class="prettyprint">aria-labelledby</code>, <code class="prettyprint">aria-describedby</code> or <code class="prettyprint">aria-label</code> attributes
     * on drawer elements (slots of the Drawer Layout) to make them accessible.
     *
     * <h4>aria-labelledby </h4>
     * If a drawer already has a visible title bar, the text inside that bar can be used to label the dialog itself.
     * Set the value of the <code class="prettyprint">aria-labelledby</code> attribute to be the id of the element used to title the drawer.
     * If there isn't appropriate text visible in the DOM that could be referenced with <code class="prettyprint">aria-labelledby</code>
     * use the <code class="prettyprint">aria-label</code> attribute to define the accessible name of an element.
     *
     * <h4> aria-describedby </h4>
     * If the drawer contains additional descriptive text besides the drawer title,
     * this text can be associated with the drawer using the <code class="prettyprint">aria-describedby</code> attribute.
     *
     * <h3 id="rtl-section">
     *   Reading direction
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#rtl-section"></a>
     * </h3>
     *
     * <p> Setting the reading direction (LTR or RTL) is supported by setting the <code class="prettyprint">"dir"</code> attribute on the
     * <code class="prettyprint">&lt;html></code> element of the page. As with any JET component, in the unusual case that the reading direction
     * is changed post-init, the page must be reloaded.</p>
     *
     * <h3 id="sizing">
     *   Sizing
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#sizing"></a>
     * </h3>
     *
     * <p>On mobile resolution side drawers stretch full-height. On non-mobile resolution side drawers stretch
     * to Drawer Layout container's height. The bottom drawer always stretch to Drawer Layout container's width.
     * The other axis dimension is not predefined. This dimension's size is determined by its content.
     * If you want to set a custom size you can use units like px, rem, etc.
     * However because there is no fixed-size parent percentages (%) wont work,
     * but you can use vw (viewport width) or vh (viewport height) units to achieve a similar effect.</p>
     * <ul>
     *   <li>Note the side drawer's built-in minimal width limit in the 'Overlay' mode.</li>
     *   <li>Note that DrawerLayout animates opening and closing. However, it is app developer's responsibility to add animations for custom runtime changes to a drawer size. See the 'Sizing' cookbook demo for an example.</li>
     * </ul>
     *
     * @ojmetadata description "A Drawer Layout adds expandable side contents (drawers) alongside some primary content."
     * @ojmetadata displayName 'Drawer Layout'
     * @ojmetadata help 'oj-c.DrawerLayout.html'
     * @ojmetadata main 'oj-c/drawer-layout'
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "17.0.0",
     *     "value": ["oj-drawer-layout"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Layout & Nav"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/drawer-layout"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-drawer",
     *     "uxSpecs": [
     *       "drawer"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "startOpened",
     *       "endOpened",
     *       "bottomOpened",
     *       "startDisplay",
     *       "endDisplay",
     *       "bottomDisplay"
     *     ]
     *   }
     * ]
     * @ojmetadata since "17.0.0"
     */
    ({ children, start, end, bottom, startOpened = false, endOpened = false, bottomOpened = false, startDisplay = 'auto', endDisplay = 'auto', bottomDisplay = 'auto', onOjBeforeClose, onOjClose, onStartOpenedChanged, onEndOpenedChanged, onBottomOpenedChanged }) => {
        const onOjBeforeCloseHandler = async (detail) => {
            // Allow veto by triggering onOjBeforeClose.
            try {
                // Cancelable ojBeforeClose event
                await onOjBeforeClose?.({
                    edge: detail.placement,
                    reason: 'escapeKey'
                });
                // Trigger writeback event.
                switch (detail.placement) {
                    case 'start':
                        onStartOpenedChanged?.(false);
                        break;
                    case 'end':
                        onEndOpenedChanged?.(false);
                        break;
                    case 'bottom':
                        onBottomOpenedChanged?.(false);
                        break;
                }
            }
            catch (_) {
                // Closing was canceled so short circuit out here
            }
        };
        const onOjCloseHandler = async (detail) => {
            // PreactDrawer TransitionEndDetail callback is triggered on both
            // when drawer opening ends and when drawer closing ends
            // In Core pack DrawerLayout, for legacy compatability reasons,
            // we trigger ojClose only when drawer closes. In legacy, there's no 'afterOpen' event.
            if (detail.value === false) {
                // Trigger onOjClose.
                onOjClose?.({
                    edge: detail.placement,
                    value: detail.value
                });
            }
        };
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_DrawerLayout_1.DrawerLayout, { startDrawer: start, endDrawer: end, bottomDrawer: bottom, isStartOpen: startOpened, isEndOpen: endOpened, isBottomOpen: bottomOpened, startDisplay: startDisplay === 'auto' ? undefined : startDisplay, endDisplay: endDisplay === 'auto' ? undefined : endDisplay, bottomDisplay: bottomDisplay === 'auto' ? undefined : bottomDisplay, onClose: onOjBeforeCloseHandler, onTransitionEnd: onOjCloseHandler, children: children }) }));
    }, "DrawerLayout", { "slots": { "": {}, "start": {}, "end": {}, "bottom": {} }, "properties": { "startOpened": { "type": "boolean", "writeback": true }, "endOpened": { "type": "boolean", "writeback": true }, "bottomOpened": { "type": "boolean", "writeback": true }, "startDisplay": { "type": "string", "enumValues": ["auto", "overlay", "reflow"] }, "endDisplay": { "type": "string", "enumValues": ["auto", "overlay", "reflow"] }, "bottomDisplay": { "type": "string", "enumValues": ["auto", "overlay", "reflow"] } }, "events": { "ojBeforeClose": { "cancelable": true }, "ojClose": {} }, "extension": { "_WRITEBACK_PROPS": ["startOpened", "endOpened", "bottomOpened"], "_READ_ONLY_PROPS": [] } }, { "startOpened": false, "endOpened": false, "bottomOpened": false, "startDisplay": "auto", "endDisplay": "auto", "bottomDisplay": "auto" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/drawer-layout',["require", "exports", "oj-c/drawer-layout/drawer-layout"], function (require, exports, drawer_layout_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DrawerLayout = void 0;
    Object.defineProperty(exports, "DrawerLayout", { enumerable: true, get: function () { return drawer_layout_1.DrawerLayout; } });
});
// declare global {
//   namespace preact.JSX {
//     interface IntrinsicElements {
//       'oj-c-drawer-layout': any;
//     }
//   }
// }
;

define('oj-c/form-layout/form-layout',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_FormLayout", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "ojs/ojvcomponent", "css!oj-c/form-layout/form-layout-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_FormLayout_1, Layout_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FormLayout = void 0;
    /**
     * @classdesc
     * <h3 id="formLayoutOverview-section">
     *   JET FormLayout Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#formLayoutOverview-section"></a>
     * </h3>
     *
     * <p>Description: The oj-c-form-layout component provides a responsive layout capability to lay out child
     * elements in the row or column direction where the number of columns displayed depends on the available
     * width of the container.  Child components are responsible for rendering the label with the alignment as
     * specified by the oj-c-form-layout's label-edge property, which the child components consume.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-form-layout columns="2">
     *   &ltoj-c-input-text label-hint="First Name">&lt/oj-c-input-text>
     *   &ltoj-c-input-text label-hint="Last Name">&lt/oj-c-input-text>
     *   &ltoj-c-input-text label-hint="address" column-span="2">&lt/oj-c-input-text>
     * &lt;/oj-c-form-layout></code></pre>
     *
     * @ojmetadata displayName "Form Layout"
     * @ojmetadata description "A form layout manages the layout of labels and fields in a form."
     * @ojmetadata help "oj-c.FormLayout.html"
     * @ojmetadata main "oj-c/form-layout"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/form-layout",
     *     "defaultColumns": 6,
     *     "minColumns": 2
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-form-layout",
     *     "uxSpecs": [
     *       "form-layout"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "columns",
     *       "columnSpan",
     *       "direction",
     *       "labelEdge",
     *       "labelStartWidth",
     *       "labelWrapping",
     *       "maxColumns",
     *       "readonly",
     *       "userAssistanceDensity"
     *     ]
     *   }
     * ]
     * @ojmetadata requirements [
     *   {
     *     type: "anyOf",
     *     label: "accessibility",
     *     slots: [""]
     *   }
     * ]
     * @ojmetadata since "16.0.0"
     */
    function FormLayoutImpl({ columns = 0, columnSpan = 1, direction = 'row', fullWidth = false, id, maxColumns = 1, ...otherProps }) {
        let preactColumns = maxColumns;
        let preactColumnBehavior = 'responsive';
        if (columns > 0) {
            preactColumns = columns;
            preactColumnBehavior = 'fixed';
        }
        return (
        // Because we are handling it here, there is no need to pass the columnSpan property down to the
        // Preact component. The layoutSpanColumn style class needs to be applied to the root dom element,
        // otherwise the css grid will ignore it.
        // Make sure to add the id on the Root element as it would have been removed
        // from there since it is from the ObservedGlobalProps.
        (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, class: Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan], children: (0, jsx_runtime_1.jsx)(UNSAFE_FormLayout_1.FormLayout, { columns: preactColumns, columnBehavior: preactColumnBehavior, direction: direction, isFullWidth: fullWidth, labelEdge: otherProps.labelEdge, labelStartWidth: otherProps.labelStartWidth, labelWrapping: otherProps.labelWrapping, isReadonly: otherProps.readonly, userAssistanceDensity: otherProps.userAssistanceDensity, children: otherProps.children }) }));
    }
    exports.FormLayout = (0, ojvcomponent_1.registerCustomElement)('oj-c-form-layout', FormLayoutImpl, "FormLayout", { "slots": { "": {} }, "properties": { "columns": { "type": "number" }, "columnSpan": { "type": "number" }, "direction": { "type": "string", "enumValues": ["row", "column"] }, "fullWidth": { "type": "boolean" }, "labelEdge": { "type": "string", "enumValues": ["start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" }, "provide": [{ "name": "containerLabelEdge" }, { "name": "labelEdge" }] } }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" }, "provide": [{ "name": "labelStartWidth" }, { "name": "labelWidth" }] } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" }, "provide": [{ "name": "labelWrapping" }] } }, "maxColumns": { "type": "number" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" }, "provide": [{ "name": "containerReadonly", "default": false }, { "name": "readonly" }] } }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" }, "provide": [{ "name": "containerUserAssistanceDensity", "default": "efficient" }, { "name": "userAssistanceDensity", "default": "efficient" }] } } }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["id"] } }, { "columns": 0, "columnSpan": 1, "direction": "row", "fullWidth": false, "maxColumns": 1 }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/form-layout',["require", "exports", "oj-c/form-layout/form-layout"], function (require, exports, form_layout_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FormLayout = void 0;
    Object.defineProperty(exports, "FormLayout", { enumerable: true, get: function () { return form_layout_1.FormLayout; } });
});

define('oj-c/utils/UNSAFE_focusTabUtils/index',["require", "exports", "./focusUtils"], function (require, exports, focusUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.focusFirstTabStop = void 0;
    Object.defineProperty(exports, "focusFirstTabStop", { enumerable: true, get: function () { return focusUtils_1.focusFirstTabStop; } });
});

define('oj-c/labelled-link/useLabelledLinkPreact',["require", "exports", "preact/hooks"], function (require, exports, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useLabelledLinkPreact = useLabelledLinkPreact;
    /**
     * A custom hook for determining the correct props for the preact
     * LabelledLink component based on the props of the core-pack
     * oj-c-labelled-link component.
     * @param props The props for the hook
     * @returns The props for the preact LabelledLink component
     */
    function useLabelledLinkPreact({ 'aria-describedby': ariaDescribedBy, href, labelEdge, labelHint, labelStartWidth, target, text, textAlign, userAssistanceDensity, onOjAction }) {
        const onClickHandler = (0, hooks_1.useCallback)((event) => {
            // If the href is not provided then it is a custom action.
            // And if this is a custom action, the prevent the default browser
            // action that opens the link
            if (href === undefined) {
                event.preventDefault();
                // trigger the custom action
                onOjAction?.();
            }
        }, [href, onOjAction]);
        return {
            'aria-describedby': ariaDescribedBy,
            children: text,
            href: href ?? '#',
            label: labelHint,
            labelEdge: labelEdge,
            labelStartWidth: labelStartWidth,
            target: target,
            textAlign: textAlign,
            userAssistanceDensity: userAssistanceDensity,
            onClick: onClickHandler
        };
    }
});


define('oj-c/labelled-link/labelled-link',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_LabelledLink", "@oracle/oraclejet-preact/hooks/UNSAFE_useAccessibleContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "../utils/UNSAFE_focusTabUtils/index", "./useLabelledLinkPreact", "css!oj-c/labelled-link/labelled-link-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_LabelledLink_1, UNSAFE_useAccessibleContext_1, UNSAFE_useFormContext_1, UNSAFE_useTabbableMode_1, Layout_1, ojvcomponent_1, compat_1, hooks_1, index_1, useLabelledLinkPreact_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LabelledLink = void 0;
    /**
     * @classdesc
     * <h3 id="labelledLinkOverview-section">
     *   JET LabelledLink
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#labelledLinkOverview-section"></a>
     * </h3>
     *
     * <p>
     * Description: LabelledLink component can be used to render a readonly form control
     * field that has a link for its content.
     * </p>
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-labelled-link
     *   href="www.oracle.com"
     *   text="Website"
     *   label-hint="Labelled Link">
     * &lt;/oj-c-linked-link>
     * </code></pre>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Link</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to the link. Opens the link or invokes the ojAction event.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Link</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the link.</td>
     *     </tr>
     *
     *      <tr>
     *       <td>Link</td>
     *       <td><kbd>Enter</kbd></td>
     *       <td>Opens the link or invokes the ojAction event.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders a visually hidden and screen-reader accessible label.
     * </p>
     *
     * @ojmetadata displayName "LabelledLink"
     * @ojmetadata description "The Labelled Link component displays a readonly field that has a link for its content."
     * @ojmetadata help "oj-c.LabelledLink.html"
     * @ojmetadata main "oj-c/labelled-link"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/labelled-link",
     *     "defaultColumns": 6,
     *     "minColumns": 2,
     *     "componentPalette": {
     *       "visibility": "never"
     *     },
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-link",
     *     "uxSpecs": [
     *       "input-text"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "labelHint",
     *       "textAlign"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "href",
     *       "target",
     *       "text"
     *     ]
     *   }
     * ]
     * @ojmetadata since "16.0.0"
     */
    const LabelledLinkImpl = (props, ref) => {
        // add the needed form context to allow for mixed readonly
        const containerProps = {
            isFormLayout: props.containerReadonly !== undefined,
            isReadonly: props.containerReadonly,
            labelWrapping: props.labelWrapping
        };
        // JET-52089: temporarily add support for unsafe_labelledBy and pass it through context
        const accessibleProps = {
            UNSAFE_ariaLabelledBy: props.unsafe_labelledBy
        };
        // get the preact component props
        const preactProps = (0, useLabelledLinkPreact_1.useLabelledLinkPreact)(props);
        // ref for the root element
        const rootRef = (0, hooks_1.useRef)(null);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => {
                if (rootRef.current?.contains(document.activeElement)) {
                    document.activeElement.blur();
                }
            },
            focus: () => (0, index_1.focusFirstTabStop)(rootRef.current)
        }));
        const { columnSpan = 1 } = props;
        // layoutSpanColumn style class needs to be applied to the root dom element,
        // otherwise the css grid will ignore it.
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, class: Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan], "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_useAccessibleContext_1.AccessibleContext.Provider, { value: accessibleProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_LabelledLink_1.LabelledLink, { ...preactProps, columnSpan: columnSpan }) }) }) }));
    };
    exports.LabelledLink = (0, ojvcomponent_1.registerCustomElement)('oj-c-labelled-link', (0, compat_1.forwardRef)(LabelledLinkImpl), "LabelledLink", { "properties": { "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "href": { "type": "string" }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "target": { "type": "string" }, "text": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "unsafe_labelledBy": { "type": "string" }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } } }, "events": { "ojAction": {} }, "extension": { "_OBSERVED_GLOBAL_PROPS": ["aria-describedby"] }, "methods": { "blur": {}, "focus": {} } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, {
        consume: [UNSAFE_useTabbableMode_1.TabbableModeContext]
    });
});

define('oj-c/labelled-link',["require", "exports", "oj-c/labelled-link/labelled-link"], function (require, exports, labelled_link_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LabelledLink = void 0;
    Object.defineProperty(exports, "LabelledLink", { enumerable: true, get: function () { return labelled_link_1.LabelledLink; } });
});


define('oj-c/menu-button/menu-button',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_MenuButton", "@oracle/oraclejet-preact/UNSAFE_IconMenuButton", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/hooks/UNSAFE_useTooltip", "@oracle/oraclejet-preact/utils/UNSAFE_mergeProps", "@oracle/oraclejet-preact/hooks/UNSAFE_useToggle", "oj-c/utils/PRIVATE_ItemsMenu/items-menu", "preact/hooks", "preact/compat", "css!oj-c/menu-button/menu-button-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_MenuButton_1, UNSAFE_IconMenuButton_1, UNSAFE_useTabbableMode_1, UNSAFE_useTooltip_1, UNSAFE_mergeProps_1, UNSAFE_useToggle_1, items_menu_1, hooks_1, compat_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuButton = void 0;
    /**
     * @classdesc
     * <h3 id="MenuButtonOverview-section">
     *   JET Menu Button
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonOverview-section"></a>
     * </h3>
     *
     * <p>Description: A menu button launches a menu when clicked.
     *
     * <pre class="prettyprint"><code>&lt;oj-c-menu-button label="Copy" items="[[items]]">
     * &lt;/oj-c-menu-button>
     * </code></pre>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Menu Button</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd> or <kbd>Down Arrow</kbd></td>
     *       <td>Invoke the Button menu.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>For accessibility, the label and suffix are used as the accessible aria label.  This is required
     * as persistent menu buttons or suffixes modify the label depending on the last menu item selection.
     *
     * <p>oj-c-menu-button follows the ARIA Authoring Practices Guide patterns for
     * <a href="https://www.w3.org/WAI/ARIA/apg/patterns/menubar/">menu</a> and
     * <a href="https://www.w3.org/WAI/ARIA/apg/patterns/menu-button/">menu button</a>.
     * Note that this is an implementation detail that may change in the future.
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "A menu button launches a menu when clicked."
     * @ojmetadata displayName "Menu Button"
     * @ojmetadata help "oj-c.MenuButton.html"
     * @ojmetadata main "oj-c/menu-button"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/menu-button",
     *     "pi":{
     *       "events":{
     *         "suggestions":[
     *             { "type":"component",
     *                "name": "ojMenuAction",
     *                "mappings": [
     *                  { "variableName": "menuItemKey",
     *                     "expression": "{{$event.detail.key}}",
     *                     "type": "string"
     *                  }
     *                ]
     *             },
     *             { "type":"component",
     *                "name": "onOjMenuSelection",
     *                "mappings": [
     *                  { "variableName": "menuSelectionValue",
     *                     "expression": "{{$event.detail.value}}",
     *                     "type": "string"
     *                  },
     *                  { "variableName": "menuSelectionGroupKey",
     *                     "expression": "{{$event.detail.menuSelectionGroupKey}}",
     *                     "type": "string"
     *                  }
     *                ]
     *              },
     *            ]
     *         }
     *      }
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-menu-button",
     *     "uxSpecs": [
     *       "menu-button"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "label",
     *       "tooltip",
     *       "display",
     *       "chroming",
     *       "size",
     *       "width",
     *       "edge",
     *       "disabled"
     *     ]
     *    },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "suffix",
     *       "items"
     *       "selection"
     *     ]
     *   }
     * ]
     * @ojmetadata since "16.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "16.0.0",
     *     "value": ["oj-menu-button","oj-menu-select-many"]
     *   }
     * ]
     */
    function MenuButtonImpl({ label = '', chroming = 'outlined', disabled = false, size = 'md', display = 'all', items = [], tooltip, suffix, startIcon, endIcon, selection, onSelectionChanged, onOjMenuAction, onOjMenuSelection, 'aria-label': accessibleLabel, 'aria-describedby': ariaDescribedBy, width }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const buttonRef = (0, hooks_1.useRef)(null);
        const isLabelButton = display !== 'icons' || (startIcon && endIcon);
        const { bool: isOpen, toggle: toggleOpen } = (0, UNSAFE_useToggle_1.useToggle)();
        const widthProps = width ? { style: { width: width } } : {};
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => buttonRef.current?.blur(),
            focus: () => buttonRef.current?.focus(),
            click: () => buttonRef.current?.click()
        }), []);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ...widthProps, ref: rootRef, children: isLabelButton ? ((0, jsx_runtime_1.jsx)(FunctionalMenuButton, { isMenuOpen: isOpen, onToggleMenu: toggleOpen, label: display === 'icons' ? (!startIcon ? label : '') : label, suffix: display === 'icons' ? (!startIcon ? suffix : '') : suffix, ref: buttonRef, variant: chroming, size: size, tooltip: tooltip, width: '100%', "aria-label": accessibleLabel, "aria-describedby": ariaDescribedBy, icon: display !== 'label' ? startIcon : null, isDisabled: disabled, children: (0, jsx_runtime_1.jsx)(items_menu_1.ItemsMenu, { items: items, selection: selection, onSelectionChanged: onSelectionChanged, onOjMenuSelection: onOjMenuSelection, onOjMenuAction: onOjMenuAction }) })) : ((0, jsx_runtime_1.jsx)(UNSAFE_IconMenuButton_1.IconMenuButton, { isMenuOpen: isOpen, width: '100%', onToggleMenu: toggleOpen, ref: buttonRef, variant: chroming, isDisabled: disabled, tooltip: tooltip, accessibleLabel: accessibleLabel && accessibleLabel !== '' ? accessibleLabel : label, "aria-describedby": ariaDescribedBy, size: size, isIconOnly: (!startIcon && endIcon) || (!startIcon && !endIcon) ? display === 'icons' : false, icon: startIcon ?? (endIcon ? endIcon : (0, jsx_runtime_1.jsx)(OverFlowIcon, {})), children: (0, jsx_runtime_1.jsx)(items_menu_1.ItemsMenu, { items: items, selection: selection, onSelectionChanged: onSelectionChanged, onOjMenuSelection: onOjMenuSelection, onOjMenuAction: onOjMenuAction }) })) }));
    }
    const OverFlowIcon = () => {
        return (0, jsx_runtime_1.jsx)("span", { class: "oj-ux-ico-overflow-h" });
    };
    exports.MenuButton = (0, ojvcomponent_1.registerCustomElement)('oj-c-menu-button', (0, compat_1.forwardRef)(MenuButtonImpl), "MenuButton", { "properties": { "label": { "type": "string" }, "suffix": { "type": "string" }, "tooltip": { "type": "string" }, "items": { "type": "Array<object>" }, "selection": { "type": "object", "writeback": true }, "display": { "type": "string", "enumValues": ["all", "label", "icons"] }, "disabled": { "type": "boolean" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg", "xs"] }, "width": { "type": "number|string" }, "chroming": { "type": "string", "enumValues": ["solid", "borderless", "outlined", "ghost"], "binding": { "consume": { "name": "containerChroming" } } } }, "slots": { "startIcon": {}, "endIcon": {} }, "events": { "ojMenuAction": { "bubbles": true }, "ojMenuSelection": { "bubbles": true } }, "extension": { "_WRITEBACK_PROPS": ["selection"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "aria-label"] }, "methods": { "focus": {}, "blur": {}, "click": {} } }, { "label": "", "chroming": "outlined", "disabled": false, "size": "md", "display": "all", "items": [] }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const FunctionalMenuButton = (0, compat_1.forwardRef)((props, ref) => {
        const { tooltipContent, tooltipProps } = (0, UNSAFE_useTooltip_1.useTooltip)({
            text: props.tooltip,
            isDisabled: props.isDisabled
        });
        return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(UNSAFE_MenuButton_1.MenuButton, { ref: ref, ...(0, UNSAFE_mergeProps_1.mergeProps)(props, tooltipProps) }), tooltipContent] }));
    });
});

define('oj-c/menu-button',["require", "exports", "oj-c/menu-button/menu-button"], function (require, exports, menu_button_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuButton = void 0;
    Object.defineProperty(exports, "MenuButton", { enumerable: true, get: function () { return menu_button_1.MenuButton; } });
});

define('oj-c/tab-bar/DataTabBarIcon',["require", "exports", "preact/jsx-runtime"], function (require, exports, jsx_runtime_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataTabBarIcon = DataTabBarIcon;
    function DataTabBarIcon(props) {
        const { icon } = props;
        if (!icon) {
            return null;
        }
        if (icon.type === 'class') {
            return (0, jsx_runtime_1.jsx)("span", { class: icon.class });
        }
        return null;
    }
});

define('oj-c/tab-bar/ContentRenderer',["require", "exports", "preact/jsx-runtime", "@oracle/oraclejet-preact/UNSAFE_TabBar", "@oracle/oraclejet-preact/UNSAFE_OverflowTabBar", "./DataTabBarIcon", "@oracle/oraclejet-preact/UNSAFE_ReorderableTabBar"], function (require, exports, jsx_runtime_1, UNSAFE_TabBar_1, UNSAFE_OverflowTabBar_1, DataTabBarIcon_1, UNSAFE_ReorderableTabBar_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TabBarRenderer = TabBarRenderer;
    exports.OverflowTabBarRenderer = OverflowTabBarRenderer;
    //To limit regualar badge to 999+ and Stacked and Only Icon badges to 99+
    const badgeRenderer = (badgeValue, display) => {
        if (badgeValue != null) {
            let modifiedBadge = '';
            if (display === 'stacked' || display === 'icons') {
                modifiedBadge = badgeValue > 99 ? '99+' : badgeValue.toString();
            }
            else {
                modifiedBadge = badgeValue > 999 ? '999+' : badgeValue.toString();
            }
            return modifiedBadge;
        }
        else
            return undefined;
    };
    const tabBarItemRenderer = (tab, display) => {
        return ((0, jsx_runtime_1.jsx)(UNSAFE_TabBar_1.TabBarItem, { icon: tab.icon ? (0, jsx_runtime_1.jsx)(DataTabBarIcon_1.DataTabBarIcon, { icon: tab.icon }) : undefined, badge: badgeRenderer(tab.badge, display), itemKey: tab.itemKey, label: tab.label, metadata: tab.metadata, severity: tab.severity, "aria-controls": tab.tabPanelId, labelMaxWidth: tab.labelMaxWidth }));
    };
    const removableTabBarItemRenderer = (tab, display) => {
        return ((0, jsx_runtime_1.jsx)(UNSAFE_TabBar_1.RemovableTabBarItem, { icon: tab.icon ? (0, jsx_runtime_1.jsx)(DataTabBarIcon_1.DataTabBarIcon, { icon: tab.icon }) : undefined, "aria-controls": tab.tabPanelId, badge: badgeRenderer(tab.badge, display), itemKey: tab.itemKey, label: tab.label, metadata: tab.metadata, severity: tab.severity }));
    };
    const linkTabBarItemRenderer = (tab, display) => {
        return ((0, jsx_runtime_1.jsx)(UNSAFE_TabBar_1.TabBarLinkItem, { icon: tab.icon ? (0, jsx_runtime_1.jsx)(DataTabBarIcon_1.DataTabBarIcon, { icon: tab.icon }) : undefined, "aria-controls": tab.tabPanelId, badge: badgeRenderer(tab.badge, display), itemKey: tab.itemKey, label: tab.label, metadata: tab.metadata, severity: tab.severity, href: tab.href }));
    };
    function TabBarRenderer(props, handleSelect, rootRef) {
        const { data, truncation, ...tabBarProps } = props;
        const display = tabBarProps.display;
        const { maxWidths } = (0, UNSAFE_TabBar_1.useProgressiveTruncation)({
            rootRef,
            isDisabled: !(truncation && truncation === 'progressive')
        });
        const items = truncation === 'progressive'
            ? data.map((item) => ({
                ...item,
                labelMaxWidth: maxWidths?.get(item.itemKey)
            }))
            : data;
        const isLinkType = (item) => {
            return 'href' in item;
        };
        return tabBarProps.reorderable === 'enabled' ? ((0, jsx_runtime_1.jsx)(UNSAFE_ReorderableTabBar_1.ReorderableTabBar, { ...tabBarProps, onSelect: handleSelect, children: items.map((tab) => tab != null &&
                (isLinkType(tab)
                    ? linkTabBarItemRenderer(tab, display)
                    : tab.isRemovable
                        ? removableTabBarItemRenderer(tab, display)
                        : tabBarItemRenderer(tab, display))) })) : ((0, jsx_runtime_1.jsx)(UNSAFE_TabBar_1.TabBar, { onSelect: handleSelect, ref: rootRef, ...tabBarProps, children: items.map((tab) => isLinkType(tab)
                ? linkTabBarItemRenderer(tab, display)
                : tab.isRemovable
                    ? removableTabBarItemRenderer(tab, display)
                    : tabBarItemRenderer(tab, display)) }));
    }
    function OverflowTabBarRenderer(props, handleSelect) {
        const { data, truncation, ...overflowTabBarProps } = props;
        return ((0, jsx_runtime_1.jsx)(UNSAFE_OverflowTabBar_1.OverflowTabBar, { items: data, onSelect: handleSelect, truncation: truncation, ...overflowTabBarProps }));
    }
});

define('oj-c/tab-bar/DataTabBar',["require", "exports", "preact/jsx-runtime", "preact", "@oracle/oraclejet-preact/UNSAFE_ConveyorBelt", "./ContentRenderer"], function (require, exports, jsx_runtime_1, preact_1, UNSAFE_ConveyorBelt_1, ContentRenderer_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataTabBar = DataTabBar;
    function DataTabBar(props) {
        const { onRemove, onReorder, onSelect, selection, data = [], display, layout, edge, overflow, reorderable, truncation, 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledby, contextMenuConfig } = props;
        const tabBarRef = (0, preact_1.createRef)();
        const handleSelect = (event) => {
            if (event.value && onSelect) {
                onSelect(event);
            }
        };
        const conveyorRenderer = () => {
            return ((0, jsx_runtime_1.jsx)(UNSAFE_ConveyorBelt_1.ConveyorBelt, { children: (0, ContentRenderer_1.TabBarRenderer)({
                    onRemove,
                    selection,
                    layout,
                    display,
                    edge,
                    'aria-label': ariaLabel,
                    'aria-labelledby': ariaLabelledby,
                    data,
                    reorderable,
                    truncation,
                    onReorder,
                    contextMenuConfig
                }, handleSelect, tabBarRef) }));
        };
        return overflow === 'popup'
            ? (0, ContentRenderer_1.OverflowTabBarRenderer)({
                selection,
                onRemove,
                data,
                layout,
                display,
                edge,
                truncation,
                contextMenuConfig,
                'aria-label': ariaLabel,
                'aria-labelledby': ariaLabelledby
            }, handleSelect)
            : overflow === 'conveyor'
                ? conveyorRenderer()
                : (0, ContentRenderer_1.TabBarRenderer)({
                    onRemove,
                    selection,
                    layout,
                    display,
                    edge,
                    'aria-label': ariaLabel,
                    'aria-labelledby': ariaLabelledby,
                    data,
                    reorderable,
                    truncation,
                    onReorder,
                    contextMenuConfig
                }, handleSelect, tabBarRef);
    }
});

define('oj-c/tab-bar/tab-bar',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "oj-c/hooks/UNSAFE_useDataProvider/useDataProvider", "ojs/ojcontext", "./DataTabBar", "preact/hooks", "preact/compat", "@oracle/oraclejet-preact/utils/UNSAFE_clientUtils", "../utils/PRIVATE_ItemsMenu/items-menu"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, useDataProvider_1, Context, DataTabBar_1, hooks_1, compat_1, UNSAFE_clientUtils_1, items_menu_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TabBar = void 0;
    // Utility to check if it is a dataProvider
    function isDataProvider(data) {
        return data && 'fetchFirst' in data;
    }
    // Utility that checks and returns true if the data is of type TabData. This is required because isRemovable is not supported in TabLinkItemData which also an allows type for data so throws type mismatch and undefined prop error when checking for isRemovable.
    const hasRemovable = (data) => {
        return 'isRemovable' in data;
    };
    exports.TabBar = (0, ojvcomponent_1.registerCustomElement)('oj-c-tab-bar', (0, compat_1.forwardRef)(
    /**
     * @classdesc
     * <h3 id="tabBarOverview-section">
     *   JET TabBar
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#tabBarOverview-section"></a>
     * </h3>
     *
     * The oj-c-tab-bar enables horizontal navigation.
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Selects the tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Remove button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Removes the tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Arrow button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>When tabs are displayed inside a conveyor belt, tapping the arrow button will scroll the conveyor belt.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>Enter or Space</kbd></td>
     *       <td>Select the current tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>LeftArrow or RightArrow</kbd></td>
     *       <td>Navigate to the previous or next tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>Delete</kbd></td>
     *       <td>Remove the current tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Hide the tooltip if tooltip is shown.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>UpArrow or DownArrow</kbd></td>
     *       <td>Navigate the tab represented as item in the list in the direction of the arrow.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Enter or Space</kbd></td>
     *       <td>Select the highlighted choice from the dropdown and close the dropdown.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Close the dropdown.</td>
     *     </tr>
     *     <tr>
     *       <td>Reorder</td>
     *       <td><kbd>Command/Ctrl + Shift + LeftArrow (RightArrow in RTL)</kbd></td>
     *       <td>Moves the tab before the previous tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Reorder</td>
     *       <td><kbd>Command/Ctrl + Shift + RightArrow (LeftArrow in RTL)</kbd></td>
     *       <td>Moves the tab after the next tab.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojmetadata description ' A tab bar allows navigation between different content sections.'
     * @ojmetadata displayName 'Tab Bar '
     * @ojmetadata help 'oj-c.TabBar.html'
     * @ojmetadata main 'oj-c/tab-bar'
     * @ojmetadata status [
     *   {
     *     type: "supersedes",
     *     since: "19.0.0",
     *     "value": ["oj-tab-bar"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Layout & Nav"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/tab-bar",
     *     "defaultColumns": 12,
     *     "minColumns": 2
     *   }
     * }
     * * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "selection",
     *       "edge",
     *       "display",
     *       "truncation",
     *       "overflow",
     *       "reorderable",
     *       "layout",
     *       "truncation"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data"
     *     ]
     *   }
     * @ojmetadata since "17.0.0"
     */
    ({ data = [], onOjBeforeSelect, onOjRemove, onOjReorder, onOjSelectionAction, onSelectionChanged, reorderable = 'disabled', overflow = 'hidden', truncation = 'none', selection, contextMenuConfig, display = 'standard', layout = 'stretch', edge = 'top', 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledby, id }, ref) => {
        const rootRef = (0, hooks_1.useRef)(null);
        // This is to pass to the useDataProvider hook
        const addBusyState = (0, hooks_1.useCallback)((description = 'MessageBanner: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current).getBusyContext().addBusyState({ description })
                : () => { };
        }, []);
        const { data: dataProviderData } = (0, useDataProvider_1.useDataProvider)({
            // Need to check if its not array otherwise we cannot assign it to data key in the hook
            data: !Array.isArray(data) && isDataProvider(data) ? data : undefined,
            addBusyState
        });
        // The array returned by useDataProvider is in the form of {data: D, key: K, metadata: ItemMetadata<K>}, so map is needed to fetch only item.data. Conversion is required only when tabData coming from DataProvider changed, hence the useMemo.
        const dataArr = (0, hooks_1.useMemo)(() => {
            let retDataArr = [];
            if (Array.isArray(data)) {
                retDataArr = data;
            }
            else {
                if (isDataProvider(data)) {
                    retDataArr = dataProviderData.map((item) => {
                        return { ...item.data };
                    });
                }
            }
            return retDataArr;
        }, [data, dataProviderData]);
        const handleRemove = (event) => {
            if (onOjRemove) {
                onOjRemove({ key: event.value });
            }
        };
        const handleReorder = (event) => {
            if (onOjReorder) {
                onOjReorder({ reorderedKeys: event.reorderedKeys });
            }
        };
        const handleSelect = (event) => {
            (async () => {
                handleOnSelectionChanged: {
                    // If 'onOjBeforeSelect' is provided, handle the result before calling 'onSelectionChanged'
                    if (onOjBeforeSelect) {
                        try {
                            await onOjBeforeSelect({ key: event.value });
                        }
                        catch {
                            // If 'onOjBeforeSelect' rejects, break out of the 'handleOnSelectionChanged'
                            // labeled block (preventing 'onSelectionChanged' from firing)
                            break handleOnSelectionChanged;
                        }
                    }
                    if (onOjSelectionAction) {
                        onOjSelectionAction({ previousValue: selection || '', value: event.value });
                    }
                    if (selection === event.value) {
                        return;
                    }
                    if (onSelectionChanged) {
                        onSelectionChanged(event.value);
                    }
                }
            })();
        };
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            _doReorderHelper: (tabBarKeys) => {
                onOjReorder && onOjReorder({ reorderedKeys: tabBarKeys });
                return Promise.resolve();
            }
        }));
        const isMobileDevice = (0, UNSAFE_clientUtils_1.isMobile)();
        const defaultContextMenuConfig = (0, hooks_1.useMemo)(() => {
            return {
                itemsRenderer: (context) => {
                    if (context) {
                        const defaultItems = context.defaultMenuItems;
                        // We need to find if the item has isRemovable set to true
                        const itemData = dataArr.find((item) => {
                            return item.itemKey === context.itemKey;
                        });
                        const isRemovableItem = hasRemovable(itemData) && itemData.isRemovable === true;
                        const isReorderableItem = reorderable === 'enabled';
                        // Only if the item has isRemovable set true or is reorderable and it is a touch device then we render a default context menu
                        if ((isRemovableItem || isReorderableItem) &&
                            isMobileDevice &&
                            defaultItems != null) {
                            return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: defaultItems });
                        }
                    }
                    return null;
                }
            };
        }, []);
        const itemsRenderer = (0, hooks_1.useCallback)((context) => {
            // Create the corepack context menu context contract from the preact context
            const corepackContextMenuContext = {
                itemKey: context.itemKey,
                hasDefaultMenuItems: context.defaultMenuItems != null
            };
            // Get the items from the corepack context menu config and based on the value render the menu items.
            const contextMenuItems = contextMenuConfig?.items(corepackContextMenuContext);
            if (contextMenuItems != null && context != null) {
                const defaultItemsRender = {
                    defaultMenuItems: () => context.defaultMenuItems,
                    remove: () => context.allMenuItems?.['remove'],
                    reorder: () => context.allMenuItems?.['reorder']
                };
                return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: (0, jsx_runtime_1.jsx)(items_menu_1.ItemsMenu, { items: contextMenuItems, defaultItemsRenderer: defaultItemsRender }) }));
            }
            return;
        }, [contextMenuConfig?.items]);
        const customContextMenuConfig = (0, hooks_1.useMemo)(() => {
            return {
                itemsRenderer,
                accessibleLabel: contextMenuConfig?.accessibleLabel
            };
        }, [contextMenuConfig?.accessibleLabel, itemsRenderer]);
        // If the context-menu-config is defined then we make use of the custom menu or render the default menu if we detect the app is being run on a mobile device.
        const contextMenuConfiguration = contextMenuConfig != null
            ? customContextMenuConfig
            : isMobileDevice
                ? defaultContextMenuConfig
                : undefined;
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, children: (0, jsx_runtime_1.jsx)(DataTabBar_1.DataTabBar, { "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, data: dataArr, onRemove: handleRemove, onReorder: handleReorder, onSelect: handleSelect, reorderable: reorderable, selection: selection, display: display, edge: edge, layout: layout, overflow: overflow, truncation: truncation, contextMenuConfig: contextMenuConfiguration }) }));
    }), "TabBar", { "properties": { "data": { "type": "Array<object>|DataProvider" }, "selection": { "type": "string|number", "writeback": true }, "reorderable": { "type": "string", "enumValues": ["disabled", "enabled"] }, "overflow": { "type": "string", "enumValues": ["hidden", "popup", "conveyor"] }, "display": { "type": "string", "enumValues": ["standard", "icons", "stacked"] }, "layout": { "type": "string", "enumValues": ["stretch", "condense"] }, "edge": { "type": "string", "enumValues": ["top", "bottom"] }, "truncation": { "type": "string", "enumValues": ["none", "progressive"] }, "contextMenuConfig": { "type": "object", "properties": { "items": { "type": "function" }, "accessibleLabel": { "type": "string" } } } }, "events": { "ojBeforeSelect": { "cancelable": true }, "ojRemove": {}, "ojReorder": {}, "ojSelectionAction": {} }, "extension": { "_WRITEBACK_PROPS": ["selection"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "id", "aria-labelledby"] }, "methods": { "_doReorderHelper": {} } }, { "data": [], "reorderable": "disabled", "overflow": "hidden", "truncation": "none", "display": "standard", "layout": "stretch", "edge": "top" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/tab-bar',["require", "exports", "oj-c/tab-bar/tab-bar"], function (require, exports, tab_bar_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TabBar = void 0;
    Object.defineProperty(exports, "TabBar", { enumerable: true, get: function () { return tab_bar_1.TabBar; } });
});

define('oj-c/tab-bar-mixed/DataTabBarMixedIcon',["require", "exports", "preact/jsx-runtime"], function (require, exports, jsx_runtime_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataTabBarMixedIcon = DataTabBarMixedIcon;
    function DataTabBarMixedIcon(props) {
        const { icon } = props;
        if (!icon) {
            return null;
        }
        if (icon.type === 'class') {
            return (0, jsx_runtime_1.jsx)("span", { class: icon.class });
        }
        return null;
    }
});

define('oj-c/tab-bar-mixed/sumBadge',["require", "exports", "ojs/ojlogger"], function (require, exports, Logger) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sumBadge = sumBadge;
    /**
     * Returns a numerical total of numerical badge values extracted from
     * a collection of objects.
     *
     * @param tabs
     * @returns
     */
    function sumBadge(items) {
        return items.reduce((total, item) => {
            if (!item.badge) {
                return total;
            }
            const num = Number(item.badge);
            if (!Number.isInteger(num)) {
                Logger.warn(`Tab item with itemKey '${item.itemKey}' provided a badge of '${item.badge}', expected integer`);
                return total;
            }
            if (num < 0) {
                Logger.warn(`Tab item with itemKey '${item.itemKey}' provided a negative numerical badge value of '${item.badge}', expected positive integer. This will be discarded from total.`);
                return total;
            }
            return total + item.badge;
        }, 0);
    }
});

define('oj-c/tab-bar-mixed/DataTabBarMixed',["require", "exports", "preact/jsx-runtime", "preact/hooks", "@oracle/oraclejet-preact/UNSAFE_ConveyorBelt", "@oracle/oraclejet-preact/UNSAFE_TabBarMixed", "./DataTabBarMixedIcon", "./sumBadge", "preact"], function (require, exports, jsx_runtime_1, hooks_1, UNSAFE_ConveyorBelt_1, UNSAFE_TabBarMixed_1, DataTabBarMixedIcon_1, sumBadge_1, preact_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataTabBarMixed = DataTabBarMixed;
    function DataTabBarMixed(props) {
        const { dynamicTabs = [], dynamicTabsOverflowIcon, dynamicTabsOverflow, onRemove, onSelect, selection, separatorPadding, size = 'lg', staticTabs = [], staticTabsDisplay, 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledby } = props;
        const [isOverflowMenuOpen, setIsOverflowMenuOpen] = (0, hooks_1.useState)(false);
        const tabBarMixedRef = (0, preact_1.createRef)();
        const isOutsideMouseDown = (0, hooks_1.useRef)(false);
        const handleClose = (e) => {
            if (tabBarMixedRef.current && ['itemAction', 'dismissed'].includes(e.reason)) {
                tabBarMixedRef?.current?.focus();
            }
            if (e.reason === 'outsideMousedown') {
                isOutsideMouseDown.current = true;
            }
            setIsOverflowMenuOpen(false);
        };
        const handleSelect = (event) => {
            if (event.value && event.value === 'overflow') {
                //If overflow item is clicked after dropdown is open, the reason is outsideMouseDown and it needs to be closed
                if (isOutsideMouseDown.current) {
                    setIsOverflowMenuOpen(false);
                }
                else {
                    setIsOverflowMenuOpen(true);
                }
            }
            else if (onSelect) {
                onSelect(event);
            }
            isOutsideMouseDown.current = false;
        };
        const badgeTotal = (0, sumBadge_1.sumBadge)(dynamicTabs);
        const isDividerVisible = staticTabs.length > 0 && dynamicTabs.length > 0;
        return ((0, jsx_runtime_1.jsxs)(UNSAFE_TabBarMixed_1.TabBarMixed, { onRemove: onRemove, onSelect: handleSelect, selection: selection, size: size, ref: tabBarMixedRef, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, children: [(0, jsx_runtime_1.jsxs)(UNSAFE_TabBarMixed_1.TabBarLayout, { layout: "stretch", display: staticTabsDisplay, children: [staticTabs.map((tab) => ((0, jsx_runtime_1.jsx)(UNSAFE_TabBarMixed_1.TabBarItem, { icon: tab.icon ? ((0, jsx_runtime_1.jsx)(DataTabBarMixedIcon_1.DataTabBarMixedIcon, { label: staticTabsDisplay === 'icons' ? tab.label : undefined, icon: tab.icon })) : undefined, itemKey: tab.itemKey, label: tab.label, badge: tab.badge ? tab.badge.toString() : undefined, "aria-controls": tab.tabPanelId }))), dynamicTabsOverflow === 'popup' && ((0, jsx_runtime_1.jsx)(UNSAFE_TabBarMixed_1.OverflowTabBarItem, { badge: badgeTotal > 0 ? badgeTotal.toString() : undefined, icon: (0, jsx_runtime_1.jsx)(DataTabBarMixedIcon_1.DataTabBarMixedIcon, { icon: dynamicTabsOverflowIcon }), isOpen: isOverflowMenuOpen, onClose: handleClose, overflowItemKey: "overflow", overflowItems: dynamicTabs.map((tab) => ({
                                itemKey: tab.itemKey,
                                badge: tab.badge ? tab.badge.toString() : undefined,
                                label: tab.label,
                                isRemovable: true
                            })) }))] }), dynamicTabsOverflow === 'conveyor' && ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [isDividerVisible && (0, jsx_runtime_1.jsx)(UNSAFE_TabBarMixed_1.TabBarMixedSeparator, { padding: separatorPadding }), (0, jsx_runtime_1.jsx)(UNSAFE_ConveyorBelt_1.ConveyorBelt, { children: (0, jsx_runtime_1.jsx)(UNSAFE_TabBarMixed_1.TabBarLayout, { display: "standard", layout: "condense", children: dynamicTabs.map((tab) => ((0, jsx_runtime_1.jsx)(UNSAFE_TabBarMixed_1.RemovableTabBarItem, { "aria-controls": tab.tabPanelId, badge: tab.badge ? tab.badge.toString() : undefined, itemKey: tab.itemKey, label: tab.label }))) }) })] }))] }));
    }
});

define('oj-c/tab-bar-mixed/tab-bar-mixed',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "./DataTabBarMixed"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, DataTabBarMixed_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TabBarMixed = void 0;
    exports.TabBarMixed = (0, ojvcomponent_1.registerCustomElement)('oj-c-tab-bar-mixed', 
    /**
     * @classdesc
     * <h3 id="tabBarMixedOverview-section">
     *   JET TabBarMixed
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#tabBarMixedOverview-section"></a>
     * </h3>
     *
     * The oj-c-tab-bar-mixed enables horizontal navigation between distinct content with a mixture of static and dynamic tabs.
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Selects the tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Remove button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Removes the tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Arrow button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>When dynamic tabs are displayed inside a conveyor belt, tapping the arrow button will scroll the conveyor belt.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>Enter or Space</kbd></td>
     *       <td>Select the current tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>LeftArrow or RightArrow</kbd></td>
     *       <td>Navigate to the previous or next tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>Delete</kbd></td>
     *       <td>Remove the current tab.</td>
     *     </tr>
     *     <tr>
     *       <td>Tab</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Hide the tooltip if tooltip is shown.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>UpArrow or DownArrow</kbd></td>
     *       <td>Navigate the dynamic tab represented as item in the list in the direction of the arrow.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Enter or Space</kbd></td>
     *       <td>Select the highlighted choice from the dropdown and close the dropdown.</td>
     *     </tr>
     *     <tr>
     *       <td>Dropdown</td>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Close the dropdown.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojmetadata description 'A navigation component that enables horizontal navigation between distinct content with a mixture of static and dynamic tabs.'
     * @ojmetadata displayName 'Tab Bar Mixed'
     * @ojmetadata help 'oj-c.TabBarMixed.html'
     * @ojmetadata main 'oj-c/tab-bar-mixed'
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Layout & Nav"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/tab-bar-mixed"
     *   }
     * }
     * @ojmetadata since "16.1.0"
     */
    (props) => {
        const { dynamicTabs = [], dynamicTabsOverflow = 'conveyor', dynamicTabsOverflowIcon = { type: 'class', class: 'oj-ux-ico-collection' }, onOjBeforeSelect, onOjRemove, onOjSelectionAction, onSelectionChanged, selection, separatorPadding = '3rem', size, staticTabs = [], staticTabsDisplay = 'standard', 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledby, id } = props;
        const handleRemove = (event) => {
            if (onOjRemove) {
                onOjRemove({ key: event.value });
            }
        };
        const handleSelect = (event) => {
            (async () => {
                handleOnSelectionChanged: {
                    // If 'onOjBeforeSelect' is provided, handle the result before calling 'onSelectionChanged'
                    if (onOjBeforeSelect) {
                        try {
                            await onOjBeforeSelect({ key: event.value });
                        }
                        catch {
                            // If 'onOjBeforeSelect' rejects, break out of the 'handleOnSelectionChanged'
                            // labeled block (preventing 'onSelectionChanged' from firing)
                            break handleOnSelectionChanged;
                        }
                    }
                    if (onOjSelectionAction) {
                        onOjSelectionAction({ previousValue: selection || '', value: event.value });
                    }
                    if (selection === event.value) {
                        return;
                    }
                    if (onSelectionChanged) {
                        onSelectionChanged(event.value);
                    }
                }
            })();
        };
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, children: (0, jsx_runtime_1.jsx)(DataTabBarMixed_1.DataTabBarMixed, { "aria-label": ariaLabel, "aria-labelledby": ariaLabelledby, dynamicTabs: dynamicTabs, dynamicTabsOverflow: dynamicTabsOverflow, dynamicTabsOverflowIcon: dynamicTabsOverflowIcon, onRemove: handleRemove, onSelect: handleSelect, selection: selection, separatorPadding: separatorPadding, size: size, staticTabs: staticTabs, staticTabsDisplay: staticTabsDisplay }) }));
    }, "TabBarMixed", { "properties": { "dynamicTabs": { "type": "Array<object>" }, "dynamicTabsOverflow": { "type": "string", "enumValues": ["popup", "conveyor"] }, "dynamicTabsOverflowIcon": { "type": "object" }, "size": { "type": "string", "enumValues": ["md", "lg"] }, "selection": { "type": "string|number", "writeback": true }, "separatorPadding": { "type": "string" }, "staticTabs": { "type": "Array<object>" }, "staticTabsDisplay": { "type": "string", "enumValues": ["standard", "icons"] } }, "events": { "ojBeforeSelect": { "cancelable": true }, "ojRemove": {}, "ojSelectionAction": {} }, "extension": { "_WRITEBACK_PROPS": ["selection"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "id", "aria-labelledby"] } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/tab-bar-mixed',["require", "exports", "oj-c/tab-bar-mixed/tab-bar-mixed"], function (require, exports, tab_bar_mixed_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TabBarMixed = void 0;
    Object.defineProperty(exports, "TabBarMixed", { enumerable: true, get: function () { return tab_bar_mixed_1.TabBarMixed; } });
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/card-view/useCardViewPreact',["require", "exports", "preact/hooks", "../hooks/UNSAFE_useListData/useListData", "../utils/PRIVATE_collectionUtils/collectionUtils"], function (require, exports, hooks_1, useListData_1, collectionUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useCardViewPreact = void 0;
    const useCardViewPreact = ({ 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, 'aria-describedby': ariaDescribedBy, data: propData, gutterSize, focusBehavior, selected, onSelectedChanged, scrollPolicyOptions, selectionMode, initialAnimation, columns: corePackColumns, reorderable, onOjReorder, onCurrentItemChanged, skeletonTemplate }, isClickthroughDisabled, busyStateContext) => {
        const [listDataState, onLoadRange] = (0, useListData_1.useListData)(propData, {
            fetchSize: scrollPolicyOptions?.fetchSize
        });
        const resolveBusyState = (0, hooks_1.useRef)();
        const listData = listDataState.status !== 'error' ? listDataState.data : null;
        // set and resolve busy state based on listDataState
        (0, hooks_1.useEffect)(() => {
            if (listDataState.status === 'loading') {
                resolveBusyState.current = busyStateContext.addBusyState('list data is in fetch state');
            }
            else {
                if (resolveBusyState.current) {
                    resolveBusyState.current();
                    resolveBusyState.current = undefined;
                }
            }
        }, [listDataState.status, busyStateContext]);
        // when the component is unmount, we should clear busy state also
        (0, hooks_1.useEffect)(() => {
            return () => {
                if (resolveBusyState.current) {
                    resolveBusyState.current();
                    resolveBusyState.current = undefined;
                }
            };
        }, []);
        // in core pack side, columns could be a number or 'auto' or undefined
        // in preact side, columns could only be number or undefined
        const numberCorepackColumns = Number(corePackColumns);
        const preactColumns = Number.isInteger(numberCorepackColumns) ? numberCorepackColumns : undefined;
        const selectedKeys = (0, collectionUtils_1.getSelectedKeys)(selected, listData, selectionMode, onSelectedChanged);
        const handleOnSelectionChange = (detail) => {
            (0, collectionUtils_1.handleOnSelectionChanged)(selectionMode, detail, onSelectedChanged, isClickthroughDisabled);
        };
        const viewportConfig = scrollPolicyOptions?.scroller
            ? {
                scroller: () => {
                    if (scrollPolicyOptions.scroller) {
                        return document.querySelector(scrollPolicyOptions.scroller);
                    }
                    return null;
                }
            }
            : undefined;
        const getRowKey = (data) => {
            return data.metadata.key;
        };
        const onLoadMore = (0, hooks_1.useCallback)(() => {
            if (listData) {
                const fetchSize = scrollPolicyOptions && scrollPolicyOptions.fetchSize ? scrollPolicyOptions.fetchSize : 25;
                onLoadRange({ offset: 0, count: listData.data.length + fetchSize });
            }
        }, [listDataState, scrollPolicyOptions, onLoadRange]);
        const handleOnCurrentItemChanged = (detail) => {
            onCurrentItemChanged?.(detail.value);
        };
        return {
            status: listDataState.status,
            cardViewProps: {
                'aria-label': ariaLabel,
                'aria-labelledby': ariaLabelledBy,
                'aria-describedby': ariaDescribedBy,
                data: listData ? listData.data : null,
                getRowKey,
                gutterSize,
                hasMore: listData ? listData.sizePrecision === 'atLeast' : false,
                onLoadMore,
                focusBehavior,
                onSelectionChange: handleOnSelectionChange,
                selectedKeys,
                selectionMode: selectionMode === 'singleRequired' ? 'single' : selectionMode,
                initialAnimation,
                columns: preactColumns,
                // in preact layer, the data is a type of Item in ItemActionDetail
                viewportConfig,
                onReorder: reorderable?.items === 'enabled'
                    ? (detail) => {
                        onOjReorder && onOjReorder(detail);
                    }
                    : null,
                onPersistCurrentItem: handleOnCurrentItemChanged,
                skeletonRenderer: skeletonTemplate
            }
        };
    };
    exports.useCardViewPreact = useCardViewPreact;
});

define('oj-c/card-view/cardViewItem',["require", "exports", "preact/jsx-runtime", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "../hooks/PRIVATE_useSelectionContext/ItemKeyContext"], function (require, exports, jsx_runtime_1, UNSAFE_useTabbableMode_1, ItemKeyContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CardViewItem = void 0;
    const CardViewItem = ({ context, itemTemplate }) => {
        const tabbableModeInfo = (0, UNSAFE_useTabbableMode_1.useTabbableMode)();
        // context.data is Item<K, D> from DataProvider
        const itemContext = {
            isTabbable: tabbableModeInfo.isTabbable,
            data: context.data.data,
            item: context.data
        };
        return ((0, jsx_runtime_1.jsx)(ItemKeyContext_1.ItemKeyContext.Provider, { value: context.metadata.key, children: (0, jsx_runtime_1.jsx)(UNSAFE_useTabbableMode_1.TabbableModeContext.Provider, { value: tabbableModeInfo, children: itemTemplate && itemTemplate(itemContext) }) }));
    };
    exports.CardViewItem = CardViewItem;
});


define('oj-c/card-view/card-view',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/hooks", "ojs/ojvcomponent", "preact/compat", "@oracle/oraclejet-preact/UNSAFE_CardFlexView", "@oracle/oraclejet-preact/UNSAFE_CardGridView", "./useCardViewPreact", "./cardViewItem", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "@oracle/oraclejet-preact/UNSAFE_EmptyList", "../hooks/PRIVATE_useSelectionContext/SelectionContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useBusyStateContext", "css!oj-c/card-view/card-view-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, hooks_1, ojvcomponent_1, compat_1, UNSAFE_CardFlexView_1, UNSAFE_CardGridView_1, useCardViewPreact_1, cardViewItem_1, UNSAFE_useTranslationBundle_1, UNSAFE_EmptyList_1, SelectionContext_1, UNSAFE_useBusyStateContext_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CardView = void 0;
    const CardViewPreactWrapper = ({ isClickthroughDisabled, busyStateContext, itemTemplate, noData, ...rest }) => {
        const { status, cardViewProps } = (0, useCardViewPreact_1.useCardViewPreact)(rest, isClickthroughDisabled, busyStateContext);
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        if (status === 'success' && !cardViewProps.hasMore && cardViewProps.data?.length === 0) {
            if (noData) {
                return (0, jsx_runtime_1.jsx)(UNSAFE_EmptyList_1.EmptyList, { children: noData(compat_1.Children) });
            }
            else {
                const noDataContent = translations.noData_message();
                return (0, jsx_runtime_1.jsx)(UNSAFE_EmptyList_1.EmptyList, { children: noDataContent });
            }
        }
        const selectInfo = {
            selected: rest.selected,
            selectionMode: cardViewProps.selectionMode,
            onSelectedChange: rest.onSelectedChanged
        };
        const itemRenderer = (0, hooks_1.useCallback)((context) => {
            return (0, jsx_runtime_1.jsx)(cardViewItem_1.CardViewItem, { context: context, itemTemplate: itemTemplate });
        }, [itemTemplate]);
        if (cardViewProps.columns) {
            return ((0, jsx_runtime_1.jsx)(SelectionContext_1.SelectionContext.Provider, { value: selectInfo, children: (0, jsx_runtime_1.jsx)(UNSAFE_CardGridView_1.CardGridView, { ...cardViewProps, children: itemRenderer }) }));
        }
        else {
            return ((0, jsx_runtime_1.jsx)(SelectionContext_1.SelectionContext.Provider, { value: selectInfo, children: (0, jsx_runtime_1.jsx)(UNSAFE_CardFlexView_1.CardFlexView, { ...cardViewProps, children: itemRenderer }) }));
        }
    };
    /**
     * @classdesc
     * <h3 id="CardViewOverview-section">
     *   JET CardView Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#CardViewOverview-section"></a>
     * </h3>
     *
     * <p>Description: The JET CardView enhances a themable, WAI-ARIA compliant, mobile friendly component with advance interactive features.
     * The child content can be configured via a DataProvider which should be used for mutable data.</p>
     *
     * <p>For migration information from the card layout feature from <code>oj-list-view</code> refer to the <a href="https://jet.oraclecorp.com/trunk/jsdocs/oj.ojListView.html#styling-section">migration section</a> in the API docs.
     *
     * <h3 id="data-section">
     *   Data
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
     * </h3>
     * <p>The JET CardView gets its data from a DataProvider.</p>
     *
     * <p><b>ArrayDataProvider</b> - Use this when the underlying data is an array object or an observableArray.  In the observableArray case, CardView will automatically react
     * when items are added or removed from the array.  See the documentation for ArrayDataProvider for more details on the available options.</p>
     *
     * <p>Example of data provider content</p>
     * <pre class="prettyprint"><code>
     *   &lt;oj-c-card-view aria-label="Accessible Summary" data="[[dataProvider]]">
     *   &lt;/oj-c-card-view>
     * </code></pre>
     *
     * <p>Check out the CardView Basic demo</a>
     *
     * <h3 id="keyboard-section">
     *   Coming Features
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#coming-features-section"></a>
     * </h3>
     *
     * <p>These features will be available in forthcoming versions</p>
     * <ul>
     *    <li>Context menu</li>
     *    <li>First selected item</li>
     *    <li>Drag and drop between components</li>
     *    <li>Managing scroll position</li>
     * </ul>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan = "20" nowrap>Card Item</td>
     *       <td><kbd>F2</kbd></td>
     *       <td>Enters tabbable mode.  This enables keyboard action on elements inside the item, including navigate between focusable elements inside the item.  It can also be used to exit tabbable mode if already in tabbable mode.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Esc</kbd></td>
     *       <td>Exits tabbable mode.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Tab</kbd></td>
     *       <td>When in tabbable mode, navigates to next focusable element within the item.  If the last focusable element is reached, shift focus back to the first focusable element.
     *           When not in tabbable mode, navigates to next focusable element on page (outside CardView).</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Tab</kbd></td>
     *       <td>When in tabbable mode, navigates to previous focusable element within the item.  If the first focusable element is reached, shift focus back to the last focusable element.
     *           When not in tabbable mode, navigates to previous focusable element on page (outside CardView).</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Move focus to the item below.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Move focus to the item above.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Move focus to the item on the left.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Move focus to the item on the right.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+DownArrow</kbd></td>
     *       <td>Extend the selection to the item below.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+UpArrow</kbd></td>
     *       <td>Extend the selection to the item above.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+LeftArrow</kbd></td>
     *       <td>Extend the selection to the item on the left.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+RightArrow</kbd></td>
     *       <td>Extend the selection to the item on the right.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Space</kbd></td>
     *       <td>Toggles to select and deselect the current item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Space</kbd></td>
     *       <td>Selects contiguous items from the last selected item to the current item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Cmd/Ctrl+DownArrow</kbd></td>
     *       <td>Reorder the current item down.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Cmd/Ctrl+UpArrow</kbd></td>
     *       <td>Reorder the current item up.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Cmd/Ctrl+LeftArrow</kbd></td>
     *       <td>Reorder the current item to the left.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>Shift+Cmd/Ctrl+RightArrow</kbd></td>
     *       <td>Reorder the current item to the right.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>Application should specify a value for the aria-label attribute with a meaningful description of the purpose of this CardView.</p>
     * <p>Note that CardView uses the grid role and follows the <a href="https://www.w3.org/TR/wai-aria-practices/examples/grid/LayoutGrids.html">Layout Grid</a> design as outlined in the <a href="https://www.w3.org/TR/wai-aria-practices/#grid">grid design pattern</a></p>
     * <p>Nesting collection components such as ListView, Table, TreeView, and CardView inside of CardView is not supported.</p>
     * <p>When reorder feature is enabled, application should specify a live region which contains an announcement to notify assistive technologies that the card reordering happens.</p>
     *
     * <h4>Custom Colours</h4>
     * <p>Using colors, including background and text colors, is not accessible if it is the only way information is conveyed.
     * Low vision users may not be able to see the different colors, and in high contrast mode the colors are removed.
     * The Redwood approved way to show status is to use badge.</p>
     *
     * <h3 id="context-section">
     *   Item Context
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#context-section"></a>
     * </h3>
     *
     * <p>For all item options, developers can specify a function as the return value.  The function takes a single argument, which is an object that contains contextual information about the particular item.  This gives developers the flexibility to return different value depending on the context.</p>
     *
     * <p>The context parameter contains the following keys:</p>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>data</kbd></td>
     *       <td>The data of the item.  Note this is made available primarily to ease migration.
     *           Applications should get the data from the item property instead.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>item</kbd></td>
     *       <td>An object that contains the data and metadata for the item.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>isTabbable</kbd></td>
     *       <td>A boolean indicating whether the item is in tabbable mode or not.
     *          This should be used to implement conditional behavior for all tabbable elements, this avoids creating a keyboard trap when tabbing through the CardView.<br/>
     *          This can be implemented as a conditional tabindex, for example <code>tabindex="[[!item.isTabbable && '-1']]"</code>.<br/>
     *          When composing with core pack components, this is not needed, as they are tabbable mode aware.
     *         </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <p>The following keys are not currently supported:</p>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Key</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>componentElement</kbd></td>
     *       <td>A reference to the root element of CardView.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>datasource</kbd></td>
     *       <td>A reference to the data source object.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>index</kbd></td>
     *       <td>The index of the item, where 0 is the index of the first item.  In the hierarchical case the index is relative to its parent.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>key</kbd></td>
     *       <td>The key of the item (this duplicates item.metadata.key and has been deprecated)</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>metadata</kbd></td>
     *       <td>The metadata of the item (this is instead available in item)</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>parentElement</kbd></td>
     *       <td>This will be supported by the Hierarchical list component and no longer applies to CardView..</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="data-attributes-section">
     *   Custom Data Attributes
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-attributes-section"></a>
     * </h3>
     *
     * <p>CardView supports the following custom data attributes.
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Name</th>
     *       <th>Description</th>
     *       <th>Example</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>data-oj-as</kbd></td>
     *       <td>Provides an alias for a specific template instance and has the same subproperties as the $current variable.</td>
     *       <td>
     *         <pre class="prettyprint"><code>&lt;oj-c-card-view id="CardView">
     *   &lt;template slot="itemTemplate" data-oj-as="item">
     *   &lt;/template>
     * &lt;/oj-c-card-view></code></pre>
     *       </td>
     *     </tr>
     *     <tr>
     *       <td><kbd>data-oj-clickthrough</kbd></td>
     *       <td><p>Specify on any element inside an item where you want to control whether CardView should perform actions triggered by
     *           a click event originating from the element or one of its descendants.</p>
     *           <p>For example, if you specify this attribute with a value of "disabled" on a link inside an item, then CardView
     *           will not select or trigger itemAction event to be fired when user clicks on the link.</p>
     *           <p>Note that the currentItem will still be updated to the item that the user clicked on.</p>
     *           <p>Also note you do not need to set this attribute on core pack components such as oj-c-button, as it natively supports
     *              disabling clickthrough.</p>
     *       </td>
     *       <td>
     *         <pre class="prettyprint"><code>&lt;oj-c-card-view id="card-view">
     *   &lt;template slot="itemTemplate">
     *     &lt;a href="#" data-oj-clickthrough="disabled">&lt;/a>
     *   &lt;/template>
     * &lt;/oj-c-card-view></code></pre>
     *       </td>
     *     </tr>
     *     <tr>
     *       <td><kbd>data-oj-manage-tabs</kbd></td>
     *       <td><p>CardView does not manipulate the tabindex of the item content.  Applications should set the tabIndex of any focusable
     *          element based on the isTabbableMode property from the context pass to the itemTemplate.</p>
     *          <p>However, there will be cases where you can't control the tabindex of the content, for example, if you are using components from another team.</p>
     *          <p>In that case, applications can specify this attribute on the element or one of its ancestors so that when the itemTemplate is processed,
     *          it will scan and manipulate the tabindex of any focusable elements.</p>
     *       </td>
     *       <td>
     *         <pre class="prettyprint"><code>&lt;oj-c-card-view id="CardView">
     *   &lt;template slot="itemTemplate">
     *     &lt;some-component-with-focusable-elements data-oj-manage-tabs>&lt;/some-component-with-focusable-elements>
     *   &lt;/template>
     * &lt;/oj-c-card-view></code></pre>
     *       </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * @ojmetadata displayName "Card View"
     * @ojmetadata description "A CardView displays data items as a grid with highly interactive features."
     * @ojmetadata help "oj-c.CardView.html"
     * @ojmetadata main "oj-c/card-view"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "19.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "vbdt": {
     *     "module": "oj-c/card-view",
     *   },
     *   "oracle": {
     *     "uxSpecs": [
     *       "card-view"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "selectionMode",
     *       "gutterSize",
     *       "focusBehavior",
     *       "initialAnimation"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data",
     *       "selected"
     *     ]
     *   }
     * ]
     * @ojmetadata since "17.0.0"
     **/
    const CardViewImpl = ({ columns = 'auto', data = null, focusBehavior = 'card', gutterSize = 'sm', initialAnimation = 'slideUp', scrollPolicyOptions = { fetchSize: 25 }, selectionMode = 'none', reorderable = { items: 'disabled' }, ...rest }) => {
        const rootRef = (0, hooks_1.useRef)(null);
        const busyStateContext = (0, hooks_1.useContext)(UNSAFE_useBusyStateContext_1.BusyStateContext);
        const isClickthroughDisabled = (0, hooks_1.useCallback)((target) => {
            if (target === null || rootRef.current === null) {
                return false;
            }
            return isEventClickthroughDisabled({ target }, rootRef.current);
        }, []);
        const props = {
            columns,
            data,
            focusBehavior,
            gutterSize,
            initialAnimation,
            scrollPolicyOptions,
            selectionMode,
            reorderable,
            ...rest
        };
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: props.id, ref: rootRef, children: (0, jsx_runtime_1.jsx)(CardViewPreactWrapper, { isClickthroughDisabled: isClickthroughDisabled, busyStateContext: busyStateContext, ...props }) }));
    };
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const CardViewWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-card-view', CardViewImpl, "CardView", { "properties": { "currentItem": { "type": "string|number", "readOnly": true, "writeback": true }, "data": { "type": "DataProvider|null" }, "gutterSize": { "type": "string", "enumValues": ["sm", "md", "lg", "xs", "xl"] }, "scrollPolicyOptions": { "type": "object", "properties": { "fetchSize": { "type": "number" }, "scroller": { "type": "string" } } }, "selected": { "type": "object", "writeback": true }, "selectionMode": { "type": "string", "enumValues": ["none", "multiple", "single", "singleRequired"] }, "initialAnimation": { "type": "string", "enumValues": ["slideUp", "slideDown"] }, "focusBehavior": { "type": "string", "enumValues": ["content", "card"] }, "columns": { "type": "number|string" }, "reorderable": { "type": "object", "properties": { "items": { "type": "string", "enumValues": ["disabled", "enabled"] } } } }, "slots": { "noData": { "data": {} }, "itemTemplate": { "data": {} }, "skeletonTemplate": { "data": {} } }, "events": { "ojReorder": {} }, "extension": { "_WRITEBACK_PROPS": ["currentItem", "selected"], "_READ_ONLY_PROPS": ["currentItem"], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby", "aria-describedby", "id"] } }, { "columns": "auto", "data": null, "focusBehavior": "card", "gutterSize": "sm", "initialAnimation": "slideUp", "scrollPolicyOptions": { "fetchSize": 25 }, "selectionMode": "none", "reorderable": { "items": "disabled" } }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
    exports.CardView = CardViewWithoutDefaultedGenerics;
    // copied from DataCollectionUtils
    const isEventClickthroughDisabled = function (event, rootElement) {
        let node = event.target;
        while (node != null && node !== rootElement) {
            if (isClickthroughDisabled(node)) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    // copied from DataCollectionUtils
    const isClickthroughDisabled = function (element) {
        return element.dataset['ojClickthrough'] === 'disabled';
    };
});

define('oj-c/card-view',["require", "exports", "oj-c/card-view/card-view"], function (require, exports, card_view_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CardView = void 0;
    Object.defineProperty(exports, "CardView", { enumerable: true, get: function () { return card_view_1.CardView; } });
});

define('oj-c/conveyor-belt/conveyorBeltItem',["require", "exports", "preact/jsx-runtime", "@oracle/oraclejet-preact/UNSAFE_ConveyorBelt"], function (require, exports, jsx_runtime_1, UNSAFE_ConveyorBelt_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConveyorBeltItem = void 0;
    const ConveyorBeltItem = ({ context, itemTemplate }) => {
        // context.data is Item<K, D> from DataProvider
        const itemContext = {
            data: context.data.data,
            item: context.data
        };
        return ((0, jsx_runtime_1.jsx)(UNSAFE_ConveyorBelt_1.ConveyorBeltItem, { children: itemTemplate && itemTemplate(itemContext) }));
    };
    exports.ConveyorBeltItem = ConveyorBeltItem;
});


define('oj-c/conveyor-belt/conveyor-belt',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojcontext", "@oracle/oraclejet-preact/UNSAFE_ConveyorBelt", "@oracle/oraclejet-preact/hooks/UNSAFE_useUser", "ojs/ojvcomponent", "preact/hooks", "preact/compat", "./conveyorBeltItem", "oj-c/hooks/UNSAFE_useDataProvider/useDataProvider", "css!oj-c/conveyor-belt/conveyor-belt-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, Context, UNSAFE_ConveyorBelt_1, UNSAFE_useUser_1, ojvcomponent_1, hooks_1, compat_1, conveyorBeltItem_1, useDataProvider_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConveyorBelt = void 0;
    // TODO: refactor to a single util along with radioset 
    function isDataProvider(items) {
        return (items && 'fetchFirst' in items) || false;
    }
    const ConveyorBeltPreactWrapper = (0, compat_1.forwardRef)(({ addBusyState, onScrollPositionChanged, items, itemTemplate, children, ...rest }, ref) => {
        const conveyorRef = (0, hooks_1.useRef)(null);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            scrollElementIntoView: (element) => conveyorRef.current?.scrollElementIntoView(element),
            scrollPrevious: () => conveyorRef.current?.scrollPrevious(),
            scrollNext: () => conveyorRef.current?.scrollNext()
        }), []);
        const isFromDataProvider = isDataProvider(items);
        const { data } = (0, useDataProvider_1.useDataProvider)({
            data: isFromDataProvider ? items : undefined,
            addBusyState
        });
        const dataArr = (0, hooks_1.useMemo)(() => {
            // if the options are an array, we want to clone the prop
            const clonedOptions = !isFromDataProvider && items
                ? [...items].map((item) => {
                    const metadata = { key: item.key };
                    return {
                        key: item.key,
                        data: {
                            data: item.data,
                            metadata: metadata
                        }
                    };
                })
                : [];
            return isFromDataProvider
                ? Array.isArray(data)
                    ? data.map((item) => {
                        const metadata = { key: item.key };
                        return {
                            key: item.key,
                            data: {
                                data: item.data,
                                metadata: item.metadata ?? metadata
                            }
                        };
                    })
                    : []
                : clonedOptions;
        }, [data, isFromDataProvider, items]);
        const scrollPositionChangedHandler = (value) => {
            if (value != null)
                onScrollPositionChanged?.(value);
        };
        const childrenContent = itemTemplate
            ? dataArr.map((dataObj, index) => {
                const context = {
                    index: index,
                    data: dataObj.data,
                    metadata: dataObj.data.metadata
                };
                return (0, jsx_runtime_1.jsx)(conveyorBeltItem_1.ConveyorBeltItem, { context: context, itemTemplate: itemTemplate });
            })
            : children;
        return ((0, jsx_runtime_1.jsx)(UNSAFE_ConveyorBelt_1.ConveyorBelt, { onScrollPositionChanged: scrollPositionChangedHandler, ref: conveyorRef, ...rest, children: childrenContent }));
    });
    /**
     * @description
     * <p>Container element that manages overflow for its child
     * elements and allows scrolling among them.
     *
     *
     * <pre class="prettyprint"><code>
     * &lt;oj-c-conveyor-belt items="[[dataArray]]">
     *    &lt;template slot='itemTemplate'>
     *        &lt;oj-c-button label="[[$current.data]]"></oj-c-button>
     *     &lt;/template>
     * &lt;/oj-c-conveyor-belt>
     * </code></pre>
     *
     * <p>Use ConveyorBelt when you want to:
     * <ul>
     * <li>handle overflow without showing a scrollbar</li>
     * <li>keep all items accessible via tabbing and readable by a screen reader</li>
     * </ul>
     *
     *
     * @ojmetadata displayName "Conveyor Belt"
     * @ojmetadata description "A conveyor belt manages overflow for its child elements and allows scrolling among them."
     * @ojmetadata main "oj-c/conveyor-belt"
     * @ojmetadata help "oj-c.ConveyorBelt.html"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "17.0.0",
     *     "value": ["oj-conveyor-belt"]
     *   }
     * ]
     *
     * @ojmetadata since "17.0.0"
     */
    const ConveyorBeltComp = ({ children, orientation = 'horizontal', ...rest }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const conveyorBeltRef = (0, hooks_1.useRef)(null);
        const busyContextRef = (0, hooks_1.useRef)(Context.getContext(rootRef.current).getBusyContext());
        const addBusyState = (0, hooks_1.useCallback)((desc) => {
            return busyContextRef.current?.addBusyState({
                description: `oj-c-conveyor-belt: ${desc}`
            });
        }, []);
        const { direction } = (0, UNSAFE_useUser_1.useUser)();
        /**
         * Handles arrow key navigation when the root element has focus
         *
         * @param event
         */
        const keyDownHandler = (event) => {
            if (event.target !== rootRef.current) {
                return;
            }
            if (orientation === 'horizontal') {
                switch (event.key) {
                    case 'ArrowRight':
                        if (direction === 'rtl') {
                            conveyorBeltRef.current?.scrollPrevious();
                        }
                        else {
                            conveyorBeltRef.current?.scrollNext();
                        }
                        event.preventDefault();
                        break;
                    case 'ArrowLeft':
                        if (direction === 'rtl') {
                            conveyorBeltRef.current?.scrollNext();
                        }
                        else {
                            conveyorBeltRef.current?.scrollPrevious();
                        }
                        event.preventDefault();
                        break;
                    default:
                        break;
                }
            }
            else if (orientation === 'vertical') {
                switch (event.key) {
                    case 'ArrowDown':
                        conveyorBeltRef.current?.scrollNext();
                        event.preventDefault();
                        break;
                    case 'ArrowUp':
                        conveyorBeltRef.current?.scrollPrevious();
                        event.preventDefault();
                        break;
                    default:
                        break;
                }
            }
        };
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            scrollElementIntoView: (element) => conveyorBeltRef.current?.scrollElementIntoView(element)
        }), []);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, onKeyDown: keyDownHandler, children: (0, jsx_runtime_1.jsx)(ConveyorBeltPreactWrapper, { ref: conveyorBeltRef, addBusyState: addBusyState, orientation: orientation, ...rest, children: children }) }));
    };
    exports.ConveyorBelt = (0, ojvcomponent_1.registerCustomElement)('oj-c-conveyor-belt', (0, compat_1.forwardRef)(ConveyorBeltComp), "ConveyorBelt", { "slots": { "": {}, "itemTemplate": { "data": {} } }, "properties": { "scrollPosition": { "type": "number", "writeback": true }, "arrowVisibility": { "type": "string", "enumValues": ["auto", "hidden", "visible"] }, "items": { "type": "Array<object>|DataProvider" }, "orientation": { "type": "string", "enumValues": ["horizontal", "vertical"] } }, "extension": { "_WRITEBACK_PROPS": ["scrollPosition"], "_READ_ONLY_PROPS": [] }, "methods": { "scrollElementIntoView": {} } }, { "orientation": "horizontal" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/conveyor-belt',["require", "exports", "oj-c/conveyor-belt/conveyor-belt"], function (require, exports, conveyor_belt_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConveyorBelt = void 0;
    Object.defineProperty(exports, "ConveyorBelt", { enumerable: true, get: function () { return conveyor_belt_1.ConveyorBelt; } });
});

define('oj-c/drag-handle/drag-handle',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_DragHandle"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_DragHandle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DragHandle = void 0;
    /**
     * @classdesc
     * <h3 id="dragHandleOverview-section">
     *   JET DragHandle Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#dragHandleOverview-section"></a>
     * </h3>
     *
     * <p>Description: The JET DragHandle is a draggable icon used in components with reorder features.</p>
     *
     * @ojmetadata displayName "Drag Handle"
     * @ojmetadata description "A drag handle is a draggable icon used in components with reorder features."
     * @ojmetadata help "oj-c.DragHandle.html"
     * @ojmetadata main "oj-c/drag-handle"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Collections"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/drag-handle",
     *   },
     *   "oracle": {
     *     "uxSpecs": [
     *       "drag-handle"
     *     ]
     *   }
     * }
     * @ojmetadata since "17.0.0"
     */
    const DragHandleImpl = () => {
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_DragHandle_1.DragHandle, {}) }));
    };
    exports.DragHandle = (0, ojvcomponent_1.registerCustomElement)('oj-c-drag-handle', DragHandleImpl, "DragHandle", undefined, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/drag-handle',["require", "exports", "oj-c/drag-handle/drag-handle"], function (require, exports, drag_handle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DragHandle = void 0;
    Object.defineProperty(exports, "DragHandle", { enumerable: true, get: function () { return drag_handle_1.DragHandle; } });
});

define('oj-c/toggle-button/toggle-button',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_ToggleButton", "@oracle/oraclejet-preact/UNSAFE_IconToggleButton", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/hooks/UNSAFE_useTooltip", "@oracle/oraclejet-preact/utils/UNSAFE_mergeProps", "preact/hooks", "preact/compat", "css!oj-c/button/button-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_ToggleButton_1, UNSAFE_IconToggleButton_1, UNSAFE_useTabbableMode_1, UNSAFE_useTooltip_1, UNSAFE_mergeProps_1, hooks_1, compat_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToggleButton = void 0;
    /**
     * @classdesc
     * <h3 id="toggleButtonOverview-section">
     *   JET ToggleButton
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#toggleButtonOverview-section"></a>
     * </h3>
     *
     * <p>Description: Themeable, WAI-ARIA-compliant toggle button, with appropriate styles for hover, active, and disabled.
     *
     * <pre class="prettyprint"><code>&lt;oj-c-toggle-button id="myToggleButton" value="{{value}}" label="My ToggleButton">
     * &lt;/oj-c-toggle-button>
     * &lt;oj-c-toggle-button label="start icon">
     *   &lt;span slot='startIcon' class='myIconClass'>&lt;/span>
     * &lt;/oj-c-toggle-button>
     *  &lt;oj-c-toggle-button label="end icon">
     *   &lt;span slot='endIcon' class='myIconClass'>&lt;/span>
     * &lt;/oj-c-toggle-button>
     * </code></pre>
     *
     * <h3 id="toggleButtons-section">
     *   Toggle Buttons
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#pushToggleButtons-section"></a>
     * </h3>
     *
     * <p>Toggle Buttons allow users to switch between states when clicked or tapped.
     * Toggle buttons are created from <code class="prettyprint">oj-c-toggle-button</code> elements.
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Push ToggleButton</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Push the button.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Push Toggle Button</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Push the button.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>For accessibility, it is not required to set an aria label on a JET button as it uses the label text to generate an aria label.
     * Therefore the label should be specified even if the button is <a href="#display">icon-only (display=icons)</a>. However,
     * you can override the default behavior by setting <code class="prettyprint">aria-label</code>.
     * The label can be hidden using the display attribute.
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "Toggle Buttons allow users to switch between states when clicked or tapped."
     * @ojmetadata displayName "Toggle Button"
     * @ojmetadata help "oj-c.ToggleButton.html"
     * @ojmetadata main "oj-c/toggle-button"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/toggle-button",
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-button",
     *     "uxSpecs": [
     *       "Toggle%20Button"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "label",
     *       "tooltip",
     *       "display",
     *       "chroming",
     *       "size",
     *       "width",
     *       "disabled"
     *     ]
     *   }
     * ]
     * @ojmetadata since "17.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "17.0.0",
     *     "value": ["oj-buttonset-many"]
     *   }
     * ]
     */
    function ToggleButtonImpl({ chroming = 'outlined', disabled = false, 'aria-label': accessibleLabel, 'aria-describedby': ariaDescribedBy, width, display = 'all', value = false, label, tooltip, startIcon, endIcon, size = 'md', onValueChanged }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const buttonRef = (0, hooks_1.useRef)(null);
        const isLabelButton = display != 'icons' ||
            (startIcon && endIcon && display == 'icons') ||
            (!startIcon && !endIcon && display == 'icons');
        const widthProps = width ? { style: { width } } : {};
        const ariaProps = { 'aria-describedby': ariaDescribedBy, 'aria-label': accessibleLabel };
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => buttonRef.current?.blur(),
            focus: () => buttonRef.current?.focus(),
            click: () => buttonRef.current?.click()
        }), []);
        if (isLabelButton) {
            return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, ...widthProps, "aria-describedby": ariaDescribedBy, children: (0, jsx_runtime_1.jsx)(FunctionalToggleButton, { ref: buttonRef, isSelected: value, tooltip: tooltip, onToggle: () => {
                        onValueChanged?.(!value);
                    }, variant: chroming, isDisabled: disabled, width: width ? '100%' : undefined, startIcon: startIcon, endIcon: endIcon, size: size, label: display == 'icons' ? (!startIcon && !endIcon ? label : '') : label, display: display != 'icons' ? display : 'all', ...ariaProps }) }));
        }
        else {
            return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, ...widthProps, "aria-describedby": ariaDescribedBy, children: (0, jsx_runtime_1.jsx)(UNSAFE_IconToggleButton_1.IconToggleButton, { isSelected: value, onToggle: () => {
                        onValueChanged?.(!value);
                    }, width: width ? '100%' : undefined, ref: buttonRef, variant: chroming, isDisabled: disabled, tooltip: tooltip && tooltip !== '' ? tooltip : label, "aria-label": accessibleLabel && accessibleLabel !== '' ? accessibleLabel : label, "aria-describedby": ariaDescribedBy, size: size, children: startIcon ?? endIcon }) }));
        }
    }
    exports.ToggleButton = (0, ojvcomponent_1.registerCustomElement)('oj-c-toggle-button', (0, compat_1.forwardRef)(ToggleButtonImpl), "ToggleButton", { "properties": { "label": { "type": "string" }, "value": { "type": "boolean", "writeback": true }, "tooltip": { "type": "string" }, "disabled": { "type": "boolean" }, "width": { "type": "number|string" }, "display": { "type": "string", "enumValues": ["all", "label", "icons"] }, "size": { "type": "string", "enumValues": ["sm", "md", "lg"] }, "chroming": { "type": "string", "enumValues": ["borderless", "outlined"], "binding": { "consume": { "name": "containerChroming" } } } }, "slots": { "startIcon": {}, "endIcon": {} }, "extension": { "_WRITEBACK_PROPS": ["value"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "aria-label"] }, "methods": { "focus": {}, "blur": {}, "click": {} } }, { "chroming": "outlined", "disabled": false, "display": "all", "value": false, "size": "md" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const FunctionalToggleButton = (0, compat_1.forwardRef)((props, ref) => {
        const { tooltipContent, tooltipProps } = (0, UNSAFE_useTooltip_1.useTooltip)({
            text: props.tooltip,
            isDisabled: props.isDisabled
        });
        return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(UNSAFE_ToggleButton_1.ToggleButton, { ref: ref, ...(0, UNSAFE_mergeProps_1.mergeProps)(props, tooltipProps) }), tooltipContent] }));
    });
});

define('oj-c/toggle-button',["require", "exports", "oj-c/toggle-button/toggle-button"], function (require, exports, toggle_button_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToggleButton = void 0;
    Object.defineProperty(exports, "ToggleButton", { enumerable: true, get: function () { return toggle_button_1.ToggleButton; } });
});

define('oj-c/utils/PRIVATE_toggleUtils/toggle-item-icon',["require", "exports", "preact/jsx-runtime"], function (require, exports, jsx_runtime_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ToggleItemIcon = ToggleItemIcon;
    function ToggleItemIcon(props) {
        if (props.icon.type === 'img') {
            return (0, jsx_runtime_1.jsx)("img", { src: props.icon.src });
        }
        else {
            return (0, jsx_runtime_1.jsx)("span", { class: props.icon.class });
        }
    }
});

define('oj-c/utils/PRIVATE_toggleUtils/widthStyle',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.widthStyle = widthStyle;
    // layoutWidth equal uses 100% width, over-riding any width value, just like legacy.
    function widthStyle(layoutWidth, width, maxWidth) {
        return layoutWidth == 'equal'
            ? maxWidth
                ? { style: { width: '100%', maxWidth: maxWidth } }
                : { style: { width: '100%' } }
            : width
                ? maxWidth
                    ? { style: { width: width, maxWidth: maxWidth } }
                    : { style: { width: width } }
                : maxWidth
                    ? { style: { maxWidth: maxWidth } }
                    : {};
    }
});

define('oj-c/utils/PRIVATE_toggleUtils/index',["require", "exports", "./toggle-item-icon", "./widthStyle"], function (require, exports, toggle_item_icon_1, widthStyle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.widthStyle = exports.ToggleItemIcon = void 0;
    Object.defineProperty(exports, "ToggleItemIcon", { enumerable: true, get: function () { return toggle_item_icon_1.ToggleItemIcon; } });
    Object.defineProperty(exports, "widthStyle", { enumerable: true, get: function () { return widthStyle_1.widthStyle; } });
});


define('oj-c/buttonset-single/buttonset-single',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_ButtonSetSingle", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "oj-c/utils/PRIVATE_toggleUtils/index", "@oracle/oraclejet-preact/UNSAFE_ButtonSetItem", "preact/compat", "preact/hooks", "css!oj-c/buttonset-single/buttonset-single-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_ButtonSetSingle_1, UNSAFE_useTabbableMode_1, index_1, UNSAFE_ButtonSetItem_1, compat_1, hooks_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ButtonsetSingle = void 0;
    /**
     * @classdesc
     * <h3 id="ButtonsetSingleOverview-section">
     *   JET Buttonset Single
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonSetSingleOverview-section"></a>
     * </h3>
     *
     * <p>Description: A Buttonset Single is a grouping of related buttons where only one button may be selected.
     *
     * <pre class="prettyprint"><code>&lt;oj-c-buttonset-single aria-label="Pick an Item" value="{{value}}" items="[[items]]">
     * &lt;/oj-c-buttonset-single>
     * </code></pre>
     *
     * <h3 id="toolbar-section">
     * Toolbar Usage
     * </h3>
     * <p>Note that oj-c-buttonset-single is not intended for usage inside oj-toolbar, it is only
     * supported in oj-c-toolbar.</p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Push Toggle Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Toggle the button.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Buttonset Single</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Toggle the focused Button.</td>
     *     </tr>
     *     <tr>
     *       <td>Buttonset Single</td>
     *       <td><kbd>Right Arrow</kbd></td>
     *       <td>Move focus to the next enabled Button, wrapping as needed.</td>
     *     </tr>
     *     <tr>
     *       <td>Buttonset Single</td>
     *       <td><kbd>Left Arrow</kbd></td>
     *       <td>Move focus to the previous enabled Button, wrapping as needed.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     *  <p>The application is responsible for applying <code class="prettyprint">aria-label</code> and/or
     * <code class="prettyprint">aria-controls</code> attributes like the following to the buttonset element, if applicable per the instructions that follow:
     *
     * <pre class="prettyprint">
     * <code>aria-label="Choose only one beverage."
     * aria-controls="myTextEditor"
     * </code></pre>
     *
     * <p>An <code class="prettyprint">aria-label</code> conveying the "choose only one" semantics should be included for a buttonset-single.
     *
     * <p>The <code class="prettyprint">aria-controls</code> attribute should be included if the buttonset is controlling something else on the page, e.g.
     * bold / italic / underline buttons controlling a rich text editor.  If the buttonset is contained in a toolbar, <code class="prettyprint">aria-controls</code>
     * should be placed on the toolbar, not on the buttonsets within the toolbar.
     *
     *  {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "A Buttonset Single allows a user to select the state of one or more related options."
     * @ojmetadata displayName "Buttonset Single"
     * @ojmetadata help "oj-c.ButtonsetSingle.html"
     * @ojmetadata main "oj-c/buttonset-single"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/buttonset-single",
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-buttonset-single",
     *     "uxSpecs": [
     *       "Toggle%20Button"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "label",
     *       "tooltip",
     *       "display",
     *       "chroming",
     *       "size",
     *       "width",
     *       "edge",
     *       "disabled"
     *       "items",
     *       "layoutWidth",
     *       "maxWidth"
     *     ]
     *   }
     * ]
     * @ojmetadata since "17.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "17.0.0",
     *     "value": ["oj-buttonset-one"]
     *   }
     * ]
     */
    function ButtonsetSingleImpl({ chroming = 'outlined', disabled = false, value, onValueChanged, size = 'md', width, maxWidth, layoutWidth, items = [], display = 'all', 'aria-label': accessibleLabel, 'aria-describedby': ariaDescribedBy, ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const buttonsetRef = (0, hooks_1.useRef)();
        const widthProps = (0, index_1.widthStyle)(layoutWidth, width, maxWidth);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => buttonsetRef.current?.blur(),
            focus: () => buttonsetRef.current?.focus()
        }), [buttonsetRef]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ...widthProps, ref: rootRef, children: (0, jsx_runtime_1.jsx)(FunctionalButtonSetSingle, { value: value, onCommit: (detail) => {
                    onValueChanged?.(detail.value);
                }, ref: buttonsetRef, display: display, variant: chroming, layoutWidth: layoutWidth, size: size, width: widthProps.style ? (widthProps.style.width ? '100%' : undefined) : undefined, "aria-label": accessibleLabel, "aria-describedby": ariaDescribedBy, isDisabled: disabled, ...otherProps, children: items?.map((item) => {
                    return ((0, jsx_runtime_1.jsx)(UNSAFE_ButtonSetItem_1.ButtonSetItem, { label: item.label, value: item.value, isDisabled: item.disabled, startIcon: item.startIcon && (0, jsx_runtime_1.jsx)(index_1.ToggleItemIcon, { icon: item.startIcon }), endIcon: item.endIcon && (0, jsx_runtime_1.jsx)(index_1.ToggleItemIcon, { icon: item.endIcon }) }));
                }) }) }));
    }
    exports.ButtonsetSingle = (0, ojvcomponent_1.registerCustomElement)('oj-c-buttonset-single', (0, compat_1.forwardRef)(ButtonsetSingleImpl), "ButtonsetSingle", { "properties": { "value": { "type": "string", "writeback": true }, "items": { "type": "Array<object>" }, "display": { "type": "string", "enumValues": ["all", "label", "icons"] }, "disabled": { "type": "boolean" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg"] }, "width": { "type": "number|string" }, "maxWidth": { "type": "number|string" }, "chroming": { "type": "string", "enumValues": ["borderless", "outlined"], "binding": { "consume": { "name": "containerChroming" } } }, "layoutWidth": { "type": "string", "enumValues": ["auto", "equal"] } }, "extension": { "_WRITEBACK_PROPS": ["value"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "aria-label"] }, "methods": { "focus": {}, "blur": {} } }, { "chroming": "outlined", "disabled": false, "size": "md", "items": [], "display": "all" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const FunctionalButtonSetSingle = (0, compat_1.forwardRef)((props, ref) => {
        const buttonRef = (0, hooks_1.useRef)();
        // We need to support methods on the custom-element layer which can only
        // be done using a class-based component. So, we will wrap this
        // functionality-packed functional component in a class-based component.
        // But, the class-based component will still need a way to pass through
        // method calls, so we will be using useImperativeHandle to add these
        // methods to this functional component's ref which can then be called
        // by the wrapping class-based component.
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            focus: () => buttonRef.current?.focus(),
            blur: () => buttonRef.current?.blur()
        }), []);
        return (0, jsx_runtime_1.jsx)(UNSAFE_ButtonSetSingle_1.ButtonSetSingle, { ref: buttonRef, ...props });
    });
});

define('oj-c/buttonset-single',["require", "exports", "oj-c/buttonset-single/buttonset-single"], function (require, exports, buttonset_single_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ButtonsetSingle = void 0;
    Object.defineProperty(exports, "ButtonsetSingle", { enumerable: true, get: function () { return buttonset_single_1.ButtonsetSingle; } });
});


define('oj-c/buttonset-multiple/buttonset-multiple',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_ButtonSetMultiple", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "oj-c/utils/PRIVATE_toggleUtils/index", "@oracle/oraclejet-preact/UNSAFE_ButtonSetItem", "preact/hooks", "preact/compat", "css!oj-c/buttonset-multiple/buttonset-multiple-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_ButtonSetMultiple_1, UNSAFE_useTabbableMode_1, index_1, UNSAFE_ButtonSetItem_1, hooks_1, compat_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ButtonsetMultiple = void 0;
    /**
     * @classdesc
     * <h3 id="ButtonsetMultipleOverview-section">
     *   JET Buttonset Multiple
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#buttonSetMultipleOverview-section"></a>
     * </h3>
     *
     * <p>Description: A Buttonset Multiple is a grouping of related buttons where any number of buttons may be selected.
     *
     * <pre class="prettyprint"><code>&lt;oj-c-buttonset-multiple aria-label="Pick Items" value="{{value}}" items="[[items]]">
     * &lt;/oj-c-buttonset-multiple>
     * </code></pre>
     *
     * <h3 id="toolbar-section">
     * Toolbar Usage
     * </h3>
     * <p>Note that oj-c-buttonset-multiple is not intended for usage inside oj-toolbar, it is only
     * supported in oj-c-toolbar.</p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Push Toggle Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Toggle the button.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Buttonset Multiple</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Toggle the focused Button.</td>
     *     </tr>
     *     <tr>
     *       <td>Buttonset Multiple</td>
     *       <td><kbd>Right Arrow</kbd></td>
     *       <td>Move focus to the next enabled Button, wrapping as needed.</td>
     *     </tr>
     *     <tr>
     *       <td>Buttonset Multiple</td>
     *       <td><kbd>Left Arrow</kbd></td>
     *       <td>Move focus to the previous enabled Button, wrapping as needed.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>The application is responsible for applying <code class="prettyprint">aria-label</code> and/or
     * <code class="prettyprint">aria-controls</code> attributes like the following to the buttonset element, if applicable per the instructions that follow:
     *
     * <pre class="prettyprint">
     * <code>aria-label="Choose beverages."
     * aria-controls="myTextEditor"
     * </code></pre>
     *
     * <p>An <code class="prettyprint">aria-label</code> conveying the "choose multiple" semantics should be included for a buttonset-multiple.
     *
     * <p>The <code class="prettyprint">aria-controls</code> attribute should be included if the buttonset is controlling something else on the page, e.g.
     * bold / italic / underline buttons controlling a rich text editor.  If the buttonset is contained in a toolbar, <code class="prettyprint">aria-controls</code>
     * should be placed on the toolbar, not on the buttonsets within the toolbar.
     *
     *  {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "A Buttonset Multiple allows a user to select the states of one or more related options."
     * @ojmetadata displayName "Buttonset Multiple"
     * @ojmetadata help "oj-c.ButtonsetMultiple.html"
     * @ojmetadata main "oj-c/buttonset-multiple"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/buttonset-multiple",
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-buttonset-multiple",
     *     "uxSpecs": [
     *        "Toggle%20Button"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "label",
     *       "tooltip",
     *       "display",
     *       "chroming",
     *       "size",
     *       "width",
     *       "edge",
     *       "disabled"
     *       "items",
     *       "layoutWidth",
     *       "maxWidth"
     *     ]
     *   }
     * ]
     * @ojmetadata since "17.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "17.0.0",
     *     "value": ["oj-buttonset-many"]
     *   }
     * ]
     */
    function ButtonsetMultipleImpl({ chroming = 'outlined', disabled = false, value, onValueChanged, size = 'md', width, maxWidth, layoutWidth, items = [], display = 'all', 'aria-label': accessibleLabel, 'aria-describedby': ariaDescribedBy, ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const buttonsetRef = (0, hooks_1.useRef)();
        const widthProps = (0, index_1.widthStyle)(layoutWidth, width, maxWidth);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => buttonsetRef.current?.blur(),
            focus: () => buttonsetRef.current?.focus()
        }), [buttonsetRef]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ...widthProps, ref: rootRef, children: (0, jsx_runtime_1.jsx)(FunctionalButtonSetMultiple, { value: value, onCommit: (detail) => {
                    onValueChanged?.(detail.value);
                }, ref: buttonsetRef, display: display, layoutWidth: layoutWidth, variant: chroming, size: size, width: widthProps.style ? (widthProps.style.width ? '100%' : undefined) : undefined, "aria-label": accessibleLabel, "aria-describedby": ariaDescribedBy, isDisabled: disabled, ...otherProps, children: items?.map((item) => {
                    return ((0, jsx_runtime_1.jsx)(UNSAFE_ButtonSetItem_1.ButtonSetItem, { label: item.label, value: item.value, isDisabled: item.disabled, startIcon: item.startIcon && (0, jsx_runtime_1.jsx)(index_1.ToggleItemIcon, { icon: item.startIcon }), endIcon: item.endIcon && (0, jsx_runtime_1.jsx)(index_1.ToggleItemIcon, { icon: item.endIcon }) }));
                }) }) }));
    }
    exports.ButtonsetMultiple = (0, ojvcomponent_1.registerCustomElement)('oj-c-buttonset-multiple', (0, compat_1.forwardRef)(ButtonsetMultipleImpl), "ButtonsetMultiple", { "properties": { "value": { "type": "Array<string>", "writeback": true }, "items": { "type": "Array<object>" }, "display": { "type": "string", "enumValues": ["all", "label", "icons"] }, "disabled": { "type": "boolean" }, "size": { "type": "string", "enumValues": ["sm", "md", "lg"] }, "width": { "type": "number|string" }, "maxWidth": { "type": "number|string" }, "chroming": { "type": "string", "enumValues": ["borderless", "outlined"], "binding": { "consume": { "name": "containerChroming" } } }, "layoutWidth": { "type": "string", "enumValues": ["auto", "equal"] } }, "extension": { "_WRITEBACK_PROPS": ["value"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "aria-label"] }, "methods": { "focus": {}, "blur": {} } }, { "chroming": "outlined", "disabled": false, "size": "md", "items": [], "display": "all" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const FunctionalButtonSetMultiple = (0, compat_1.forwardRef)((props, ref) => {
        const buttonRef = (0, hooks_1.useRef)();
        // We need to support methods on the custom-element layer which can only
        // be done using a class-based component. So, we will wrap this
        // functionality-packed functional component in a class-based component.
        // But, the class-based component will still need a way to pass through
        // method calls, so we will be using useImperativeHandle to add these
        // methods to this functional component's ref which can then be called
        // by the wrapping class-based component.
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            focus: () => buttonRef.current?.focus(),
            blur: () => buttonRef.current?.blur()
        }), []);
        return (0, jsx_runtime_1.jsx)(UNSAFE_ButtonSetMultiple_1.ButtonSetMultiple, { ref: buttonRef, ...props });
    });
});

define('oj-c/buttonset-multiple',["require", "exports", "oj-c/buttonset-multiple/buttonset-multiple"], function (require, exports, buttonset_multiple_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ButtonsetMultiple = void 0;
    Object.defineProperty(exports, "ButtonsetMultiple", { enumerable: true, get: function () { return buttonset_multiple_1.ButtonsetMultiple; } });
});

define('oj-c/table/hooks/UNSAFE_useWhenReadyContext/useWhenReadyContext',["require", "exports", "preact/hooks", "ojs/ojcontext"], function (require, exports, hooks_1, Context) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useWhenReadyContext = useWhenReadyContext;
    function useWhenReadyContext(elemRef) {
        const whenReady = (0, hooks_1.useCallback)((timeout) => {
            // If the component is not mounted, just resolve
            return elemRef.current
                ? Context.getContext(elemRef.current).getBusyContext().whenReady(timeout)
                : Promise.resolve();
        }, [elemRef]);
        const busyContext = (0, hooks_1.useMemo)(() => ({
            whenReady
        }), [whenReady]);
        return busyContext;
    }
});

define('oj-c/table/utils/TableRendererUtils',["require", "exports", "preact/jsx-runtime"], function (require, exports, jsx_runtime_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRowContext = getRowContext;
    exports.getPreactRowKey = getPreactRowKey;
    exports.getPreactCellRenderer = getPreactCellRenderer;
    exports.getPreactHeaderRenderer = getPreactHeaderRenderer;
    exports.getPreactFooterRenderer = getPreactFooterRenderer;
    exports.getPreactNoDataRenderer = getPreactNoDataRenderer;
    exports.tableCellSelectorRenderer = tableCellSelectorRenderer;
    exports.tableHeaderSelectorRenderer = tableHeaderSelectorRenderer;
    function getRowContext(context) {
        return { item: context.data };
    }
    function getPreactRowKey(data) {
        return data.metadata.key;
    }
    function getPreactCellRenderer(cellTemplate, field) {
        return (context) => {
            const templateContext = {
                item: context.rowData,
                columnKey: context.columnKey,
                data: field != null ? context.rowData.data[field] : undefined,
                isTabbable: context.isTabbable
            };
            if (cellTemplate != null) {
                return cellTemplate(templateContext);
            }
            return templateContext.data != null ? String(templateContext.data) : undefined;
        };
    }
    function getPreactHeaderRenderer(headerTemplate) {
        if (headerTemplate != null) {
            return (context) => {
                const templateContext = {
                    key: context.key,
                    headerText: context.headerText,
                    isTabbable: context.isTabbable
                };
                return headerTemplate(templateContext);
            };
        }
        return undefined;
    }
    function getPreactFooterRenderer(footerTemplate) {
        if (footerTemplate != null) {
            return (context) => {
                const templateContext = {
                    key: context.key,
                    footerText: context.footerText,
                    isTabbable: context.isTabbable
                };
                return footerTemplate(templateContext);
            };
        }
        return undefined;
    }
    function getPreactNoDataRenderer(noData) {
        if (noData != null) {
            return (context) => {
                return noData({ isTabbable: context.isTabbable });
            };
        }
        return undefined;
    }
    function tableCellSelectorRenderer(context) {
        return context.selector != null ? context.selector() : undefined;
    }
    function tableHeaderSelectorRenderer(context) {
        return context.selector != null ? ((0, jsx_runtime_1.jsx)("div", { "data-oj-table-selector": 'all', children: context.selector() })) : undefined;
    }
});


define('oj-c/table/table',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojcustomelement-registry", "ojs/ojkeyset", "ojs/ojvcomponent", "preact/hooks", "./hooks/UNSAFE_useWhenReadyContext/useWhenReadyContext", "../hooks/UNSAFE_useListData/useListData", "../utils/PRIVATE_keyUtils/keySetUtils", "@oracle/oraclejet-preact/hooks/UNSAFE_useBusyStateContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useCollectionInteractionContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTableViewColumnResizing", "@oracle/oraclejet-preact/UNSAFE_TableView", "./utils/TableRendererUtils", "css!oj-c/table/table-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojcustomelement_registry_1, ojkeyset_1, ojvcomponent_1, hooks_1, useWhenReadyContext_1, useListData_1, keySetUtils_1, UNSAFE_useBusyStateContext_1, UNSAFE_useCollectionInteractionContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTableViewColumnResizing_1, UNSAFE_TableView_1, TableRendererUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Table = void 0;
    const _SELECTION_COLUMN_KEY = 'oj-c-table_selection';
    const _selectedDefault = {};
    const _selectionModeDefault = { row: 'none', column: 'none' };
    const _scrollPolicyOptionsDefault = { fetchSize: 25 };
    // copied from DataCollectionUtils
    const _isClickthroughDisabled = function (element) {
        return element.dataset['ojClickthrough'] === 'disabled';
    };
    // copied from DataCollectionUtils
    const _isEventClickthroughDisabled = function (event, rootElement) {
        let node = event.target;
        while (node != null && node !== rootElement) {
            if (_isClickthroughDisabled(node)) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    };
    /**
     * @classdesc
     * <h3 id="tableOverview-section">
     *   JET Table Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#tableOverview-section"></a>
     * </h3>
     *
     * <p>Description: The Table component presents data in a tabular format with highly interactive features.
     *
     * <h3 id="data-section">
     *   Data
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-section"></a>
     * </h3>
     * <p>The JET Table gets its data from a DataProvider.</p>
     *
     * <p>Example of data provider content</p>
     * <pre class="prettyprint"><code>&lt;oj-c-table data="[[dataProvider]]">&lt;/oj-c-table></code></pre>
     *
     *
     * <h3 id="coming-features-section">
     *   Coming Features
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#coming-features-section"></a>
     * </h3>
     *
     * <p>These features will be available in forthcoming versions</p>
     * <ul>
     *     <li>Sorting</li>
     *     <li>Drag and Drop</li>
     *     <li>Editing</li>
     *     <li>Add Row</li>
     *     <li>Page Scrolling</li>
     *     <li>First Selected Row</li>
     *     <li>Sticky Columns</li>
     *     <li>Edge To Edge Padding</li>
     *     <li>Tree Data</li>
     *     <li>Context menu</li>
     *     <li>Per Row Selectable</li>
     *     <li>Group By Table</li>
     * </ul>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="18" style="vertical-align:top;">Data Cell</td>
     *       <td>Tab</td>
     *       <td>Move browser focus to next tab stop on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Tab</td>
     *       <td>Move browser focus to previous tab stop on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>F2</td>
     *       <td>If there is focusable content in the current cell, move browser focus to the first focusable element in the current cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Esc</td>
     *       <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Up Arrow</td>
     *       <td>Focus the cell above the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Down Arrow</td>
     *       <td>Focus the cell below the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Left Arrow</td>
     *       <td>Focus the cell to the left of the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Right Arrow</td>
     *       <td>Focus the cell to the right of the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Up Arrow</td>
     *       <td>If multiple row selection is enabled, begin or extend a range selection to include the next row in the given direction without changing the currently focused cell. If multipleToggle row selection is enabled, begin or extend a range selection to include the next row in the given direction while also changing the currently focused cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Down Arrow</td>
     *       <td>If multiple row selection is enabled, begin or extend a range selection to include the next row in the given direction without changing the currently focused cell. If multipleToggle row selection is enabled, begin or extend a range selection to include the next row in the given direction while also changing the currently focused cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Space</td>
     *       <td>If row selection is enabled, toggle the selection state of the current row. Additionally, if row actions are enabled, trigger an ojRowAction event. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Enter</td>
     *       <td>If there is focusable content in the current cell, move browser focus to the first focusable element in the current cell. Additionally, if row actions are enabled, trigger an ojRowAction event. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Page Up</td>
     *       <td>Focus the corresponding cell in the first visible data row and scroll to make that data row the last visible data row of the table if possible.</td>
     *     </tr>
     *     <tr>
     *       <td>Page Down</td>
     *       <td>Focus the corresponding cell in the last visible data row and scroll to make that data row the first visible data row of the table if possible.</td>
     *     </tr>
     *     <tr>
     *       <td>Home</td>
     *       <td>Focus the first cell in the current row.</td>
     *     </tr>
     *     <tr>
     *       <td>End</td>
     *       <td>Focus the last cell in the current row.</td>
     *     </tr>
     *     <tr>
     *       <td>Ctrl/Cmd + Home</td>
     *       <td>Focus the first cell in the first row.</td>
     *     </tr>
     *     <tr>
     *       <td>Ctrl/Cmd + End</td>
     *       <td>Focus the last cell in the last available row.</td>
     *     </tr>
     *
     *     <tr>
     *       <td rowspan="18" style="vertical-align:top;">Header Cell</td>
     *       <td>Tab</td>
     *       <td>Move browser focus to next tab stop on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Tab</td>
     *       <td>Move browser focus to previous tab stop on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>F2</td>
     *       <td>If there is focusable content in the current header cell, move browser focus to the first focusable element in the current header cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Esc</td>
     *      <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Up Arrow</td>
     *       <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Down Arrow</td>
     *       <td>Focus the cell below the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Left Arrow</td>
     *       <td>Focus the header cell to the left of the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Right Arrow</td>
     *       <td>Focus the header cell to the right of the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Left Arrow</td>
     *       <td>If multiple column selection is enabled, begin or extend a range selection to include the next column in the given direction without changing the currently focused header cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Right Arrow</td>
     *       <td>If multiple column selection is enabled, begin or extend a range selection to include the next column in the given direction without changing the currently focused header cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Space</td>
     *       <td>If column selection is enabled and the current column is selectable, toggle the selection state of the current column. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Enter</td>
     *       <td>If there is focusable content in the current header cell, move browser focus to the first focusable element in the current header cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Page Up</td>
     *       <td>Focus the corresponding cell in the first visible data row and scroll to make that data row the last visible data row of the table if possible.</td>
     *     </tr>
     *     <tr>
     *       <td>Page Down</td>
     *       <td>Focus the corresponding cell in the last visible data row and scroll to make that data row the first visible data row of the table if possible.</td>
     *     </tr>
     *     <tr>
     *       <td>Home</td>
     *       <td>Focus the first header cell.</td>
     *     </tr>
     *     <tr>
     *       <td>End</td>
     *       <td>Focus the last header cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Ctrl/Cmd + Home</td>
     *       <td>Focus the first cell in the first row.</td>
     *     </tr>
     *     <tr>
     *       <td>Ctrl/Cmd + End</td>
     *       <td>Focus the last cell in the last available row.</td>
     *     </tr>
     *
     *
     *     <tr>
     *       <td rowspan="18" style="vertical-align:top;">Footer Cell</td>
     *       <td>Tab</td>
     *       <td>Move browser focus to next tab stop on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Tab</td>
     *       <td>Move browser focus to previous tab stop on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>F2</td>
     *       <td>If there is focusable content in the current footer cell, move browser focus to the first focusable element in the current footer cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Esc</td>
     *       <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Up Arrow</td>
     *       <td>Focus the cell above the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Down Arrow</td>
     *       <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Left Arrow</td>
     *       <td>Focus the footer cell to the left of the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Right Arrow</td>
     *       <td>Focus the footer cell to the right of the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Left Arrow</td>
     *       <td>If multiple column selection is enabled, begin or extend a range selection to include the next column in the given direction without changing the currently focused footer cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Right Arrow</td>
     *       <td>If multiple column selection is enabled, begin or extend a range selection to include the next column in the given direction without changing the currently focused footer cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Space</td>
     *       <td>If column selection is enabled and the current column is selectable, toggle the selection state of the current column. No action otherwise.</td>
     *     </tr>
     *    <tr>
     *       <td>Enter</td>
     *       <td>If there is focusable content in the current footer cell, move browser focus to the first focusable element in the current footer cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Page Up</td>
     *       <td>Focus the corresponding cell in the first visible data row and scroll to make that data row the last visible data row of the table if possible.</td>
     *     </tr>
     *     <tr>
     *       <td>Page Down</td>
     *       <td>Focus the corresponding cell in the last visible data row and scroll to make that data row the first visible data row of the table if possible.</td>
     *     </tr>
     *     <tr>
     *       <td>Home</td>
     *       <td>Focus the first footer cell.</td>
     *     </tr>
     *     <tr>
     *       <td>End</td>
     *       <td>Focus the last footer cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Ctrl/Cmd + Home</td>
     *       <td>Focus the first cell in the first row.</td>
     *     </tr>
     *     <tr>
     *       <td>Ctrl/Cmd + End</td>
     *       <td>Focus the last cell in the last available row.</td>
     *     </tr>
     *
     *
     *     <tr>
     *       <td rowspan="10" style="vertical-align:top;">No Data Cell</td>
     *       <td>Tab</td>
     *       <td>Move browser focus to next tab stop on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Tab</td>
     *       <td>Move browser focus to previous tab stop on the page.</td>
     *     </tr>
     *     <tr>
     *       <td>F2</td>
     *       <td>If there is focusable content in the no data cell, move browser focus to the first focusable element in the no data cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Esc</td>
     *       <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Up Arrow</td>
     *       <td>Focus the first header cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Down Arrow</td>
     *       <td>If footer cells are rendered, focus the first footer cell. No action otherwise.</td>
     *     </tr>
     *     <tr>
     *       <td>Left Arrow</td>
     *       <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Right Arrow</td>
     *       <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Space</td>
     *       <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Enter</td>
     *       <td>If there is focusable content in the no data cell, move browser focus to the first focusable element in the no data cell. No action otherwise.</td>
     *     </tr>
     *
     *
     *     <tr>
     *       <td rowspan="18" style="vertical-align:top;">Focused Cell Content</td>
     *       <td>Tab</td>
     *       <td>Move browser focus to the next focusable element in the table. If that element is already focused, move browser focus to the first focusable element in the table.</td>
     *     </tr>
     *     <tr>
     *       <td>Shift + Tab</td>
     *       <td>Move browser focus to the previous focusable element in the table. If that element is already focused, move browser focus to the last focusable element in the table.</td>
     *     </tr>
     *     <tr>
     *       <td>F2</td>
     *       <td>Restore focus to the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Esc</td>
     *       <td>Restore focus to the current cell.</td>
     *     </tr>
     *     <tr>
     *       <td>Space</td>
     *       <td>No action.</td>
     *     </tr>
     *     <tr>
     *       <td>Enter</td>
     *       <td>No action.</td>
     *     </tr>
     *
     *   </tbody>
     * </table>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td rowspan="1" style="vertical-align:top;">
     *         Data Cell
     *       </td>
     *       <td>Tap</td>
     *       <td>Focus the data cell. Additionally, if row selection is enabled and the current row is selectable, toggle the selection state of the current row. Additionally, if row actions are enabled, trigger an ojRowAction event.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="1" style="vertical-align:top;">
     *         Header Cell
     *       </td>
     *       <td>Tap</td>
     *       <td>Focus the header cell. Additionally, if column selection is enabled and the current column is selectable, toggle the selection state of the current column.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="1" style="vertical-align:top;">
     *         Footer Cell
     *       </td>
     *       <td>Tap</td>
     *       <td>Focus the footer cell. Additionally, if column selection is enabled and the current column is selectable, toggle the selection state of the current column.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="1" style="vertical-align:top;">
     *         No Data Cell
     *       </td>
     *       <td>Tap</td>
     *       <td>Focus the no data cell.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>The Table implements the grid role for accessibility. This enables the Table to be compatible with the special 'table
     * reading' commands that most assistive technologies provide in addition to the standard keyboard interactions described
     * in the Keyboard End User Information section above.</p>
     *
     * <p>An application is required to include contextual information to make the Table accessible for assistive technologies
     * by providing one or more the following properties as appropriate:</p>
     *
     * <ul>
     *   <li>aria-labelledby</li>
     *   <li>aria-label</li>
     * </ul>
     *
     * <p>Additionally, an application should specify at least 1 accessible row header per row by providing a value for the
     * <code>row.accessible-row-header</code> attribute. The information in the cell(s) specified will be used by assistive technologies
     * to convey basic contextual information for the focused row. For example, if a user is arrowing up or down in an 'Amount Due'
     * column, having something like '$500' read out does not provide any helpful information as to who or what that amount corresponds
     * to. If an 'Account Holder' column is specified as an accessible row header, then something like 'Larry Ellison, $500' would be read
     * out instead. Providing this additional row context is essential for creating accessible tables.</p>
     *
     * <h4>Managing Tab Stops</h4>
     * <p>The Table does not manipulate the <code>tabindex</code> attribute of cell contents. For oj-c components specified
     * as children of the Table, <code>tabindex</code> management will happen automatically. Otherwise, applications must
     * specifically set the <code>tabindex</code> of tabbable child elements based on the <code>isTabbable</code> property
     * of the template context.</p>
     * <p>However, there may be cases where applications do not have access to the tabbable elements themselves. For
     * example, a third-party component that does not support JET's new <code>tabindex</code> management. In that case,
     * applications can specify the <code>data-oj-manage-tabs</code> attribute on any tabbable elements (or any one of
     * their ancestors) to ensure the Table remains a single tab stop for accessibility purposes.</p>
     *
     * <h4>Custom Colors</h4>
     * <p>Using colors, including background and text colors, is not accessible if it is the only way information is conveyed.
     * Low vision users may not be able to see the different colors, and in high contrast mode the colors are removed.
     * The Redwood approved way to show status is to use a badge.</p>
     *
     * <h3 id="background-section">
     *   Background Color
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#background-section"></a>
     * </h3>
     *
     * <p>The Table's background color is managed via the --oj-current-bg-color CSS variable. If a different
     * background color is desired, one can be set by adding a background color class on the Table. <b>The Table does
     * not support background colors with transparencies.</b> See the 'Background Color' cookbook demo for examples.
     * </p>
     *
     * <h3 id="data-attributes-section">
     *   Custom Data Attributes
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#data-attributes-section"></a>
     * </h3>
     *
     * <p>Table supports the following custom data attributes.
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Name</th>
     *       <th>Description</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td><kbd>data-oj-as</kbd></td>
     *       <td><p>Provides an alias for a specific template instance and has the same subproperties as the $current variable.</p>
     *         <pre class="prettyprint"><code>&lt;oj-c-table id="table">
     *   &lt;template slot="cellTemplate" data-oj-as="cell">
     *   &lt;/template>
     * &lt;/oj-c-table></code></pre>
     *       </td>
     *     </tr>
     *     <tr>
     *       <td><kbd>data-oj-clickthrough</kbd></td>
     *       <td><p>Specify on any element inside a cell where you want to control whether the Table should perform actions triggered
     *         by a click event originating from the element or one of its descendants.</p>
     *         <p>For example, if you specify this attribute with a value of "disabled" on a button inside a cell, the Table
     *         will not select the row or trigger an action event when a user clicks on the button.</p>
     *         <pre class="prettyprint"><code>&lt;oj-c-table id="table">
     *   &lt;template slot="cellTemplate">
     *     &lt;oj-c-button data-oj-clickthrough="disabled">&lt;/oj-c-button>
     *   &lt;/template>
     * &lt;/oj-c-table></code></pre>
     *       </td>
     *     </tr>
     *     <tr>
     *       <td><kbd>data-oj-manage-tabs</kbd></td>
     *       <td><p>The Table does not manipulate the <code>tabindex</code> attribute of cell contents. For oj-c elements
     *         specified as children of the Table, <code>tabindex</code> management will happen automatically. Otherwise,
     *         applications must specifically set the <code>tabindex</code> of tabbable child elements based on the
     *         <code>isTabbable</code> property of the template context.</p>
     *         <p>However, there may be cases where applications do not have access to the tabbable elements themselves. For
     *         example, a third-party component that does not support JET's new <code>tabindex</code> management. In that case,
     *         applications can specify the <code>data-oj-manage-tabs</code> attribute on any tabbable elements (or any one
     *         of their ancestors) to ensure the Table remains a single tab stop for accessibility purposes.</p>
     *         <pre class="prettyprint"><code>&lt;oj-c-table>
     *   &lt;template slot="cellTemplate1" data-oj-as="cell">
     *     &lt;a href="#" :tabindex="[[cell.isTabbable ? 0 : -1]]">Link&lt;/a>
     *   &lt;/template>
     *   &lt;template slot="cellTemplate2" data-oj-as="cell">
     *     &lt;some-tabbable-component data-oj-manage-tabs>&lt;/some-tabbable-component>
     *   &lt;/template>
     * &lt;/oj-c-table></code></pre>
     *       </td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * @ojmetadata displayName "Table"
     * @ojmetadata description "A table displays data items in a tabular format with highly interactive features."
     * @ojmetadata help "oj-c.Table.html"
     * @ojmetadata main "oj-c/table"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "17.1.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Collections"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/table",
     *     "defaultColumns": 12,
     *     "minColumns": 2,
     *   },
     *   "oracle": {
     *     "uxSpecs": ["table"],
     *     "icon" : "oj-ux-ico-tables-basic"
     *   }
     * }
     *
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "selectionMode.row",
     *       "selectionMode.column",
     *       "horizontalGridVisible",
     *       "verticalGridVisible"
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "data",
     *       "columns",
     *       "selected.row",
     *       "selected.column"
     *     ]
     *   }
     * ]
     * @ojmetadata since "17.1.0"
     */
    function TableImpl({ 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, id, data, columns, row, horizontalGridVisible = 'enabled', verticalGridVisible = 'disabled', layout = 'contents', currentCellOverride, onCurrentCellChanged, selected = _selectedDefault, selectionMode = _selectionModeDefault, onSelectedChanged, selectAllControl = 'visible', columnOrder, cellTemplate, headerTemplate, footerTemplate, templates, onOjRowAction, noData, columnWidths, onColumnWidthsChanged, columnResizeBehavior = 'redistribute', scrollPolicyOptions = _scrollPolicyOptionsDefault }) {
        const rootRef = (0, hooks_1.useRef)(null);
        const tableViewRef = (0, hooks_1.useRef)(null);
        const isClickthroughDisabled = (0, hooks_1.useCallback)((target) => {
            if (target == null || rootRef.current == null) {
                return false;
            }
            return _isEventClickthroughDisabled({ target }, rootRef.current);
        }, []);
        const [listDataState, onLoadRange] = (0, useListData_1.useListData)(data, {
            fetchSize: scrollPolicyOptions?.fetchSize
        });
        // At this point, core-pack supports just loadMoreOnScroll
        const onLoadMore = (0, hooks_1.useCallback)(() => {
            if (listDataState.status === 'success' && listDataState.data && onLoadRange) {
                const fetchSize = scrollPolicyOptions && scrollPolicyOptions.fetchSize != null
                    ? scrollPolicyOptions.fetchSize
                    : 25;
                onLoadRange({ offset: 0, count: listDataState.data.data.length + fetchSize });
            }
        }, [listDataState, onLoadRange, scrollPolicyOptions]);
        const hasMore = listDataState.status === 'loading' ||
            (listDataState.status === 'success' && listDataState.data.sizePrecision === 'atLeast');
        const isMultipleRowSelection = selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle';
        const [realizedColumnWidths, setRealizedColumnWidths] = (0, hooks_1.useState)(() => {
            const preactColumnWidths = { ...columnWidths };
            if (isMultipleRowSelection) {
                preactColumnWidths[_SELECTION_COLUMN_KEY] = 36;
            }
            return preactColumnWidths;
        });
        (0, hooks_1.useEffect)(() => {
            const updated = { ...columnWidths };
            if (isMultipleRowSelection) {
                updated[_SELECTION_COLUMN_KEY] = 36;
            }
            setRealizedColumnWidths(updated);
        }, [columnWidths, isMultipleRowSelection]);
        // add a keydown handler to handle spacebar on select all column header
        const handleKeyDown = (0, hooks_1.useCallback)((event) => {
            if (event.key === ' ') {
                const targetElement = event.target;
                if (targetElement.children.length > 0 &&
                    targetElement.children[0].dataset['ojTableSelector'] === 'all' &&
                    !event.repeat) {
                    let newRowSelection;
                    if (selected.row?.isAddAll() && selected.row.keys.deletedKeys?.size === 0) {
                        newRowSelection = new ojkeyset_1.KeySetImpl();
                    }
                    else {
                        newRowSelection = new ojkeyset_1.AllKeySetImpl();
                    }
                    onSelectedChanged({
                        row: newRowSelection,
                        column: new ojkeyset_1.KeySetImpl()
                    });
                }
            }
        }, [onSelectedChanged, selected]);
        const selectAllHandlerProps = isMultipleRowSelection && selectAllControl !== 'hidden' ? { onKeyDown: handleKeyDown } : {};
        const preactColumnOrder = (0, hooks_1.useMemo)(() => {
            const newColumnOrder = [];
            let hasSelectorColumn = false;
            if (isMultipleRowSelection) {
                newColumnOrder.push(_SELECTION_COLUMN_KEY);
                hasSelectorColumn = true;
            }
            if (columns != null) {
                if (columnOrder != null) {
                    for (const key of columnOrder) {
                        // don't allow for duplicate column keys to be specified
                        if (columns[key] != null && !newColumnOrder.includes(key)) {
                            newColumnOrder.push(key);
                        }
                    }
                }
                else {
                    for (const [key] of Object.entries(columns)) {
                        if (key !== _SELECTION_COLUMN_KEY) {
                            newColumnOrder.push(key);
                        }
                    }
                }
            }
            // don't include columns if only the selector column is present
            return newColumnOrder.length === 1 && hasSelectorColumn ? [] : newColumnOrder;
        }, [columnOrder, columns, isMultipleRowSelection]);
        const preactColumns = (0, hooks_1.useMemo)(() => {
            const preactColumns = {};
            if (columns != null) {
                if (isMultipleRowSelection) {
                    preactColumns[_SELECTION_COLUMN_KEY] = {
                        sticky: 'enabled',
                        selectable: 'disabled',
                        renderer: TableRendererUtils_1.tableCellSelectorRenderer,
                        headerRenderer: selectAllControl !== 'hidden' ? TableRendererUtils_1.tableHeaderSelectorRenderer : undefined,
                        padding: 'disabled',
                        headerPadding: 'disabled',
                        tooltip: 'disabled',
                        headerTooltip: 'disabled',
                        accessibleColumnHeader: 'disabled'
                    };
                }
                Object.keys(columns).forEach((key) => {
                    // js doesn't allow object.keys to be typed as C
                    const colKey = key;
                    const column = columns[colKey];
                    const cellRenderer = column.template && templates && templates[column.template]
                        ? (0, TableRendererUtils_1.getPreactCellRenderer)(templates[column.template], column.field)
                        : (0, TableRendererUtils_1.getPreactCellRenderer)(cellTemplate, column.field);
                    const headerCellRenderer = column.headerTemplate && templates && templates[column.headerTemplate]
                        ? (0, TableRendererUtils_1.getPreactHeaderRenderer)(templates[column.headerTemplate])
                        : (0, TableRendererUtils_1.getPreactHeaderRenderer)(headerTemplate);
                    const footerCellRenderer = column.footerTemplate && templates && templates[column.footerTemplate]
                        ? (0, TableRendererUtils_1.getPreactFooterRenderer)(templates[column.footerTemplate])
                        : (0, TableRendererUtils_1.getPreactFooterRenderer)(footerTemplate);
                    const headerText = column.headerText ?? undefined;
                    const footerText = column.footerText ?? undefined;
                    const maxWidth = column.maxWidth ?? undefined;
                    const minWidth = column.minWidth ?? undefined;
                    const weight = column.weight ?? undefined;
                    let padding;
                    const columnPadding = column.padding;
                    if (typeof columnPadding === 'function') {
                        padding = (context) => {
                            const internalContext = (0, TableRendererUtils_1.getRowContext)(context);
                            return columnPadding(internalContext);
                        };
                    }
                    else {
                        padding = columnPadding ?? 'enabled';
                    }
                    const headerPadding = column.headerPadding ?? 'enabled';
                    const footerPadding = column.footerPadding ?? 'enabled';
                    let tooltip;
                    const columnTooltip = column.tooltip;
                    if (typeof columnTooltip === 'function') {
                        tooltip = (context) => {
                            const internalContext = (0, TableRendererUtils_1.getRowContext)(context);
                            return columnTooltip(internalContext);
                        };
                    }
                    else {
                        tooltip = columnTooltip ?? 'enabled';
                    }
                    const headerTooltip = column.headerTooltip ?? 'enabled';
                    const footerTooltip = column.footerTooltip ?? 'enabled';
                    const sticky = column.sticky ?? 'disabled';
                    const horizontalAlignment = column.horizontalAlignment ?? 'start';
                    const resizable = column.resizable ?? 'disabled';
                    let edgeResizable = resizable;
                    if (resizable === 'enabled' && columnResizeBehavior === 'redistribute') {
                        // if last column, edgeResizable is disabled
                        const position = preactColumnOrder.indexOf(colKey);
                        const isLastColumn = position === preactColumnOrder.length - 1;
                        const nextColumnKey = !isLastColumn ? preactColumnOrder[position + 1] : undefined;
                        const nextColumnResizable = nextColumnKey != null ? columns[nextColumnKey]?.resizable : undefined;
                        edgeResizable =
                            isLastColumn || nextColumnResizable !== 'enabled' ? 'disabled' : 'enabled';
                    }
                    preactColumns[colKey] = {
                        headerText: headerText,
                        footerText: footerText,
                        renderer: cellRenderer,
                        headerRenderer: headerCellRenderer,
                        footerRenderer: footerCellRenderer,
                        maxWidth,
                        minWidth,
                        weight,
                        padding,
                        headerPadding,
                        footerPadding,
                        tooltip,
                        headerTooltip,
                        footerTooltip,
                        sticky,
                        horizontalAlignment,
                        resizable,
                        edgeResizable
                    };
                });
            }
            return preactColumns;
        }, [
            columns,
            cellTemplate,
            headerTemplate,
            footerTemplate,
            selectAllControl,
            templates,
            isMultipleRowSelection,
            columnResizeBehavior,
            preactColumnOrder
        ]);
        const preactData = listDataState.status === 'success' ? listDataState?.data?.data || [] : [];
        const preactGetAccessibleRowHeaders = (preactContext) => {
            const internalContext = (0, TableRendererUtils_1.getRowContext)(preactContext);
            const rowHeaders = new Set();
            if (row != null && row.accessibleRowHeader != null) {
                if (typeof row.accessibleRowHeader === 'string') {
                    rowHeaders.add(row.accessibleRowHeader);
                }
                else if (Array.isArray(row.accessibleRowHeader)) {
                    row.accessibleRowHeader.forEach((header) => rowHeaders.add(header));
                }
                else if (typeof row.accessibleRowHeader === 'function') {
                    const result = row.accessibleRowHeader(internalContext);
                    if (typeof result === 'string') {
                        rowHeaders.add(result);
                    }
                    else if (Array.isArray(result)) {
                        result.forEach((header) => rowHeaders.add(header));
                    }
                }
            }
            else if (preactColumnOrder.length > 0) {
                // column order is only populated if at least 1 non-selector columns is valid
                if (isMultipleRowSelection) {
                    rowHeaders.add(preactColumnOrder[1]);
                }
                else {
                    rowHeaders.add(preactColumnOrder[0]);
                }
            }
            return rowHeaders;
        };
        const preactOnRowAction = (0, hooks_1.useCallback)((eventDetail) => {
            if (onOjRowAction && eventDetail != null && !isClickthroughDisabled(eventDetail.target)) {
                onOjRowAction({ context: (0, TableRendererUtils_1.getRowContext)(eventDetail.context) });
            }
        }, [onOjRowAction, isClickthroughDisabled]);
        const gridlines = (0, hooks_1.useMemo)(() => ({
            horizontal: horizontalGridVisible === 'enabled' ? 'visible' : 'hidden',
            vertical: verticalGridVisible === 'enabled' ? 'visible' : 'hidden'
        }), [horizontalGridVisible, verticalGridVisible]);
        const noDataRenderer = (0, hooks_1.useMemo)(() => {
            return (0, TableRendererUtils_1.getPreactNoDataRenderer)(noData);
        }, [noData]);
        const preactSelected = (0, hooks_1.useMemo)(() => {
            return selected
                ? {
                    row: selected.row ? (0, keySetUtils_1.keySetToKeys)(selected.row) : undefined,
                    column: selected.column ? (0, keySetUtils_1.keySetToKeys)(selected.column) : undefined
                }
                : undefined;
        }, [selected]);
        const preactOnSelectionChange = (0, hooks_1.useCallback)((detail) => {
            if (!isClickthroughDisabled(detail.target)) {
                const value = detail.value;
                const rowKeySet = value.row
                    ? (0, keySetUtils_1.keysToKeySet)(value.row)
                    : undefined;
                const columnKeySet = value.column
                    ? (0, keySetUtils_1.keysToKeySet)(value.column)
                    : undefined;
                // cast as ImmutableKeySet<C> since the default selector column does not support selection
                onSelectedChanged({
                    row: rowKeySet,
                    column: columnKeySet
                });
            }
        }, [onSelectedChanged, isClickthroughDisabled]);
        const onPersistCurrentCell = (0, hooks_1.useCallback)((detail) => {
            if (onCurrentCellChanged) {
                onCurrentCellChanged(detail.value);
            }
        }, [onCurrentCellChanged]);
        const preactContextMenuConfig = (0, hooks_1.useMemo)(() => {
            return {
                itemsRenderer: (context) => {
                    return context.defaultMenuItems;
                }
            };
        }, []);
        const busyStateContext = (0, hooks_1.useContext)(UNSAFE_useBusyStateContext_1.BusyStateContext);
        const childBusyStateContext = (0, useWhenReadyContext_1.useWhenReadyContext)(tableViewRef);
        const resolveDataBusyStateRef = (0, hooks_1.useRef)();
        const resolveContentBusyStateRef = (0, hooks_1.useRef)();
        const [isInitialLoading, setIsInitialLoading] = (0, hooks_1.useState)(layout === 'contents');
        const isInitialLoadingRef = (0, hooks_1.useRef)(isInitialLoading);
        (0, hooks_1.useEffect)(() => {
            if (listDataState.status === 'loading') {
                // if loading, create a new data busy state
                resolveDataBusyStateRef.current = busyStateContext.addBusyState('loading data');
            }
            else {
                // only create children busy state on initial load of contents layout
                if (isInitialLoadingRef.current) {
                    resolveContentBusyStateRef.current = busyStateContext.addBusyState('content initializing');
                    childBusyStateContext.whenReady().then(function () {
                        // resolve the child busy state once content is ready for sizing
                        if (resolveContentBusyStateRef.current) {
                            resolveContentBusyStateRef.current();
                            resolveContentBusyStateRef.current = undefined;
                        }
                        setIsInitialLoading(false);
                        isInitialLoadingRef.current = false;
                    });
                }
            }
            return () => {
                // clear busy states to ensure no orphaned busy states persist on unmount
                if (resolveDataBusyStateRef.current) {
                    resolveDataBusyStateRef.current();
                    resolveDataBusyStateRef.current = undefined;
                }
                if (resolveContentBusyStateRef.current) {
                    resolveContentBusyStateRef.current();
                    resolveContentBusyStateRef.current = undefined;
                }
            };
        }, [listDataState.status, busyStateContext, childBusyStateContext]);
        const handleColumnWidthsChange = (0, hooks_1.useCallback)((newWidths) => {
            setRealizedColumnWidths(newWidths);
            if (onColumnWidthsChanged) {
                onColumnWidthsChanged(newWidths);
            }
        }, [onColumnWidthsChanged]);
        const handleColumnResizing = (0, hooks_1.useCallback)((newWidths) => {
            setRealizedColumnWidths(newWidths);
        }, []);
        const { columnResizingProps } = (0, UNSAFE_useTableViewColumnResizing_1.useTableViewColumnResizing)({
            columnOrder: preactColumnOrder,
            columnWidths: realizedColumnWidths,
            onColumnWidthsChanging: handleColumnResizing,
            onColumnWidthsChange: handleColumnWidthsChange,
            resizeBehavior: columnResizeBehavior
        });
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, children: (0, jsx_runtime_1.jsx)("div", { ref: tableViewRef, "data-oj-context": true, ...selectAllHandlerProps, ...(cellTemplate ? { 'data-oj-ct': true } : {}), ...(headerTemplate ? { 'data-oj-ht': true } : {}), ...(footerTemplate ? { 'data-oj-ft': true } : {}), ...(noData ? { 'data-oj-ndt': true } : {}), style: "display: contents;", children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormVariantContext_1.FormVariantContext.Provider, { value: 'embedded', children: (0, jsx_runtime_1.jsx)(ojvcomponent_1.ReportBusyContext.Provider, { value: tableViewRef, children: (0, jsx_runtime_1.jsx)(UNSAFE_TableView_1.TableView, { "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, columns: preactColumns, contextMenuConfig: preactContextMenuConfig, data: preactData, getRowKey: TableRendererUtils_1.getPreactRowKey, getAccessibleRowHeaders: preactGetAccessibleRowHeaders, gridlines: gridlines, layout: isInitialLoading ? 'pending' : layout, selected: preactSelected, selectionMode: selectionMode, onSelectionChange: preactOnSelectionChange, columnOrder: preactColumnOrder, onRowAction: preactOnRowAction, noDataRenderer: noDataRenderer, onLoadMore: onLoadMore, hasMore: hasMore, currentCellOverride: currentCellOverride, onPersistCurrentCell: onPersistCurrentCell, width: '100%', ...columnResizingProps }) }) }) }) }));
    }
    // register oj-c-table custom element
    // **** must run BEFORE the user assistance density update below ****
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const TableWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-table', TableImpl, "Table", { "properties": { "layout": { "type": "string", "enumValues": ["fixed", "contents"] }, "data": { "type": "DataProvider" }, "columns": { "type": "object" }, "row": { "type": "object", "properties": { "accessibleRowHeader": { "type": "string|Array<string>|function" } } }, "horizontalGridVisible": { "type": "string", "enumValues": ["disabled", "enabled"] }, "verticalGridVisible": { "type": "string", "enumValues": ["disabled", "enabled"] }, "selected": { "type": "object", "properties": { "column": { "type": "object" }, "row": { "type": "object" } }, "writeback": true }, "selectionMode": { "type": "object", "properties": { "column": { "type": "string", "enumValues": ["none", "multiple", "single"] }, "row": { "type": "string", "enumValues": ["none", "multiple", "single", "multipleToggle"] } } }, "selectAllControl": { "type": "string", "enumValues": ["hidden", "visible"] }, "columnOrder": { "type": "Array<string>", "writeback": true }, "currentCellOverride": { "type": "object" }, "currentCell": { "type": "object", "readOnly": true, "writeback": true }, "columnWidths": { "type": "object", "writeback": true }, "scrollPolicyOptions": { "type": "object", "properties": { "fetchSize": { "type": "number" } } }, "columnResizeBehavior": { "type": "string", "enumValues": ["add", "redistribute"] } }, "slots": { "cellTemplate": { "data": {} }, "headerTemplate": { "data": {} }, "footerTemplate": { "data": {} }, "noData": { "data": {} } }, "extension": { "_DYNAMIC_SLOT": { "prop": "templates", "isTemplate": 1 }, "_WRITEBACK_PROPS": ["selected", "columnOrder", "currentCell", "columnWidths"], "_READ_ONLY_PROPS": ["currentCell"], "_OBSERVED_GLOBAL_PROPS": ["aria-label", "aria-labelledby", "id"] }, "events": { "ojRowAction": { "bubbles": true } } }, { "horizontalGridVisible": "enabled", "verticalGridVisible": "disabled", "layout": "contents", "selected": {}, "selectionMode": { "row": "none", "column": "none" }, "selectAllControl": "visible", "columnResizeBehavior": "redistribute", "scrollPolicyOptions": { "fetchSize": 25 } }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useCollectionInteractionContext_1.CollectionInteractionContext] });
    exports.Table = TableWithoutDefaultedGenerics;
    // propagate 'compact' userAssistanceDensity defaults to underlying components
    // **** must run AFTER the custom element registration above ****
    const metadata = (0, ojcustomelement_registry_1.getMetadata)('oj-c-table');
    metadata.properties.__oj_private_do_not_use_userAssistanceDensity = {
        binding: {
            provide: [
                { name: 'containerUserAssistanceDensity', default: 'compact' },
                { name: 'userAssistanceDensity', default: 'compact' }
            ]
        }
    };
});

define('oj-c/table',["require", "exports", "oj-c/table/table"], function (require, exports, table_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Table = void 0;
    Object.defineProperty(exports, "Table", { enumerable: true, get: function () { return table_1.Table; } });
});


define('oj-c/progress-button/progress-button',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_ProgressButton", "@oracle/oraclejet-preact/UNSAFE_IconProgressButton", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/hooks/UNSAFE_useTooltip", "@oracle/oraclejet-preact/utils/UNSAFE_mergeProps", "preact/hooks", "preact/compat", "css!oj-c/progress-button/progress-button-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_ProgressButton_1, UNSAFE_IconProgressButton_1, UNSAFE_useTabbableMode_1, UNSAFE_useTooltip_1, UNSAFE_mergeProps_1, hooks_1, compat_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressButton = void 0;
    /**
     * @classdesc
     * <h3 id="progressButtonOverview-section">
     *   JET Progress Button
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#progressButtonOverview-section"></a>
     * </h3>
     *
     * <p>Description: A Progress button represents button-level action initiation.
     *
     * <pre class="prettyprint"><code>&lt;oj-c-progress-button id="myButton" label="My Button">
     * &lt;/oj-c-progress-button>
     * &lt;oj-c-progress-button label="start icon" is-loading="[[loading]]" on-oj-action="[[handler]]" >
     *   &lt;span slot='startIcon' class='myIconClass'>&lt;/span>
     * &lt;/oj-c-progress-button>
     * </code></pre>
     *
     * <h3 id="progressButtons-section">
     *   Progress Buttons
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#progressButtons-section"></a>
     * </h3>
     *
     * <p>Progress buttons communicate
     * button-level initiation of an indeterminate action with a typical progress span of less
     * than 8 seconds.  They reflect a user's brief interaction with a button.
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Progress Button</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Push the button.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Progress Button</td>
     *       <td><kbd>Enter</kbd> or <kbd>Space</kbd></td>
     *       <td>Push the button.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>For accessibility, it is not required to set an aria label on a JET button as it uses the label text to generate an aria label.
     * Therefore the label should be specified even if the button is <a href="#display">icon-only (display=icons)</a>. However,
     * you can override the default behavior by setting <code class="prettyprint">aria-label</code>.
     * The label can be hidden using the display attribute.
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "A Progress button represents button-level initiation."
     * @ojmetadata displayName "Progress Button"
     * @ojmetadata help "oj-c.ProgressButton.html"
     * @ojmetadata main "oj-c/progress-button"
     * @ojmetadata since "17.1.0"
     * @ojmetadata status [
     *   {
     *     "type": "production",
     *     "since": "17.1.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/progress-button",
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-button",
     *     "uxSpecs": [
     *       "button"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "label",
     *       "tooltip",
     *       "display",
     *       "chroming",
     *       "isloading",
     *       "size",
     *       "width",
     *       "edge",
     *       "disabled"
     *     ]
     *   }
     * ]
     */
    function ProgressButtonImpl({ chroming = 'outlined', disabled = false, size = 'md', display = 'all', startIcon, edge = 'none', tooltip, isLoading, width, label, onOjAction, ...otherProps }, ref) {
        const rootRef = (0, hooks_1.useRef)();
        const buttonRef = (0, hooks_1.useRef)(null);
        const isLabelButton = display != 'icons' || (!startIcon && display == 'icons');
        const widthSize = { width: edge === 'bottom' ? '100%' : width };
        const widthProps = width || edge !== 'none' ? { style: widthSize } : {};
        const ariaProps = { 'aria-label': label };
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => buttonRef?.current?.blur(),
            focus: () => buttonRef?.current?.focus(),
            click: () => buttonRef?.current?.click()
        }), []);
        if (isLabelButton) {
            return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, ...widthProps, children: (0, jsx_runtime_1.jsx)(FunctionalProgressButton, { ref: buttonRef, type: "submit", variant: chroming, isDisabled: disabled, width: '100%', onAction: onOjAction, startIcon: startIcon, isLoading: isLoading, size: size, label: display == 'icons' ? (!startIcon ? label : '') : label, display: display != 'icons' ? display : 'all', ...otherProps }) }));
        }
        else {
            return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { ref: rootRef, ...widthProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_IconProgressButton_1.IconProgressButton, { width: '100%', ref: buttonRef, type: "submit", variant: chroming, isDisabled: disabled, isLoading: isLoading, tooltip: label, onAction: onOjAction, size: size, ...ariaProps, ...otherProps, children: startIcon }) }));
        }
    }
    exports.ProgressButton = (0, ojvcomponent_1.registerCustomElement)('oj-c-progress-button', (0, compat_1.forwardRef)(ProgressButtonImpl), "ProgressButton", { "properties": { "label": { "type": "string" }, "tooltip": { "type": "string" }, "disabled": { "type": "boolean" }, "isLoading": { "type": "boolean" }, "width": { "type": "number|string" }, "display": { "type": "string", "enumValues": ["all", "label", "icons"] }, "size": { "type": "string", "enumValues": ["sm", "md", "lg"] }, "edge": { "type": "string", "enumValues": ["none", "bottom"] }, "chroming": { "type": "string", "enumValues": ["solid", "borderless", "outlined", "callToAction"], "binding": { "consume": { "name": "containerChroming" } } } }, "slots": { "startIcon": {} }, "events": { "ojAction": { "bubbles": true } }, "methods": { "focus": {}, "blur": {}, "click": {} } }, { "chroming": "outlined", "disabled": false, "size": "md", "display": "all", "edge": "none" }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const FunctionalProgressButton = (0, compat_1.forwardRef)((props, ref) => {
        const { tooltipContent, tooltipProps } = (0, UNSAFE_useTooltip_1.useTooltip)({
            text: props.tooltip,
            isDisabled: props.isDisabled
        });
        return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(UNSAFE_ProgressButton_1.ProgressButton, { ref: ref, ...(0, UNSAFE_mergeProps_1.mergeProps)(props, tooltipProps) }), tooltipContent] }));
    });
});

define('oj-c/progress-button',["require", "exports", "oj-c/progress-button/progress-button"], function (require, exports, progress_button_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgressButton = void 0;
    Object.defineProperty(exports, "ProgressButton", { enumerable: true, get: function () { return progress_button_1.ProgressButton; } });
});

define('oj-c/skeleton/skeleton',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_Skeleton", "ojs/ojvcomponent"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_Skeleton_1, ojvcomponent_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Skeleton = void 0;
    /**
     * @classdesc
     * <h3 id="skeletonOverview-section">
     *   JET Skeleton
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#skeletonOverview-section"></a>
     * </h3>
     * <p>Description: A skeleton gives a visual representation that content is loading. </p>
     * <p>The oj-c-skeleton is a component that may be placed within the skeletonTemplate of oj-c-card-view.
     *
     * <pre class="prettyprint">
     * <code>
     &lt;oj-c-card-view
     *    id="cardview"
                class="demo-card-view"
                aria-label="cardview with custom skeleton"
                data=[[dataProvider]]>
            &lt;template slot="skeletonTemplate" data-oj-as="context">
              &lt;div class="oj-panel oj-sm-padding-0
               :style="[[context.loadingStatus === 'initial' ? { width: '300px', height: '240px' } : { width: context.width, height: context.height } ]]">
                  &lt;oj-c-skeleton height ="100%">
                  &lt;/oj-c-skeleton>
              &lt;/div>
            &lt;/template>
            &lt;template data-oj-as="item" slot="itemTemplate">
              &lt;div class="oj-panel">
                &lt;demo-profile-card-layout
                  name="[[item.data.name]]"
                  initials="[[item.data.initials]]"
                >
                &lt;/demo-profile-card-layout>
              &lt;/div>
            &lt;/template>
     * &lt;/oj-c-card-view>
     * </code></pre>
     *
     * @ojmetadata description "The skeleton component allows the appropriate skeleton to be rendered based on the property values"
     * @ojmetadata displayName "Skeleton"
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Collections"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/skeleton"
     *   }
     * }
     * @ojmetadata help "oj-c.Skeleton.html"
     * @ojmetadata since "18.0.0"
     * @ojmetadata status [
     *   {
     *    type: "production",
     *    since: "19.0.0"
     *   }
     * ]
     */
    const SkeletonImpl = ({ height, width, borderRadius }) => {
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_Skeleton_1.Skeleton, { height: height, width: width, borderRadius: borderRadius }) }));
    };
    exports.Skeleton = (0, ojvcomponent_1.registerCustomElement)('oj-c-skeleton', SkeletonImpl, "Skeleton", { "properties": { "height": { "type": "number|string" }, "width": { "type": "number|string" }, "borderRadius": { "type": "number|string" } } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/skeleton',["require", "exports", "oj-c/skeleton/skeleton"], function (require, exports, skeleton_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Skeleton = void 0;
    Object.defineProperty(exports, "Skeleton", { enumerable: true, get: function () { return skeleton_1.Skeleton; } });
});

define('oj-c/toolbar/items-toolbar',["require", "exports", "preact/jsx-runtime", "@oracle/oraclejet-preact/UNSAFE_Toolbar", "oj-c/button", "oj-c/menu-button", "oj-c/split-menu-button", "oj-c/utils/PRIVATE_ItemsMenu/menu-item-icon", "oj-c/buttonset-single", "oj-c/buttonset-multiple", "oj-c/toggle-button", "oj-c/progress-button"], function (require, exports, jsx_runtime_1, UNSAFE_Toolbar_1, button_1, menu_button_1, split_menu_button_1, menu_item_icon_1, buttonset_single_1, buttonset_multiple_1, toggle_button_1, progress_button_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ItemsToolbar = void 0;
    const toMenuItemIcon = (icon) => {
        return icon && (0, jsx_runtime_1.jsx)(menu_item_icon_1.MenuItemIcon, { icon: icon });
    };
    const toIconProps = (item) => {
        return {
            startIcon: toMenuItemIcon(item.startIcon),
            endIcon: toMenuItemIcon(item.endIcon)
        };
    };
    const ItemsToolbar = ({ items = [], size, chroming, toolbarSelection = {}, onToolbarSelectionChanged, onOjToolbarAction, onOjToolbarSelection }) => {
        const setSelectionValue = (selection, value, key, menuButtonSelection = {}) => {
            let updatedSelection = { ...selection };
            if (!key) {
                // special logic for updating selection for menu buttons
                for (const k in menuButtonSelection) {
                    //delete select multiple selections when missing from incoming change value, using menuButtonSelection to determine which key to index
                    if (!(k in value))
                        delete updatedSelection[k];
                }
                //overwrite previous selection group values with new ones
                updatedSelection = { ...updatedSelection, ...value };
            }
            else {
                if (Array.isArray(value) && value.length === 0) {
                    delete updatedSelection[key];
                }
                else {
                    updatedSelection[key] = value;
                }
            }
            return updatedSelection;
        };
        const getItemActionHandler = (key, onAction) => {
            return () => {
                onAction?.();
                onOjToolbarAction?.({ key });
            };
        };
        const getSelectionChanges = (selection, key = '', value) => {
            onOjToolbarSelection?.({ value: value, toolbarSelectionGroupKey: key });
            onToolbarSelectionChanged?.(setSelectionValue(selection, value, key));
        };
        const getMenuButtonSelection = (toolbarSelection, menuItems, menuButtonSelection) => {
            menuItems?.forEach((item) => {
                if (item.type === 'selectsingle' || item.type === 'selectmultiple') {
                    if (item.key in toolbarSelection) {
                        menuButtonSelection[item.key] = toolbarSelection[item.key];
                    }
                }
                else if (item.type === 'submenu') {
                    menuButtonSelection = getMenuButtonSelection(toolbarSelection, item.items, menuButtonSelection);
                }
            });
            return menuButtonSelection;
        };
        return ((0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: items.map((item) => {
                switch (item.type) {
                    case 'button': {
                        return ((0, jsx_runtime_1.jsx)(button_1.Button, { disabled: item.disabled, display: item.display, label: item.label, tooltip: item.tooltip, chroming: item.chroming || chroming, size: size, "data-oj-private-key": item.key, onOjAction: getItemActionHandler(item.key, item.onAction), ...toIconProps(item) }));
                    }
                    case 'menu-button': {
                        let menuButtonSelection = {};
                        menuButtonSelection = getMenuButtonSelection(toolbarSelection, item.items, menuButtonSelection);
                        return ((0, jsx_runtime_1.jsx)(menu_button_1.MenuButton, { disabled: item.disabled, display: item.display, label: item.label, tooltip: item.tooltip, items: item.items, suffix: item.suffix, chroming: item.chroming || chroming, size: size, "data-oj-private-key": item.key, onOjMenuAction: getItemActionHandler(''), selection: menuButtonSelection, onOjMenuSelection: (value) => {
                                onOjToolbarSelection?.({
                                    value: value,
                                    toolbarSelectionGroupKey: ''
                                });
                            }, onSelectionChanged: (value) => {
                                onToolbarSelectionChanged?.(setSelectionValue(toolbarSelection, value, '', menuButtonSelection));
                            }, ...toIconProps(item) }));
                    }
                    case 'split-menu-button': {
                        return ((0, jsx_runtime_1.jsx)(split_menu_button_1.SplitMenuButton, { size: size, disabled: item.disabled, label: item.label, tooltip: item.tooltip, items: item.items, chroming: item.chroming, "data-oj-private-key": item.key, onOjAction: getItemActionHandler(item.key, item.onAction) }));
                    }
                    case 'buttonset-single': {
                        return ((0, jsx_runtime_1.jsx)(buttonset_single_1.ButtonsetSingle, { disabled: item.disabled, display: item.display, items: item.items, chroming: item.chroming || chroming, size: size, value: toolbarSelection[item.key], "data-oj-private-key": item.key, onValueChanged: (value) => {
                                getSelectionChanges(toolbarSelection, item.key, value);
                            } }));
                    }
                    case 'buttonset-multiple': {
                        return ((0, jsx_runtime_1.jsx)(buttonset_multiple_1.ButtonsetMultiple, { disabled: item.disabled, display: item.display, items: item.items, chroming: item.chroming || chroming, size: size, value: toolbarSelection[item.key], "data-oj-private-key": item.key, onValueChanged: (value) => {
                                getSelectionChanges(toolbarSelection, item.key, value);
                            } }));
                    }
                    case 'toggle-button': {
                        return ((0, jsx_runtime_1.jsx)(toggle_button_1.ToggleButton, { disabled: item.disabled, display: item.display, label: item.label, tooltip: item.tooltip, chroming: item.chroming || chroming, size: size, value: toolbarSelection[item.key], "data-oj-private-key": item.key, onValueChanged: (value) => {
                                getSelectionChanges(toolbarSelection, item.key, value);
                            }, ...toIconProps(item) }));
                    }
                    case 'progress-button': {
                        return ((0, jsx_runtime_1.jsx)(progress_button_1.ProgressButton, { disabled: item.disabled, display: item.display, label: item.label, tooltip: item.tooltip, isLoading: item.isLoading, chroming: item.chroming || chroming, size: size, "data-oj-private-key": item.key, onOjAction: getItemActionHandler(item.key, item.onAction), startIcon: toMenuItemIcon(item.startIcon) }));
                    }
                    case 'separator':
                        return (0, jsx_runtime_1.jsx)(UNSAFE_Toolbar_1.ToolbarSeparator, {});
                    default:
                        return;
                }
            }) }));
    };
    exports.ItemsToolbar = ItemsToolbar;
});

define('oj-c/toolbar/toolbar',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/UNSAFE_Toolbar", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "ojs/ojvcomponent", "./items-toolbar"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_Toolbar_1, UNSAFE_useTabbableMode_1, ojvcomponent_1, items_toolbar_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Toolbar = void 0;
    exports.Toolbar = (0, ojvcomponent_1.registerCustomElement)('oj-c-toolbar', 
    /**
     * @classdesc
     * <h3 id="toolbarOverview-section">
     *   JET Toolbar
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#toolbarOverview-section"></a>
     * </h3>
     * <p>Description: A toolbar displays a strip of control elements such as buttons and menu buttons, often grouped by separators.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-toolbar items="[[toolbarItems]]">
     * &lt;/oj-c-toolbar>
     * </code></pre>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *  <tr>
     *     <td>Navigate right</td>
     *     <td>
     *       <kbd>Right Arrow Key</kbd> or <kbd>Left Arrow Key(RTL)</kbd>
     *     </td>
     *     <td>Change focus to next item on the right</td>
     *   </tr>
     *   <tr>
     *     <td>Navigate left</td>
     *     <td>
     *       <kbd>Left Arrow Key</kbd> or <kbd>Right Arrow Key(RTL)</kbd>
     *     </td>
     *     <td>Change focus to next item on the left</td>
     *   </tr>
     *  </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>JET Toolbar takes care of focus management, as noted above.
     *
     * <p>The application is responsible for applying <code class="prettyprint">aria-label</code> and/or
     * <code class="prettyprint">aria-controls</code> attributes to the toolbar element, if applicable per the instructions that follow:
     *
     * <p>If this toolbar is (or might be) placed in context with other toolbars, then the application should apply an
     * <code class="prettyprint">aria-label</code> to the toolbar element to distinguish it, e.g. an "Edit" toolbar.  The
     * <code class="prettyprint">aria-label</code> is optional when there is only one toolbar.
     *
     * <p>If the toolbar is controlling something else on the page, e.g. bold / italic / underline buttons controlling a rich
     * text editor, then the application should apply an <code class="prettyprint">aria-controls</code> attribute to the toolbar element,
     * e.g. <code class="prettyprint">aria-controls="myTextEditor"</code>.
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "A toolbar displays a strip of control elements such as buttons and menu buttons, often grouped by separators."
     * @ojmetadata displayName "Toolbar"
     * @ojmetadata help "oj-c.Toolbar.html"
     * @ojmetadata main "oj-c/toolbar"
     * @ojmetadata since "18.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "18.0.0",
     *     "value": ["oj-toolbar"]
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/toolbar"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-toolbar",
     *     "uxSpecs": [
     *       "toolbar"
     *     ]
     *   }
     * }
     */
    ({ 'aria-controls': ariaControls, 'aria-label': ariaLabel, spacing, size, chroming, items = [], toolbarSelection = {}, onToolbarSelectionChanged, onOjToolbarAction, onOjToolbarSelection }) => {
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_Toolbar_1.Toolbar, { "aria-controls": ariaControls, "aria-label": ariaLabel, spacing: spacing, children: (0, jsx_runtime_1.jsx)(items_toolbar_1.ItemsToolbar, { items: items, size: size, chroming: chroming, toolbarSelection: toolbarSelection, onToolbarSelectionChanged: onToolbarSelectionChanged, onOjToolbarAction: onOjToolbarAction, onOjToolbarSelection: onOjToolbarSelection }) }) }));
    }, "Toolbar", { "properties": { "spacing": { "type": "string", "enumValues": ["sm", "lg"] }, "chroming": { "type": "string", "enumValues": ["borderless", "outlined"] }, "size": { "type": "string", "enumValues": ["sm", "md", "lg"] }, "items": { "type": "Array<object>" }, "toolbarSelection": { "type": "object", "writeback": true } }, "events": { "ojToolbarAction": { "bubbles": true }, "ojToolbarSelection": { "bubbles": true } }, "extension": { "_WRITEBACK_PROPS": ["toolbarSelection"], "_READ_ONLY_PROPS": [], "_OBSERVED_GLOBAL_PROPS": ["aria-controls", "aria-label"] } }, { "items": [], "toolbarSelection": {} }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/toolbar',["require", "exports", "oj-c/toolbar/toolbar"], function (require, exports, toolbar_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Toolbar = void 0;
    Object.defineProperty(exports, "Toolbar", { enumerable: true, get: function () { return toolbar_1.Toolbar; } });
});

define('oj-c/editable-value/UNSAFE_useSelectionRangeValidator/SelectionRangeValidatorError',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeValidatorError = void 0;
    /**
     * A SelectionRangeValidatorError is thrown by SelectionRangeValidator when the number of
     * selected values falls outside of a given range, defined by min and max props.
     *
     * We extend the Error class so we can include an optional 'messageDisplayStrategy' field that
     * indicates when a validation error should be displayed. If unset, we show it immediately.
     */
    class SelectionRangeValidatorError extends Error {
        constructor(message) {
            super(message);
            this.name = 'SelectionRangeValidatorError';
            this.messageDisplayStrategy = 'displayOnBlur';
        }
    }
    exports.SelectionRangeValidatorError = SelectionRangeValidatorError;
});

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
define('oj-c/editable-value/UNSAFE_useSelectionRangeValidator/SelectionRangeValidator',["require", "exports", "./SelectionRangeValidatorError"], function (require, exports, SelectionRangeValidatorError_1) {
    "use strict";
    var _SelectionRangeValidator_instances, _SelectionRangeValidator_getOverflowErrorDetail, _SelectionRangeValidator_getUnderflowErrorDetail, _SelectionRangeValidator_getExactErrorDetail, _SelectionRangeValidator_getRangeErrorDetail;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SelectionRangeValidator = void 0;
    /**
     * Constructs a SelectionRangeValidator that ensures the number of
     * selections is within the range specified using min and max.
     * @template V type of the value to be validated
     * @implements {Validator}
     */
    class SelectionRangeValidator {
        /**
         * Instantiates the SelectionRangeValidator
         * @param options The validator options
         */
        constructor(options) {
            _SelectionRangeValidator_instances.add(this);
            if (options.min && options.max && options.min > options.max) {
                // this is an app developer error, so it doesn't need to be translated.
                throw new Error('min must be less than max');
            }
            this.options = options;
        }
        /**
         * Validates that the number of selections is within the range
         * @param value The value to be validated
         * @throws {SelectionRangeValidatorError} when the value is not within the range
         */
        validate(value) {
            const { max, min } = this.options;
            const selections = value;
            const numSelections = selections.length;
            // Check for selection underflow (min only).
            if (min !== undefined && max === undefined && numSelections < min) {
                throw new SelectionRangeValidatorError_1.SelectionRangeValidatorError(__classPrivateFieldGet(this, _SelectionRangeValidator_instances, "m", _SelectionRangeValidator_getUnderflowErrorDetail).call(this, min));
            }
            // Check for selection overflow (max only).
            if (min === undefined && max !== undefined && numSelections > max) {
                throw new SelectionRangeValidatorError_1.SelectionRangeValidatorError(__classPrivateFieldGet(this, _SelectionRangeValidator_instances, "m", _SelectionRangeValidator_getOverflowErrorDetail).call(this, max));
            }
            // Check for exact number of selections (min === max).
            if (min !== undefined && max !== undefined && min === max && numSelections !== min) {
                throw new SelectionRangeValidatorError_1.SelectionRangeValidatorError(__classPrivateFieldGet(this, _SelectionRangeValidator_instances, "m", _SelectionRangeValidator_getExactErrorDetail).call(this, min));
            }
            // Check the number of selections falls between min and max (> min && < max).
            if (min !== undefined &&
                max !== undefined &&
                min !== max &&
                (numSelections < min || numSelections > max)) {
                throw new SelectionRangeValidatorError_1.SelectionRangeValidatorError(__classPrivateFieldGet(this, _SelectionRangeValidator_instances, "m", _SelectionRangeValidator_getRangeErrorDetail).call(this, min, max));
            }
        }
    }
    exports.SelectionRangeValidator = SelectionRangeValidator;
    _SelectionRangeValidator_instances = new WeakSet(), _SelectionRangeValidator_getOverflowErrorDetail = function _SelectionRangeValidator_getOverflowErrorDetail(max) {
        const { selectionOverflowMessageDetail, defaultSelectionOverflowMessageDetail } = this.options;
        return selectionOverflowMessageDetail
            ? selectionOverflowMessageDetail({ max })
            : defaultSelectionOverflowMessageDetail({ max: max.toString() });
    }, _SelectionRangeValidator_getUnderflowErrorDetail = function _SelectionRangeValidator_getUnderflowErrorDetail(min) {
        const { selectionUnderflowMessageDetail, defaultSelectionUnderflowMessageDetail } = this.options;
        return selectionUnderflowMessageDetail
            ? selectionUnderflowMessageDetail({ min })
            : defaultSelectionUnderflowMessageDetail({ min: min.toString() });
    }, _SelectionRangeValidator_getExactErrorDetail = function _SelectionRangeValidator_getExactErrorDetail(exact) {
        const { selectionExactMessageDetail, defaultSelectionExactMessageDetail } = this.options;
        return selectionExactMessageDetail
            ? selectionExactMessageDetail({ exact })
            : defaultSelectionExactMessageDetail({ n: exact.toString() });
    }, _SelectionRangeValidator_getRangeErrorDetail = function _SelectionRangeValidator_getRangeErrorDetail(min, max) {
        const { selectionRangeMessageDetail, defaultSelectionRangeMessageDetail } = this.options;
        return selectionRangeMessageDetail
            ? selectionRangeMessageDetail({ min, max })
            : defaultSelectionRangeMessageDetail({ min: min.toString(), max: max.toString() });
    };
});

define('oj-c/editable-value/UNSAFE_useSelectionRangeValidator/useSelectionRangeValidator',["require", "exports", "preact/hooks", "./SelectionRangeValidator"], function (require, exports, hooks_1, SelectionRangeValidator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useSelectionRangeValidator = useSelectionRangeValidator;
    /**
     * A custom hook that creates an implicit SelectionRangeValidator if either min or max is defined.
     * @returns An array of validators, e.g. Validator<V>[]
     */
    function useSelectionRangeValidator({ defaultSelectionExactMessageDetail, defaultSelectionOverflowMessageDetail, defaultSelectionRangeMessageDetail, defaultSelectionUnderflowMessageDetail, max, min, selectionExactMessageDetail, selectionOverflowMessageDetail, selectionRangeMessageDetail, selectionUnderflowMessageDetail }) {
        return (0, hooks_1.useMemo)(() => {
            // If there is a min or max, we need a validator otherwise null.
            const selectionValidator = !min && !max
                ? null
                : new SelectionRangeValidator_1.SelectionRangeValidator({
                    defaultSelectionExactMessageDetail,
                    defaultSelectionOverflowMessageDetail,
                    defaultSelectionRangeMessageDetail,
                    defaultSelectionUnderflowMessageDetail,
                    max,
                    min,
                    selectionExactMessageDetail,
                    selectionOverflowMessageDetail,
                    selectionRangeMessageDetail,
                    selectionUnderflowMessageDetail
                });
            return [selectionValidator].filter(Boolean);
        }, [
            defaultSelectionExactMessageDetail,
            defaultSelectionOverflowMessageDetail,
            defaultSelectionRangeMessageDetail,
            defaultSelectionUnderflowMessageDetail,
            max,
            min,
            selectionExactMessageDetail,
            selectionOverflowMessageDetail,
            selectionRangeMessageDetail,
            selectionUnderflowMessageDetail
        ]);
    }
});

define('oj-c/rich-checkboxset/useRichCheckboxsetPreact',["require", "exports", "preact/hooks", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/hooks/UNSAFE_useEditableValue/index", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "oj-c/editable-value/UNSAFE_useSelectionRangeValidator/useSelectionRangeValidator"], function (require, exports, hooks_1, UNSAFE_useTranslationBundle_1, useComponentMessages_1, index_1, useDeferredValidators_1, useSelectionRangeValidator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useRichCheckboxsetPreact = useRichCheckboxsetPreact;
    function useRichCheckboxsetPreact({ 'aria-describedby': ariaDescribedBy, disabled, displayOptions, labelEdge, labelHint, labelStartWidth, maxSelected, messagesCustom, minSelected, onMessagesCustomChanged, onValidChanged, onValueChanged, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail: propRequiredMessageDetail, selectionExactMessageDetail, selectionOverflowMessageDetail, selectionRangeMessageDetail, selectionUnderflowMessageDetail, userAssistanceDensity, value: propValue }, addBusyState) {
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const requiredMessageDetail = propRequiredMessageDetail || translations.checkboxSet_requiredMessageDetail?.();
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const selectionRangeValidators = (0, useSelectionRangeValidator_1.useSelectionRangeValidator)({
            defaultSelectionExactMessageDetail: translations.formControl_selectionExactMessageDetail,
            defaultSelectionOverflowMessageDetail: translations.formControl_selectionOverflowMessageDetail,
            defaultSelectionRangeMessageDetail: translations.formControl_selectionRangeMessageDetail,
            defaultSelectionUnderflowMessageDetail: translations.formControl_selectionUnderflowMessageDetail,
            max: maxSelected,
            min: minSelected,
            selectionExactMessageDetail,
            selectionOverflowMessageDetail,
            selectionRangeMessageDetail,
            selectionUnderflowMessageDetail
        });
        const { addMessage, clearInteractionFlags, displayValue, methods, onCommitValue, refreshDisplayValue, textFieldProps: evTextFieldProps } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy,
            defaultDisplayValue: null,
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            validators: selectionRangeValidators,
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        // Maintain a ref that tells us if the user has interacted with the control at all.
        // Tabbing through without interacting should never show errors.
        const isInteractedRef = (0, hooks_1.useRef)(false);
        // Maintain a ref that keeps track of whether the component is focused.
        // When we blur, we want to show messages so that any hidden messages
        // from SelectionRangeValidator are shown. Note that the focusable area
        // includes the entire component, i.e. including any user assistance links,
        // in addition to the cards.
        const isFocusedRef = (0, hooks_1.useRef)(false);
        const onFocusIn = (0, hooks_1.useCallback)(() => {
            if (!isFocusedRef.current) {
                isFocusedRef.current = true;
            }
        }, []);
        const onFocusOut = (0, hooks_1.useCallback)((event) => {
            // Trigger focus event changes only when focus goes outside of the current target.
            // Ignore focus changes within the current target.
            if (isFocusedRef.current &&
                (event.relatedTarget == null ||
                    !event.currentTarget.contains(event.relatedTarget))) {
                isFocusedRef.current = false;
                if (isInteractedRef.current) {
                    methods.showMessages();
                }
                isInteractedRef.current = false;
                clearInteractionFlags();
            }
        }, [clearInteractionFlags, methods]);
        // we want to normalize the value to an array
        // if the committed value is invalid (ie empty when required), we retain the last valid value
        // but give the internal Preact component an empty displayValue
        const onCommitHandler = (0, hooks_1.useCallback)(async ({ value }) => {
            const valueAsArray = value ? Array.from(value) : null;
            const numSelected = valueAsArray ? valueAsArray.length : 0;
            // This ref tracks whether the user has interacted with the the component.
            // If they interact and then focus out, we want to show any hidden messages.
            isInteractedRef.current = true;
            // No-op if the number of selections exceeds the max. Short circuit and return.
            if (maxSelected && numSelected > maxSelected) {
                return;
            }
            await onCommitValue(valueAsArray);
            refreshDisplayValue(valueAsArray);
            // Display an info message when the number of selections equals the max.
            if (numSelected === maxSelected) {
                addMessage({
                    severity: 'info',
                    detail: translations.formControl_selectionOverflowMessageDetail({
                        max: maxSelected.toString()
                    })
                });
            }
        }, [addMessage, onCommitValue, maxSelected, refreshDisplayValue, translations]);
        return {
            methods,
            outerProps: disabled || readonly
                ? {}
                : {
                    onFocusIn,
                    onFocusOut
                },
            richCheckboxsetProps: {
                'aria-describedby': textFieldProps['aria-describedby'],
                isRequired: required,
                isReadonly: readonly,
                isDisabled: disabled,
                label: labelHint,
                labelEdge,
                labelStartWidth,
                messages,
                onCommit: onCommitHandler,
                userAssistanceDensity,
                value: displayValue
            }
        };
    }
});


define('oj-c/rich-checkboxset/rich-checkboxset',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/compat", "preact/hooks", "ojs/ojvcomponent", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "ojs/ojcontext", "@oracle/oraclejet-preact/UNSAFE_RichCheckboxSet", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "@oracle/oraclejet-preact/UNSAFE_RichSelectionItem", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "./useRichCheckboxsetPreact", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "css!oj-c/rich-checkboxset/rich-checkboxset-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, compat_1, hooks_1, ojvcomponent_1, useAssistiveText_1, useMergedFormContext_1, Context, UNSAFE_RichCheckboxSet_1, UNSAFE_useTabbableMode_1, UNSAFE_useFormContext_1, UNSAFE_RichSelectionItem_1, Layout_1, useRichCheckboxsetPreact_1, UNSAFE_classNames_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RichCheckboxset = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const FunctionalRichCheckboxset = (0, compat_1.forwardRef)(
    /**
     * @classdesc
     * <h3 id="richCheckboxsetOverview-section">
     *   JET Rich Checkboxset Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#richCheckboxsetOverview-section"></a>
     * </h3>
     *
     * <p>
     * Description: A JET Rich Checkbox Set allows the user to select one or more options from a set of rich options.
     * </p>
     *
     * <p>The options content can be configured via an array.
     * Once an array is set it should not be mutated. In order to change the data, a new array instance must be set.
     * </p>
  
     * <pre class="prettyprint">
     * <code>
     * &lt;oj-c-rich-checkboxset options="[[immutableArray]]">
     * &lt;/oj-c-rich-checkboxset>
     * </code>
     * </pre>
     *
     * <p>
     *  You can enable and disable an oj-c-rich-checkboxset,
     *  which will enable and disable all contained checkboxes.
     * </p>
     * <p>
     *  You can also set an oj-c-rich-checkboxset to readonly,
     *  which will make all the checkbox items readonly.
     * </p>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
  
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h4 id="selection-limitation-validation-section">
     *  Selection Limitation Validation
     *  <a class="bookmarkable-link" title="Bookmarkable Link" href="#selection-limitation-validation-section"></a>
     * </h4>
     * Simply tabbing through the component will not trigger any validation messages. Validation occurs during user interaction
     * upon each selection change. However, validation errors might not be displayed immediately to avoid disrupting the user experience.
     * These messages may remain hidden until the user blurs the component, calls showMessages(), or calls validate().
     * While editing, if a user is in a "valid" state and then fails validation upon selection, the validation messages will update accordingly.
     * If a user is in an "invalidShown" state and then passes validation upon selection, the validation messages will also update accordingly.
     * Also note, that the required indicator appears only when required is set to true. Having a minimum selection does not
     * automatically trigger the required validation or the display of required indicators.
     * <ul>
     *  <li>
     *    When the value passes validation, the component provides immediate feedback for any subsequent interactions until the user
     *    blurs the component.
     *  </li>
     *  <li>
     *    When a user focuses back in, validation message display will be handled the same as on initial interaction.
     *  </li>
     *  <li>
     *    When validate() is called, comprehensive validation is conducted, and all validation messages are displayed to the user.
     *  </li>
     * </ul>
     *
     * </h4>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline at the top of the rich checkboxset and is always displayed if there is any defined for the set.
     * See the user-assistance-density property for other ways the user assistance text can render.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction, and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then help-hints.definition shows;</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>
     * If the required property was set to true, this can also be used to guide the user.
     * In this case, the word Required will be rendered under the rich checkboxset when no value was set for the component.
     * </p>
     *
     * <h3 id="touch-section">
     * Touch End User Information
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Rich Checkbox Card</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Select/unselect the corresponding checkbox</td>
     *    </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     * Keyboard End User Information
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Rich Checkboxset</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Set focus to the first focusable card in the rich checkboxset.
     *       Disabled checkboxes are not focusable.</td>
     *     </tr>
     *     <tr>
     *       <td>Rich Checkbox Card</td>
     *       <td><kbd>Space</kbd></td>
     *       <td>Toggles the checkbox; If the checkbox is unselected, it will select it and vice versa.</td>
     *     </tr>
     *    <tr>
     *       <td>Rich Checkbox Card</td>
     *       <td><kbd>Tab</kbd></td>
     *       <td>Sets focus to the next focusable checkbox card in the rich checkboxset.
     *        Disabled checkboxes are not focusable. If focus is on the last focusable checkbox card in the
     *        checkboxset, focus goes to the next focusable element on the page after the `oj-c-rich-checkboxset`</td>
     *     </tr>
     *    <tr>
     *       <td>Rich Checkboxset</td>
     *       <td><kbd>Shift+Tab</kbd></td>
     *       <td>Sets focus to the previous focusable checkbox card in the rich checkboxset.
     *        Disabled checkboxes are not focusable. If the focus is currently on the
     *        first focusable checkbox card in the set, it will shift to the "Learn More" link if
     *        help source exists. If no help source is available, the focus will move to the
     *        previous focusable element on the page before the `oj-c-rich-checkboxset`</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     * Accessibility
     * <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>JET Rich Checkboxset takes care of setting <code class="prettyprint">role="group"</code>.
     *
     * <p>
     * For accessibility, set the label-hint property.
     * If the desire is to not have a visible label, then to make this accessible to screen reader users,
     * set label-hint to a value and the label-edge to 'none' which renders an aria-label with the label-hint text.
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "A rich checkbox set allows the user to select one or more options from a set of rich options."
     * @ojmetadata displayName "RichCheckboxset"
     * @ojmetadata main "oj-c/rich-checkboxset"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "18.1.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *  "vbdt": {
     *    "module": "oj-c/rich-checkboxset",
     *    "defaultColumns": 6,
     *    "minColumns": 2
     *  },
     *  "oracle": {
     *    "icon": "oj-ux-ico-checkbox-on",
     *    "uxSpecs": [
     *      "checkboxset"
     *    ]
     *  }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "direction",
     *       "placeholder",
     *       "readonly",
     *       "required",
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "options",
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "18.1.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint", "layout", "options"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    ({ columnSpan = 1, containerReadonly: propContainerReadonly, disabled = false, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, id, layout, maxSelected, messagesCustom = messagesCustomDefault, minSelected, options, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, userAssistanceDensity: propUserAssistanceDensity, value = null, ...otherProps }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const richCheckboxsetRef = (0, hooks_1.useRef)();
        const hasMin = minSelected != null;
        const hasMax = maxSelected != null;
        const hasValue = value != null;
        // Runtime error checking
        if (hasMin && minSelected < 2) {
            throw new Error('RichCheckboxSet: minSelected should be equal to or greater than 2.');
        }
        if (hasMax && maxSelected < 2) {
            throw new Error('RichCheckboxSet: maxSelected should be equal to or greater than 2.');
        }
        const addBusyState = (0, hooks_1.useCallback)((description) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-rich-checkboxset id=${id} is ${description}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping: 'wrap',
            propReadonly,
            propUserAssistanceDensity
        });
        const { richCheckboxsetProps, methods, outerProps } = (0, useRichCheckboxsetPreact_1.useRichCheckboxsetPreact)({
            disabled,
            displayOptions,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            maxSelected,
            messagesCustom,
            minSelected,
            value,
            userAssistanceDensity: uadValue,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => richCheckboxsetRef.current?.blur(),
            focus: () => richCheckboxsetRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: uadValue
        });
        const { value: hookValue, ...richCheckboxsetRest } = richCheckboxsetProps;
        // ensure that the value is a Set type and memoize to prevent creating a new set with every rerender
        const memoizedSetValue = (0, hooks_1.useMemo)(() => (hookValue ? new Set(hookValue) : undefined), [hookValue]);
        // to prevent the component from rerendering with mutated data, we need to memoize the options array
        // if a developer wants to refresh the component with new data, they must explicitly provide a new reference
        const memoizedOptions = (0, hooks_1.useMemo)(() => (options ? [...options] : []), [options]);
        const hasMaxSelected = hasValue && hasMax && maxSelected === memoizedSetValue?.size;
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            containerProps.isFormLayout && 'in-form-layout'
        ]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)("div", { ...outerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_RichCheckboxSet_1.RichCheckboxSet, { ...assistiveTextProps, ...richCheckboxsetRest, columnSpan: columnSpan, ref: richCheckboxsetRef, layout: layout, userAssistanceDensity: uadValue, value: memoizedSetValue, children: memoizedOptions.map(({ secondaryText, thumbnailSrc, iconClass, avatar, label, value }) => {
                            const mediaObj = iconClass
                                ? { iconClass }
                                : thumbnailSrc
                                    ? { thumbnailSrc }
                                    : avatar
                                        ? { avatar }
                                        : {};
                            // Once the component reaches its maximum selection limit, we want to put any
                            // unselected individual cards into readonly mode.
                            const isItemReadonly = readonlyValue || (hasMaxSelected && !memoizedSetValue?.has(value));
                            return ((0, jsx_runtime_1.jsx)(UNSAFE_RichSelectionItem_1.RichSelectionItem, { isReadonly: isItemReadonly, label: label, secondaryText: secondaryText, value: value, ...mediaObj }, value));
                        }) }) }) }) }));
    });
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const RichCheckboxsetWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-rich-checkboxset', FunctionalRichCheckboxset, "RichCheckboxset", { "properties": { "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "columnSpan": { "type": "number" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "layout": { "type": "string", "enumValues": ["sm", "md", "xl"] }, "maxSelected": { "type": "number" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "minSelected": { "type": "number" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "selectionExactMessageDetail": { "type": "function" }, "selectionOverflowMessageDetail": { "type": "function" }, "selectionRangeMessageDetail": { "type": "function" }, "selectionUnderflowMessageDetail": { "type": "function" }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "options": { "type": "Array<object>" }, "requiredMessageDetail": { "type": "string" }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true }, "value": { "type": "Array<string|number>|null", "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "valid", "value"], "_READ_ONLY_PROPS": ["valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "columnSpan": 1, "disabled": false, "displayOptions": { "messages": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const RichCheckboxset = RichCheckboxsetWithoutDefaultedGenerics;
    exports.RichCheckboxset = RichCheckboxset;
});

define('oj-c/rich-checkboxset',["require", "exports", "oj-c/rich-checkboxset/rich-checkboxset"], function (require, exports, rich_checkboxset_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RichCheckboxset = void 0;
    Object.defineProperty(exports, "RichCheckboxset", { enumerable: true, get: function () { return rich_checkboxset_1.RichCheckboxset; } });
});

define('oj-c/rich-radioset/useRichRadiosetPreact',["require", "exports", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "oj-c/hooks/UNSAFE_useEditableValue/index", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle"], function (require, exports, useComponentMessages_1, useDeferredValidators_1, index_1, UNSAFE_useTranslationBundle_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useRichRadiosetPreact = useRichRadiosetPreact;
    function useRichRadiosetPreact({ disabled, displayOptions, labelEdge, labelHint, labelStartWidth, layout, messagesCustom, readonly, readonlyUserAssistanceShown, requiredMessageDetail: propRequiredMessageDetail, required, userAssistanceDensity, value: propValue, onMessagesCustomChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        const requiredMessageDetail = propRequiredMessageDetail || translations.radio_requiredMessageDetail();
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const { value, methods, textFieldProps: evTextFieldProps } = (0, index_1.useEditableValue)({
            ariaDescribedBy: otherProps['aria-describedby'],
            deferredValidators,
            defaultDisplayValue: null,
            disabled,
            displayOptions,
            messagesCustom,
            readonly,
            value: propValue,
            addBusyState,
            onMessagesCustomChanged,
            onValidChanged,
            onValueChanged
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        return {
            methods,
            richRadiosetProps: {
                'aria-describedby': textFieldProps['aria-describedby'],
                isRequired: required,
                isReadonly: readonly,
                isDisabled: disabled,
                label: labelHint,
                labelEdge,
                labelStartWidth,
                layout,
                messages,
                onCommit: textFieldProps['onCommit'],
                userAssistanceDensity,
                value
            }
        };
    }
});


define('oj-c/rich-radioset/rich-radioset',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "preact/hooks", "preact/compat", "ojs/ojvcomponent", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "ojs/ojcontext", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "@oracle/oraclejet-preact/UNSAFE_RichRadioSet", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "@oracle/oraclejet-preact/UNSAFE_RichSelectionItem", "./useRichRadiosetPreact", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "css!oj-c/rich-radioset/rich-radioset-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, hooks_1, compat_1, ojvcomponent_1, useAssistiveText_1, Context, useMergedFormContext_1, UNSAFE_RichRadioSet_1, Layout_1, UNSAFE_useTabbableMode_1, UNSAFE_useFormContext_1, UNSAFE_RichSelectionItem_1, useRichRadiosetPreact_1, UNSAFE_classNames_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RichRadioset = void 0;
    // Define constants for object literal default values to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const FunctionalRichRadioset = (0, compat_1.forwardRef)(
    /**
     * @classdesc
     * <h3 id="richRadiosetOverview-section">
     *   JET Rich Radioset Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#richRadiosetOverview-section"></a>
     * </h3>
     * <p>
     * Description: A JET Rich Radio Set component allows the user to select one option from a set of mutually exclusive rich options.
     * </p>
     * <p>The options content can be configured via an array.
     * Once an array is set it should not be mutated. In order to change the data, a new array instance must be set.
     * </p>
     * <p>
     *  You can enable and disable an oj-c-rich-radioset, which will enable and disable all contained radio items.
     * </p>
     * <p>
     *  You can also set an oj-c-rich-radioset to readonly,
     *  which will make all the radio items readonly.
     * </p>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
  
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property changes (for components that support converters). See <a href="#converter">converter</a> property for details.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline at the top of the rich radioset and is always displayed if there is any defined for the set.
     * See the user-assistance-density property for other ways the user assistance text can render.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction, and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then help-hints.definition shows;</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>
     * If the required property was set to true, this can also be used to guide the user.
     * In this case, the word Required will be rendered under the rich radioset when no value was set for the component.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Rich Radio Card</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Select the corresponding radio button.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Rich Radioset</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Sets focus to the selected card in the rich radioset.
     *       Otherwise, it will set focus to the first focusable card in the rich radioset.
     *       Disabled radio cards are not focusable.</td>
     *     </tr>
     *     <tr>
     *       <td rowspan="2">Rich Radio Card</td>
     *       <td><kbd>UpArrow</kbd></td>
     *       <td>Select the previous radio button in the group.</td>
     *     </tr>
     *     <tr>
     *       <td><kbd>DownArrow</kbd></td>
     *       <td>Select the next radio button in the group.</td>
     *     </tr>
     *     <tr>
     *       <td>Rich Radioset</td>
     *       <td><kbd>Shift+Tab</kbd></td>
     *       <td>Sets focus to the selected card in the rich radioset.
     *        If the focus is currently on the first focusable radio card in the set, it will
     *        shift to the "Learn More" link if help source exists. If no help source is available,
     *        the focus will move to the previous focusable element on the page before the `oj-c-rich-radioset`.
     *        Disabled radio cards are not focusable.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>JET oj-c-rich-radioset takes care of setting
     * <code class="prettyprint">role="radiogroup"</code> on the oj-c-rich-radioset element.
     * </p>
     *
     * <p>
     * For accessibility, set the label-hint property.
     * If the desire is to not have a visible label, then to make this accessible to screen reader users,
     * set label-hint to a value and the label-edge to 'none' which renders an aria-label with the label-hint text.
     *
     * {@include accessibility_doc.ts#a11y-section-disabled-content}
     *
     * @ojmetadata description "A rich radio set allows the user to select one option from a set of mutually exclusive rich options."
     * @ojmetadata displayName "RichRadioset"
     * @ojmetadata main "oj-c/rich-radioset"
     * @ojmetadata status [
     *   {
     *     type: "production",
     *     since: "18.1.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Forms"
     *   },
     *  "vbdt": {
     *    "module": "oj-c/rich-radioset",
     *    "defaultColumns": 6,
     *    "minColumns": 2
     *  },
     *  "oracle": {
     *    "icon": "oj-ux-ico-radio-set",
     *    "uxSpecs": [
     *      "radioset"
     *    ]
     *  }
     * }
  
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "disabled",
     *       "labelHint",
     *       "direction",
     *       "placeholder",
     *       "readonly",
     *       "required",
     *     ]
     *   },
     *   {
     *     "propertyGroup": "data",
     *     "items": [
     *       "options",
     *       "value"
     *     ]
     *   }
     * ]
     * @ojmetadata since "18.1.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint", "layout", "options"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    ({ id, options, containerReadonly: propContainerReadonly, displayOptions = displayOptionsDefault, help = helpDefault, helpHints = helpHintsDefault, disabled = false, layout, messagesCustom = messagesCustomDefault, columnSpan = 1, readonly: propReadonly, readonlyUserAssistanceShown = 'none', userAssistanceDensity: propUserAssistanceDensity, required = false, value, ...otherProps }, ref) => {
        const rootRef = (0, hooks_1.useRef)();
        const richRadiosetRef = (0, hooks_1.useRef)();
        const addBusyState = (0, hooks_1.useCallback)((description) => {
            return rootRef.current
                ? Context.getContext(rootRef.current)
                    .getBusyContext()
                    .addBusyState({ description: `oj-c-rich-radioset id=${id} is ${description}` })
                : () => { }; // if the component is not mounted return Noop
        }, [id]);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping: 'wrap',
            propReadonly,
            propUserAssistanceDensity
        });
        const { richRadiosetProps, methods } = (0, useRichRadiosetPreact_1.useRichRadiosetPreact)({
            displayOptions,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            messagesCustom,
            disabled,
            value,
            userAssistanceDensity: uadValue,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => richRadiosetRef.current?.blur(),
            focus: () => richRadiosetRef.current?.focus(),
            ...methods
        }), [methods]);
        const { value: hookValue, ...richRadiosetRest } = richRadiosetProps;
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: uadValue
        });
        // to prevent the component from rerendering with mutated data, we need to memoize the options array
        // if a developer wants to refresh the component with new data, they must explicitly provide a new reference
        const memoizedOptions = (0, hooks_1.useMemo)(() => (options ? [...options] : []), [options]);
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            containerProps.isFormLayout && 'in-form-layout'
        ]);
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: id, ref: rootRef, class: rootClasses, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_RichRadioSet_1.RichRadioSet, { ref: richRadiosetRef, ...assistiveTextProps, ...richRadiosetRest, columnSpan: columnSpan, layout: layout, userAssistanceDensity: uadValue, value: hookValue, children: memoizedOptions.map(({ secondaryText, thumbnailSrc, iconClass, avatar, label, value }) => {
                        const mediaObj = iconClass
                            ? { iconClass }
                            : thumbnailSrc
                                ? { thumbnailSrc }
                                : avatar
                                    ? { avatar }
                                    : {};
                        return ((0, jsx_runtime_1.jsx)(UNSAFE_RichSelectionItem_1.RichSelectionItem, { label: label, secondaryText: secondaryText, value: value, ...mediaObj }, value));
                    }) }) }) }));
    });
    // This custom element supports generic parameters, but was introduced before the pattern for exposing
    // generic parameters on the functional value-based element was established.  In order to introduce the generics in
    // a backwards-compatible way, they must be defaulted, but we don't want the defaults to be added to the existing
    // types which had generics from the start.  The solution is to use two consts:
    //   * the first is not exported, but is used as the basis for the custom element types and does not default its generics
    //   * the second is the exported functional value-based element and defaults the generics for backwards compatibility
    const RichRadiosetWithoutDefaultedGenerics = (0, ojvcomponent_1.registerCustomElement)('oj-c-rich-radioset', FunctionalRichRadioset, "RichRadioset", { "properties": { "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "columnSpan": { "type": "number" }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] } } }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "layout": { "type": "string", "enumValues": ["sm", "md", "xl"] }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "options": { "type": "Array<object>" }, "requiredMessageDetail": { "type": "string" }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true }, "value": { "type": "string|number|null", "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "valid", "value"], "_READ_ONLY_PROPS": ["valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "displayOptions": { "messages": "display" }, "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "disabled": false, "messagesCustom": [], "columnSpan": 1, "readonlyUserAssistanceShown": "none", "required": false }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
    const RichRadioset = RichRadiosetWithoutDefaultedGenerics;
    exports.RichRadioset = RichRadioset;
});

define('oj-c/rich-radioset',["require", "exports", "oj-c/rich-radioset/rich-radioset"], function (require, exports, rich_radioset_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RichRadioset = void 0;
    Object.defineProperty(exports, "RichRadioset", { enumerable: true, get: function () { return rich_radioset_1.RichRadioset; } });
});

define('oj-c/input-time-mask/TimeConverter',["require", "exports", "@oracle/oraclejet-preact/utils/UNSAFE_timeUtils"], function (require, exports, UNSAFE_timeUtils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeConverter = void 0;
    /**
     * A converter for oj-c-input-time-mask. TimeISOStr <--> Time Object.
     */
    class TimeConverter {
        constructor(options) {
            this.timeConverter_parseErrorFn = options?.timeConverter_parseErrorFn;
        }
        /**
         * This method takes a time-only local iso string and returns a Time Object with
         * hour and minute defined
         * which can then be passed to the InputTimeMask component.
         * For example, given 'T19:23:59', return {hour: 19, minute: 23, second: 59}.
         * @param value {TimeISOStr} time-only local iso string.
         * @returns {TimeWithValidIsoStrParts} The Time will have hour and minute.
         * @throws {Error} if the value is not a time-only ISO string with no offset.
         */
        format(value) {
            const time = (0, UNSAFE_timeUtils_1.getTimeObjFromTimeOnlyISOStr)(value);
            if (!time) {
                throw new Error('value must be a time-only ISO string with no offset');
            }
            return time;
        }
        /**
         * This method takes a Time object with hour and minute defined and optionally with second and millisecond defined
         * and returns a local time-only iso string.
         * For example, given {hour: 19, minute: 23, second: 59, millisecond: 888} return 'T19:23:59.888'
         * @param input {TimeWithValidIsoStrParts} a Time object with hour and minute defined and optionally with second and millisecond defined.
         * @returns a local time-only iso string
         * @throws {Error} if the input does not have hour and minute defined, since you cannot have an iso string without hour and minute.
         * If milliseconds is defined but its value is out of range of 0-999. This could happen because the allowed range is too large to express in Typescript;
         * this would be an application developer error.
         */
        parse(input) {
            const timeStr = (0, UNSAFE_timeUtils_1.getTimeOnlyISOStrFromTimeObj)(input);
            if (timeStr === undefined) {
                const errorStr = this.timeConverter_parseErrorFn && this.timeConverter_parseErrorFn();
                // This error could happen if the user clears out the hour field, for example, and the time is not complete. This error is shown to the user.
                throw new Error(errorStr ?? 'parse failed');
            }
            return timeStr;
        }
    }
    exports.TimeConverter = TimeConverter;
});

var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
define('oj-c/input-time-mask/TimeRangeValidator',["require", "exports", "@oracle/oraclejet-preact/utils/UNSAFE_timeUtils"], function (require, exports, UNSAFE_timeUtils_1) {
    "use strict";
    var _TimeRangeValidator_instances, _TimeRangeValidator_getOverflowErrorDetail, _TimeRangeValidator_getUnderflowErrorDetail;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeRangeValidator = void 0;
    /**
     * Constructs a TimeRangeValidator that ensures the time provided is
     * within the range specified using min and max. This throws an error if min is not less than max.
     * @template V type of the value to be validated. This is a time only iso string.
     * @implements {Validator}
     */
    class TimeRangeValidator {
        /**
         * Instantiates the TimeRangeValidator
         * @param options The validator options
         */
        constructor(options) {
            _TimeRangeValidator_instances.add(this);
            if (options.min && options.max && (0, UNSAFE_timeUtils_1.compareTimes)(options.min, options.max) > 0) {
                // this is an app developer error, so it doesn't need to be translated.
                throw new Error('min must be less than max');
            }
            this.options = options;
        }
        /**
         * Validates that the provided time is within the range.
         * @param value The time to be validated. V is a time-only iso string.
         * @throws {Error} when the time is not within the range
         */
        validate(value) {
            if (value === null)
                return;
            const { converter, max, min } = this.options;
            // if value is specified, then convert the time-only iso string value to Time format
            // converter.format throws an error if the value is not formatted correctly, like if it is empty, null, undefined, or has an offset or zulu,
            // or isn't a valid time-only local iso string.
            // valueTime is guaranteed to have hour+minute.
            const valueTime = converter.format(value);
            if (max !== undefined && (0, UNSAFE_timeUtils_1.compareTimes)(valueTime, max) > 0) {
                throw new Error(__classPrivateFieldGet(this, _TimeRangeValidator_instances, "m", _TimeRangeValidator_getOverflowErrorDetail).call(this, value, max));
            }
            if (min !== undefined && (0, UNSAFE_timeUtils_1.compareTimes)(valueTime, min) < 0) {
                throw new Error(__classPrivateFieldGet(this, _TimeRangeValidator_instances, "m", _TimeRangeValidator_getUnderflowErrorDetail).call(this, value, min));
            }
        }
    }
    exports.TimeRangeValidator = TimeRangeValidator;
    _TimeRangeValidator_instances = new WeakSet(), _TimeRangeValidator_getOverflowErrorDetail = function _TimeRangeValidator_getOverflowErrorDetail(value, max) {
        const { converter, timeRangeOverflowMessageDetail, defaultRangeOverflowMessageDetailFn, formatObj } = this.options;
        const isoMax = converter.parse(max);
        const maxString = formatObj.format(isoMax);
        if (timeRangeOverflowMessageDetail) {
            const valueString = formatObj.format(value);
            return timeRangeOverflowMessageDetail({ value: valueString, max: maxString });
        }
        return defaultRangeOverflowMessageDetailFn({ max: maxString });
    }, _TimeRangeValidator_getUnderflowErrorDetail = function _TimeRangeValidator_getUnderflowErrorDetail(value, min) {
        const { converter, timeRangeUnderflowMessageDetail, defaultRangeUnderflowMessageDetailFn, formatObj } = this.options;
        const isoMin = converter.parse(min);
        const minString = formatObj.format(isoMin);
        if (timeRangeUnderflowMessageDetail) {
            const valueString = formatObj.format(value);
            return timeRangeUnderflowMessageDetail({ value: valueString, min: minString });
        }
        return defaultRangeUnderflowMessageDetailFn({ min: minString });
    };
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define('oj-c/input-time-mask/useImplicitTimeRangeValidator',["require", "exports", "preact/hooks", "./TimeRangeValidator"], function (require, exports, hooks_1, TimeRangeValidator_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useImplicitTimeRangeValidator = void 0;
    /**
     * Custom hook that creates an implicit TimeRangeValidator for oj-c-input-time-mask.
     *
     * @returns A TimeRangeValidator instance or undefined if there is no min and no max, and therefore no need for validation.
     */
    const useImplicitTimeRangeValidator = ({ converter, defaultRangeOverflowMessageDetailFn, defaultRangeUnderflowMessageDetailFn, timeRangeOverflowMessageDetail, timeRangeUnderflowMessageDetail, formatObj, max, min }) => (0, hooks_1.useMemo)(() => {
        // if there is no min and no max, no need for validation
        if (!min && !max)
            return undefined;
        // since there is a min or max, return a validator
        return new TimeRangeValidator_1.TimeRangeValidator({
            converter,
            defaultRangeOverflowMessageDetailFn,
            defaultRangeUnderflowMessageDetailFn,
            timeRangeOverflowMessageDetail,
            timeRangeUnderflowMessageDetail,
            formatObj,
            max,
            min
        });
    }, [
        converter,
        defaultRangeOverflowMessageDetailFn,
        defaultRangeUnderflowMessageDetailFn,
        timeRangeOverflowMessageDetail,
        timeRangeUnderflowMessageDetail,
        formatObj,
        max,
        min
    ]);
    exports.useImplicitTimeRangeValidator = useImplicitTimeRangeValidator;
});

define('oj-c/input-time-mask/useInputTimeMaskPreact',["require", "exports", "oj-c/hooks/UNSAFE_useComponentMessages/useComponentMessages", "oj-c/editable-value/UNSAFE_useDeferredValidators/useDeferredValidators", "oj-c/hooks/UNSAFE_useEditableValue/index", "preact/hooks", "./TimeConverter", "@oracle/oraclejet-preact/hooks/UNSAFE_useTranslationBundle", "ojs/ojconfig", "@oracle/oraclejet-preact/UNSAFE_IntlDateTime", "./useImplicitTimeRangeValidator", "@oracle/oraclejet-preact/utils/UNSAFE_timeUtils", "ojs/ojconverter-preferences"], function (require, exports, useComponentMessages_1, useDeferredValidators_1, index_1, hooks_1, TimeConverter_1, UNSAFE_useTranslationBundle_1, ojconfig_1, UNSAFE_IntlDateTime_1, useImplicitTimeRangeValidator_1, UNSAFE_timeUtils_1, ojconverter_preferences_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useInputTimeMaskPreact = useInputTimeMaskPreact;
    /**
     * This hook manages state and other related props for the Input Time Mask component.
     */
    function useInputTimeMaskPreact({ disabled, displayOptions, granularity = 'minute', hourClock, labelEdge, labelHint, labelStartWidth, leadingZeroForHour, max, messagesCustom, min, readonly, readonlyUserAssistanceShown, required, requiredMessageDetail, textAlign, timeRangeOverflowMessageDetail, timeRangeUnderflowMessageDetail, userAssistanceDensity, validators, value: propValue, onMessagesCustomChanged, onRawValueChanged, onValidChanged, onValueChanged, ...otherProps }, addBusyState) {
        // First assert that all the props are expected.
        assertProps({ value: propValue, min, max });
        // get the translation resources
        const translations = (0, UNSAFE_useTranslationBundle_1.useTranslationBundle)('@oracle/oraclejet-preact');
        // User preferences are set before the application runs, and never after that.
        const { masksFromUserPref, leadingZeroForHourFromUserPref } = (0, hooks_1.useMemo)(() => {
            return getMasksFromTimePatternPreferences();
        }, []);
        // create implicit converter.
        const implicitConverter = (0, hooks_1.useMemo)(() => {
            return new TimeConverter_1.TimeConverter({
                timeConverter_parseErrorFn: translations.timeConverter_parseError
            });
        }, [translations.timeConverter_parseError]);
        // get min and max as TimeWithValidIsoStrParts. Treats null as undefined for the min/max options.
        const { max: maxTime, min: minTime } = useMinMax({
            converter: implicitConverter,
            max,
            min
        });
        const masksFromLocaleAndOptions = (0, hooks_1.useMemo)(() => {
            const isHour12 = hourClock === '12' ? true : hourClock === '24' ? false : undefined;
            return (0, UNSAFE_timeUtils_1.getTimeMasksFromLocaleAndOptions)((0, ojconfig_1.getLocale)(), granularity, isHour12);
        }, [granularity, hourClock]);
        // returns a formatted time to use in error messages shown to the user, like the min/max error. We
        // want this time to match the format in the field.
        // Memoize this because formatObj in useImplicitTimeRangeValidator is a dependency. If we do not memoize,
        // then our code would create a new converter on every keystroke the user types.
        const timeFormatter = (0, hooks_1.useMemo)(() => {
            return {
                format: (value) => {
                    const locale = (0, ojconfig_1.getLocale)();
                    let hasLeadingZeroForHour;
                    if (leadingZeroForHourFromUserPref !== undefined) {
                        hasLeadingZeroForHour = leadingZeroForHourFromUserPref === 'show';
                    }
                    else {
                        hasLeadingZeroForHour =
                            leadingZeroForHour === 'show'
                                ? true
                                : leadingZeroForHour === 'hide'
                                    ? false
                                    : (0, UNSAFE_timeUtils_1.getLeadingZeroForHour)(locale);
                    }
                    return (0, UNSAFE_timeUtils_1.formatIsoTimeStrAsExample)(value, locale, granularity, hasLeadingZeroForHour, masksFromUserPref ?? masksFromLocaleAndOptions);
                }
            };
        }, [
            granularity,
            leadingZeroForHour,
            leadingZeroForHourFromUserPref,
            masksFromLocaleAndOptions,
            masksFromUserPref
        ]);
        // create implicit validators
        const implicitComponentValidator = (0, useImplicitTimeRangeValidator_1.useImplicitTimeRangeValidator)({
            converter: implicitConverter,
            timeRangeOverflowMessageDetail,
            timeRangeUnderflowMessageDetail,
            defaultRangeOverflowMessageDetailFn: translations.inputTimeMask_timeRangeOverflowMessageDetail,
            defaultRangeUnderflowMessageDetailFn: translations.inputTimeMask_timeRangeUnderflowMessageDetail,
            formatObj: timeFormatter,
            max: maxTime,
            min: minTime
        });
        const combinedValidators = (0, hooks_1.useMemo)(() => {
            const v1 = implicitComponentValidator ? [implicitComponentValidator] : [];
            const v2 = validators ? validators : [];
            return [...v1, ...v2];
        }, [implicitComponentValidator, validators]);
        const deferredValidators = (0, useDeferredValidators_1.useDeferredValidators)({
            labelHint,
            required,
            requiredMessageDetail
        });
        const { methods, textFieldProps: evTextFieldProps, value } = (0, index_1.useEditableValue)({
            addBusyState,
            ariaDescribedBy: otherProps['aria-describedby'],
            converter: implicitConverter,
            defaultDisplayValue: undefined,
            deferredValidators,
            disabled,
            displayOptions,
            messagesCustom,
            onMessagesCustomChanged,
            onRawValueChanged,
            onValidChanged,
            onValueChanged,
            readonly,
            validators: combinedValidators,
            value: propValue
        });
        const { messages: evMessages, ...textFieldProps } = evTextFieldProps;
        const messages = (0, useComponentMessages_1.useComponentMessages)({
            evMessages,
            messagesCustom,
            readonly,
            readonlyUserAssistanceShown
        });
        // this is used to determine isRequiredShown
        const hasNoValue = value === undefined || !isPartialOrCompleteTime(textFieldProps.value);
        // These properties will get passed down to InputTimeMask.
        return {
            methods,
            inputTimeMaskProps: {
                granularity,
                leadingZeroForHour: leadingZeroForHourFromUserPref ?? leadingZeroForHour,
                isDisabled: disabled,
                hourClock,
                isReadonly: readonly,
                isRequired: required,
                isRequiredShown: required && (userAssistanceDensity === 'compact' || hasNoValue),
                label: labelHint,
                labelEdge,
                labelStartWidth,
                masks: masksFromUserPref,
                messages,
                textAlign,
                userAssistanceDensity,
                ...textFieldProps
            }
        };
    }
    const isPartialOrCompleteTime = (value) => {
        if (value === undefined)
            return false;
        return Object.values(value).some((t) => t !== undefined);
    };
    /**
     * Gets the user preference pattern for time, if any, and from that we get the masks: TimePlaceholder and the leading zero for hour.
     * If there are no user preferences
     * for time, this function returns {masksFromUserPref: undefined, leadingZeroForHourFromUserPref: undefined}.
     * The masks property is an array-based representation of the segments used for time based on the time pattern from user preferences.
     * The masks property overrides the locale-specific time format, like whether or not it has a dayPeriod field (AM/PM) and what the segment separators are.
     * Some user preferences for time are: 'H.mm', 'HH:mm:ss', 'a h:mm', 'ah:mm', 'h.mm.a'. The order of hour, minute, second is always the same.
     * The leadingZeroForHourFromUserPref looks at the user preference pattern for HH or hh. Two h's means 'show' leading zero for hour.
     * @returns {masksFromUserPref: undefined, leadingZeroForHourFromUserPref: undefined} if no user preferences, otherwise returns
     * {masksFromUserPref: TimePlaceholders, leadingZeroForHourFromUserPref: 'show'|'hide'}.
     */
    const getMasksFromTimePatternPreferences = () => {
        const prefs = (0, ojconverter_preferences_1.getDateTimePreferences)();
        const pattern = prefs.timeStyle?.short?.pattern;
        // return undefined if no pattern
        if (!pattern) {
            return { leadingZeroForHourFromUserPref: undefined, masksFromUserPref: undefined };
        }
        // Parse the pattern to get the masks and the leading zero for hour.
        const hasTwoHs = pattern.toLowerCase().includes('hh');
        const leadingZeroForHourFromUserPref = hasTwoHs ? 'show' : 'hide';
        return {
            leadingZeroForHourFromUserPref,
            masksFromUserPref: (0, UNSAFE_timeUtils_1.getTimePlaceholdersFromPattern)(pattern)
        };
    };
    /**
     * Asserts if the props provided are valid.
     * @param props The props provided to the InputTimeMask that need to be checked.
     * @throws If any of the props provided has invalid value.
     */
    const assertProps = ({ min, max, value }) => {
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isTimeOnlyIsoString(value)) {
            throw new Error(`InputTimeMask - value must be a time-only ISO string`);
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isTimeOnlyIsoString(min)) {
            throw new Error(`InputTimeMask - min must be a time-only ISO string`);
        }
        if (!UNSAFE_IntlDateTime_1.DateTimeUtils.isTimeOnlyIsoString(max)) {
            throw new Error(`InputTimeMask - max must be a time-only ISO string`);
        }
    };
    /**
     * A custom hook for getting min and max as TimeWithValidIsoStrParts.
     * If min or max are null, this treats them as undefined.
     */
    const useMinMax = ({ converter, max, min }) => {
        // convert min and max
        return (0, hooks_1.useMemo)(() => {
            const formattedMax = max ? converter.format(max) : undefined;
            const formattedMin = min ? converter.format(min) : undefined;
            return {
                max: formattedMax,
                min: formattedMin
            };
        }, [converter, max, min]);
    };
});


define('oj-c/input-time-mask/input-time-mask',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "@oracle/oraclejet-preact/hooks/UNSAFE_useFormContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useFormVariantContext", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_InputTimeMask", "@oracle/oraclejet-preact/utils/UNSAFE_classNames", "@oracle/oraclejet-preact/utils/UNSAFE_styles/FormControl", "@oracle/oraclejet-preact/utils/UNSAFE_styles/Layout", "oj-c/editable-value/UNSAFE_useAssistiveText/useAssistiveText", "oj-c/hooks/UNSAFE_useMergedFormContext/useMergedFormContext", "ojs/ojvcomponent", "preact/compat", "preact/hooks", "./useInputTimeMaskPreact", "ojs/ojcontext", "@oracle/oraclejet-preact/UNSAFE_TextField", "@oracle/oraclejet-preact/hooks/UNSAFE_useComponentTheme", "css!oj-c/input-time-mask/input-time-mask-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, UNSAFE_useFormContext_1, UNSAFE_useFormVariantContext_1, UNSAFE_useTabbableMode_1, UNSAFE_InputTimeMask_1, UNSAFE_classNames_1, FormControl_1, Layout_1, useAssistiveText_1, useMergedFormContext_1, ojvcomponent_1, compat_1, hooks_1, useInputTimeMaskPreact_1, Context, UNSAFE_TextField_1, UNSAFE_useComponentTheme_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputTimeMask = void 0;
    // Define constants for object literal default values and [] to prevent extra re-renders.
    const displayOptionsDefault = {
        messages: 'display',
        validatorHint: 'display'
    };
    const helpDefault = {
        instruction: ''
    };
    const helpHintsDefault = {
        definition: '',
        source: ''
    };
    const messagesCustomDefault = [];
    const validatorsDefault = [];
    /**
     * @classdesc
     * <h3 id="InputTimeMaskOverview-section">
     *   JET Input Time Mask Component
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#InputTimeMaskOverview-section"></a>
     * </h3>
     *
     * <p>Description: A JET Input Time Mask allows a user to individually edit, step, or spin the
     * values of the hour, minute, second, and millisecond fields of a time.</p>
     *
     * <pre class="prettyprint"><code>&lt;oj-c-input-time-mask label-hint="Time">&lt;/oj-c-input-time-mask></code></pre>
     *
     * <h3 id="validation-section">
     *   Validation and Messaging
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#validation-section"></a>
     * </h3>
     *
     * <p>
     * For components that support validators, any invalid values entered by the user are not pushed into the value
     * if validation fails: the <a href="#valid">valid property</a> will change but the original value will remain unchanged.
     * The same thing applies to required validation: if required is set to true and the user clears the field,
     * valid will change, but empty values will not be pushed so the original value remains unchanged.
     * </p>
     * <p>
     * Use <a href="../jetCookbook.html?component=validationGroup&demo=requiredFieldValidation">
     * &lt;oj-validation-group></a> to handle tracking valid across multiple components.
     * </p>
     * <p>
     * An editable component runs validation (normal or deferred) based on the action performed on it
     * (either by end-user or page author), and the state it was in when the action occurred. Examples
     * of actions are - creating a component, user changing the value of the component by interacting
     * with it, the app setting a value programmatically, the app calling the validate() method etc. At
     * the time the action occurs, the component could already be showing errors, or can have a deferred
     * error or have no errors.
     * </p>
     * <p>
     * These factors also determine whether validation errors/messages get shown to the user immediately
     * or get deferred. The following sections highlight the kinds of validation that are run and how
     * messages get handled.
     * </p>
     *
     * <h4 id="normal-validation-section">
     *   Normal Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#normal-validation-section"></a>
     * </h4>
     * Normal validation is run in the following cases on the display value, using the converter and
     * validators (this includes async-validators) set on the component (for components that support these properties),
    
     * and validation errors are reported to user immediately.
     * <ul>
     * <li>When value changes as a result of user interaction all messages are cleared, including custom
     * messages added by the app, and full validation is run on the UI value. The steps performed are
     * outlined below.
     * <ol>
     * <li>All messages are cleared and <code class="prettyprint">messagesCustom</code> property is cleared</li>
     * <li>If no converter is present then processing continues to next step. If a converter is
     * present, the UI value is first converted (i.e., parsed). If there is a parse error then
     * the messages are shown and processing returns.</li>
     * <li>If there are no validators setup for the component then the value is set on the component.
     * Otherwise all validators are run in sequence using the parsed value from the previous step. The
     * implicit required validator is run first if the component is marked required. When a validation error is
     * encountered it is remembered and the next validator in the sequence is run.
     * <ul><li>NOTE: The value is trimmed before required validation is run</li></ul>
     * </li>
     * <li>At the end of the validation run if there are errors, the messages are shown
     * and processing returns. If there are async-validators, those errors are shown as soon as they
     * come in, and not until all validators, sync and async validators, are complete, does processing
     * return, that is, value and valid are updated. If there are no errors, then the
     * <code class="prettyprint">value</code> property is updated and the formatted value displayed on the
     * UI.</li>
     * </ol>
     * </li>
     * <li>When the <code class="prettyprint">validate</code> method is called by app, all messages are
     * cleared and full validation is run using the display value. See <code class="prettyprint">validate</code>
     * method on the sub-classes for details. Note: JET validation is designed to catch user input errors, and not invalid
     * data passed from the server; this should be caught on the server.</li>
     * <li>When certain properties change through programmatic intervention by app, the component
     * determines whether it needs to run normal validation based on the state the component is in.
     * Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details. </li>
     * </ul>
     *
     * <h4 id="deferred-validation-section">
     *   Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validation-section"></a>
     * </h4>
     * Deferred validation is run in the following cases on the component value using the implicit
     * required validator if required is true, and validation errors are deferred, i.e., not shown to user immediately.
     * Refer to the <a href="#deferred-messages-section">Showing Deferred Messages</a> section to
     * understand how deferred messages can be shown.
     * <ul>
     *  <li>When a component is created and it is required deferred validation is run and no messages are cleared
     *  prior to running validation.
     *  Refer to the <a href="#deferred-validators-section">Validators
     *  Participating in Deferred Validation</a> section for details.</li>
     *  <li>When the <code class="prettyprint">value</code> property changes due to programmatic
     *  intervention deferred validation is run, after all messages and messagesCustom property are cleared.</li>
     *  <li>When the <code class="prettyprint">reset</code> method is called, deferred validation is run
     *   after all messages and messagesCustom property are cleared.</li>
     *  <li>When certain properties change through programmatic intervention by app, the component
     *  determines whether it needs to run deferred validation based on the state the component is in.
     *  Refer to the <a href="#mixed-validation-section">Mixed Validation</a> section below for details.</li>
     * </ul>
     *
     * <h4 id="mixed-validation-section">
     *   Mixed Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#mixed-validation-section"></a>
     * </h4>
     * Either deferred or normal validation is run in the following cases based on the state the
     * component is in and any validation errors encountered are either hidden or shown to user.
     * <ul>
     *  <li>when disabled property changes. See <a href="#disabled">disabled</a> property for details.</li>
     *  <li>when converter property (if available) changes.</li>
     *  <li>when required property changes. See <a href="#required">required</a> property for details.</li>
     *  <li>when validators property changes (for components that support validators). See <a href="#validators">validators</a> property for details.</li>
     * </ul>
     *
     * <h3 id="deferred-messages-section">
     *   Showing Deferred Messages
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-messages-section"></a>
     * </h3>
     * Deferred validation messages are displayed only when page author requests for it explicitly in
     * one of the following ways:
     * <ul>
     * <li>calls the <a href="#showMessages"><code class="prettyprint">showMessages</code></a> method on the component</li>
     * </ul>
     *
     * <h3 id="deferred-validators-section">
     *   Validators Participating in Deferred Validation
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#deferred-validators-section"></a>
     * </h3>
     * The required validator is the only validator type that participates in deferred validation.
     * The required property needs to be set to true for the required validator to run.
     *
     * <h3 id="user-assistance-text-section">
     *   User Assistance Text
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#user-assistance-text-section"></a>
     * </h3>
     * <p>
     * User assistive text provides guidance to help the user understand what data to enter or select.
     * </p>
     * <p>
     * By default all user assistance text shows inline.
     * For input components, it shows when the field takes focus. In other components
     * it shows all the time. See the user-assistance-density property for other ways
     * the user assistance text can render, like in 'compact' mode, it will render as an icon on the label
     * which when clicked will show the user assistance text in a notewindow.
     * </p>
     * <p>
     * The JET form component properties that are used for user assistance text are help.instruction,
     * validator and converter hints (for components that support these properties), and help-hints.
     * In the Redwood theme for clarity only one user assistance text shows to the user.
     * The precedence rules are:
     * <ul>
     * <li>help.instruction shows;</li>
     * <li>if no help.instruction, then validator hint shows;</li>
     * <li>if no help.instruction or validator hint, then help-hints.definition shows;</li>
     * <li>if no help.instruction, validator hint, or help-hints.definition, then converter hint shows.</li>
     * <li>help-hints.source always shows along side the above.</li>
     * </ul>
     * </p>
     * <p>For components that support validators or converters, sometimes a hint shows that you do not want to show. To not show it,
     *  set the display-options.validator-hint and/or display-options.converter-hint property to 'none'.
     * </p>
     * <p>required property can be used to guide the user.
     * In Redwood, a required field shows the word Required under the field
     * when the field is empty and does not have focus.
     * The mask placeholder is shown when the field is empty and has focus. The mask placeholder is not configurable.
     * </p>
     *
     * <h3 id="touch-section">
     *   Touch End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#touch-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Gesture</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Field (Not a Segment)</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to first segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Segment</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Segment</td>
     *       <td><kbd>Double Tap</kbd></td>
     *       <td>If the time is complete, selects the entire time. Hitting backspace clears it.</td>
     *     </tr>
     *     <tr>
     *       <td>Day Period Segment</td>
     *       <td><kbd>Tap</kbd></td>
     *       <td>Sets focus to the day period segment. Type the first letter of the desired day period to select it. The 'AM'/'PM' string is localized to the user's locale. For example, in locale 'en-US', 'A' sets the day period segment to 'AM' and 'P' sets the day period segment to 'PM'. If the localized 'AM'/'PM' strings start with the same letter, then typing the first letter will toggle between them.</td>
     *     </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="keyboard-section">
     *   Keyboard End User Information
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#keyboard-section"></a>
     * </h3>
     *
     * <table class="keyboard-table">
     *   <thead>
     *     <tr>
     *       <th>Target</th>
     *       <th>Key</th>
     *       <th>Action</th>
     *     </tr>
     *   </thead>
     *   <tbody>
     *     <tr>
     *       <td>Field</td>
     *       <td><kbd>Tab In</kbd></td>
     *       <td>Sets focus to first segment. Show user assistance text.</td>
     *     </tr>
     *     <tr>
     *       <td>Field</td>
     *       <td><kbd>Ctrl + A</kbd> or <kbd>Command + A</kbd></td>
     *       <td>If the time is complete, selects the entire time. Double clicking on the field also selects the time.</td>
     *     </tr>
     *     <tr>
     *       <td>Field with time selected</td>
     *       <td><kbd>Backspace/Delete</kbd></td>
     *       <td>Backspace or delete key clears the time. The mask placeholders will be shown again and focus will be on the first segment.</td>
     *     </tr>
     *     <tr>
     *       <td>Time Segment</td>
     *       <td><kbd>Backspace/Delete</kbd></td>
     *       <td>Clears the time segment. Focus remains on the time segment.</td>
     *     </tr>
     *     <tr>
     *       <td>Time Segment</td>
     *       <td><kbd>RightArrow</kbd></td>
     *       <td>Moves focus to the segment on the right. If focus is on the rightmost segment, the focus does not move.</td>
     *     </tr>
     *     <tr>
     *       <td>Time Segment</td>
     *       <td><kbd>LeftArrow</kbd></td>
     *       <td>Moves focus to the segment on the left. If focus is on the leftmost segment, the focus does not move.</td>
     *     </tr>
     *    <tr>
     *       <td>Hour Segment</td>
     *       <td><kbd>UpArrow/DownArrow</kbd></td>
     *       <td>
     *        <p>
     *          Increments or decrements the number by one in the segment. The value wraps around when it reaches the minimum or maximum allowed for the segment.</p>
     *       <p>
     *          If there is no number in the segment, and the time is a 12-hour clock, it initializes the hour segment to 12, and auto-fills any empty segments; minute, second and millisecond to 0, and the dayPeriod segment to AM (the string will be localized to the user's locale).
     *       </p>
     *       <p>
     *         If there is no number in the segment, and the time is a 24-hour clock, it initializes the hour segment to 0, and auto-fills any empty segments to 0.
     *       </p>
     *       </td>
     *    </tr>
     *    <tr>
     *       <td>Minute, Second, or Millisecond Segment</td>
     *       <td><kbd>UpArrow/DownArrow</kbd></td>
     *       <td>Increments or decrements the number by one in the segment. The value wraps around when it reaches the minimum or maximum allowed for the segment.
     *         If there is no number in the segment, it initializes the segment to 0.
     *       </td>
     *    </tr>
     *   <tr>
     *       <td>Day Period Segment</td>
     *       <td><kbd>UpArrow/DownArrow</kbd></td>
     *       <td>Toggles the day period. If the day period is empty, it initializes it to AM (the 'AM'/'PM' string is localized to the user's locale).</td>
     *    </tr>
     *    <tr>
     *       <td>Hour Segment</td>
     *       <td><kbd>End</kbd></td>
     *       <td>
     *        <p>
     *          Sets the segment to the maximum number for the segment, and auto-fills the rest of the empty segments;
     *          sets minute, second and millisecond segments to 0, and the dayPeriod segment to AM (the 'AM'/'PM' string is localized to the user's locale).
     *        </p>
     *        <p>
     *           For example, if on the hour segment for a 12-hour clock with granularity="minute", and all segments are empty,
     *           this will set the hour to 12, and minute to 0, and day period to AM. If on the hour segment for a 24-hour clock
     *           with granularity="minute", and all segments are empty, this will set the hour to 23 and minute to 0.
     *        </p>
     *      </td>
     *    </tr>
     *    <tr>
     *       <td>Minute, Second, or Millisecond Segment</td>
     *       <td><kbd>End</kbd></td>
     *       <td>Sets the segment to the maximum number for the segment.</td>
     *    </tr>
     *    <tr>
     *       <td>Day Period Segment</td>
     *       <td><kbd>End</kbd></td>
     *       <td>Sets the segment to the maximum value for the segment which is PM for the day period segment (the 'AM'/'PM' string is localized to the user's locale).</td>
     *    </tr>
     *    <tr>
     *       <td>Hour Segment</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>
     *        <p>
     *          Sets the segment to the minimum number for the segment, and auto-fills the rest of the empty segments;
     *          minute, second and millisecond segments to 0, and the dayPeriod segment to AM (the 'AM'/'PM' string is localized to the user's locale).
     *        </p>
     *        <p>
     *           For example, if on the hour segment for a 12-hour clock with granularity="minute", and all segments are empty,
     *           this will set the hour to 1, and minute to 0, and day period to AM. If on the hour segment for a 24-hour clock
     *           with granularity="minute", and all segments are empty, this will set the hour to 0 and minute to 0.
     *        </p>
     *      </td>
     *    </tr>
     *    <tr>
     *       <td>Minute, Second, or Millisecond Segment</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>Sets the segment to the minimum number for the segment which is 0 for the minute, second, and millisecond segments.</td>
     *    </tr>
     *    <tr>
     *       <td>Day Period Segment</td>
     *       <td><kbd>Home</kbd></td>
     *       <td>Sets the segment to the minimum value for the segment which is AM for the day period segment (the 'AM'/'PM' string is localized to the user's locale).</td>
     *    </tr>
     *    <tr>
     *       <td>Hour Segment</td>
     *       <td><kbd>Page Up/Page Down</kbd></td>
     *       <td>
     *        <p>
     *          Increments or decrements the number by two in the hour segment, and auto-fills the rest of the empty segments;
     *          minute, second and millisecond segments to 0, and the dayPeriod segment to AM (the 'AM'/'PM' string is localized to the user's locale).
     *          The value wraps around when it reaches the minimum or maximum allowed for the segment.
     *        </p>
     *        <p>
     *          If there is no number in the segment, and the time is a 12-hour clock, it initializes the hour segment to 12, and auto-fills any empty segments; minute, second and millisecond to 0, and the dayPeriod segment to AM (the string will be localized to the user's locale).
     *        </p>
     *        <p>
     *         If there is no number in the segment, and the time is a 24-hour clock, it initializes the hour segment to 0, and auto-fills any empty segments to 0.
     *        </p>
     *      </td>
     *    </tr>
     *    <tr>
     *       <td>Minute, Second, or Millisecond Segment</td>
     *       <td><kbd>Page Up/Page Down</kbd></td>
     *       <td>Increments or decrements the number by 10 in the minute and second segments, or by 100 in the millisecond segment. The value wraps around when it reaches the minimum or maximum allowed for the segment.</td>
     *    </tr>
     *    <tr>
     *       <td>Day Period Segment</td>
     *       <td><kbd>Page Up/Page Down</kbd></td>
     *       <td>Toggles the day period segment between AM and PM (the 'AM'/'PM' string is localized to the user's locale).</td>
     *    </tr>
     *   </tbody>
     * </table>
     *
     * <h3 id="a11y-section">
     *   Accessibility
     *   <a class="bookmarkable-link" title="Bookmarkable Link" href="#a11y-section"></a>
     * </h3>
     *
     * <p>
     * For accessibility, set the <a href="#labelHint">label-hint</a> property.
     * If there is no visible label, then to make this accessible to screen reader users,
     * set the <a href="#labelHint">label-hint</a> and <a href="#labelEdge">label-edge</a>='none'
     * which renders an aria-label with the label-hint text.
     * </p>
     *
     *
     * <p>
     * Disabled content: JET supports an accessible luminosity contrast ratio,
     * as specified in <a href="http://www.w3.org/TR/WCAG20/#visual-audio-contrast-contrast">WCAG 2.0 - Section 1.4.3 "Contrast"</a>,
     * in the themes that are accessible.  (See the "Theming" chapter of the JET Developer Guide for more information on which
     * themes are accessible.)  Note that Section 1.4.3 says that text or images of text that are part of an inactive user
     * interface component have no contrast requirement.  Because disabled content may not meet the minimum contrast ratio
     * required of enabled content, it cannot be used to convey meaningful information.
     * </p>
     *
     * @ojmetadata displayName "InputTimeMask"
     * @ojmetadata description "An input time mask field allows a user to enter, edit, or display a time value."
     * @ojmetadata help "oj-c.InputTimeMask.html"
     * @ojmetadata main "oj-c/input-time-mask"
     * @ojmetadata status [
     *   {
     *     type: "candidate",
     *     since: "19.0.0"
     *   }
     * ]
     * @ojmetadata since "19.0.0"
     * @ojmetadata requirements [
     *  {
     *    type: "anyOf",
     *    label: "accessibility",
     *    properties: ["labelHint"]
     *  },
     *  {
     *    type: "not",
     *    label: "accessibility",
     *    properties: ["aria-label", "aria-labelledby"]
     *  }
     * ]
     */
    const InputTimeMaskImpl = ({ columnSpan = 1, containerReadonly: propContainerReadonly, disabled = false, displayOptions = displayOptionsDefault, granularity = 'minute', leadingZeroForHour = 'fromLocale', help = helpDefault, helpHints = helpHintsDefault, hourClock = 'fromLocale', labelWrapping: propLabelWrapping, messagesCustom = messagesCustomDefault, readonly: propReadonly, readonlyUserAssistanceShown = 'none', required = false, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, validators = validatorsDefault, value = null, ...otherProps }, ref) => {
        // Tip: the doc generator gets the property's defaults from the properties object above.
        const rootRef = (0, hooks_1.useRef)();
        const inputTimeMaskRef = (0, hooks_1.useRef)(null);
        const addBusyState = (0, hooks_1.useCallback)((description = 'InputTimeMask: busyState') => {
            return rootRef.current
                ? Context.getContext(rootRef.current).getBusyContext().addBusyState({ description })
                : () => { }; // if the component is not mounted return Noop
        }, []);
        const { containerProps, uadValue, readonlyValue } = (0, useMergedFormContext_1.useMergedFormContext)({
            propContainerReadonly,
            propLabelWrapping,
            propReadonly,
            propUserAssistanceDensity,
            propTextAlign
        });
        const { inputTimeMaskProps, methods } = (0, useInputTimeMaskPreact_1.useInputTimeMaskPreact)({
            disabled,
            displayOptions,
            granularity,
            hourClock,
            leadingZeroForHour,
            messagesCustom,
            readonly: readonlyValue,
            readonlyUserAssistanceShown,
            required,
            userAssistanceDensity: uadValue,
            validators,
            value,
            ...otherProps
        }, addBusyState);
        (0, hooks_1.useImperativeHandle)(ref, () => ({
            blur: () => inputTimeMaskRef.current?.blur(),
            focus: () => inputTimeMaskRef.current?.focus(),
            ...methods
        }), [methods]);
        const assistiveTextProps = (0, useAssistiveText_1.useAssistiveText)({
            displayOptions,
            help,
            helpHints,
            userAssistanceDensity: inputTimeMaskProps.userAssistanceDensity,
            validators
        });
        const variant = (0, UNSAFE_useFormVariantContext_1.useFormVariantContext)();
        const { classes } = (0, UNSAFE_useComponentTheme_1.useComponentTheme)(UNSAFE_TextField_1.TextFieldRedwoodTheme, {
            maxWidth: otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? otherProps.maxWidth : 'none',
            width: otherProps.width === 'md' || otherProps.width === 'sm' ? otherProps.width : 'none'
        });
        const rootClasses = (0, UNSAFE_classNames_1.classNames)([
            Layout_1.layoutSpanStyles.layoutSpanColumn[columnSpan],
            variant && ['embedded', 'legacyEmbedded'].includes(variant) && FormControl_1.formControlStyles.embeddedRoot,
            containerProps.isFormLayout && 'in-form-layout',
            classes
        ]);
        const widthStyle = otherProps.width === 'md' || otherProps.width === 'sm' ? undefined : otherProps.width;
        const maxWidthStyle = otherProps.maxWidth === 'md' || otherProps.maxWidth === 'sm' ? undefined : otherProps.maxWidth;
        const styleProps = { style: { width: widthStyle, maxWidth: maxWidthStyle } };
        return (
        // Even though we are handling the styling here, we pass the columnSpan property down to the
        // Preact component because it may be needed for other purposes, like calculating the start
        // label width.
        (0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { id: otherProps.id, ref: rootRef, class: rootClasses, ...styleProps, "data-oj-renders-label": true, children: (0, jsx_runtime_1.jsx)(UNSAFE_useFormContext_1.FormContext.Provider, { value: containerProps, children: (0, jsx_runtime_1.jsx)(UNSAFE_InputTimeMask_1.InputTimeMask, { ref: inputTimeMaskRef, ...assistiveTextProps, ...inputTimeMaskProps, columnSpan: columnSpan, variant: variant }) }) }));
    };
    exports.InputTimeMask = (0, ojvcomponent_1.registerCustomElement)('oj-c-input-time-mask', (0, compat_1.forwardRef)(InputTimeMaskImpl), "InputTimeMask", { "properties": { "columnSpan": { "type": "number" }, "containerReadonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "disabled": { "type": "boolean" }, "displayOptions": { "type": "object", "properties": { "messages": { "type": "string", "enumValues": ["none", "display"] }, "validatorHint": { "type": "string", "enumValues": ["none", "display"] } } }, "granularity": { "type": "string", "enumValues": ["minute", "second", "millisecond"] }, "leadingZeroForHour": { "type": "string", "enumValues": ["hide", "show", "fromLocale"] }, "help": { "type": "object", "properties": { "instruction": { "type": "string" } } }, "helpHints": { "type": "object", "properties": { "definition": { "type": "string" }, "source": { "type": "string" }, "sourceText": { "type": "string" } } }, "hourClock": { "type": "string", "enumValues": ["12", "24", "fromLocale"] }, "labelEdge": { "type": "string", "enumValues": ["none", "start", "top", "inside"], "binding": { "consume": { "name": "containerLabelEdge" } } }, "labelHint": { "type": "string" }, "labelStartWidth": { "type": "number|string", "binding": { "consume": { "name": "labelWidth" } } }, "labelWrapping": { "type": "string", "enumValues": ["truncate", "wrap"], "binding": { "consume": { "name": "labelWrapping" } } }, "max": { "type": "string|null" }, "maxWidth": { "type": "number|string" }, "messagesCustom": { "type": "Array<object>", "writeback": true }, "min": { "type": "string|null" }, "readonly": { "type": "boolean", "binding": { "consume": { "name": "containerReadonly" } } }, "readonlyUserAssistanceShown": { "type": "string", "enumValues": ["none", "confirmationAndInfoMessages"] }, "required": { "type": "boolean" }, "requiredMessageDetail": { "type": "string" }, "textAlign": { "type": "string", "enumValues": ["end", "start", "right"] }, "timeRangeOverflowMessageDetail": { "type": "function" }, "timeRangeUnderflowMessageDetail": { "type": "function" }, "userAssistanceDensity": { "type": "string", "enumValues": ["compact", "reflow", "efficient"], "binding": { "consume": { "name": "containerUserAssistanceDensity" } } }, "validators": { "type": "Array<object>|null" }, "value": { "type": "string|null", "writeback": true }, "width": { "type": "number|string" }, "rawValue": { "type": "object", "properties": { "hour": { "type": "number" }, "minute": { "type": "number" }, "second": { "type": "number" }, "millisecond": { "type": "number" } }, "readOnly": true, "writeback": true }, "valid": { "type": "string", "enumValues": ["pending", "valid", "invalidHidden", "invalidShown"], "readOnly": true, "writeback": true } }, "extension": { "_WRITEBACK_PROPS": ["messagesCustom", "rawValue", "valid", "value"], "_READ_ONLY_PROPS": ["rawValue", "valid"], "_OBSERVED_GLOBAL_PROPS": ["aria-describedby", "id"] }, "methods": { "blur": {}, "focus": {}, "showMessages": {}, "reset": {}, "validate": {} } }, { "columnSpan": 1, "disabled": false, "displayOptions": { "messages": "display", "validatorHint": "display" }, "granularity": "minute", "leadingZeroForHour": "fromLocale", "help": { "instruction": "" }, "helpHints": { "definition": "", "source": "" }, "hourClock": "fromLocale", "messagesCustom": [], "readonlyUserAssistanceShown": "none", "required": false, "validators": [], "value": null }, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useFormContext_1.FormContext, UNSAFE_useFormVariantContext_1.FormVariantContext, UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/input-time-mask',["require", "exports", "oj-c/input-time-mask/input-time-mask"], function (require, exports, input_time_mask_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InputTimeMask = void 0;
    Object.defineProperty(exports, "InputTimeMask", { enumerable: true, get: function () { return input_time_mask_1.InputTimeMask; } });
});


define('oj-c/badge/badge',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_Badge", "css!oj-c/badge/badge-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_Badge_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Badge = void 0;
    exports.Badge = (0, ojvcomponent_1.registerCustomElement)('oj-c-badge', 
    /**
     *
     *
     * @ojmetadata displayName "Badge"
     * @ojmetadata description "A badge is a label which holds a small amount of information."
     * @ojmetadata main "oj-c/badge"
     * @ojmetadata since "19.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "supersedes",
     *     "since": "19.0.0",
     *     "description": "Note: This component supersedes the following style class: <a href='stylingdocs/Badge.html#oj-badge'>oj-badge</a>."
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/badge"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-badge",
     *     "uxSpecs": [
     *       "badge"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "variant",
     *       "size",
     *       "edge",
     *       "label"
     *     ]
     *   }
     * ]
     */
    ({ variant, size, edge, label }) => {
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_Badge_1.Badge, { variant: variant, size: size, edge: edge, children: label }) }));
    }, "Badge", { "properties": { "variant": { "type": "string", "enumValues": ["success", "danger", "info", "warning", "neutral", "neutralSubtle", "dangerSubtle", "successSubtle", "warningSubtle", "infoSubtle"] }, "size": { "type": "string", "enumValues": ["sm", "md"] }, "edge": { "type": "string", "enumValues": ["none", "end"] }, "label": { "type": "string" } } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    });
});

define('oj-c/badge',["require", "exports", "oj-c/badge/badge"], function (require, exports, badge_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Badge = void 0;
    Object.defineProperty(exports, "Badge", { enumerable: true, get: function () { return badge_1.Badge; } });
});

define('oj-c/truncating-badge/truncating-badge',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/UNSAFE_TruncatingBadge", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "css!oj-c/badge/badge-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_TruncatingBadge_1, UNSAFE_useTabbableMode_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TruncatingBadge = void 0;
    exports.TruncatingBadge = (0, ojvcomponent_1.registerCustomElement)('oj-c-truncating-badge', 
    /**
     *
     *
     * @ojmetadata displayName "Truncating Badge"
     * @ojmetadata description "A truncating badge is a label which holds a small amount of information, and also displays a tooltip when truncation occurs."
     * @ojmetadata main "oj-c/truncating-badge"
     * @ojmetadata since "19.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "production",
     *     "since": "19.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/truncating-badge"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-badge",
     *     "uxSpecs": [
     *       "badge"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "variant",
     *       "size",
     *       "edge",
     *       "label"
     *     ]
     *   }
     * ]
     */
    ({ variant, size, edge, label }) => {
        return ((0, jsx_runtime_1.jsx)(ojvcomponent_1.Root, { children: (0, jsx_runtime_1.jsx)(UNSAFE_TruncatingBadge_1.TruncatingBadge, { variant: variant, size: size, edge: edge, children: label }) }));
    }, "TruncatingBadge", { "properties": { "variant": { "type": "string", "enumValues": ["success", "danger", "info", "warning", "neutral", "neutralSubtle", "dangerSubtle", "successSubtle", "warningSubtle", "infoSubtle"] }, "size": { "type": "string", "enumValues": ["sm", "md"] }, "edge": { "type": "string", "enumValues": ["none", "end"] }, "label": { "type": "string" } } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/truncating-badge',["require", "exports", "oj-c/truncating-badge/truncating-badge"], function (require, exports, truncating_badge_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TruncatingBadge = void 0;
    Object.defineProperty(exports, "TruncatingBadge", { enumerable: true, get: function () { return truncating_badge_1.TruncatingBadge; } });
});


define('oj-c/truncating-text/truncating-text',["require", "exports", "preact/jsx-runtime", '@oracle/oraclejet-preact/translationBundle', "ojs/ojvcomponent", "@oracle/oraclejet-preact/hooks/UNSAFE_useTabbableMode", "@oracle/oraclejet-preact/UNSAFE_TruncatingText", "css!oj-c/truncating-text/truncating-text-styles.css"], function (require, exports, jsx_runtime_1, translationBundle_1, ojvcomponent_1, UNSAFE_useTabbableMode_1, UNSAFE_TruncatingText_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TruncatingText = void 0;
    exports.TruncatingText = (0, ojvcomponent_1.registerCustomElement)('oj-c-truncating-text', 
    /**
     *
     *
     * @ojmetadata displayName "Truncating Text"
     * @ojmetadata description "Truncating Text shows a tooltip containing the full text while also acting as a tab stop when truncation occurs."
     * @ojmetadata main "oj-c/truncating-text"
     * @ojmetadata since "19.0.0"
     * @ojmetadata status [
     *   {
     *     "type": "production",
     *     "since": "19.0.0"
     *   }
     * ]
     * @ojmetadata extension {
     *   "catalog": {
     *     "category": "Controls"
     *   },
     *   "vbdt": {
     *     "module": "oj-c/truncating-text"
     *   },
     *   "oracle": {
     *     "icon": "oj-ux-ico-text",
     *     "uxSpecs": [
     *       "text"
     *     ]
     *   }
     * }
     * @ojmetadata propertyLayout [
     *   {
     *     "propertyGroup": "common",
     *     "items": [
     *       "variant",
     *       "size",
     *       "weight",
     *       "value"
     *     ]
     *   }
     * ]
     */
    ({ variant, size, weight, overflowWrap, hyphens, lineClamp, truncation, value }) => {
        const truncateProps = !truncation && lineClamp ? { lineClamp: lineClamp } : { truncation: truncation };
        return ((0, jsx_runtime_1.jsx)(UNSAFE_TruncatingText_1.TruncatingText, { variant: variant, size: size, weight: weight, overflowWrap: overflowWrap, hyphens: hyphens, ...truncateProps, children: value }));
    }, "TruncatingText", { "properties": { "variant": { "type": "string", "enumValues": ["inherit", "disabled", "success", "danger", "warning", "primary", "secondary"] }, "size": { "type": "string", "enumValues": ["inherit", "sm", "md", "lg", "xs", "2xs", "xl"] }, "weight": { "type": "string", "enumValues": ["bold", "normal", "inherit", "semiBold"] }, "overflowWrap": { "type": "string", "enumValues": ["normal", "anywhere", "breakWord"] }, "hyphens": { "type": "string", "enumValues": ["auto", "none"] }, "truncation": { "type": "string", "enumValues": ["none", "clip", "ellipsis"] }, "lineClamp": { "type": "number" }, "value": { "type": "string" } } }, undefined, {
        '@oracle/oraclejet-preact': translationBundle_1.default
    }, { consume: [UNSAFE_useTabbableMode_1.TabbableModeContext] });
});

define('oj-c/truncating-text',["require", "exports", "oj-c/truncating-text/truncating-text"], function (require, exports, truncating_text_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TruncatingText = void 0;
    Object.defineProperty(exports, "TruncatingText", { enumerable: true, get: function () { return truncating_text_1.TruncatingText; } });
});

