{"version":3,"file":"UNSAFE_useTableViewColumnResizing.js","sources":["../../../src/hooks/UNSAFE_useTableViewColumnResizing/useTableViewColumnResizing.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { createRef } from 'preact';\nimport { useCallback, useRef, useState } from 'preact/hooks';\nimport { useResizeObserver } from '../../hooks/UNSAFE_useResizeObserver';\nimport { UnsafeDomHandle } from '../../utils/UNSAFE_unsafeDomAccess';\nimport { ColumnResizeDetail, ColumnResizingDetail, ColumnWidths } from '../../UNSAFE_TableView';\n\nconst _defaultMinWidth = 16;\n\nexport type TableViewColumnResizingProps<C extends string> = {\n  columnOrder: C[];\n  applyWidths?: 'onResizing' | 'onResize';\n  columnWidths?: ColumnWidths<C>;\n  onColumnWidthsChanging?: (columnWidths: ColumnWidths<C>) => void;\n  onColumnWidthsChange?: (columnWidths: ColumnWidths<C>) => void;\n  minColumnWidth?: number;\n  resizeBehavior?: 'redistribute' | 'add';\n};\n\n/**\n * Utility hook for controlling a TableView's sizing.\n */\nfunction useTableViewColumnResizing<C extends string>({\n  columnOrder,\n  columnWidths,\n  onColumnWidthsChanging,\n  onColumnWidthsChange,\n  applyWidths = 'onResizing',\n  minColumnWidth = _defaultMinWidth,\n  resizeBehavior = 'redistribute'\n}: TableViewColumnResizingProps<C>) {\n  const columnWidthsRef = useRef<ColumnWidths<C> | undefined>(columnWidths);\n  columnWidthsRef.current = columnWidths;\n\n  const [columnResizingIndicator, setColumnResizingIndicator] = useState<\n    { key: C; delta: number } | undefined\n  >();\n  const columnResizingStartingColumnWidthsRef = useRef<ColumnWidths<C>>();\n\n  const frozenAddColumnWidthsRef = useRef<ColumnWidths<C>>({} as ColumnWidths<C>);\n  const [frozenAddColumnWidths, setFrozenAddColumnWidths] = useState<ColumnWidths<C>>(\n    {} as ColumnWidths<C>\n  );\n\n  // ensure all 'real' column widths are applied to the local realizedColumnWidths\n  const realizedColumnWidths = {} as ColumnWidths<C>;\n  const updatedKeys = [];\n  if (columnWidths != null) {\n    const keys = Object.keys(columnWidths) as C[];\n    for (const key of keys) {\n      realizedColumnWidths[key] = columnWidths[key];\n      updatedKeys.push(key);\n    }\n  }\n  // ensure all 'frozenAdd' column widths are applied to the local realizedColumnWidths\n  const frozenAddKeys = Object.keys(frozenAddColumnWidths) as C[];\n  for (const frozenAddKey of frozenAddKeys) {\n    if (!updatedKeys.includes(frozenAddKey)) {\n      realizedColumnWidths[frozenAddKey] = frozenAddColumnWidths[frozenAddKey];\n    }\n  }\n  const addResizePaddingWidthRef = useRef<number>(0);\n\n  const _cloneColumnWidths = useCallback((widths: ColumnWidths<C>) => {\n    const keys = Object.keys(widths) as C[];\n    const newColumnWidths = {} as ColumnWidths<C>;\n    for (const key of keys) {\n      newColumnWidths[key] = widths[key];\n    }\n    return newColumnWidths;\n  }, []);\n\n  /**\n   * Helper method to update the Table's column widths while a column resize operation is ongoing.\n   */\n  const onColumnResizing = useCallback(\n    (detail: ColumnResizingDetail<C>) => {\n      // save the initial state when column resize begins\n      if (columnResizingStartingColumnWidthsRef.current == null) {\n        columnResizingStartingColumnWidthsRef.current = detail.allColumnWidths;\n      }\n      const newStaticColumnWidths = _cloneColumnWidths(\n        columnWidthsRef.current != null ? columnWidthsRef.current : ({} as ColumnWidths<C>)\n      );\n      const startKey = detail.key;\n      const endKey = columnOrder[columnOrder.indexOf(startKey) + 1];\n      const initialStartWidth = columnResizingStartingColumnWidthsRef.current[startKey];\n      const initialEndWidth = columnResizingStartingColumnWidthsRef.current[endKey];\n      const newStartWidth = Math.min(\n        Math.max(initialStartWidth + detail.delta, minColumnWidth),\n        initialStartWidth + initialEndWidth - minColumnWidth\n      );\n      newStaticColumnWidths[startKey] = newStartWidth;\n      const newEndWidth = initialEndWidth + initialStartWidth - newStartWidth;\n      newStaticColumnWidths[endKey] = newEndWidth;\n\n      if (onColumnWidthsChanging != null) {\n        onColumnWidthsChanging(newStaticColumnWidths);\n      }\n      columnWidthsRef.current = newStaticColumnWidths;\n      setColumnResizingIndicator({ key: startKey, delta: 0 });\n    },\n    [onColumnWidthsChanging, minColumnWidth, columnOrder, _cloneColumnWidths]\n  );\n\n  /**\n   * Helper method to update the Table's column resize indicator line only.\n   */\n  const onColumnIndicatorResizing = useCallback(\n    (detail: ColumnResizingDetail<C>) => {\n      const startKey = detail.key;\n      const endKey = columnOrder[columnOrder.indexOf(startKey) + 1];\n      const initialStartWidth = detail.allColumnWidths[startKey];\n      const initialEndWidth = detail.allColumnWidths[endKey];\n      const newStartWidth = Math.min(\n        Math.max(initialStartWidth + detail.delta, minColumnWidth),\n        initialStartWidth + initialEndWidth - minColumnWidth\n      );\n      setColumnResizingIndicator({ key: startKey, delta: newStartWidth - initialStartWidth });\n    },\n    [columnOrder, minColumnWidth]\n  );\n\n  /**\n   * Helper method to update the Table's column widths at the end of column resize operation. This is\n   * the same as during an ongoing resize operation, but additionally pushes back the resized column widths\n   * to the consumer if a 'setInitialColumnWidths' callback is provided, and removes the indicator line.\n   */\n  const onColumnResize = useCallback(\n    (detail: ColumnResizeDetail<C>) => {\n      const initialWidths =\n        columnResizingStartingColumnWidthsRef.current != null\n          ? columnResizingStartingColumnWidthsRef.current\n          : detail.allColumnWidths;\n      const newStaticColumnWidths = _cloneColumnWidths(\n        columnWidthsRef.current != null ? columnWidthsRef.current : ({} as ColumnWidths<C>)\n      );\n      const startKey = detail.key;\n      const initialStartWidth = initialWidths[startKey];\n      let newStartWidth;\n      if (detail.type === 'absolute') {\n        newStartWidth = Math.max(detail.newWidth, minColumnWidth);\n        newStaticColumnWidths[startKey] = newStartWidth;\n      } else {\n        const endKey = columnOrder[columnOrder.indexOf(startKey) + 1];\n        const initialEndWidth = initialWidths[endKey];\n        newStartWidth = Math.min(\n          Math.max(initialStartWidth + detail.delta, minColumnWidth),\n          initialStartWidth + initialEndWidth - minColumnWidth\n        );\n        const newEndWidth = initialEndWidth + initialStartWidth - newStartWidth;\n        newStaticColumnWidths[endKey] = newEndWidth;\n      }\n      newStaticColumnWidths[startKey] = newStartWidth;\n      if (onColumnWidthsChange != null) {\n        onColumnWidthsChange(newStaticColumnWidths);\n      }\n      columnWidthsRef.current = newStaticColumnWidths;\n      columnResizingStartingColumnWidthsRef.current = undefined;\n      setColumnResizingIndicator(undefined);\n    },\n    [onColumnWidthsChange, minColumnWidth, columnOrder, _cloneColumnWidths]\n  );\n\n  /**\n   * Helper method to update the Table's column widths while a column resize operation is ongoing.\n   */\n  const onAddBehaviorResizing = useCallback(\n    (detail: ColumnResizingDetail<C>) => {\n      addResizePaddingWidthRef.current = detail.paddingWidth;\n      // save the initial state when column resize begins\n      if (columnResizingStartingColumnWidthsRef.current == null) {\n        columnResizingStartingColumnWidthsRef.current = detail.allColumnWidths;\n      }\n      const newFrozenColumnWidths = _cloneColumnWidths(\n        columnResizingStartingColumnWidthsRef.current != null\n          ? columnResizingStartingColumnWidthsRef.current\n          : detail.allColumnWidths\n      );\n      const newStaticColumnWidths = _cloneColumnWidths(\n        columnWidthsRef.current != null ? columnWidthsRef.current : ({} as ColumnWidths<C>)\n      );\n\n      const startKey = detail.key;\n      const initialStartWidth = columnResizingStartingColumnWidthsRef.current[startKey];\n      const newStartWidth = Math.max(initialStartWidth + detail.delta, minColumnWidth);\n      newStaticColumnWidths[startKey] = newStartWidth;\n      newFrozenColumnWidths[startKey] = newStartWidth;\n\n      if (onColumnWidthsChanging != null) {\n        onColumnWidthsChanging(newStaticColumnWidths);\n      }\n      setFrozenAddColumnWidths(newFrozenColumnWidths);\n      frozenAddColumnWidthsRef.current = newFrozenColumnWidths;\n      setColumnResizingIndicator({ key: startKey, delta: 0 });\n    },\n    [onColumnWidthsChanging, minColumnWidth, _cloneColumnWidths]\n  );\n\n  /**\n   * Helper method to update the Table's column resize indicator line only.\n   */\n  const onAddBehaviorIndicatorResizing = useCallback(\n    (detail: ColumnResizingDetail<C>) => {\n      addResizePaddingWidthRef.current = detail.paddingWidth;\n      const startKey = detail.key;\n      const initialStartWidth = detail.allColumnWidths[startKey];\n      const newStartWidth = Math.max(initialStartWidth + detail.delta, minColumnWidth);\n      setColumnResizingIndicator({ key: startKey, delta: newStartWidth - initialStartWidth });\n    },\n    [minColumnWidth]\n  );\n\n  /**\n   * Helper method to update the Table's column widths at the end of column resize operation. This is\n   * the same as during an ongoing resize operation, but additionally pushes back the resized column widths\n   * to the consumer if a 'setInitialColumnWidths' callback is provided, and removes the indicator line.\n   */\n  const onAddBehaviorResize = useCallback(\n    (detail: ColumnResizeDetail<C>) => {\n      addResizePaddingWidthRef.current = detail.paddingWidth;\n      const initialWidths =\n        columnResizingStartingColumnWidthsRef.current != null\n          ? columnResizingStartingColumnWidthsRef.current\n          : detail.allColumnWidths;\n      const newFrozenColumnWidths = _cloneColumnWidths(\n        columnResizingStartingColumnWidthsRef.current != null\n          ? columnResizingStartingColumnWidthsRef.current\n          : detail.type === 'absolute'\n          ? columnWidthsRef.current != null\n            ? columnWidthsRef.current\n            : ({} as ColumnWidths<C>)\n          : detail.allColumnWidths\n      );\n      const newStaticColumnWidths = _cloneColumnWidths(\n        columnWidthsRef.current != null ? columnWidthsRef.current : ({} as ColumnWidths<C>)\n      );\n      const startKey = detail.key;\n      const initialStartWidth = initialWidths[startKey];\n      const newStartWidth =\n        detail.type === 'delta'\n          ? Math.max(initialStartWidth + detail.delta, minColumnWidth)\n          : Math.max(detail.newWidth, minColumnWidth);\n      newStaticColumnWidths[startKey] = newStartWidth;\n      newFrozenColumnWidths[startKey] = newStartWidth;\n\n      if (onColumnWidthsChange != null) {\n        onColumnWidthsChange(newStaticColumnWidths);\n      }\n      setFrozenAddColumnWidths(newFrozenColumnWidths);\n      frozenAddColumnWidthsRef.current = newFrozenColumnWidths;\n      columnResizingStartingColumnWidthsRef.current = undefined;\n      setColumnResizingIndicator(undefined);\n    },\n    [onColumnWidthsChange, minColumnWidth, _cloneColumnWidths]\n  );\n\n  const onColumnResizingHandler =\n    applyWidths === 'onResize'\n      ? resizeBehavior === 'add'\n        ? onAddBehaviorIndicatorResizing\n        : onColumnIndicatorResizing\n      : resizeBehavior === 'add'\n      ? onAddBehaviorResizing\n      : onColumnResizing;\n\n  const tableWidthRef = useRef<number>();\n\n  // scrollerRef is callback-based to meet useResizeObserver hook's state management requirements\n  const [scrollerRef, setScrollerRef] = useState(createRef<UnsafeDomHandle>());\n  const scrollerRefCallback = useCallback((unsafeDomAccess: UnsafeDomHandle | null) => {\n    setScrollerRef({ current: unsafeDomAccess });\n  }, []);\n\n  // setup a resize observer to unfreeze and previously 'frozen' column widths when required\n  useResizeObserver(\n    scrollerRef,\n    useCallback((entry: ResizeObserverEntry) => {\n      const boxSize = entry.contentBoxSize;\n      const newWidth = boxSize[0].inlineSize;\n      if (tableWidthRef.current == null || tableWidthRef.current !== newWidth) {\n        tableWidthRef.current = newWidth;\n\n        let totalWidth = 0;\n        const keys = Object.keys(frozenAddColumnWidthsRef.current) as C[];\n        for (const key of keys) {\n          totalWidth += frozenAddColumnWidthsRef.current[key];\n        }\n        if (newWidth >= totalWidth + addResizePaddingWidthRef.current) {\n          setFrozenAddColumnWidths({} as ColumnWidths<C>);\n          frozenAddColumnWidthsRef.current = {} as ColumnWidths<C>;\n        }\n      }\n    }, []),\n    { isDisabled: resizeBehavior === 'redistribute' }\n  );\n\n  const onColumnResizeHandler = resizeBehavior === 'add' ? onAddBehaviorResize : onColumnResize;\n\n  return {\n    columnResizingProps: {\n      onColumnResizing: onColumnResizingHandler,\n      onColumnResize: onColumnResizeHandler,\n      columnResizingIndicator: columnResizingIndicator,\n      columnWidths: realizedColumnWidths,\n      scrollerRef: scrollerRefCallback\n    }\n  };\n}\n\nexport { useTableViewColumnResizing };\n"],"names":["columnOrder","columnWidths","onColumnWidthsChanging","onColumnWidthsChange","applyWidths","minColumnWidth","resizeBehavior","columnWidthsRef","useRef","current","columnResizingIndicator","setColumnResizingIndicator","useState","columnResizingStartingColumnWidthsRef","frozenAddColumnWidthsRef","frozenAddColumnWidths","setFrozenAddColumnWidths","realizedColumnWidths","updatedKeys","keys","Object","key","push","frozenAddKeys","frozenAddKey","includes","addResizePaddingWidthRef","_cloneColumnWidths","useCallback","widths","newColumnWidths","onColumnResizing","detail","allColumnWidths","newStaticColumnWidths","startKey","endKey","indexOf","initialStartWidth","initialEndWidth","newStartWidth","Math","min","max","delta","newEndWidth","onColumnIndicatorResizing","onColumnResize","initialWidths","type","newWidth","undefined","onAddBehaviorResizing","paddingWidth","newFrozenColumnWidths","onAddBehaviorIndicatorResizing","onAddBehaviorResize","onColumnResizingHandler","tableWidthRef","scrollerRef","setScrollerRef","createRef","scrollerRefCallback","unsafeDomAccess","useResizeObserver","entry","contentBoxSize","inlineSize","totalWidth","isDisabled","columnResizingProps"],"mappings":"6QA4BA,UAAsDA,YACpDA,EAAWC,aACXA,EAAYC,uBACZA,EAAsBC,qBACtBA,EAAoBC,YACpBA,EAAc,aAAYC,eAC1BA,EArBuB,GAqBUC,eACjCA,EAAiB,iBAEjB,MAAMC,EAAkBC,SAAoCP,GAC5DM,EAAgBE,QAAUR,EAE1B,MAAOS,EAAyBC,GAA8BC,EAAQA,WAGhEC,EAAwCL,EAAAA,SAExCM,EAA2BN,SAAwB,CAAA,IAClDO,EAAuBC,GAA4BJ,EAAQA,SAChE,CAAqB,GAIjBK,EAAuB,CAAA,EACvBC,EAAc,GACpB,GAAoB,MAAhBjB,EAAsB,CACxB,MAAMkB,EAAOC,OAAOD,KAAKlB,GACzB,IAAK,MAAMoB,KAAOF,EAChBF,EAAqBI,GAAOpB,EAAaoB,GACzCH,EAAYI,KAAKD,EAEpB,CAED,MAAME,EAAgBH,OAAOD,KAAKJ,GAClC,IAAK,MAAMS,KAAgBD,EACpBL,EAAYO,SAASD,KACxBP,EAAqBO,GAAgBT,EAAsBS,IAG/D,MAAME,EAA2BlB,SAAe,GAE1CmB,EAAqBC,eAAaC,IACtC,MAAMV,EAAOC,OAAOD,KAAKU,GACnBC,EAAkB,CAAA,EACxB,IAAK,MAAMT,KAAOF,EAChBW,EAAgBT,GAAOQ,EAAOR,GAEhC,OAAOS,CAAe,GACrB,IAKGC,EAAmBH,eACtBI,IAEsD,MAAjDnB,EAAsCJ,UACxCI,EAAsCJ,QAAUuB,EAAOC,iBAEzD,MAAMC,EAAwBP,EACD,MAA3BpB,EAAgBE,QAAkBF,EAAgBE,QAAW,CAAA,GAEzD0B,EAAWH,EAAOX,IAClBe,EAASpC,EAAYA,EAAYqC,QAAQF,GAAY,GACrDG,EAAoBzB,EAAsCJ,QAAQ0B,GAClEI,EAAkB1B,EAAsCJ,QAAQ2B,GAChEI,EAAgBC,KAAKC,IACzBD,KAAKE,IAAIL,EAAoBN,EAAOY,MAAOvC,GAC3CiC,EAAoBC,EAAkBlC,GAExC6B,EAAsBC,GAAYK,EAClC,MAAMK,EAAcN,EAAkBD,EAAoBE,EAC1DN,EAAsBE,GAAUS,EAEF,MAA1B3C,GACFA,EAAuBgC,GAEzB3B,EAAgBE,QAAUyB,EAC1BvB,EAA2B,CAAEU,IAAKc,EAAUS,MAAO,GAAI,GAEzD,CAAC1C,EAAwBG,EAAgBL,EAAa2B,IAMlDmB,EAA4BlB,eAC/BI,IACC,MAAMG,EAAWH,EAAOX,IAClBe,EAASpC,EAAYA,EAAYqC,QAAQF,GAAY,GACrDG,EAAoBN,EAAOC,gBAAgBE,GAC3CI,EAAkBP,EAAOC,gBAAgBG,GACzCI,EAAgBC,KAAKC,IACzBD,KAAKE,IAAIL,EAAoBN,EAAOY,MAAOvC,GAC3CiC,EAAoBC,EAAkBlC,GAExCM,EAA2B,CAAEU,IAAKc,EAAUS,MAAOJ,EAAgBF,GAAoB,GAEzF,CAACtC,EAAaK,IAQV0C,EAAiBnB,eACpBI,IACC,MAAMgB,EAC6C,MAAjDnC,EAAsCJ,QAClCI,EAAsCJ,QACtCuB,EAAOC,gBACPC,EAAwBP,EACD,MAA3BpB,EAAgBE,QAAkBF,EAAgBE,QAAW,CAAA,GAEzD0B,EAAWH,EAAOX,IAClBiB,EAAoBU,EAAcb,GACxC,IAAIK,EACJ,GAAoB,aAAhBR,EAAOiB,KACTT,EAAgBC,KAAKE,IAAIX,EAAOkB,SAAU7C,GAC1C6B,EAAsBC,GAAYK,MAC7B,CACL,MAAMJ,EAASpC,EAAYA,EAAYqC,QAAQF,GAAY,GACrDI,EAAkBS,EAAcZ,GACtCI,EAAgBC,KAAKC,IACnBD,KAAKE,IAAIL,EAAoBN,EAAOY,MAAOvC,GAC3CiC,EAAoBC,EAAkBlC,GAExC,MAAMwC,EAAcN,EAAkBD,EAAoBE,EAC1DN,EAAsBE,GAAUS,CACjC,CACDX,EAAsBC,GAAYK,EACN,MAAxBrC,GACFA,EAAqB+B,GAEvB3B,EAAgBE,QAAUyB,EAC1BrB,EAAsCJ,aAAU0C,EAChDxC,OAA2BwC,EAAU,GAEvC,CAAChD,EAAsBE,EAAgBL,EAAa2B,IAMhDyB,EAAwBxB,eAC3BI,IACCN,EAAyBjB,QAAUuB,EAAOqB,aAEW,MAAjDxC,EAAsCJ,UACxCI,EAAsCJ,QAAUuB,EAAOC,iBAEzD,MAAMqB,EAAwB3B,EACqB,MAAjDd,EAAsCJ,QAClCI,EAAsCJ,QACtCuB,EAAOC,iBAEPC,EAAwBP,EACD,MAA3BpB,EAAgBE,QAAkBF,EAAgBE,QAAW,CAAA,GAGzD0B,EAAWH,EAAOX,IAClBiB,EAAoBzB,EAAsCJ,QAAQ0B,GAClEK,EAAgBC,KAAKE,IAAIL,EAAoBN,EAAOY,MAAOvC,GACjE6B,EAAsBC,GAAYK,EAClCc,EAAsBnB,GAAYK,EAEJ,MAA1BtC,GACFA,EAAuBgC,GAEzBlB,EAAyBsC,GACzBxC,EAAyBL,QAAU6C,EACnC3C,EAA2B,CAAEU,IAAKc,EAAUS,MAAO,GAAI,GAEzD,CAAC1C,EAAwBG,EAAgBsB,IAMrC4B,EAAiC3B,eACpCI,IACCN,EAAyBjB,QAAUuB,EAAOqB,aAC1C,MAAMlB,EAAWH,EAAOX,IAClBiB,EAAoBN,EAAOC,gBAAgBE,GAC3CK,EAAgBC,KAAKE,IAAIL,EAAoBN,EAAOY,MAAOvC,GACjEM,EAA2B,CAAEU,IAAKc,EAAUS,MAAOJ,EAAgBF,GAAoB,GAEzF,CAACjC,IAQGmD,EAAsB5B,eACzBI,IACCN,EAAyBjB,QAAUuB,EAAOqB,aAC1C,MAAML,EAC6C,MAAjDnC,EAAsCJ,QAClCI,EAAsCJ,QACtCuB,EAAOC,gBACPqB,EAAwB3B,EACqB,MAAjDd,EAAsCJ,QAClCI,EAAsCJ,QACtB,aAAhBuB,EAAOiB,KACoB,MAA3B1C,EAAgBE,QACdF,EAAgBE,QACf,CAAsB,EACzBuB,EAAOC,iBAEPC,EAAwBP,EACD,MAA3BpB,EAAgBE,QAAkBF,EAAgBE,QAAW,CAAA,GAEzD0B,EAAWH,EAAOX,IAClBiB,EAAoBU,EAAcb,GAClCK,EACY,UAAhBR,EAAOiB,KACHR,KAAKE,IAAIL,EAAoBN,EAAOY,MAAOvC,GAC3CoC,KAAKE,IAAIX,EAAOkB,SAAU7C,GAChC6B,EAAsBC,GAAYK,EAClCc,EAAsBnB,GAAYK,EAEN,MAAxBrC,GACFA,EAAqB+B,GAEvBlB,EAAyBsC,GACzBxC,EAAyBL,QAAU6C,EACnCzC,EAAsCJ,aAAU0C,EAChDxC,OAA2BwC,EAAU,GAEvC,CAAChD,EAAsBE,EAAgBsB,IAGnC8B,EACY,aAAhBrD,EACuB,QAAnBE,EACEiD,EACAT,EACiB,QAAnBxC,EACA8C,EACArB,EAEA2B,EAAgBlD,EAAAA,UAGfmD,EAAaC,GAAkBhD,EAAAA,SAASiD,EAAAA,aACzCC,EAAsBlC,eAAamC,IACvCH,EAAe,CAAEnD,QAASsD,GAAkB,GAC3C,IA2BH,OAxBAC,EAAAA,kBACEL,EACA/B,eAAaqC,IACX,MACMf,EADUe,EAAMC,eACG,GAAGC,WAC5B,GAA6B,MAAzBT,EAAcjD,SAAmBiD,EAAcjD,UAAYyC,EAAU,CACvEQ,EAAcjD,QAAUyC,EAExB,IAAIkB,EAAa,EACjB,MAAMjD,EAAOC,OAAOD,KAAKL,EAAyBL,SAClD,IAAK,MAAMY,KAAOF,EAChBiD,GAActD,EAAyBL,QAAQY,GAE7C6B,GAAYkB,EAAa1C,EAAyBjB,UACpDO,EAAyB,CAAqB,GAC9CF,EAAyBL,QAAU,GAEtC,IACA,IACH,CAAE4D,WAA+B,iBAAnB/D,IAKT,CACLgE,oBAAqB,CACnBvC,iBAAkB0B,EAClBV,eAL6C,QAAnBzC,EAA2BkD,EAAsBT,EAM3ErC,wBAAyBA,EACzBT,aAAcgB,EACd0C,YAAaG,GAGnB"}