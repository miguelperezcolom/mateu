{"version":3,"file":"ConveyorBelt-9982a911.js","sources":["../../src/UNSAFE_ConveyorBelt/ConveyorBelt.tsx"],"sourcesContent":["import { ComponentChildren, Ref } from 'preact';\nimport { useEffect, useRef, useState, useCallback, useMemo } from 'preact/hooks';\nimport { BaseButton } from '../UNSAFE_BaseButton';\nimport { ButtonLabelLayout } from '../UNSAFE_ButtonLabelLayout';\nimport { ChevronLeft } from '../UNSAFE_RedwoodIcons/ChevronLeft';\nimport { ChevronRight } from '../UNSAFE_RedwoodIcons/ChevronRight';\nimport { ChevronUp } from '../UNSAFE_RedwoodIcons/ChevronUp';\nimport { ChevronDown } from '../UNSAFE_RedwoodIcons/ChevronDown';\nimport { classNames as clsx } from '../utils/UNSAFE_classNames';\nimport { styles } from './themes/ConveyorBeltStyles.css';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { ConveyorBeltContext } from './ConveyorBeltContext';\nimport { TestIdProps, useTestId } from '../hooks/UNSAFE_useTestId';\nimport { forwardRef, useImperativeHandle } from 'preact/compat';\nimport { ConveyorBeltVariantOptions } from './themes/ConveyorBeltStyles.css';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { ConveyorBeltRedwoodTheme } from './themes/redwood/ConveyorBeltTheme';\n\nexport type ConveyorBeltProps = TestIdProps & {\n  /**\n   * ConveyorBelt Component content\n   */\n  children?: ComponentChildren;\n  /**\n   * Sets the number of pixels that an element's content is scrolled from its initial position.\n   */\n  scrollPosition?: number;\n  /**\n   * Callback that is executed every time conveyor belt is scrolled and the scroll position is changed.\n   * @param value The value is the new scroll position of the conveyor belt.\n   * @returns\n   */\n  onScrollPositionChanged?: (value?: number) => void;\n  /**\n   * Indicates whether overflow content arrows are visible or hidden.\n   * \"auto\" show overflow arrows on desktop, hide on mobile.\n   * \"visible\" always show overflow arrows.\n   * \"hidden\" never show overflow arrows.\n   */\n  arrowVisibility?: 'auto' | 'visible' | 'hidden';\n\n  /**\n   * Specify the orientation of the conveyorBelt.\n   * \"horizontal\" Orient the conveyorBelt horizontally.\n   * \"vertical\" Orient the conveyorBelt vertically.\n   */\n  orientation?: 'horizontal' | 'vertical';\n};\n\n/**\n * Helper function to determine whether the current device is a mobile device\n * @returns true if runnning on a mobile device, false otherwise\n */\nfunction isMobile() {\n  const deviceType = getClientHints().deviceRenderMode;\n  return deviceType === 'phone';\n}\n\nfunction getOffsetParent(element: HTMLElement) {\n  if (getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent as HTMLElement;\n}\n\nfunction getOffsetLeft(element: HTMLElement, contentContainer?: HTMLElement | null) {\n  let offsetParent = getOffsetParent(element);\n  let offsetLeft = element.offsetLeft;\n\n  while (offsetParent && offsetParent !== contentContainer && offsetParent !== document.body) {\n    offsetLeft = offsetLeft + offsetParent.offsetLeft;\n    offsetParent = getOffsetParent(offsetParent);\n  }\n  return offsetLeft;\n}\n\nfunction getOffsetTop(element: HTMLElement, contentContainer?: HTMLElement | null) {\n  let offsetParent = getOffsetParent(element);\n  let offsetTop = element.offsetTop;\n\n  while (offsetParent !== contentContainer) {\n    if (offsetParent != null) {\n      offsetTop = offsetTop + offsetParent.offsetTop;\n      offsetParent = getOffsetParent(offsetParent);\n    }\n  }\n  return offsetTop;\n}\n\ntype ConveyorItemElement = {\n  element: HTMLElement;\n  isVisible: boolean;\n  isCurrent: boolean;\n  index: number;\n};\n\n// utility hook that calculates which conveyorbelt items are visible inside conveyorbelt viewport\n// and which are hidden\nconst useConveyorElementsVisible = (\n  root: HTMLDivElement,\n  orientation: 'horizontal' | 'vertical',\n  prevBtn?: HTMLDivElement,\n  nextBtn?: HTMLDivElement,\n  direction?: 'ltr' | 'rtl'\n) => {\n  const observerRef = useRef<IntersectionObserver>();\n  const targetsRef = useRef<ConveyorItemElement[]>([]);\n  const [targets] = useState<ConveyorItemElement[]>([]);\n  const addTarget = useCallback(\n    (target: ConveyorItemElement) => {\n      if (targetsRef.current !== null) {\n        targetsRef.current.push(target);\n        targets.push(target);\n      }\n    },\n    [targets]\n  );\n\n  useEffect(() => {\n    if (targets && targets.length > 0 && root) {\n      // IntersectionObserver calls visibility change only when item is\n      // fully visible inside (threshold: 1)\n      // conveyorbelt viewport (root),\n      // taking arrow buttons into the account\n      // and viewport should be smaller by the buttons width (rootMargin)\n      const rootMargin =\n        orientation === 'horizontal'\n          ? direction === 'ltr'\n            ? `0px ${nextBtn ? -nextBtn.offsetWidth : 0}px 0px ${\n                prevBtn ? -prevBtn.offsetWidth : 0\n              }px`\n            : `0px ${prevBtn ? -prevBtn.offsetWidth : 0}px 0px ${\n                nextBtn ? -nextBtn.offsetWidth : 0\n              }px`\n          : `${nextBtn ? -nextBtn.offsetHeight : 0}px 0px ${\n              prevBtn ? -prevBtn.offsetHeight : 0\n            }px 0px`;\n\n      observerRef.current = new IntersectionObserver(onVisibilityChange, {\n        root,\n        rootMargin: rootMargin,\n        threshold: 1\n      });\n      for (const target of targets) {\n        if (target != null) observerRef.current.observe(target.element);\n      }\n    }\n    return () => {\n      for (const target of targets) {\n        if (observerRef.current && target != null) observerRef.current.unobserve(target.element);\n      }\n    };\n  }, [targets, targets.length, root, nextBtn, prevBtn, direction, orientation]);\n\n  // handle visibility changes\n  const onVisibilityChange = (entries: IntersectionObserverEntry[]) => {\n    const newItems: ConveyorItemElement[] = targetsRef.current.map((conveyorItem, index) => {\n      const foundEntry = entries.find((entry) => entry.target === conveyorItem.element);\n      // if visibility changed for the item, change isVisible property,\n      // otherwise just return the original\n      if (foundEntry) {\n        return {\n          element: foundEntry.target as HTMLDivElement,\n          isVisible: foundEntry.isIntersecting,\n          isCurrent: conveyorItem.isCurrent,\n          index: index\n        };\n      } else {\n        return conveyorItem;\n      }\n    });\n    targetsRef.current = newItems;\n  };\n\n  return useMemo(\n    () => ({\n      itemElementsRef: targetsRef,\n      addItem: addTarget\n    }),\n    [targetsRef, addTarget]\n  );\n};\n\nexport type ScrollableHandle = {\n  scrollElementIntoView: (element: HTMLElement) => void;\n};\n\n/**\n * The Conveyor belt component is a container element that manages\n * overflow for its child elements and allows scrolling among them\n */\nexport const ConveyorBelt = forwardRef(\n  (\n    {\n      children,\n      scrollPosition,\n      onScrollPositionChanged,\n      arrowVisibility = 'auto',\n      orientation = 'horizontal',\n      testId\n    }: ConveyorBeltProps,\n    ref: Ref<ScrollableHandle> = null\n  ) => {\n    const [canPaginateNext, setCanPaginateNext] = useState(false);\n    const [canPaginatePrevious, setCanPaginatePrevious] = useState(false);\n    const overflowContainerRef = useRef<HTMLDivElement | null>(null);\n    const contentContainerRef = useRef<HTMLDivElement | null>(null);\n    const nextButtonContainerRef = useRef<HTMLDivElement | null>(null);\n    const prevButtonContainerRef = useRef<HTMLDivElement | null>(null);\n    const baseRef = useRef<HTMLDivElement | null>(null);\n    const leftRef = useRef<HTMLDivElement | null>(null);\n    const rightRef = useRef<HTMLDivElement | null>(null);\n    const observerRef = useRef<any>(null);\n    const currentItemRef = useRef<HTMLElement | null>(null);\n    const [buttonsHidden, setButtonsHidden] = useState(\n      (isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden'\n    );\n    const { direction } = useUser();\n    const { itemElementsRef, addItem } = useConveyorElementsVisible(\n      overflowContainerRef.current!,\n      orientation,\n      prevButtonContainerRef.current!,\n      nextButtonContainerRef.current!,\n      direction\n    );\n\n    useImperativeHandle(ref, () => ({\n      scrollElementIntoView: (element: HTMLElement) => {\n        scrollIntoView(element);\n      },\n      scrollPrevious: () => {\n        scrollToPreviousPage();\n      },\n      scrollNext: () => {\n        scrollToNextPage();\n      }\n    }));\n\n    const testIdProps = useTestId(testId);\n    const leftArrowTestIdProps = 'leftArrow' + testId;\n    const rightArrowTestIdProps = 'rightArrow' + testId;\n\n    const { variantClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        orientation\n      }\n    );\n\n    const { variantClasses: contentClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        content: orientation\n      }\n    );\n\n    const { variantClasses: overflowClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        pagination:\n          canPaginateNext && canPaginatePrevious\n            ? 'both'\n            : canPaginateNext\n            ? 'next'\n            : canPaginatePrevious\n            ? 'previous'\n            : 'none',\n        direction,\n        orientation,\n        overflow: orientation,\n        arrowVisibility: buttonsHidden === true ? 'hidden' : 'visible'\n      }\n    );\n\n    const { classes: nextButtonClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        nextButton: orientation,\n        direction\n      }\n    );\n\n    const { classes: previousButtonClasses } = useComponentTheme<ConveyorBeltVariantOptions>(\n      ConveyorBeltRedwoodTheme,\n      {\n        previousButton: orientation,\n        direction\n      }\n    );\n\n    // utility method to get all conveyorbelt items\n    const _getConveyorItems = () => {\n      const conveyorContentChildren = contentContainerRef.current\n        ? Array.from(contentContainerRef.current.querySelectorAll('[data-oj-conveyorbelt-item]'))\n        : [];\n \n      if (conveyorContentChildren) {\n        let index = -1;\n        itemElementsRef.current = [];\n         for (const child of conveyorContentChildren) {\n          index++;\n          const element = child as HTMLElement;\n          if (element) {\n              addItem({\n                element: element,\n                isVisible: false,\n                index: index,\n                isCurrent: false\n              });\n          }\n        }\n      }\n    };\n\n    useEffect(() => {\n      _getConveyorItems();\n    });\n\n    const scrollEndHandler = useCallback(() => {\n      if (onScrollPositionChanged)\n        onScrollPositionChanged(overflowContainerRef.current?.scrollLeft);\n    }, [onScrollPositionChanged]);\n\n    useEffect(() => {\n      setButtonsHidden((isMobile() && arrowVisibility === 'auto') || arrowVisibility === 'hidden');\n    }, [arrowVisibility]);\n\n    useEffect(() => {\n      if (!overflowContainerRef.current) return;\n      overflowContainerRef.current.scrollTo({\n        left: scrollPosition\n      });\n    }, [scrollPosition]);\n\n    // useEffect hook that calculates when arrow buttons should become visible or hidden\n    // using IntersectionObserver\n    useEffect(() => {\n      const overflowContainer = overflowContainerRef.current;\n      const leftGuard = leftRef.current;\n      const rightGuard = rightRef.current;\n\n      if (overflowContainer && leftGuard && rightGuard) {\n        if (!buttonsHidden) {\n          observerRef.current = new IntersectionObserver(\n            (entries) => {\n              entries.forEach((entry) => {\n                if (entry.target.getAttribute('data-intersection-id') === 'left') {\n                  setCanPaginatePrevious(!entry.isIntersecting);\n                } else {\n                  setCanPaginateNext(!entry.isIntersecting);\n                }\n              });\n            },\n            {\n              root: overflowContainer\n            }\n          );\n          observerRef.current.observe(leftGuard);\n          observerRef.current.observe(rightGuard);\n        }\n        overflowContainer.addEventListener('scrollend', scrollEndHandler);\n      }\n\n      // Clean-up\n      return () => {\n        if (!overflowContainer) return;\n        overflowContainer.removeEventListener('scrollend', scrollEndHandler);\n        observerRef.current?.unobserve(leftGuard);\n        observerRef.current?.unobserve(rightGuard);\n      };\n    }, [buttonsHidden, scrollEndHandler]);\n\n    const scrollIntoView = useCallback(\n      (element: HTMLElement) => {\n        const prevOffsetWidth = prevButtonContainerRef.current ? prevButtonContainerRef.current.offsetWidth : 0;\n        const prevOffsetHeight = nextButtonContainerRef.current ? nextButtonContainerRef.current.offsetHeight : 0;\n        const nextOffsetWidth = prevButtonContainerRef.current ? prevButtonContainerRef.current.offsetWidth : 0;\n        const nextOffsetHeight = nextButtonContainerRef.current ? nextButtonContainerRef.current.offsetWidth : 0;\n        // utility method to check if the element is closer to the end edge of the conveyorbelt\n        const _shouldSnapToTheEndEdge = (\n          ltr: boolean,\n          orientation: 'horizontal' | 'vertical',\n          elem?: HTMLElement | null,\n          scroller?: HTMLDivElement | null\n        ) => {\n          if (!elem || !scroller) return false;\n          let right;\n          let left;\n          let bottom;\n\n          if (scroller === document.documentElement) {\n            left = 0;\n            right = document.documentElement.clientWidth;\n            bottom = document.documentElement.clientHeight;\n          } else {\n            const scrollerBounds = scroller.getBoundingClientRect();\n            right = canPaginateNext\n              ? scrollerBounds.right - nextOffsetWidth\n              : scrollerBounds.right;\n            left = canPaginateNext\n              ? scrollerBounds.left - nextOffsetWidth\n              : scrollerBounds.left;\n            bottom = canPaginateNext\n              ? scrollerBounds.bottom - nextOffsetHeight\n              : scrollerBounds.bottom;\n          }\n          const bounds = elem.getBoundingClientRect();\n          return orientation === 'horizontal'\n            ? ltr\n              ? bounds.right > right\n              : bounds.left < left\n            : bounds.bottom > bottom;\n        };\n\n        // utility method to check that an element is fully visible inside conveyorbelt\n        const _isElementInsideScrollerBounds = (\n          orientation: 'vertical' | 'horizontal',\n          elem?: HTMLElement | null,\n          scroller?: HTMLDivElement | null\n        ) => {\n          if (!elem || !scroller) return false;\n          let left;\n          let right;\n          let top;\n          let bottom;\n          if (scroller === document.documentElement) {\n            left = 0;\n            right = document.documentElement.clientWidth;\n            top = 0;\n            bottom = document.documentElement.clientHeight;\n          } else {\n\n            const scrollerBounds = scroller.getBoundingClientRect();\n            left = canPaginatePrevious\n              ? scrollerBounds.left + prevOffsetWidth\n              : scrollerBounds.left;\n            right = canPaginateNext\n              ? scrollerBounds.right - nextOffsetWidth\n              : scrollerBounds.right;\n            top = canPaginatePrevious\n              ? scrollerBounds.top + prevOffsetHeight\n              : scrollerBounds.top;\n            bottom = canPaginateNext\n              ? scrollerBounds.bottom - nextOffsetHeight\n              : scrollerBounds.bottom;\n          }\n          const bounds = elem.getBoundingClientRect();\n          return orientation === 'horizontal'\n            ? bounds.left <= right &&\n                bounds.right <= right &&\n                bounds.left >= left &&\n                bounds.right >= left\n            : bounds.top <= bottom &&\n                bounds.bottom <= bottom &&\n                bounds.top >= top &&\n                bounds.bottom >= top;\n        };\n\n        const _isElementOverflowingScrollerBounds = (\n          orientation: 'vertical' | 'horizontal',\n          elem?: HTMLElement | null,\n          scroller?: HTMLDivElement | null\n        ) => {\n          if (!elem || !scroller) return false;\n          const bounds = elem.getBoundingClientRect();\n          const scrollerBounds = scroller.getBoundingClientRect();\n          let width = scrollerBounds.width;\n          let height = scrollerBounds.height;\n          if (orientation === 'horizontal') {\n            width =\n              canPaginatePrevious && prevButtonContainerRef.current\n                ? width - prevButtonContainerRef.current.offsetWidth\n                : width;\n            width =\n              canPaginateNext && nextButtonContainerRef.current\n                ? width - nextButtonContainerRef.current.offsetWidth\n                : width;\n          } else {\n            height =\n              canPaginatePrevious && prevButtonContainerRef.current\n                ? height - prevButtonContainerRef.current.offsetHeight!\n                : height;\n            height =\n              canPaginateNext && nextButtonContainerRef.current\n                ? height - nextButtonContainerRef.current.offsetHeight!\n                : height;\n          }\n\n          return orientation === 'horizontal' ? bounds.width > width : bounds.height > height;\n        };\n\n        const isElementVisible = _isElementInsideScrollerBounds(\n          orientation,\n          element,\n          overflowContainerRef.current\n        );\n        if (isElementVisible) {\n          return;\n        }\n        const isElementOverflowing = _isElementOverflowingScrollerBounds(\n          orientation,\n          element,\n          overflowContainerRef.current\n        );\n\n        if (!overflowContainerRef.current || !contentContainerRef.current) return;\n        const shouldSnapEnd = _shouldSnapToTheEndEdge(\n          direction === 'ltr',\n          orientation,\n          element,\n          overflowContainerRef.current\n        );\n        if (orientation === 'vertical') {\n          if (shouldSnapEnd && !isElementOverflowing) {\n            overflowContainerRef.current.scrollTo({\n              top:\n                getOffsetTop(element, contentContainerRef.current) +\n                element.offsetHeight -\n                overflowContainerRef.current.offsetHeight +\n                (nextButtonContainerRef.current?.offsetHeight\n                  ? nextButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainerRef.current.scrollTo({\n              top:\n                getOffsetTop(element, contentContainerRef.current) -\n                (prevButtonContainerRef.current?.offsetHeight\n                  ? prevButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n          return;\n        }\n\n        if (direction === 'ltr') {\n          if (shouldSnapEnd && !isElementOverflowing) {\n            overflowContainerRef.current.scrollTo({\n              left:\n                getOffsetLeft(element, contentContainerRef.current) +\n                element.offsetWidth -\n                overflowContainerRef.current.offsetWidth +\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainerRef.current.scrollTo({\n              left:\n                getOffsetLeft(element, contentContainerRef.current) -\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          if (shouldSnapEnd && !isElementOverflowing) {\n            overflowContainerRef.current.scrollTo({\n              left:\n                getOffsetLeft(element, contentContainerRef.current) -\n                contentContainerRef.current.offsetWidth +\n                overflowContainerRef.current.offsetWidth -\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainerRef.current.scrollTo({\n              left:\n                getOffsetLeft(element, contentContainerRef.current) +\n                element.offsetWidth -\n                contentContainerRef.current.offsetWidth +\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        }\n      },\n      [canPaginateNext, canPaginatePrevious, direction, orientation]\n    );\n\n    const getNextInvisible = useCallback(() => {\n      const nextInvisible = itemElementsRef.current.find((item) => {\n        if (\n          item.isVisible == false &&\n          item.index >= 1 &&\n          itemElementsRef.current[item.index - 1].isVisible == true\n        ) {\n          return true;\n        }\n        return false;\n      });\n      return nextInvisible?.element;\n    }, [itemElementsRef]);\n\n    const getPreviousInvisible = useCallback(() => {\n      const previousInvisible = itemElementsRef.current.find((item) => {\n        if (\n          item.isVisible == false &&\n          item.index < itemElementsRef.current.length - 1 &&\n          itemElementsRef.current[item.index + 1].isVisible == true\n        ) {\n          return true;\n        }\n        return false;\n      });\n      return previousInvisible?.element;\n    }, [itemElementsRef]);\n\n    // paginates to the previous partially visible or hidden item in the conveyorbelt,\n    // so that it is the last visible of the conveyorbelt view port\n    const scrollToPreviousPage = useCallback(() => {\n      const overflowContainer = overflowContainerRef.current;\n      const scrollAmount =\n        orientation === 'horizontal'\n          ? overflowContainerRef.current?.clientWidth\n          : overflowContainerRef.current?.clientHeight;\n\n      if (overflowContainer && scrollAmount) {\n        const previousInvisible: HTMLElement | undefined = getPreviousInvisible();\n        if (orientation === 'vertical') {\n          if (!previousInvisible) {\n            overflowContainer.scrollTo({\n              top: overflowContainer.scrollTop - scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              top:\n                getOffsetTop(previousInvisible, contentContainerRef.current) +\n                previousInvisible.offsetHeight -\n                overflowContainer.offsetHeight +\n                (prevButtonContainerRef.current?.offsetHeight\n                  ? prevButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n          return;\n        }\n        if (direction === 'ltr') {\n          if (!previousInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft - scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                getOffsetLeft(previousInvisible, contentContainerRef.current) +\n                previousInvisible.offsetWidth -\n                overflowContainer.offsetWidth +\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          if (!previousInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft + scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                getOffsetLeft(previousInvisible, contentContainerRef.current) -\n                (contentContainerRef.current ? contentContainerRef.current.offsetWidth: 0) +\n                overflowContainer.offsetWidth -\n                (prevButtonContainerRef.current?.offsetWidth\n                  ? prevButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        }\n      }\n    }, [direction, orientation, getPreviousInvisible]);\n\n    // paginates to the next partially visible or hidden item in the conveyorbelt,\n    // so that it is the first at the start of the conveyorbelt view port\n    const scrollToNextPage = useCallback(() => {\n      const overflowContainer = overflowContainerRef.current;\n      const scrollAmount =\n        orientation === 'horizontal'\n          ? overflowContainerRef.current?.clientWidth\n          : overflowContainerRef.current?.clientHeight;\n\n      if (overflowContainer && scrollAmount) {\n        const nextInvisible: HTMLElement | undefined = getNextInvisible();\n        if (orientation === 'vertical') {\n          if (!nextInvisible) {\n            overflowContainer.scrollTo({\n              top: overflowContainer.scrollTop + scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              top:\n                getOffsetTop(nextInvisible, contentContainerRef.current) -\n                (nextButtonContainerRef.current?.offsetHeight\n                  ? nextButtonContainerRef.current?.offsetHeight + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n          return;\n        }\n        if (direction === 'ltr') {\n          if (!nextInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft + scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                (getOffsetLeft(nextInvisible, contentContainerRef.current) ?? 0) -\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        } else {\n          if (!nextInvisible) {\n            overflowContainer.scrollTo({\n              left: overflowContainer.scrollLeft - scrollAmount,\n              behavior: 'smooth'\n            });\n          } else {\n            overflowContainer.scrollTo({\n              left:\n                -(\n                  (contentContainerRef.current ? contentContainerRef.current.offsetWidth : 0) -\n                  (getOffsetLeft(nextInvisible, contentContainerRef.current) ?? 0)\n                ) +\n                (nextInvisible?.offsetWidth ?? 0) +\n                (nextButtonContainerRef.current?.offsetWidth\n                  ? nextButtonContainerRef.current?.offsetWidth + 1\n                  : 0),\n              behavior: 'smooth'\n            });\n          }\n        }\n      }\n    }, [direction, orientation, getNextInvisible]);\n\n    const setCurrentItem = useCallback(\n      (node: HTMLElement | null) => {\n        if (currentItemRef.current !== node) {\n          // this logic below is needed to make sure only one item is current\n          const item = itemElementsRef.current.find((item) => item.element === node);\n          const currentItem = itemElementsRef.current.find((item) => item.isCurrent === true);\n          if (item === currentItem || !item) return;\n          if (currentItem) currentItem.isCurrent = false;\n          item.isCurrent = true;\n\n          currentItemRef.current = node;\n          if (node) scrollIntoView(node);\n        }\n      },\n      [itemElementsRef, scrollIntoView]\n    );\n\n    const onFocus = useCallback(\n      (event: FocusEvent) => {\n        if (baseRef.current?.isEqualNode(event.target as HTMLElement)) {\n          return;\n        }\n        if (itemElementsRef.current.length > 0) {\n          const item = itemElementsRef.current.find((item) =>\n            item.element.contains(event.target as Node)\n          );\n          if (item) {\n            scrollIntoView(item.element);\n          }\n        } else {\n          scrollIntoView(event.target as HTMLElement);\n        }\n      },\n      [scrollIntoView, itemElementsRef]\n    );\n\n    const previousButtonStyle = clsx([styles.buttonContainer, previousButtonClasses]);\n\n    const nextButtonStyle = clsx([styles.buttonContainer, nextButtonClasses]);\n\n    return (\n      <ConveyorBeltContext.Provider value={{ setCurrentItem }}>\n        <div\n          onFocus={onFocus}\n          ref={baseRef}\n          className={clsx([styles.conveyorStyle, variantClasses])}\n          {...testIdProps}>\n          {canPaginatePrevious && !buttonsHidden && (\n            <div ref={prevButtonContainerRef} class={previousButtonStyle}>\n              <BaseButton\n                elementDetails={{ type: 'span', isFocusable: false }}\n                styling={['min']}\n                size={'sm'}\n                variant={'ghost'}\n                onAction={() => scrollToPreviousPage()}\n                aria-hidden={true}\n                testId={leftArrowTestIdProps}>\n                <ButtonLabelLayout\n                  size={'sm'}\n                  display={'icons'}\n                  startIcon={\n                    orientation === 'horizontal' ? (\n                      direction === 'ltr' ? (\n                        <ChevronLeft />\n                      ) : (\n                        <ChevronRight />\n                      )\n                    ) : (\n                      <ChevronUp />\n                    )\n                  }></ButtonLabelLayout>\n              </BaseButton>\n            </div>\n          )}\n          <div\n            className={clsx([styles.overflowContainer, overflowClasses])}\n            ref={overflowContainerRef}\n            tabIndex={-1}>\n            <div\n              className={clsx([styles.contentContainer, variantClasses, contentClasses])}\n              ref={contentContainerRef}>\n              <div\n                data-intersection-id=\"left\"\n                ref={leftRef}\n                style={{ minWidth: 1, minHeight: 1 }}\n              />\n              {children}\n              <div\n                data-intersection-id=\"right\"\n                ref={rightRef}\n                style={{ minWidth: 1, minHeight: 1 }}\n              />\n            </div>\n          </div>\n          {canPaginateNext && !buttonsHidden && (\n            <div ref={nextButtonContainerRef} class={nextButtonStyle}>\n              <BaseButton\n                elementDetails={{ type: 'span', isFocusable: false }}\n                styling={['min']}\n                size={'sm'}\n                variant={'ghost'}\n                onAction={() => scrollToNextPage()}\n                aria-hidden={true}\n                testId={rightArrowTestIdProps}>\n                <ButtonLabelLayout\n                  size={'sm'}\n                  display={'icons'}\n                  startIcon={\n                    orientation === 'horizontal' ? (\n                      direction === 'ltr' ? (\n                        <ChevronRight />\n                      ) : (\n                        <ChevronLeft />\n                      )\n                    ) : (\n                      <ChevronDown />\n                    )\n                  }></ButtonLabelLayout>\n              </BaseButton>\n            </div>\n          )}\n        </div>\n      </ConveyorBeltContext.Provider>\n    );\n  }\n);\n"],"names":["isMobile","getClientHints","deviceRenderMode","getOffsetParent","element","getComputedStyle","position","offsetParent","getOffsetLeft","contentContainer","offsetLeft","document","body","getOffsetTop","offsetTop","ConveyorBelt","forwardRef","children","scrollPosition","onScrollPositionChanged","arrowVisibility","orientation","testId","ref","canPaginateNext","setCanPaginateNext","useState","canPaginatePrevious","setCanPaginatePrevious","overflowContainerRef","useRef","contentContainerRef","nextButtonContainerRef","prevButtonContainerRef","baseRef","leftRef","rightRef","observerRef","currentItemRef","buttonsHidden","setButtonsHidden","direction","useUser","itemElementsRef","addItem","root","prevBtn","nextBtn","targetsRef","targets","addTarget","useCallback","target","current","push","useEffect","length","rootMargin","offsetWidth","offsetHeight","IntersectionObserver","onVisibilityChange","threshold","observe","unobserve","entries","newItems","map","conveyorItem","index","foundEntry","find","entry","isVisible","isIntersecting","isCurrent","useMemo","useConveyorElementsVisible","useImperativeHandle","scrollElementIntoView","scrollIntoView","scrollPrevious","scrollToPreviousPage","scrollNext","scrollToNextPage","testIdProps","useTestId","leftArrowTestIdProps","rightArrowTestIdProps","variantClasses","useComponentTheme","ConveyorBeltRedwoodTheme","contentClasses","content","overflowClasses","pagination","overflow","classes","nextButtonClasses","nextButton","previousButtonClasses","previousButton","conveyorContentChildren","Array","from","querySelectorAll","child","_getConveyorItems","scrollEndHandler","scrollLeft","scrollTo","left","overflowContainer","leftGuard","rightGuard","forEach","getAttribute","addEventListener","removeEventListener","prevOffsetWidth","prevOffsetHeight","nextOffsetWidth","nextOffsetHeight","isElementVisible","elem","scroller","right","top","bottom","documentElement","clientWidth","clientHeight","scrollerBounds","getBoundingClientRect","bounds","_isElementInsideScrollerBounds","isElementOverflowing","width","height","_isElementOverflowingScrollerBounds","shouldSnapEnd","ltr","_shouldSnapToTheEndEdge","behavior","getNextInvisible","nextInvisible","item","getPreviousInvisible","previousInvisible","scrollAmount","scrollTop","setCurrentItem","node","currentItem","onFocus","event","isEqualNode","contains","previousButtonStyle","clsx","styles","buttonContainer","nextButtonStyle","_jsx","ConveyorBeltContext","Provider","value","_jsxs","className","conveyorStyle","jsx","class","BaseButton","elementDetails","type","isFocusable","styling","size","variant","onAction","ButtonLabelLayout","display","startIcon","ChevronLeft","SvgChevronLeft","ChevronRight","ChevronUp","tabIndex","style","minWidth","minHeight","ChevronDown","SvgChevronDown"],"mappings":"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"}