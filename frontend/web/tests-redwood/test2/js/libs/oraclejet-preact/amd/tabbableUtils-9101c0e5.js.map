{"version":3,"file":"tabbableUtils-9101c0e5.js","sources":["../../../../node_modules/ramda/es/last.js","../../src/utils/PRIVATE_tabbableUtils/tabbableUtils.ts"],"sourcesContent":["import nth from \"./nth.js\";\n/**\n * Returns the last element of the given list or string.\n *\n * @func\n * @memberOf R\n * @since v0.1.4\n * @category List\n * @sig [a] -> a | Undefined\n * @sig String -> String\n * @param {*} list\n * @return {*}\n * @see R.init, R.head, R.tail\n * @example\n *\n *      R.last(['fi', 'fo', 'fum']); //=> 'fum'\n *      R.last([]); //=> undefined\n *\n *      R.last('abc'); //=> 'c'\n *      R.last(''); //=> ''\n */\n\nvar last =\n/*#__PURE__*/\nnth(-1);\nexport default last;","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n/**\n * Tabbable Mode helpers\n */\nimport { head } from 'ramda';\nimport { last } from 'ramda';\nimport { pipe } from 'ramda';\n\n// definition for Element types that can receive focus\nexport type FocusableElement = HTMLElement | SVGElement;\n\nimport { getClientHints } from '../PRIVATE_clientHints';\n\n/**\n * Query selector to return all tabbable elements\n * @param allowAllTabIndex This param is optional. The default value is false. To include the element with tabIndex='-1', specify allowAllTabIndex to true.\n */\nconst findTabbableQuery = (allowAllTabIndex?: boolean) => {\n  const defaultFocusableElements = [\n    'button',\n    '[href]',\n    'input',\n    'select',\n    'textarea',\n    '[tabindex]',\n    'video'\n  ];\n  const selectorSuffix = ':not([tabindex=\"-1\"]):not([disabled]):not([hidden])';\n\n  const elementsCount = defaultFocusableElements.length;\n  let safeFocusablesSelector = '';\n\n  // Loop adding suffix\n  for (let i = 0; i < elementsCount; i++) {\n    const elSelector = `${defaultFocusableElements[i]}${selectorSuffix}`;\n    safeFocusablesSelector += `${elSelector}, `;\n  }\n\n  // Special cases\n  safeFocusablesSelector += \"[contenteditable]:not([contenteditable='false'])\";\n  if (allowAllTabIndex) {\n    safeFocusablesSelector += ', [tabIndex]';\n  }\n  return safeFocusablesSelector;\n};\n\n/**\n * Use tabbableQuery selector to determine if an element is tabbable\n * @param element the element\n * @param allowAllTabIndex This param is optional. The default value is false. To include the element with tabIndex='-1', specify allowAllTabIndex to true\n */\nconst isTabbableElement = (element: FocusableElement, allowAllTabIndex?: boolean) =>\n  element.matches(findTabbableQuery(allowAllTabIndex));\n\n/**\n * All tabbable child elements in a node.\n * @param el the node\n * @param includeItself This param is optional. The default value is false. To include the current node, specify includeItself to true\n * @param allowAllTabIndex This param is optional. The default value is false. To include the element with tabIndex='-1', specify allowAllTabIndex to true.\n */\nconst allTabbableElements = (\n  el: FocusableElement,\n  includeItself?: boolean,\n  allowAllTabIndex?: boolean\n) => {\n  const tabbableQuery = findTabbableQuery(allowAllTabIndex);\n  const tabbable = Array.from(el.querySelectorAll(tabbableQuery)).filter((element) => {\n    // @ts-ignore\n    return !isHidden(element);\n  }) as FocusableElement[];\n\n  if (includeItself && isTabbableElement(el, allowAllTabIndex)) {\n    tabbable.push(el);\n  }\n  return tabbable;\n};\n\n// All tabbable child elements in a node,  or the container itself if there is none\nconst tabbablesOrContainer = (element: FocusableElement) => {\n  const tabbableElements = allTabbableElements(element);\n  return tabbableElements.length ? tabbableElements : [element];\n};\n\n// First tabbable child element in a node, or the container itself if there is none\nconst firstTabbableOrContainer = pipe(tabbablesOrContainer, head);\n\n/**\n * Focus Helpers\n */\n\n// preventScroll safe focus setter\nconst focusOn = (element: FocusableElement | { focus: () => void }) => {\n  element.focus({ preventScroll: true });\n};\n\n// focus on first tabbable in a container or container itself if there is none\nconst focusWithin = (element: FocusableElement) => {\n  const firstTabbable = firstTabbableOrContainer(element);\n  focusOn(firstTabbable as FocusableElement);\n};\n\n// focus on initial tabstop\nconst focusOnStart = pipe(tabbablesOrContainer, head, focusOn);\n\n// focus on last tabstop\nconst focusOnEnd = pipe(tabbablesOrContainer, last, focusOn);\n\n// get active element from document parent of the node\nconst getActiveElement = (node?: Node) => {\n  const conditionalDocument = node?.ownerDocument ?? document;\n  return conditionalDocument.activeElement as FocusableElement;\n};\n\n// get active element from document parent of the node\nconst getBodyElement = (node?: Node) => {\n  const conditionalDocument = node?.ownerDocument ?? document;\n  return conditionalDocument.body;\n};\n\nconst isHidden = (element: HTMLElement): boolean => {\n  // 1.A Case: display: 'none' | position: 'fixed' (except Firefox)\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n  // Note: offsetParent returns null in the following situations:\n  // The element or any ancestor has the display property set to none.\n  // The element has the position property set to fixed (Firefox returns <body>).\n  // ...\n  // To check the latter - whether the element has fixed position\n  // we would have to call expensive getComputedStyle()\n  // As we have not seen a fixed position tabbable element yet\n  // we intentionally don't do that until we got a usecase.\n  // Most hidden elements are hidden using display none which\n  // can be checked cheap using following:\n  if (element.offsetParent === null) {\n    return true;\n  }\n\n  // 2. Case: visibility: 'hidden'\n  // There's no other way than calling getComputedStyle():\n  // getComputedStyle() correctly computes visibility even it is inherited.\n  // https://developer.mozilla.org/en-US/docs/Web/API/Window/getComputedStyle\n  // The Window.getComputedStyle() method returns an object containing the values of all CSS properties of an element,\n  // after applying active stylesheets and resolving any basic computation those values may contain.\n  const elComputedStyles = window.getComputedStyle(element);\n  if (elComputedStyles.visibility === 'hidden') {\n    return true;\n  }\n\n  // 1.B Firefox case (see comment of 1.A):\n  // \"The element has the position property set to fixed (Firefox returns <body>).\"\n  // But in case element's parent has 'translate' css style applied, which is a typical\n  // residual style left on an element after an animation effect, Firefox does not\n  // report document.body as the offsetParent.\n  // Therefore we eliminate fixed positioned elements from the tabbable array with a direct check:\n  const browser = getClientHints().browser;\n  if (browser === 'firefox' && elComputedStyles.position === 'fixed') {\n    return true;\n  }\n  // Element is not hidden\n  return false;\n};\n\nconst getAutofocusFocusables = (element: HTMLElement): HTMLElement[] => {\n  const selector = '[autofocus]:not([tabindex=\"-1\"]):not([disabled]):not([hidden])';\n  const focusableCandidates: HTMLElement[] = Array.from(element.querySelectorAll(selector));\n  const focusables: HTMLElement[] = focusableCandidates.filter((item: HTMLElement) => {\n    return isHidden(item);\n  });\n  return focusables;\n};\n\nfunction isElement(element: HTMLElement) {\n  return element instanceof Element;\n}\n\nconst focusOnElementOrNearestAncestor = (element: HTMLElement): void => {\n  if (isElement(element)) {\n    if (isTabbableElement(element)) {\n      element.focus();\n    } else {\n      // If the drawer opener is not focusable, focus the nearest focusable ancestor.\n      let nearestAncestor = element.parentElement;\n      // In case the launcher was removed (e.g. drawer opener was a dropdown menu item)\n      // focus ends on <body> which ancestor is <html>.\n      // In this case stop looking for the nearest ancestor.\n      while (\n        nearestAncestor &&\n        nearestAncestor.nodeName !== 'HTML' &&\n        !isTabbableElement(nearestAncestor)\n      ) {\n        nearestAncestor = nearestAncestor.parentElement;\n      }\n      if (nearestAncestor) {\n        nearestAncestor.focus();\n      }\n    }\n  }\n};\n\nexport {\n  focusOn, // preventScroll safe focus setter\n  focusWithin, // focus on first tabbable in a container or container itself if there is none\n  focusOnEnd, // focus on last tabstop in a container\n  focusOnStart, // focus on first tabstop in a container\n  getActiveElement, // get active element from document parent of the node\n  getAutofocusFocusables, // get elements with autofocus attribute\n  getBodyElement, // get the body element from document parent of the node\n  isTabbableElement, // uses tabbableQuery selector to determine if an element is tabbable\n  allTabbableElements, // uses tabbableQuery selector to find all tabbable elements inside an element\n  focusOnElementOrNearestAncestor\n};\n"],"names":["last$1","nth","findTabbableQuery","allowAllTabIndex","defaultFocusableElements","elementsCount","length","safeFocusablesSelector","i","isTabbableElement","element","matches","allTabbableElements","el","includeItself","tabbableQuery","tabbable","Array","from","querySelectorAll","filter","isHidden","push","tabbablesOrContainer","tabbableElements","firstTabbableOrContainer","pipe","head","focusOn","focus","preventScroll","focusOnStart","focusOnEnd","last","offsetParent","elComputedStyles","window","getComputedStyle","visibility","getClientHints","browser","position","Element","isElement","nearestAncestor","parentElement","nodeName","firstTabbable","node","ownerDocument","document","activeElement","item","body"],"mappings":"4FAsBA,IAGAA,EADAC,EAAAA,KAAK,GCAL,MAAMC,EAAqBC,IACzB,MAAMC,EAA2B,CAC/B,SACA,SACA,QACA,SACA,WACA,aACA,SAIIC,EAAgBD,EAAyBE,OAC/C,IAAIC,EAAyB,GAG7B,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAeG,IAAK,CAEtCD,GAA0B,GADP,GAAGH,EAAyBI,2DAEhD,CAOD,OAJAD,GAA0B,mDACtBJ,IACFI,GAA0B,gBAErBA,CAAsB,EAQzBE,EAAoB,CAACC,EAA2BP,IACpDO,EAAQC,QAAQT,EAAkBC,IAQ9BS,EAAsB,CAC1BC,EACAC,EACAX,KAEA,MAAMY,EAAgBb,EAAkBC,GAClCa,EAAWC,MAAMC,KAAKL,EAAGM,iBAAiBJ,IAAgBK,QAAQV,IAE9DW,EAASX,KAMnB,OAHII,GAAiBL,EAAkBI,EAAIV,IACzCa,EAASM,KAAKT,GAETG,CAAQ,EAIXO,EAAwBb,IAC5B,MAAMc,EAAmBZ,EAAoBF,GAC7C,OAAOc,EAAiBlB,OAASkB,EAAmB,CAACd,EAAQ,EAIzDe,EAA2BC,EAAIA,KAACH,EAAsBI,EAAAA,MAOtDC,EAAWlB,IACfA,EAAQmB,MAAM,CAAEC,eAAe,GAAO,EAUlCC,EAAeL,EAAIA,KAACH,EAAsBI,EAAAA,KAAMC,GAGhDI,EAAaN,EAAIA,KAACH,EAAsBU,EAAML,GAc9CP,EAAYX,IAahB,GAA6B,OAAzBA,EAAQwB,aACV,OAAO,EAST,MAAMC,EAAmBC,OAAOC,iBAAiB3B,GACjD,GAAoC,WAAhCyB,EAAiBG,WACnB,OAAO,EAUT,MAAgB,YADAC,mBAAiBC,SAC0B,UAA9BL,EAAiBM,QAIlC,wEAgB2B/B,IACvC,GALF,SAAmBA,GACjB,OAAOA,aAAmBgC,OAC5B,CAGMC,CAAUjC,GACZ,GAAID,EAAkBC,GACpBA,EAAQmB,YACH,CAEL,IAAIe,EAAkBlC,EAAQmC,cAI9B,KACED,GAC6B,SAA7BA,EAAgBE,WACfrC,EAAkBmC,IAEnBA,EAAkBA,EAAgBC,cAEhCD,GACFA,EAAgBf,OAEnB,CACF,gDAnGkBnB,IACnB,MAAMqC,EAAgBtB,EAAyBf,GAC/CkB,EAAQmB,EAAkC,qBAUlBC,IACIA,GAAMC,eAAiBC,UACxBC,uCAmDGzC,GAEaO,MAAMC,KAAKR,EAAQS,iBAD7C,mEAEqCC,QAAQgC,GACrD/B,EAAS+B,sBAnDIJ,IACMA,GAAMC,eAAiBC,UACxBG"}