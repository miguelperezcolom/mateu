{"version":3,"file":"usePress-949a0d03.js","sources":["../../src/hooks/UNSAFE_usePress/usePress.ts"],"sourcesContent":["import { useMemo, useCallback, useState, useRef } from 'preact/hooks';\n\nexport type PressOptions = {\n  isDisabled?: boolean;\n  isRepeat?: boolean;\n  repeatDelay?: number;\n  repeatInterval?: number;\n};\n\nconst DefaultSettings = {\n  isDisabled: false,\n  isRepeat: false,\n  repeatDelay: 500,\n  repeatInterval: 40\n};\n\n/**\n * Returns a click handler that can make a target element either clickable or keyboard pressable.\n * This is intended for elements that do not generate a click for kb interaction (non-buttons).\n * (For those, usePressClick is recommended.)`\n *\n * @param onPressHandler function\n * @param isRepeat boolean\n * @param repeatInterval number number of ms between events for mouse and touch\n * @param repeatDelay number number of ms before repeat events initiates\n * @param isDisabled boolean\n * @returns\n */\n\nexport function usePress(\n  onPressHandler: (event: Event) => void,\n  settings: PressOptions = DefaultSettings\n): { pressProps: Record<string, any> } {\n  const [isPressed, setIsPressed] = useState<boolean>(false);\n  const intervalID = useRef<ReturnType<typeof setInterval>>();\n  const isRepeating = useRef<boolean>(false);\n  const mergedSettings = useMemo(() => {\n    return { ...DefaultSettings, ...settings };\n  }, [settings]);\n\n  const repeatHandler = useCallback(\n    (event: Event) => {\n      if (isRepeating.current) {\n        onPressHandler(event);\n      }\n      intervalID.current = setInterval(onPressHandler, mergedSettings.repeatInterval, event); // @HTMLUpdateOK\n    },\n    [mergedSettings.repeatInterval, onPressHandler]\n  );\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (\n        (event.code === 'Space' || event.code === 'Enter') &&\n        (mergedSettings.isRepeat || !event.repeat)\n      ) {\n        event.preventDefault();\n        setIsPressed(true);\n        if (mergedSettings.isRepeat) {\n          onPressHandler(event);\n        }\n      }\n    },\n    [mergedSettings.isRepeat, onPressHandler, setIsPressed]\n  );\n\n  const onKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      if (isPressed && (event.code === 'Space' || event.code === 'Enter')) {\n        setIsPressed(false);\n        event.preventDefault();\n        if (!mergedSettings.isRepeat) {\n          onPressHandler(event);\n        }\n      }\n    },\n    [mergedSettings.isRepeat, onPressHandler, setIsPressed, isPressed]\n  );\n\n  const onBlur = useCallback(() => {\n    setIsPressed(false);\n  }, [setIsPressed]);\n\n  const onPointerDown = useCallback(\n    (event: PointerEvent) => {\n      setIsPressed(true);\n      isRepeating.current = true;\n      event.preventDefault();\n      onPressHandler(event);\n      intervalID.current = setTimeout(repeatHandler, mergedSettings.repeatDelay, event);\n    },\n    [mergedSettings, onPressHandler, intervalID, repeatHandler, setIsPressed]\n  );\n\n  const onPointerUp = useCallback(\n    (event: PointerEvent) => {\n      if (intervalID.current) {\n        isRepeating.current = false;\n        clearInterval(intervalID.current);\n        intervalID.current = undefined;\n      } else {\n        if (isPressed) {\n          onPressHandler(event);\n        }\n      }\n      setIsPressed(false);\n    },\n    [intervalID, onPressHandler, isPressed]\n  );\n\n  // Keep this to permit automated invocation of target via click event\n  // Need to ignore this for manual invocation whereby browser generates click\n  // pointerdown/pointerup/click -> ignore click\n  // keydown/keyup/click -> ignore click\n  // click without pointerup or keyup -> ignore\n  const onClick = useCallback(\n    (event: Event) => {\n      // There are use cases where pressable/clickable components (eg. Buttons) are nested inside of other\n      // components that also process bubbling click events (eg. Collapsible). In order to avoid conflicting\n      // processing of clicks (eg. in order to avoid the click both activating a Button as well as toggling the\n      // ancestor Collapsible), we stop propagation here. That way, only the child component handles the\n      // click and the ancestor component is oblivious to the fact that the click even occurred.\n      event.stopPropagation();\n      if (intervalID.current) {\n        onPressHandler(event);\n      }\n    },\n    [onPressHandler, intervalID]\n  );\n\n  const onClickSingle = useCallback(\n    (event: Event) => {\n      // See note above about why propagation is stopped: to prevent nested component bubbling clicks issue\n      event.stopPropagation();\n      // This usePress is intended for non-button components that do no generate emulated clicks for kb.\n      // So if a click is received, it's coming from a pointer interaction and should be honored.\n      // No need to enforce down/up so just use default click html behavior.\n      onPressHandler(event);\n    },\n    [onPressHandler]\n  );\n\n  const onPointerOut = useCallback(() => {\n    if (intervalID.current) {\n      clearInterval(intervalID.current);\n    }\n  }, [intervalID]);\n\n  const onPointerCancel = useCallback(() => {\n    if (intervalID.current) {\n      clearInterval(intervalID.current);\n    }\n  }, [intervalID]);\n\n  const onContextMenu = useCallback((event: PointerEvent) => {\n    event.preventDefault();\n  }, []);\n\n  const pressProps = mergedSettings.isDisabled\n    ? {}\n    : mergedSettings.isRepeat\n    ? {\n        onPointerUp,\n        onPointerDown,\n        onPointerOut,\n        onPointerCancel,\n        onKeyDown,\n        onKeyUp,\n        onContextMenu,\n        onClick,\n        onBlur\n      }\n    : {\n        onKeyDown,\n        onKeyUp,\n        onClick: onClickSingle\n      };\n\n  return {\n    pressProps\n  };\n}\n"],"names":["DefaultSettings","isDisabled","isRepeat","repeatDelay","repeatInterval","onPressHandler","settings","isPressed","setIsPressed","useState","intervalID","useRef","isRepeating","mergedSettings","useMemo","repeatHandler","useCallback","event","current","setInterval","onKeyDown","code","repeat","preventDefault","onKeyUp","onBlur","onPointerDown","setTimeout","onPointerUp","clearInterval","undefined","onClick","stopPropagation","onClickSingle","onPointerOut","onPointerCancel","onContextMenu","pressProps"],"mappings":"8DASA,MAAMA,EAAkB,CACtBC,YAAY,EACZC,UAAU,EACVC,YAAa,IACbC,eAAgB,wBAiBhBC,EACAC,EAAyBN,GAEzB,MAAOO,EAAWC,GAAgBC,EAAQA,UAAU,GAC9CC,EAAaC,EAAAA,SACbC,EAAcD,UAAgB,GAC9BE,EAAiBC,EAAAA,SAAQ,KACtB,IAAKd,KAAoBM,KAC/B,CAACA,IAEES,EAAgBC,eACnBC,IACKL,EAAYM,SACdb,EAAeY,GAEjBP,EAAWQ,QAAUC,YAAYd,EAAgBQ,EAAeT,eAAgBa,EAAM,GAExF,CAACJ,EAAeT,eAAgBC,IAG5Be,EAAYJ,eACfC,IAEmB,UAAfA,EAAMI,MAAmC,UAAfJ,EAAMI,OAChCR,EAAeX,UAAae,EAAMK,SAEnCL,EAAMM,iBACNf,GAAa,GACTK,EAAeX,UACjBG,EAAeY,GAElB,GAEH,CAACJ,EAAeX,SAAUG,EAAgBG,IAGtCgB,EAAUR,eACbC,KACKV,GAA6B,UAAfU,EAAMI,MAAmC,UAAfJ,EAAMI,OAChDb,GAAa,GACbS,EAAMM,iBACDV,EAAeX,UAClBG,EAAeY,GAElB,GAEH,CAACJ,EAAeX,SAAUG,EAAgBG,EAAcD,IAGpDkB,EAAST,EAAAA,aAAY,KACzBR,GAAa,EAAM,GAClB,CAACA,IAEEkB,EAAgBV,eACnBC,IACCT,GAAa,GACbI,EAAYM,SAAU,EACtBD,EAAMM,iBACNlB,EAAeY,GACfP,EAAWQ,QAAUS,WAAWZ,EAAeF,EAAeV,YAAac,EAAM,GAEnF,CAACJ,EAAgBR,EAAgBK,EAAYK,EAAeP,IAGxDoB,EAAcZ,eACjBC,IACKP,EAAWQ,SACbN,EAAYM,SAAU,EACtBW,cAAcnB,EAAWQ,SACzBR,EAAWQ,aAAUY,GAEjBvB,GACFF,EAAeY,GAGnBT,GAAa,EAAM,GAErB,CAACE,EAAYL,EAAgBE,IAQzBwB,EAAUf,eACbC,IAMCA,EAAMe,kBACFtB,EAAWQ,SACbb,EAAeY,EAChB,GAEH,CAACZ,EAAgBK,IAGbuB,EAAgBjB,eACnBC,IAECA,EAAMe,kBAIN3B,EAAeY,EAAM,GAEvB,CAACZ,IAGG6B,EAAelB,EAAAA,aAAY,KAC3BN,EAAWQ,SACbW,cAAcnB,EAAWQ,QAC1B,GACA,CAACR,IAEEyB,EAAkBnB,EAAAA,aAAY,KAC9BN,EAAWQ,SACbW,cAAcnB,EAAWQ,QAC1B,GACA,CAACR,IAEE0B,EAAgBpB,eAAaC,IACjCA,EAAMM,gBAAgB,GACrB,IAsBH,MAAO,CACLc,WArBiBxB,EAAeZ,WAC9B,CAAE,EACFY,EAAeX,SACf,CACE0B,cACAF,gBACAQ,eACAC,kBACAf,YACAI,UACAY,gBACAL,UACAN,UAEF,CACEL,YACAI,UACAO,QAASE,GAMjB"}