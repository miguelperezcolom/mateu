{"version":3,"file":"useSelection-205a2bda.js","sources":["../../src/hooks/PRIVATE_useVisSelection/ClearSelectionButton.tsx","../../src/hooks/PRIVATE_useVisSelection/useSelection.tsx","../../src/hooks/PRIVATE_useVisSelection/useClearSelection.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { BaseButton } from '#UNSAFE_BaseButton';\nimport { Text } from '#UNSAFE_Text';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '#resources/nls/bundle';\nimport { clearButtonStyles } from './themes/ClearSelection.css';\n\ntype Props = {\n  onAction: () => void;\n};\n\n/**\n * Clear selection button component\n */\nexport const ClearSelectionButton = ({ onAction }: Props) => {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const clearSelectionLabel = `${translations.vis_clearSelection()}`;\n  return (\n    <div class={clearButtonStyles.base}>\n      <BaseButton\n        styling={['default']}\n        elementDetails={{ type: 'span', isFocusable: false, isLabel: true }}\n        variant=\"outlined\"\n        onAction={onAction}>\n        <Text truncation={'ellipsis'} weight={'inherit'}>\n          {clearSelectionLabel}\n        </Text>\n      </BaseButton>\n    </div>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useCallback, useRef } from 'preact/hooks';\nimport { isEqual } from '#utils/UNSAFE_visUtils/eventsUtils';\nimport { useClearSelection } from './useClearSelection';\n\nexport type SelectionMode = 'none' | 'single' | 'multiple';\nexport type SelectionDetail<K, D> = {\n  ids: K[];\n  data: (D | undefined)[];\n};\ntype SelectionBehavior = 'toggle' | 'replace';\n\nconst NAVKEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\n/**\n * The constant that defines time to wait to change selection after pointer up is fired.\n * If double click didn't happen\n */\nconst DBLCLICK_THRESHOLD = 250;\n\n/**\n * Handles the selection.\n * @param itemId The id of the item.\n * @param selectedIds The set of selected item ids.\n * @param selectionMode The selection mode.\n * @param selectionBehavior The selection behavior. If 'toggle', unselected item will be selected and\n * vice versa. If 'replace', the item will replace the previous selection.\n * @param getDataById The callback to get item data from idDataMap.\n * @param onChange The callback to trigger when selection changes.\n */\nconst handleSelect = <K, D>(\n  itemId: K | undefined,\n  selectedIds: Set<K>,\n  selectionMode: SelectionMode,\n  selectionBehavior: SelectionBehavior,\n  getDataById: (id: K) => D | undefined,\n  onChange?: (detail: SelectionDetail<K, D>) => void\n) => {\n  let ids = new Set<K>([]);\n  if (itemId != null) {\n    ids = new Set(selectedIds);\n    const isSelected = selectedIds.has(itemId);\n\n    if (selectionBehavior === 'toggle') {\n      if (isSelected) {\n        ids.delete(itemId);\n      } else if (selectionMode === 'single') {\n        ids = new Set([itemId]); // only selection\n      } else {\n        ids.add(itemId); // add to selection in \"multiple\" selectionMode\n      }\n    } else if (!isSelected) {\n      // In \"multiple\" selection mode, only replace selection if unselected item is selected.\n      // In \"single\" selection mode, only need to replace if unselected item is selected.\n      ids = new Set([itemId]);\n    }\n  }\n\n  if (!isEqual<K>(ids, selectedIds)) {\n    onChange?.({ ids: [...ids], data: [...ids].map(getDataById) });\n  }\n};\n\ntype Props<K, D> = {\n  selection?: K[];\n  selectionMode?: SelectionMode;\n  idExtracter: (event: Event) => K | undefined;\n  onChange?: (detail: SelectionDetail<K, D>) => void;\n  isKeyboardSelection?: (event: KeyboardEvent) => boolean;\n  isDrillEnabled?: boolean;\n  getDataById: (id: K) => D | undefined;\n  ignoreAsTrigger?: (element: EventTarget | null) => boolean;\n};\n\n/**\n * The hook to handle the selection behavior in vizualization components.\n */\nexport function useSelection<K, D>({\n  selection = [],\n  selectionMode = 'none',\n  idExtracter,\n  onChange,\n  isDrillEnabled,\n  isKeyboardSelection,\n  getDataById,\n  ignoreAsTrigger\n}: Props<K, D>) {\n  const setTimeOutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  const clearSelection = () => {\n    handleSelect<K, D>(\n      undefined,\n      new Set(selection),\n      selectionMode,\n      'replace',\n      getDataById,\n      onChange\n    );\n  };\n\n  const { clearSelectionContent, tryToggleClearButton } = useClearSelection<K>({ clearSelection });\n\n  const onPointerUp = useCallback(\n    (event: PointerEvent) => {\n      // ignore pointer up when marquee is released\n      if (ignoreAsTrigger && ignoreAsTrigger(event.target)) {\n        return;\n      }\n\n      const selectedIds = new Set(selection);\n      if (setTimeOutRef.current && isDrillEnabled) {\n        clearTimeout(setTimeOutRef.current);\n        setTimeOutRef.current = undefined;\n        // doubleClick happened\n        return;\n      }\n\n      const key = idExtracter(event);\n\n      if (tryToggleClearButton(event, key, selectionMode, selectedIds)) {\n        return;\n      }\n\n      const isMeta = event.metaKey;\n      const isCtrl = event.ctrlKey;\n      // If there was a previous pointerUp event that occurred that should prevent selection,\n      // event.preventDefault was called\n      if (event.defaultPrevented || (key == null && (isMeta || isCtrl))) {\n        return;\n      }\n\n      // TODO: Encorporate more logic of dvt.EventManager.prototype._onClick\n      // this is a simple version of EventManager.prototype._onClick. Currently we are not checking\n      // for event.pageX, event.pageY to determine if they are exactly clicked on the same point.\n      // for now, the assumption is that if the pointerups are within 250ms, they are for a same double click.\n      if (isDrillEnabled) {\n        setTimeOutRef.current = setTimeout(() => {\n          // double pointer up didn't happen\n          handleSelect<K, D>(\n            key,\n            selectedIds,\n            selectionMode,\n            isMeta || isCtrl || event.pointerType === 'touch' ? 'toggle' : 'replace',\n            getDataById,\n            onChange\n          );\n          setTimeOutRef.current = undefined;\n        }, DBLCLICK_THRESHOLD);\n      } else {\n        handleSelect<K, D>(\n          key,\n          selectedIds,\n          selectionMode,\n          isMeta || isCtrl || event.pointerType === 'touch' ? 'toggle' : 'replace',\n          getDataById,\n          onChange\n        );\n      }\n    },\n    [\n      selection,\n      selectionMode,\n      onChange,\n      idExtracter,\n      isDrillEnabled,\n      getDataById,\n      tryToggleClearButton,\n      ignoreAsTrigger\n    ]\n  );\n\n  const onContextMenu = useCallback(\n    (event: MouseEvent) => {\n      const key = idExtracter(event);\n      const isCtrl = event.ctrlKey;\n      handleSelect<K, D>(\n        key,\n        new Set(selection),\n        selectionMode,\n        isCtrl ? 'toggle' : 'replace',\n        getDataById,\n        onChange\n      );\n    },\n    [selection, selectionMode, onChange, idExtracter, getDataById]\n  );\n\n  const onKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      const isShift = event.shiftKey;\n      const isSpaceCtrl = event.ctrlKey && event.key === ' ';\n      const isArrowKey = NAVKEYS.indexOf(event.key) !== -1;\n      const itemKey = idExtracter(event);\n\n      if (isArrowKey || isSpaceCtrl || (isKeyboardSelection && isKeyboardSelection(event))) {\n        const behavior = isShift || isSpaceCtrl ? 'toggle' : 'replace';\n        handleSelect<K, D>(\n          itemKey,\n          new Set(selection),\n          selectionMode,\n          behavior,\n          getDataById,\n          onChange\n        );\n      }\n    },\n    [selection, selectionMode, onChange, idExtracter, isKeyboardSelection, getDataById]\n  );\n\n  return {\n    selectionContent: clearSelectionContent,\n    selectionProps:\n      selectionMode === 'none' || onChange == null\n        ? {}\n        : {\n            onKeyUp,\n            onContextMenu,\n            onPointerUp\n          }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useRef, useState } from 'preact/hooks';\nimport { ClearSelectionButton } from './ClearSelectionButton';\nimport { Layer } from '#UNSAFE_Layer';\nimport { Floating } from '#UNSAFE_Floating';\n\n/**\n * The default offset for clear selection mainAxis.\n */\nconst DEFAULT_OFFSET = 18;\ntype Props = {\n  clearSelection: () => void;\n};\ntype SelectionMode = 'none' | 'single' | 'multiple';\n\nexport function useClearSelection<K>({ clearSelection }: Props) {\n  const [isVisible, setIsVisible] = useState(false);\n  const coordinates = useRef({ x: 0, y: 0 });\n\n  const tryToggleClearButton = (\n    event: PointerEvent,\n    key: K | undefined,\n    selectionMode: SelectionMode,\n    selectedIds: Set<K>\n  ) => {\n    if (\n      event.pointerType === 'touch' &&\n      key === undefined &&\n      selectionMode === 'multiple' &&\n      selectedIds.size > 1\n    ) {\n      setIsVisible(!isVisible);\n      coordinates.current = { x: event.clientX, y: event.clientY };\n      return true;\n    }\n    return false;\n  };\n\n  const offsetValue = { mainAxis: 2 * DEFAULT_OFFSET };\n  const anchorRef = { current: coordinates.current };\n\n  const clearSelectionContent = isVisible ? (\n    <Layer>\n      <Floating\n        anchorRef={anchorRef}\n        offsetValue={offsetValue}\n        placement=\"top\"\n        flipOptions={{ crossAxis: false, mainAxis: false }}\n        shiftOptions={{ crossAxis: true, mainAxis: true }}>\n        <ClearSelectionButton\n          onAction={() => {\n            setIsVisible(false);\n            clearSelection();\n          }}\n        />\n      </Floating>\n    </Layer>\n  ) : null;\n\n  return {\n    clearSelectionContent,\n    tryToggleClearButton\n  };\n}\n"],"names":["ClearSelectionButton","onAction","clearSelectionLabel","useTranslationBundle","vis_clearSelection","_jsx","class","clearButtonStyles","base","children","BaseButton","styling","elementDetails","type","isFocusable","isLabel","variant","Text","truncation","weight","NAVKEYS","handleSelect","itemId","selectedIds","selectionMode","selectionBehavior","getDataById","onChange","ids","Set","isSelected","has","delete","add","isEqual","data","map","selection","idExtracter","isDrillEnabled","isKeyboardSelection","ignoreAsTrigger","setTimeOutRef","useRef","clearSelectionContent","tryToggleClearButton","clearSelection","isVisible","setIsVisible","useState","coordinates","x","y","offsetValue","mainAxis","anchorRef","current","Layer","jsx","Floating","placement","flipOptions","crossAxis","shiftOptions","event","key","pointerType","undefined","size","clientX","clientY","useClearSelection","onPointerUp","useCallback","target","clearTimeout","isMeta","metaKey","isCtrl","ctrlKey","defaultPrevented","setTimeout","onContextMenu","onKeyUp","isShift","shiftKey","isSpaceCtrl","isArrowKey","indexOf","itemKey","behavior","selectionContent","selectionProps"],"mappings":"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"}