{"version":3,"file":"keys-4755c121.js","sources":["../../src/utils/UNSAFE_keys/keys.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport type ImmutableSet<V> = {\n  size: number;\n  has(value: V): boolean;\n  values(): IterableIterator<V>;\n};\n\n/**\n * Type for key set used mainly for selection and expansion\n */\nexport type Keys<K> =\n  | {\n      all: true;\n      keys?: never;\n      deletedKeys: ImmutableSet<K>;\n    }\n  | {\n      all: false;\n      keys: ImmutableSet<K>;\n      deletedKeys?: never;\n    };\n\n/**\n * Returns true if the key is contains in keys, false otherwise\n */\nexport const containsKey = <K>(keys: Keys<K> | undefined, key: K) => {\n  if (keys == null) {\n    return false;\n  }\n  if (!keys.all) {\n    return keys.keys.has(key);\n  }\n  return !keys.deletedKeys.has(key);\n};\n\n/**\n * Returns a new Keys that includes the specified key.\n * If the key is already in keys, then just return keys.\n */\nexport const addKey = <K>(keys: Keys<K>, key: K) => {\n  return addKeys(keys, [key]);\n};\n\n/**\n * Returns a new Keys that includes all the specified keys.\n * @param keys the base Keys<K>\n * @param addKeys an array of keys that we we want to include\n */\nexport const addKeys = <K>(keys: Keys<K>, addKeys: K[]) => {\n  if (keys.all) {\n    const deletedKeys = keys.deletedKeys;\n    if (deletedKeys.size === 0) {\n      return keys;\n    }\n\n    const keySet = new Set(deletedKeys.values());\n    addKeys.forEach((key) => {\n      if (deletedKeys.has(key)) {\n        keySet.delete(key);\n      }\n    });\n    keys = { all: true, deletedKeys: keySet };\n  } else {\n    const currentKeys = keys.keys;\n    const keySet = new Set(currentKeys.values());\n    addKeys.forEach((key) => {\n      if (!currentKeys.has(key)) {\n        keySet.add(key);\n      }\n    });\n    keys = { all: false, keys: keySet };\n  }\n  return keys;\n};\n\n/**\n * Returns a new Keys that excludes the specified key.\n * If the key is already in keys, then just return keys.\n * disallowEmpty if set to true, will ensure that the returning keys will not be empty.\n */\nexport const removeKey = <K>(keys: Keys<K>, key: K, disallowEmpty: boolean) => {\n  return removeKeys(keys, [key], disallowEmpty);\n};\n\n/**\n * Returns a new Keys that excludes all the specified keys.\n * @param keys the base Keys<K>\n * @param removeKeys an array of keys that we we want to exclude\n * @param disallowEmpty if set to true, will ensure that the returning keys will not be empty\n */\nexport const removeKeys = <K>(keys: Keys<K>, removeKeys: K[], disallowEmpty: boolean) => {\n  if (keys.all) {\n    const deletedKeys = keys.deletedKeys;\n    const keySet = new Set(deletedKeys.values());\n    removeKeys.forEach((key) => {\n      if (!deletedKeys.has(key)) {\n        keySet.add(key);\n      }\n    });\n    keys = { all: true, deletedKeys: keySet };\n  } else {\n    const currentKeys = keys.keys;\n    const keySet = new Set(currentKeys.values());\n    removeKeys.forEach((key) => {\n      if (currentKeys.has(key) && (!disallowEmpty || keySet.size > 1)) {\n        keySet.delete(key);\n      }\n    });\n    keys = { all: false, keys: keySet };\n  }\n  return keys;\n};\n\n/**\n * Helper function for checking for an undefined key\n * Keys can be null or undefined when not set, but falsey check is not appropriate for this as 0 is a legitimate key\n */\nexport const isKeyDefined = <K>(key: K) => key !== undefined && key !== null;\n\n/**\n * Compares two Keys and return true if the keys inside each are the same including\n * having the same order.\n */\nexport const isSameKey = <K>(key1?: Keys<K>, key2?: Keys<K>) => {\n  if (key1 == null || key2 == null) {\n    return key1 == key2;\n  }\n  if (key1.all !== key2.all) {\n    return false;\n  }\n  const arr1 = Array.from(key1.all ? key1.deletedKeys.values() : key1.keys.values());\n  const arr2 = Array.from(key2.all ? key2.deletedKeys.values() : key2.keys.values());\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n"],"names":["addKeys","keys","all","deletedKeys","size","keySet","Set","values","forEach","key","has","delete","currentKeys","add","removeKeys","disallowEmpty","key1","key2","arr1","Array","from","arr2","length","i"],"mappings":"mDAuDaA,EAAU,CAAIC,EAAeD,KACxC,GAAIC,EAAKC,IAAK,CACZ,MAAMC,EAAcF,EAAKE,YACzB,GAAyB,IAArBA,EAAYC,KACd,OAAOH,EAGT,MAAMI,EAAS,IAAIC,IAAIH,EAAYI,UACnCP,EAAQQ,SAASC,IACXN,EAAYO,IAAID,IAClBJ,EAAOM,OAAOF,EACf,IAEHR,EAAO,CAAEC,KAAK,EAAMC,YAAaE,EAClC,KAAM,CACL,MAAMO,EAAcX,EAAKA,KACnBI,EAAS,IAAIC,IAAIM,EAAYL,UACnCP,EAAQQ,SAASC,IACVG,EAAYF,IAAID,IACnBJ,EAAOQ,IAAIJ,EACZ,IAEHR,EAAO,CAAEC,KAAK,EAAOD,KAAMI,EAC5B,CACD,OAAOJ,CAAI,EAkBAa,EAAa,CAAIb,EAAea,EAAiBC,KAC5D,GAAId,EAAKC,IAAK,CACZ,MAAMC,EAAcF,EAAKE,YACnBE,EAAS,IAAIC,IAAIH,EAAYI,UACnCO,EAAWN,SAASC,IACbN,EAAYO,IAAID,IACnBJ,EAAOQ,IAAIJ,EACZ,IAEHR,EAAO,CAAEC,KAAK,EAAMC,YAAaE,EAClC,KAAM,CACL,MAAMO,EAAcX,EAAKA,KACnBI,EAAS,IAAIC,IAAIM,EAAYL,UACnCO,EAAWN,SAASC,IACdG,EAAYF,IAAID,MAAUM,GAAiBV,EAAOD,KAAO,IAC3DC,EAAOM,OAAOF,EACf,IAEHR,EAAO,CAAEC,KAAK,EAAOD,KAAMI,EAC5B,CACD,OAAOJ,CAAI,WAvES,CAAIA,EAAeQ,IAChCT,EAAQC,EAAM,CAACQ,8BAfG,CAAIR,EAA2BQ,IAC5C,MAARR,IAGCA,EAAKC,KAGFD,EAAKE,YAAYO,IAAID,GAFpBR,EAAKA,KAAKS,IAAID,mBAuFOA,GAAWA,oBAMlB,CAAIO,EAAgBC,KAC3C,GAAY,MAARD,GAAwB,MAARC,EAClB,OAAOD,GAAQC,EAEjB,GAAID,EAAKd,MAAQe,EAAKf,IACpB,OAAO,EAET,MAAMgB,EAAOC,MAAMC,KAAKJ,EAAKd,IAAMc,EAAKb,YAAYI,SAAWS,EAAKf,KAAKM,UACnEc,EAAOF,MAAMC,KAAKH,EAAKf,IAAMe,EAAKd,YAAYI,SAAWU,EAAKhB,KAAKM,UACzE,GAAIW,EAAKI,SAAWD,EAAKC,OACvB,OAAO,EAGT,IAAK,IAAIC,EAAI,EAAGA,EAAIL,EAAKI,OAAQC,IAC/B,GAAIL,EAAKK,KAAOF,EAAKE,GACnB,OAAO,EAGX,OAAO,CAAI,cA7DY,CAAItB,EAAeQ,EAAQM,IAC3CD,EAAWb,EAAM,CAACQ,GAAMM"}