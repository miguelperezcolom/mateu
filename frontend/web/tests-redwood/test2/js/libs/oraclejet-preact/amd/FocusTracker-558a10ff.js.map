{"version":3,"file":"FocusTracker-558a10ff.js","sources":["../../src/PRIVATE_FocusTracker/FocusGuard.tsx","../../src/PRIVATE_FocusTracker/FocusTracker.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { styles } from './themes/FocusTrackerStyles.css';\n\ntype Props = {\n  onFocus: (event: FocusEvent) => void;\n};\n\n/**\n * Styled FocusTrap sub-component to render non-visible focus guards\n */\nexport const FocusGuard = forwardRef(\n  ({ onFocus }: Props, guardRef: ForwardedRef<HTMLDivElement>) => {\n    const classes = classNames([styles.guardStyle]);\n\n    return <div class={classes} onFocus={onFocus} ref={guardRef} tabIndex={0} />;\n  }\n);\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren, Fragment } from 'preact';\nimport { useEffect, useRef } from 'preact/compat';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { baseStyle } from './themes/FocusTrackerStyles.css';\nimport {\n  FocusableElement,\n  getActiveElement,\n  allTabbableElements\n} from '../utils/PRIVATE_tabbableUtils';\nimport { FocusGuard } from './FocusGuard';\n\nexport type FocusGuardCallbackDetail = {\n  tabbableElements: FocusableElement[];\n};\n\ntype Props = {\n  /**\n   * The children that focus tracking should be handled on.\n   */\n  children: ComponentChildren;\n\n  /**\n   * Sets whether focus is tracked and whether guards are present.\n   * @default false\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Optional callback to be notified that the tracking is starting (when mounted and changing isDisabled from true to false).\n   */\n  onStartTracking?: (detail: {\n    activeElement: FocusableElement;\n    hasFocusWithin: boolean;\n    tabbableElements: FocusableElement[];\n  }) => void;\n\n  /**\n   * Optional callback to be notified that the tracking is stopping (when unmounted and changing isDisabled from false to true).\n   */\n  onStopTracking?: (detail: {\n    hasFocusWithin: boolean;\n    lastActiveElement: FocusableElement | null;\n  }) => void;\n\n  /**\n   * Optional callback to to be notified when the start focus guard gains focus\n   */\n  onFocusStartEdge?: (detail: FocusGuardCallbackDetail) => void;\n\n  /**\n   * Optional callback to to be notified when the end focus guard gains focus\n   */\n  onFocusEndEdge?: (detail: FocusGuardCallbackDetail) => void;\n\n  /**\n   * Optional style class to be applied to the outer div of the tracker\n   */\n  styleClass?: string;\n};\n\n/**\n * Tracks focus within a DOM node.\n */\nexport const FocusTracker = ({\n  children,\n  onFocusStartEdge,\n  onFocusEndEdge,\n  onStartTracking,\n  onStopTracking,\n  isDisabled = false,\n  styleClass\n}: Props) => {\n  const trackerRef = useRef<HTMLDivElement>(null);\n  const startGuardRef = useRef<HTMLDivElement>(null);\n  const endGuardRef = useRef<HTMLDivElement>(null);\n  const lastActiveElementRef = useRef<FocusableElement | null>(null);\n  const onStartTrackingRef = useRef<Props['onStartTracking']>();\n  const onStopTrackingRef = useRef<Props['onStopTracking']>();\n\n  // classes to be set on the children wrapper\n  const classes = classNames([baseStyle, styleClass]);\n\n  // store onStartTracking in our own ref to avoid this callback being triggered if it is ever updated externally.\n  // for example, if we were not using a ref here and the component controlling this focus tracker passed in a\n  // new onStartTracking callback function for whatever reason, the useEffect that invokes this callback would be\n  // triggered at that time, and the new instance of this callback would be triggered as well.\n  useEffect(() => {\n    onStartTrackingRef.current = onStartTracking;\n  }, [onStartTracking]);\n\n  // store onStopTracking in our own ref to avoid this callback being triggered if it is ever updated externally.\n  // for example, if we were not using a ref here and the component controlling this focus tracker passed in a\n  // new onStopTracking callback function for whatever reason, the useEffect that invokes this callback would be\n  // triggered at that time, and the previous instance of this callback would be triggered as well.\n  useEffect(() => {\n    onStopTrackingRef.current = onStopTracking;\n  }, [onStopTracking]);\n\n  // helper to handle guard focus\n  const handleGuardFocus = (\n    event: FocusEvent,\n    trackerElement: HTMLDivElement,\n    focusCallbackFunc?: Props['onFocusStartEdge'] // same as Props['onFocusEndEdge']\n  ) => {\n    if (focusCallbackFunc != null) {\n      focusCallbackFunc({\n        tabbableElements: allTabbableElements(trackerElement)\n      });\n    }\n    // prevent scroll jump and bubbling this event up as a focus event\n    event.stopPropagation();\n    event.preventDefault();\n  };\n\n  // notify focus on start guard\n  const handleOnFocusStartGuard = (event: FocusEvent) => {\n    if (trackerRef.current != null) {\n      handleGuardFocus(event, trackerRef.current, onFocusStartEdge);\n    }\n  };\n\n  // notify focus on end guard\n  const handleOnFocusEndGuard = (event: FocusEvent) => {\n    if (trackerRef.current != null) {\n      handleGuardFocus(event, trackerRef.current, onFocusEndEdge);\n    }\n  };\n\n  // handle focus on child or other descendant\n  const handleOnFocus = (event: FocusEvent) => {\n    lastActiveElementRef.current = event.target as FocusableElement;\n  };\n\n  // handle initial render or re-render when 'isDisabled' changes\n  useEffect(() => {\n    // determines if this focus tracker contains real browser focus\n    const _hasFocusWithin = () => {\n      if (trackerRef.current != null) {\n        return hasFocus([trackerRef.current, startGuardRef.current, endGuardRef.current]);\n      }\n      return false;\n    };\n\n    const trackerElement = trackerRef.current;\n    if (trackerElement != null && !isDisabled) {\n      if (onStartTrackingRef.current != null) {\n        onStartTrackingRef.current({\n          activeElement: getActiveElement(trackerElement),\n          hasFocusWithin: _hasFocusWithin(),\n          tabbableElements: allTabbableElements(trackerElement)\n        });\n      }\n\n      // the 'cleanup' function of a useEffect is run when unmounted as well as before the useEffect is run on a re-render\n      // 'isDisabled' is the only trigger so this should only run when unmounted and on isDisabled changes from false to true\n      return () => {\n        if (onStopTrackingRef.current != null) {\n          onStopTrackingRef.current({\n            hasFocusWithin: _hasFocusWithin(),\n            lastActiveElement: lastActiveElementRef.current\n          });\n        }\n      };\n    }\n    return;\n    // it is very important that this useEffect is ONLY dependent on isDisabled changes. otherwise, the\n    // start / stop tracking callbacks will be triggered whenever those other dependencies are updated.\n  }, [isDisabled]);\n\n  return (\n    <Fragment>\n      {!isDisabled && <FocusGuard onFocus={handleOnFocusStartGuard} ref={startGuardRef} />}\n      <div onFocus={!isDisabled ? handleOnFocus : undefined} ref={trackerRef} class={classes}>\n        {children}\n      </div>\n      {!isDisabled && <FocusGuard onFocus={handleOnFocusEndGuard} ref={endGuardRef} />}\n    </Fragment>\n  );\n};\n\n/**\n * Helper function used to help determine if real browser focus is currently contained in the\n * array of elements provided.\n */\nconst hasFocus = (elements: (FocusableElement | null)[]) => {\n  if (elements.length === 0) {\n    return false;\n  }\n  const activeElement = getActiveElement(elements[0] as Node);\n  return elements.some((el) => el?.contains(activeElement));\n};\n"],"names":["FocusGuard","forwardRef","onFocus","guardRef","classes","classNames","styles","guardStyle","_jsx","class","ref","tabIndex","hasFocus","elements","length","activeElement","getActiveElement","some","el","contains","children","onFocusStartEdge","onFocusEndEdge","onStartTracking","onStopTracking","isDisabled","styleClass","trackerRef","useRef","startGuardRef","endGuardRef","lastActiveElementRef","onStartTrackingRef","onStopTrackingRef","baseStyle","useEffect","current","handleGuardFocus","event","trackerElement","focusCallbackFunc","tabbableElements","allTabbableElements","stopPropagation","preventDefault","_hasFocusWithin","hasFocusWithin","lastActiveElement","_jsxs","Fragment","jsx","undefined","target"],"mappings":"iNAmBO,MAAMA,EAAaC,EAAAA,YACxB,EAAGC,WAAkBC,KACnB,MAAMC,EAAUC,EAAUA,WAAC,CAACC,EAAAA,OAAOC,aAEnC,OAAOC,aAAKC,MAAOL,EAASF,QAASA,EAASQ,IAAKP,EAAUQ,SAAU,GAAK,ICwK1EC,EAAYC,IAChB,GAAwB,IAApBA,EAASC,OACX,OAAO,EAET,MAAMC,EAAgBC,EAAgBA,iBAACH,EAAS,IAChD,OAAOA,EAASI,MAAMC,GAAOA,GAAIC,SAASJ,IAAe,iBA9H/B,EAC1BK,WACAC,mBACAC,iBACAC,kBACAC,iBACAC,cAAa,EACbC,iBAEA,MAAMC,EAAaC,SAAuB,MACpCC,EAAgBD,SAAuB,MACvCE,EAAcF,SAAuB,MACrCG,EAAuBH,SAAgC,MACvDI,EAAqBJ,EAAAA,SACrBK,EAAoBL,EAAAA,SAGpBxB,EAAUC,EAAUA,WAAC,CAAC6B,EAAAA,UAAWR,IAMvCS,EAAAA,WAAU,KACRH,EAAmBI,QAAUb,CAAe,GAC3C,CAACA,IAMJY,EAAAA,WAAU,KACRF,EAAkBG,QAAUZ,CAAc,GACzC,CAACA,IAGJ,MAAMa,EAAmB,CACvBC,EACAC,EACAC,KAEyB,MAArBA,GACFA,EAAkB,CAChBC,iBAAkBC,EAAmBA,oBAACH,KAI1CD,EAAMK,kBACNL,EAAMM,gBAAgB,EA0DxB,OAnCAT,EAAAA,WAAU,KAER,MAAMU,EAAkB,IACI,MAAtBlB,EAAWS,SACNxB,EAAS,CAACe,EAAWS,QAASP,EAAcO,QAASN,EAAYM,UAKtEG,EAAiBZ,EAAWS,QAClC,GAAsB,MAAlBG,IAA2Bd,EAW7B,OAVkC,MAA9BO,EAAmBI,SACrBJ,EAAmBI,QAAQ,CACzBrB,cAAeC,EAAgBA,iBAACuB,GAChCO,eAAgBD,IAChBJ,iBAAkBC,EAAmBA,oBAACH,KAMnC,KAC4B,MAA7BN,EAAkBG,SACpBH,EAAkBG,QAAQ,CACxBU,eAAgBD,IAChBE,kBAAmBhB,EAAqBK,SAE3C,CAGE,GAGN,CAACX,IAGFuB,EAAAA,KAACC,EAAAA,SAAQ,CAAA7B,SAAA,EACLK,GAAcjB,EAAA0C,IAAClD,EAAU,CAACE,QAxDCoC,IACL,MAAtBX,EAAWS,SACbC,EAAiBC,EAAOX,EAAWS,QAASf,EAC7C,EAqD+DX,IAAKmB,IACnErB,EAAA0C,IAAA,MAAA,CAAKhD,QAAUuB,OAA6B0B,EA3CzBb,IACrBP,EAAqBK,QAAUE,EAAMc,MAA0B,EA0CN1C,IAAKiB,EAAYlB,MAAOL,EAC5EgB,SAAAA,KAEDK,GAAcjB,EAAAA,IAACR,EAAU,CAACE,QArDDoC,IACH,MAAtBX,EAAWS,SACbC,EAAiBC,EAAOX,EAAWS,QAASd,EAC7C,EAkD6DZ,IAAKoB,MAEnE"}