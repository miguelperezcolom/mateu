{"version":3,"file":"TransitionGroup-3b9d81b6.js","sources":["../../src/PRIVATE_TransitionGroup/TransitionUtils.ts","../../src/PRIVATE_TransitionGroup/TransitionGroup.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { cloneElement, VNode } from 'preact';\nimport { TransitionProps } from './Transition';\n\nexport type ChildKey = number | string;\nexport type ChildMapping = Map<string | number, VNode<TransitionProps>>;\nexport type ChildrenRecord<T = any> = {\n  [Key in number | string | any]: T[];\n};\n\n/**\n * @classdesc\n * A utility class consisting of helper functions for handling transitions\n * related operations.\n */\nexport class TransitionUtils {\n  /**\n   * Creates a map of the children array with the calculated in prop\n   *\n   * @param children The newly received children\n   * @param prevChildMapping The previous child mapping\n   * @returns the newly created child mapping\n   */\n  public static getChildMapping(\n    children: VNode<TransitionProps>[],\n    prevChildMapping: ChildMapping = new Map(),\n    onExited: (child: VNode<TransitionProps>, node: Element, key?: ChildKey) => void = () => {}\n  ): ChildMapping {\n    // A symbol to store trailing children\n    const TRAILING = Symbol();\n    let mappedDeletions = {} as ChildrenRecord;\n\n    if (prevChildMapping.size !== 0) {\n      // If previous children exists, get the mapped deleted children\n      mappedDeletions = TransitionUtils._getMappedDeletions(children, prevChildMapping, TRAILING);\n    }\n\n    // Create a new Map with the new children along with the deletions inserted in their\n    // respective positions\n    const mergedChildrenMap: ChildMapping = children.reduce<ChildMapping>(\n      (accumulator, currentChild) => {\n        if (mappedDeletions[currentChild.key]) {\n          // There are keys from prev that are deleted before the current\n          // next key, so add them first\n          const deletedChildren = mappedDeletions[currentChild.key];\n          for (const key of deletedChildren) {\n            const previousChild = prevChildMapping.get(key);\n            // Set the in property to false, as this is children is removed\n            accumulator.set(key, cloneElement(previousChild!, { in: false }));\n          }\n          // Then add the current key. Do not change the 'in' or 'onExited' properties as this is a\n          // retained child.\n          const previousChild = prevChildMapping.get(currentChild.key);\n          accumulator.set(\n            currentChild.key,\n            cloneElement(currentChild, {\n              onExited: previousChild!.props.onExited,\n              in: previousChild!.props.in\n            })\n          );\n        } else {\n          // This is a new children. Set the in property to true\n          const newChild = cloneElement(currentChild, {\n            // bind the original child so that the original callbacks can be\n            // called in the onExited callback from the argument.\n            onExited: onExited.bind(null, currentChild),\n            in: true\n          });\n          accumulator.set(currentChild.key, newChild);\n        }\n\n        return accumulator;\n      },\n      new Map() as ChildMapping\n    );\n\n    // Finally add any trailing deleted children present in the mappedDeletions[TRAILING]\n    for (const key of mappedDeletions[TRAILING as any] || []) {\n      const previousChild = prevChildMapping.get(key);\n      // Set the in property to false, as this is children is removed\n      mergedChildrenMap.set(key, cloneElement(previousChild!, { in: false }));\n    }\n\n    // Finally return the merged children map\n    return mergedChildrenMap;\n  }\n\n  ////////////////////////////\n  // Private helper methods //\n  ////////////////////////////\n\n  /**\n   * Creates a map of deleted children wrt to the keys in the new data.\n   *\n   * @param children The newly received children\n   * @param prevChildMapping The previous child mapping\n   * @param TRAILING A unique symbol to be used for storing the trailing children\n   * @returns A map containing deleted children\n   */\n  private static _getMappedDeletions(\n    children: VNode<TransitionProps>[],\n    prevChildMapping: ChildMapping,\n    TRAILING: symbol\n  ): ChildrenRecord<ChildKey> {\n    // Create a set with keys of next children\n    const nextChildrenKeys = new Set(children.map((children) => children.key));\n\n    return [...prevChildMapping.keys()].reduce<ChildrenRecord<ChildKey>>(\n      (accumulator, currentKey) => {\n        if (nextChildrenKeys.has(currentKey)) {\n          // We have reached a point where the closest prevKey that\n          // is in the next, so if there are any pending keys add them\n          // to this key in mappedDeletions so that the pending keys will\n          // be added before the current next key\n          accumulator[currentKey] = accumulator[TRAILING as any];\n          delete accumulator[TRAILING as any];\n        } else {\n          // If key is not found in next, then add it to the trailing keys.\n          const trailingChildren = accumulator[TRAILING as any]\n            ? [...accumulator[TRAILING as any], currentKey]\n            : [currentKey];\n          accumulator[TRAILING as any] = trailingChildren;\n        }\n\n        return accumulator;\n      },\n      {} as ChildrenRecord<ChildKey>\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Component, ComponentChild, ComponentType, VNode } from 'preact';\nimport { TransitionProps } from './Transition';\nimport { ChildKey, ChildMapping, TransitionUtils } from './TransitionUtils';\n\n/**\n * Props for the TransitionGroup Component\n */\ntype TransitionGroupProps = {\n  /**\n   * @description\n   * <TransitionGroup> renders a '<div>' by default. You can change this\n   * behavior by providing a different ComponentType value to this prop.\n   */\n  elementType?: 'div' | ComponentType;\n\n  /**\n   * @description\n   * Children component should be a collection of TransitionComponent. The child\n   * components should be a Transition Component.\n   */\n  children: VNode<TransitionProps>[];\n};\n\n/**\n * State for the TransitionGroup component\n */\ntype State = {\n  childMapping?: ChildMapping;\n  handleExited?: (child: VNode<TransitionProps>, node: Element, key?: ChildKey) => void;\n};\n\n/**\n * @classdesc\n * The <TransitionGroup> component manages a set of components that involves animations.\n * This component does not handle any animation, rather just a state machine that manages\n * the mounting and unmounting of the components over the time. The actual animation needs\n * to be handled by the content component.\n *\n * Consider the example below:\n * <TransitionGroup>\n *   {\n *      messages.map(message => {\n *        <Transition key={message.key}>\n *          <Message\n *            type={type}\n *            index={index}\n *            item={data.message}\n *            onOjClose={onOjClose}\n *          />\n *        </Transition>\n *      });\n *   }\n * </TransitionGroup>\n * As the messages are added/removed, the TransitionGroup Component automatically\n * toggles the 'in' prop of the Transition Component.\n *\n * @ignore\n */\nexport class TransitionGroup extends Component<TransitionGroupProps, State> {\n  static defaultProps: Partial<TransitionGroupProps> = {\n    elementType: 'div'\n  };\n\n  /**\n   * Derives state from the current props\n   *\n   * @param props The current Props that will be used to get the new state\n   * @param state The current state\n   *\n   * @returns The new state\n   */\n  static getDerivedStateFromProps(\n    props: Readonly<TransitionGroupProps>,\n    state: Readonly<State>\n  ): State | null {\n    const { childMapping, handleExited } = state;\n    return {\n      childMapping: TransitionUtils.getChildMapping(props.children, childMapping, handleExited)\n    };\n  }\n\n  private _mounted: boolean;\n\n  ////////////////////////////////////////////////////////////////////////\n  // Handler functions are created as members to have them 'this' bound //\n  ////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Handles when a transition component exits\n   *\n   * @param child The child instance that exited\n   * @param node The corresponding transition element\n   * @param metadata The metadata of the corresponding transition component\n   */\n  private readonly _handleExited = (\n    child: VNode<TransitionProps>,\n    node?: Element,\n    metadata?: any\n  ) => {\n    const { children } = this.props;\n    // get the child mapping for the current children\n    const currentChildMapping = TransitionUtils.getChildMapping(children);\n\n    // if the exited child is added again, do nothing here\n    if (currentChildMapping.has(child.key)) return;\n\n    // The child component has exited, call the original onExited callback\n    child.props.onExited?.(node, metadata);\n\n    // Check if this component is still mounted, if so update the state\n    if (this._mounted) {\n      this.setState((state: Readonly<State>): Partial<State> => {\n        const childMapping = new Map(state.childMapping!);\n        // delete the exited child\n        childMapping.delete(child.key);\n        return { childMapping };\n      });\n    }\n  };\n\n  ///////////////////////////\n  // Handler functions end //\n  ///////////////////////////\n\n  /**\n   * Instantiates Component\n   *\n   * @param props The component properties\n   */\n  constructor(props: Readonly<TransitionGroupProps>) {\n    super(props);\n\n    this.state = {\n      childMapping: undefined,\n      handleExited: this._handleExited\n    };\n    this._mounted = false;\n  }\n\n  //////////////////////////////////////\n  // Component Life Cycle Hooks Start //\n  //////////////////////////////////////\n\n  /**\n   * Life cycle hook that gets called when the component is mounted on to\n   * the DOM\n   */\n  componentDidMount() {\n    this._mounted = true;\n  }\n\n  /**\n   * Life cycle hook that gets called when the component is unmounted from\n   * the DOM\n   */\n  componentWillUnmount() {\n    this._mounted = false;\n  }\n\n  ////////////////////////////////////\n  // Component Life Cycle Hooks End //\n  ////////////////////////////////////\n\n  /**\n   * Renders the transition components\n   */\n  render(): ComponentChild {\n    const WrapperComponent = this.props.elementType!;\n    const { childMapping } = this.state;\n    const children = [...childMapping!.values()];\n    return <WrapperComponent>{children}</WrapperComponent>;\n  }\n}\n"],"names":["TransitionUtils","getChildMapping","children","prevChildMapping","Map","onExited","TRAILING","Symbol","mappedDeletions","size","_getMappedDeletions","mergedChildrenMap","reduce","accumulator","currentChild","key","deletedChildren","previousChild","get","set","cloneElement","in","props","newChild","bind","nextChildrenKeys","Set","map","keys","currentKey","has","trailingChildren","TransitionGroup","Component","getDerivedStateFromProps","state","childMapping","handleExited","constructor","super","this","_handleExited","child","node","metadata","_mounted","setState","delete","undefined","componentDidMount","componentWillUnmount","render","WrapperComponent","elementType","values","_jsx","jsx","defaultProps"],"mappings":"qFAqBaA,EAQJ,sBAAOC,CACZC,EACAC,EAAiC,IAAIC,IACrCC,EAAmF,QAGnF,MAAMC,EAAWC,SACjB,IAAIC,EAAkB,CAAA,EAEQ,IAA1BL,EAAiBM,OAEnBD,EAAkBR,EAAgBU,oBAAoBR,EAAUC,EAAkBG,IAKpF,MAAMK,EAAkCT,EAASU,QAC/C,CAACC,EAAaC,KACZ,GAAIN,EAAgBM,EAAaC,KAAM,CAGrC,MAAMC,EAAkBR,EAAgBM,EAAaC,KACrD,IAAK,MAAMA,KAAOC,EAAiB,CACjC,MAAMC,EAAgBd,EAAiBe,IAAIH,GAE3CF,EAAYM,IAAIJ,EAAKK,EAAYA,aAACH,EAAgB,CAAEI,IAAI,IACzD,CAGD,MAAMJ,EAAgBd,EAAiBe,IAAIJ,EAAaC,KACxDF,EAAYM,IACVL,EAAaC,IACbK,EAAAA,aAAaN,EAAc,CACzBT,SAAUY,EAAeK,MAAMjB,SAC/BgB,GAAIJ,EAAeK,MAAMD,KAG9B,KAAM,CAEL,MAAME,EAAWH,EAAYA,aAACN,EAAc,CAG1CT,SAAUA,EAASmB,KAAK,KAAMV,GAC9BO,IAAI,IAENR,EAAYM,IAAIL,EAAaC,IAAKQ,EACnC,CAED,OAAOV,CAAW,GAEpB,IAAIT,KAIN,IAAK,MAAMW,KAAOP,EAAgBF,IAAoB,GAAI,CACxD,MAAMW,EAAgBd,EAAiBe,IAAIH,GAE3CJ,EAAkBQ,IAAIJ,EAAKK,EAAYA,aAACH,EAAgB,CAAEI,IAAI,IAC/D,CAGD,OAAOV,CACR,CAcO,0BAAOD,CACbR,EACAC,EACAG,GAGA,MAAMmB,EAAmB,IAAIC,IAAIxB,EAASyB,KAAKzB,GAAaA,EAASa,OAErE,MAAO,IAAIZ,EAAiByB,QAAQhB,QAClC,CAACC,EAAagB,KACZ,GAAIJ,EAAiBK,IAAID,GAKvBhB,EAAYgB,GAAchB,EAAYP,UAC/BO,EAAYP,OACd,CAEL,MAAMyB,EAAmBlB,EAAYP,GACjC,IAAIO,EAAYP,GAAkBuB,GAClC,CAACA,GACLhB,EAAYP,GAAmByB,CAChC,CAED,OAAOlB,CAAW,GAEpB,CAA8B,EAEjC,ECrEG,MAAOmB,UAAwBC,EAAAA,UAanC,+BAAOC,CACLZ,EACAa,GAEA,MAAMC,aAAEA,EAAYC,aAAEA,GAAiBF,EACvC,MAAO,CACLC,aAAcpC,EAAgBC,gBAAgBqB,EAAMpB,SAAUkC,EAAcC,GAE/E,CAkDD,WAAAC,CAAYhB,GACViB,MAAMjB,GApCSkB,KAAaC,cAAG,CAC/BC,EACAC,EACAC,KAEA,MAAM1C,SAAEA,GAAasC,KAAKlB,MAEEtB,EAAgBC,gBAAgBC,GAGpC4B,IAAIY,EAAM3B,OAGlC2B,EAAMpB,MAAMjB,WAAWsC,EAAMC,GAGzBJ,KAAKK,UACPL,KAAKM,UAAUX,IACb,MAAMC,EAAe,IAAIhC,IAAI+B,EAAMC,cAGnC,OADAA,EAAaW,OAAOL,EAAM3B,KACnB,CAAEqB,eAAc,IAE1B,EAeDI,KAAKL,MAAQ,CACXC,kBAAcY,EACdX,aAAcG,KAAKC,eAErBD,KAAKK,UAAW,CACjB,CAUD,iBAAAI,GACET,KAAKK,UAAW,CACjB,CAMD,oBAAAK,GACEV,KAAKK,UAAW,CACjB,CASD,MAAAM,GACE,MAAMC,EAAmBZ,KAAKlB,MAAM+B,aAC9BjB,aAAEA,GAAiBI,KAAKL,MACxBjC,EAAW,IAAIkC,EAAckB,UACnC,OAAOC,EAACC,IAAAJ,EAAkB,CAAAlD,SAAAA,GAC3B,EAhHM8B,EAAAyB,aAA8C,CACnDJ,YAAa"}