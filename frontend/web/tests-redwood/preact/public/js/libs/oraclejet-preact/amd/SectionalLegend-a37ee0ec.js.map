{"version":3,"file":"SectionalLegend-a37ee0ec.js","sources":["../../src/UNSAFE_SectionalLegend/sectionalLegendNavUtils.ts","../../src/UNSAFE_SectionalLegend/getSectionalLegendLayout.ts","../../src/UNSAFE_SectionalLegend/SectionalLegend.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  ItemFocusDetail,\n  ItemHoverDetail,\n  ItemInfo,\n  LegendItemData,\n  LegendSectionData\n} from '#utils/UNSAFE_visTypes/legend';\n\nfunction getItem<K, D>(itemInfo: ItemInfo, sections: LegendSectionData<K, D>[]) {\n  const { sectionIdx, itemIdx } = itemInfo;\n\n  if (sectionIdx == -1 && itemIdx == -1) {\n    const itemsLength = sections[sections.length - 1].items.length;\n    return sections[sections.length - 1].items[itemsLength - 1];\n  }\n\n  return sections[sectionIdx].items[itemIdx];\n}\n\nfunction getNextItemInfo<K, D>(itemInfo: ItemInfo, sections: LegendSectionData<K, D>[]) {\n  let { itemIdx, sectionIdx } = itemInfo;\n\n  if (sectionIdx == -1 && itemIdx == -1) {\n    return {\n      itemIdx: sections[sections.length - 1].items.length - 1,\n      sectionIdx: sections.length - 1\n    };\n  }\n\n  itemIdx += 1;\n  const itemsLength = sections[sectionIdx].items.length;\n  if (itemIdx >= itemsLength) {\n    if (sectionIdx === sections.length - 1) {\n      itemIdx = itemInfo.itemIdx;\n    } else {\n      sectionIdx += 1;\n      itemIdx = 0;\n    }\n  }\n  const item = sections[sectionIdx].items[itemIdx] as LegendItemData<D>; //TODO : Work for better fix instead of adding 'as LegendItem<D>'\n  if (item?.actionable !== 'off') {\n    return { itemIdx, sectionIdx };\n  }\n  return getNextItemInfo({ itemIdx, sectionIdx }, sections);\n}\n\nfunction getPrevItemInfo<K, D>(itemInfo: ItemInfo, sections: LegendSectionData<K, D>[]) {\n  let { itemIdx, sectionIdx } = itemInfo;\n\n  if (sectionIdx == -1 && itemIdx == -1) {\n    (itemIdx = sections[sections.length - 1].items.length - 1), (sectionIdx = sections.length - 1);\n  }\n  itemIdx -= 1;\n\n  if (itemIdx < 0) {\n    if (sectionIdx === 0) {\n      itemIdx = 0;\n    } else {\n      itemIdx = sections[sectionIdx - 1].items.length - 1;\n      sectionIdx -= 1;\n    }\n  }\n\n  const item = sections[sectionIdx].items[itemIdx] as LegendItemData<D>; //TODO : Work for better fix instead of adding 'as LegendItem<D>'\n  if (item?.actionable !== 'off') {\n    return { itemIdx, sectionIdx };\n  }\n  return getPrevItemInfo({ itemIdx, sectionIdx }, sections);\n}\n\n/**\n * Returns utils functions for navigation in simple sectional legend.\n * @param items\n * @returns\n */\nexport function getSectionalNavUtils<\n  K extends string | number,\n  D extends LegendItemData<K>,\n  S extends LegendSectionData<K, D>\n>(sections: S[]) {\n  return {\n    getItem: (itemInfo: ItemInfo) => {\n      return getItem(itemInfo, sections);\n    },\n    getDetailFromInfo: (itemInfo?: ItemInfo): ItemFocusDetail<K, D> | ItemHoverDetail<K, D> => {\n      if (!itemInfo || sections.length === 0) {\n        return { itemId: undefined, sectionId: undefined, data: undefined };\n      }\n      const item = getItem(itemInfo, sections);\n      const sectionId = sections[itemInfo.sectionIdx].id;\n      return {\n        itemId: item.id,\n        sectionId: sectionId,\n        data: sections[itemInfo.sectionIdx].items[itemInfo.itemIdx]\n      };\n    },\n    getPrevItemInfo: (itemInfo: ItemInfo) => {\n      return getPrevItemInfo(itemInfo, sections);\n    },\n    getNextItemInfo: (itemInfo: ItemInfo) => {\n      return getNextItemInfo(itemInfo, sections);\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { RefObject } from 'preact';\nimport { LegendItemData, LegendSectionData } from '#utils/UNSAFE_visTypes/legend';\nimport { Font, TextDimensions, useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { getSectionGridNums } from '#utils/PRIVATE_legendUtils/legendUtils';\n\ntype Props<K, D> = {\n  width: number;\n  getTextDimensions?: ((textString: string, font?: Font | undefined) => TextDimensions) | undefined;\n  resolvedVars: Record<string, any>;\n  rootRef: RefObject<HTMLDivElement>;\n  orientation?: 'vertical' | 'horizontal';\n  legendFontStylesObj?: Font;\n  symbolWidth?: number;\n  symbolHeight?: number;\n  sections: LegendSectionData<K, D>[];\n};\nexport type LayoutInfo = {\n  totalWidth: number;\n  maxItemWidth: number;\n  maxItemHeight: number;\n  itemsPerRow?: number;\n  isWrapped?: boolean;\n  isSectionWrappedArray?: boolean[];\n  isLegendWrappedArray?: boolean[];\n  itemsPerRowArray: number[];\n};\ntype getTextDimensionsType = NonNullable<\n  NonNullable<ReturnType<typeof useTextDimensions>>['getTextDimensions']\n>;\n\nexport const getSectionalLegendLayoutInfo = <K, D extends LegendItemData<K>>({\n  width,\n  getTextDimensions,\n  resolvedVars,\n  rootRef,\n  orientation,\n  legendFontStylesObj = {},\n  symbolWidth,\n  symbolHeight,\n  sections\n}: Props<K, D>) => {\n  let maxWidth = 0;\n  let maxHeight = 0;\n  let totalWidth = 0;\n  const containerWidth = width;\n\n  if (!rootRef.current || !Object.keys(resolvedVars).length || !getTextDimensions) {\n    return;\n  }\n  const unitLength = parseFloat(resolvedVars['unit']);\n  let currentRowWidth = 0;\n  let maxRowWidth = 0;\n  const isSectionWrappedArray: boolean[] = [];\n  const isLegendWrappedArray: boolean[] = [];\n\n  const itemsPerRowArray: number[] = [];\n  let legendHeight = 0;\n  const paddingTop = 0.75 * unitLength;\n  // const paddingBottom = 1.5 * unitLength;\n\n  sections.forEach((section, index) => {\n    let isSectionWrapped = false;\n    let isLegendWrapped = false;\n    let totalSectionalWidth;\n    let rowsAndCol;\n\n    // getTextDimensions calculating text height as +6 from orignal size\n    const titleDims = getTextDimensions(section.title, { fontWeight: '600' });\n\n    //0.5 is adjustment made as getTextdimensions is not calculating correct height\n    const titleHeight = titleDims.height + paddingTop + 0.5;\n    const titlePaddingStart = 3;\n    const titleWidth = titleDims.width + titlePaddingStart;\n    const { maxItemWidth, maxItemHeight, horizontalSectionWidth } = getMaxWidth<K>(\n      section.items,\n      unitLength,\n      getTextDimensions,\n      legendFontStylesObj,\n      symbolWidth,\n      symbolHeight\n    );\n    let initialNumberOfItemsPerRow = section.items.length;\n    const rowGap = 4 * unitLength;\n\n    if (titleWidth + horizontalSectionWidth < containerWidth) {\n      totalSectionalWidth = horizontalSectionWidth + titleWidth;\n      if (\n        currentRowWidth !== 0 &&\n        currentRowWidth + rowGap + totalSectionalWidth < containerWidth &&\n        !isLegendWrappedArray[index - 1]\n      ) {\n        currentRowWidth = currentRowWidth + totalSectionalWidth + rowGap;\n      } else {\n        currentRowWidth = totalSectionalWidth;\n        legendHeight += Math.max(titleHeight, maxItemHeight);\n        if (index !== 0) {\n          legendHeight += rowGap;\n        }\n      }\n    } else {\n      isSectionWrapped = true;\n      totalSectionalWidth = horizontalSectionWidth;\n      const rowPadding = 0.4 * unitLength;\n      if (horizontalSectionWidth > containerWidth) {\n        isLegendWrapped = true;\n        currentRowWidth = 0;\n        initialNumberOfItemsPerRow = Math.floor(containerWidth / maxItemWidth);\n        rowsAndCol = getSectionGridNums(section.items.length, initialNumberOfItemsPerRow);\n        if (rowsAndCol.itemsPerCol && rowsAndCol.itemsPerRow) {\n          legendHeight += titleHeight + 2 * (maxItemHeight + rowPadding) + 2 * paddingTop;\n          currentRowWidth = rowsAndCol.itemsPerRow * maxItemWidth;\n          if (rowsAndCol.itemsPerCol > 2) {\n            //here padding gets added to top and bottom\n            legendHeight += (rowsAndCol.itemsPerCol - 2) * (maxItemHeight + 2 * rowPadding);\n          }\n        }\n      } else {\n        currentRowWidth = totalSectionalWidth;\n        legendHeight += maxItemHeight + titleHeight + 2 * paddingTop;\n        if (index !== 0) {\n          legendHeight += rowGap;\n        }\n      }\n    }\n\n    maxRowWidth = Math.max(currentRowWidth, maxRowWidth);\n    totalWidth += horizontalSectionWidth;\n    maxWidth = Math.max(maxWidth, maxItemWidth);\n    maxHeight = maxItemHeight;\n    isSectionWrappedArray.push(isSectionWrapped);\n    isLegendWrappedArray.push(isLegendWrapped);\n    itemsPerRowArray.push(orientation === 'vertical' ? 1 : Math.max(1, initialNumberOfItemsPerRow));\n  });\n\n  const legendLayoutInfo = {\n    maxRowWidth: Math.ceil(maxRowWidth),\n    legendHeight,\n    totalWidth,\n    maxItemWidth: Math.min(maxWidth, containerWidth),\n    maxItemHeight: Math.ceil(maxHeight),\n    itemsPerRowArray,\n    isSectionWrappedArray,\n    isLegendWrappedArray\n  };\n  return legendLayoutInfo;\n};\n\n/**\n * Returns maximum of the width among the items in a section of legend also return the width of the entire section.\n * @param items Legend items array\n * @param unitLength Base  element\n * @param getTextDimensions Text width measurement function\n * @param legendFontStylesObj Legend text font style properties object\n * @param symbolWidth Width of legend symbol\n *\n * @returns\n */\nconst getMaxWidth = <K>(\n  items: LegendItemData<K>[],\n  unitLength: number,\n  getTextDimensions: getTextDimensionsType,\n  legendFontStylesObj?: Font,\n  symbolWidth?: number,\n  symbolHeight?: number\n) => {\n  let maxItemWidth = 0;\n  let maxItemHeight = 0;\n  let horizontalSectionWidth = 0;\n  let itemSymbolWidth = 0;\n  let itemSymbolHeight = 0;\n  const symbolPadding = unitLength * 1.5;\n  if (symbolWidth) {\n    itemSymbolWidth = symbolPadding + symbolWidth;\n  } else {\n    //below expression is simplified as, itemSymbolWidth = marginLeft + marginRight + width\n    itemSymbolWidth = 4 * unitLength;\n  }\n  const paddingTop = 1.7 * unitLength;\n  const defaultSymbolHeight = 2.5 * unitLength;\n  if (symbolHeight) {\n    // symbolHeight/defaultSymbolHeight + paddingTopBottom\n    itemSymbolHeight = symbolHeight + paddingTop;\n  } else {\n    itemSymbolHeight = defaultSymbolHeight + paddingTop;\n  }\n  const paddingLeftRight = 2.5 * unitLength;\n\n  items?.forEach((item) => {\n    const legendItem = item as LegendItemData<K>;\n    const { width, height } = getTextDimensions(legendItem.text, legendFontStylesObj);\n\n    //itemTextWidth = paddingLeft + paddingRight + width\n    const itemTextWidth = paddingLeftRight + width;\n    //horizontalSectionWidth = total width of the section\n    horizontalSectionWidth += itemSymbolWidth + itemTextWidth;\n    maxItemWidth = Math.max(maxItemWidth, itemSymbolWidth + itemTextWidth);\n    maxItemHeight = Math.max(maxItemHeight, height, itemSymbolHeight);\n  });\n\n  return { maxItemWidth, maxItemHeight, horizontalSectionWidth };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.̦\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Ref, VNode } from 'preact';\nimport { forwardRef } from 'preact/compat';\nimport { useImperativeHandle, useRef, useState } from 'preact/hooks';\nimport { useVisEvent } from '#hooks/PRIVATE_useVisEvents/useVisEvents';\nimport { getSectionalNavUtils } from './sectionalLegendNavUtils';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { getRandomId } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport {\n  getDatatipText,\n  getAriaProps,\n  getSectionGridNums,\n  getLegendTextStyle,\n  getIsLegendItemActionable,\n  isEqualItem,\n  getItemInfo,\n  getKeyUpHandler\n} from '#utils/PRIVATE_legendUtils/legendUtils';\nimport { useLegendDatatip } from '#UNSAFE_Legend/useLegendDatatip';\nimport { useItemFocus } from '#hooks/PRIVATE_useVisEvents';\nimport { getSectionalLegendLayoutInfo } from './getSectionalLegendLayout';\nimport { Flex } from '#UNSAFE_Flex';\nimport { styles } from '#PRIVATE_BaseLegend/themes/LegendStyles.css';\nimport { useCssVars } from '#hooks/PRIVATE_useCssVars';\nimport { legendVars } from '#utils/PRIVATE_legendUtils/legendUtils';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { useTestId } from '#hooks/UNSAFE_useTestId';\nimport { BaseLegend } from '#PRIVATE_BaseLegend//BaseLegend';\nimport { useSectionalLegendContextMenu } from '#PRIVATE_BaseLegend/useLegendContextMenu';\nimport { SectionalLegendDragStartDetail, SectionalLegendProps } from './sectionalLegend.type';\nimport {\n  ItemFocusDetail,\n  ItemActionDetail,\n  ItemInfo,\n  LegendItemData,\n  LegendSectionData\n} from '#utils/UNSAFE_visTypes/legend';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { merge } from '@oracle/oraclejet-internal-utilities/stringUtils';\nimport { useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { TrackResizeContainer } from '#UNSAFE_TrackResizeContainer';\nimport { useLegendDnd } from '#hooks/PRIVATE_useLegendDnD';\nimport { styles as VisDndStyles } from '#hooks/PRIVATE_useVisDnd/themes/VisDndStyles.css';\nimport { LegendText } from '#PRIVATE_BaseLegend/LegendText';\n\nexport type SizeHandle = {\n  _getPreferredSize: (\n    _width: number,\n    _height: number\n  ) => { width: number; height: number } | undefined;\n};\n\ntype ForwardRefSectionalLegend = <\n  K extends string | number,\n  D extends LegendItemData<K>,\n  S extends LegendSectionData<K, D>\n>(\n  props: SectionalLegendProps<K, D, S> & { ref?: Ref<SizeHandle> }\n) => VNode | null;\n\n/**\n * A Sectional Legend allows grouping of legend items in sections with a specific title.\n */\nexport const SectionalLegend = forwardRef(\n  <K extends string | number, D extends LegendItemData<K>, S extends LegendSectionData<K, D>>(\n    {\n      orientation = 'horizontal',\n      sectionTitleHAlign = 'start',\n      sections,\n      isReadOnly = true,\n      onItemAction,\n      onItemHover,\n      onItemFocus,\n      testId,\n      contextMenuConfig,\n      hideAndShowBehavior = 'off',\n      hoverBehavior = 'none',\n      valign = 'top',\n      halign = 'start',\n      ...props\n    }: SectionalLegendProps<K, D, S>,\n    ref: Ref<SizeHandle> = null\n  ) => {\n    return (\n      <TrackResizeContainer\n        width={'100%'}\n        height={'100%'}\n        class={classNames([\n          styles.flexStyle,\n          styles[`${halign}HAlign`],\n          styles[`${valign}VAlign`]\n        ])}>\n        {function _(width, _height) {\n          const testIdProps = useTestId(testId);\n          const rootRef = useRef<HTMLDivElement>(null);\n          const isTestEnv = testIdProps['data-testid'] !== undefined;\n          const rootDimsRef = useRef<DOMRect>();\n          const { resolvedVars, cssContent } = useCssVars(legendVars);\n\n          const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } =\n            getSectionalNavUtils<K, D, S>(sections);\n          const legendFontStylesObj = getLegendTextStyle(\n            {\n              fontStyle: props.textFontStyle,\n              fontSize: props.textFontSize?.toString(),\n              fontWeight: props.textFontWeight?.toString(),\n              fontFamily: props.textFontFamily\n            },\n            resolvedVars\n          );\n          const { textMeasureContent, getTextDimensions } = useTextDimensions();\n\n          const isLegendItemActionable = getIsLegendItemActionable(sections, isReadOnly, true);\n          const hasData = sections.length > 0;\n\n          const layoutInfo = getSectionalLegendLayoutInfo({\n            width,\n            rootRef,\n            getTextDimensions,\n            resolvedVars,\n            orientation,\n            legendFontStylesObj,\n            symbolWidth: props.symbolWidth,\n            symbolHeight: props.symbolHeight,\n            sections\n          });\n          const { touchResponse, touchResponseStyle } = useVisTouchResponse({ type: 'touchStart' });\n\n          const {\n            focusedItemInfo,\n            hoveredItemInfo,\n            onContextMenuDismissed,\n            activeId,\n            eventsProps\n          } = useVisEvent<ItemInfo, ItemActionDetail<K, D>, ItemFocusDetail<K, D>, D>(\n            touchResponse,\n            !isReadOnly,\n            isLegendItemActionable,\n            getKeyUpHandler,\n            getDetailFromInfo,\n            getPrevItemInfo,\n            getNextItemInfo,\n            onItemAction,\n            onItemHover,\n            onItemFocus,\n            isEqualItem,\n            getItemInfo,\n            { itemIdx: 0, sectionIdx: 0 }\n          );\n\n          const { focusedItemRef } = useItemFocus(focusedItemInfo);\n          const text = getDatatipText(sections, getItem, focusedItemInfo, hoveredItemInfo);\n          const [datatipDisabled, setDatatipDisabled] = useState(false);\n          const {\n            datatipContent,\n            datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps }\n          } = useLegendDatatip({\n            text,\n            rootDimsRef,\n            focusedItemInfo,\n            focusedItemRef,\n            touchResponse,\n            isDisabled: datatipDisabled\n          });\n          const ariaProps = getAriaProps<K>(\n            isReadOnly,\n            props['aria-label'],\n            props.hiddenIds,\n            merge([props['aria-describedby'], datatipAriaDescribedby]),\n            props['aria-labelledby']\n          );\n\n          const { contextMenuContent, contextMenuProps } = useSectionalLegendContextMenu<K, D, S>({\n            rootRef,\n            contextMenuConfig: hasData ? contextMenuConfig : undefined,\n            focusedItemInfo,\n            sections,\n            isReadOnly,\n            onContextMenuDismissed\n          });\n\n          const [dragOver, setDragOver] = useState<boolean>();\n          const { draggable, dndProps, dndContent } = useLegendDnd<\n            K,\n            D,\n            SectionalLegendDragStartDetail<D>,\n            S\n          >({\n            onDrag: props.onDrag,\n            onDragStart: props.onDragStart,\n            onDragEnd: props.onDragEnd,\n            onDragEnter: props.onDragEnter,\n            onDragLeave: props.onDragLeave,\n            onDragOver: props.onDragOver,\n            onDrop: props.onDrop,\n            sections,\n            setDragOver,\n            setDatatipDisabled,\n            itemDraggable: props.itemDraggable\n          });\n\n          const mergedProps = mergeProps(eventsProps, datatipProps, contextMenuProps, dndProps);\n          const titleStyle = {\n            fontFamily: props.sectionTitleFontFamily,\n            fontSize: props.sectionTitleFontSize,\n            color: props.sectionTitleColor,\n            fontStyle: props.sectionTitleFontStyle,\n            fontWeight: props.sectionTitleFontWeight,\n            textDecoration: props.sectionTitleTextDecoration\n          };\n          const { sectionalLegendBaseStyles, renderedLegendStyle } = styles;\n          const isHoriz = orientation === 'horizontal';\n\n          useImperativeHandle(\n            ref,\n            () => ({\n              _getPreferredSize: (_width: number, _height: number) => {\n                const legendLayoutInfo = getSectionalLegendLayoutInfo({\n                  width: _width,\n                  getTextDimensions,\n                  resolvedVars,\n                  rootRef,\n                  orientation,\n                  legendFontStylesObj,\n                  symbolWidth: props.symbolWidth,\n                  symbolHeight: props.symbolHeight,\n                  sections\n                });\n                if (legendLayoutInfo) {\n                  return {\n                    width: legendLayoutInfo?.maxRowWidth,\n                    height: legendLayoutInfo?.legendHeight\n                  };\n                } else {\n                  return;\n                }\n              }\n            }),\n            [getTextDimensions, legendFontStylesObj, resolvedVars]\n          );\n\n          return (\n            <div\n              ref={rootRef}\n              tabIndex={isReadOnly ? undefined : 0}\n              role=\"application\"\n              class={classNames([\n                sectionalLegendBaseStyles,\n                renderedLegendStyle,\n                dragOver\n                  ? VisDndStyles.dndDragOverHTMLStyle\n                  : dragOver === false\n                  ? VisDndStyles.dndRejectedStyle\n                  : undefined\n              ])}\n              draggable={draggable}\n              style={touchResponseStyle}\n              {...testIdProps}\n              {...ariaProps}\n              {...mergedProps}\n              aria-activedescendant={activeId}>\n              <Flex direction={isHoriz ? 'row' : 'column'} wrap={'wrap'} gap={'4x'}>\n                {sections.map((section: S, index: number) => {\n                  const labelledById = !isReadOnly ? getRandomId() : '';\n                  const isWrappedSection = layoutInfo\n                    ? layoutInfo.isSectionWrappedArray[index]\n                    : false;\n                  const flexDirection = !isHoriz || isWrappedSection ? 'column' : 'row';\n                  const alignItems = !isHoriz || isWrappedSection ? 'start' : 'center';\n                  const { itemsPerCol, itemsPerRow } = getSectionGridNums(\n                    section.items.length,\n                    layoutInfo?.itemsPerRowArray[index]\n                  );\n                  return (\n                    <Flex\n                      align={alignItems}\n                      direction={flexDirection}\n                      maxWidth={'100%'}\n                      justify={'start'}\n                      wrap=\"wrap\">\n                      <LegendText\n                        text={section.title}\n                        {...titleStyle}\n                        type=\"title\"\n                        id={labelledById}\n                        align={sectionTitleHAlign}\n                      />\n                      <BaseLegend\n                        {...props}\n                        focusedItemRef={focusedItemRef}\n                        labelledBy={labelledById}\n                        sectionIdx={index}\n                        items={section.items}\n                        orientation={orientation}\n                        itemsPerRow={itemsPerRow}\n                        itemsPerCol={itemsPerCol}\n                        itemWidth={\n                          layoutInfo?.isLegendWrappedArray[index]\n                            ? layoutInfo?.maxItemWidth\n                            : undefined\n                        }\n                        isReadOnly={isReadOnly}\n                        focusedItemInfo={focusedItemInfo}\n                        hoveredItemInfo={hoveredItemInfo}\n                        activeId={activeId}\n                        hideAndShowBehavior={hideAndShowBehavior}\n                        hoverBehavior={hoverBehavior}\n                        isTestEnv={isTestEnv}\n                      />\n                    </Flex>\n                  );\n                })}\n              </Flex>\n              {datatipContent}\n              {textMeasureContent}\n              {cssContent}\n              {contextMenuContent}\n              {dndContent}\n            </div>\n          );\n        }}\n      </TrackResizeContainer>\n    );\n  }\n) as ForwardRefSectionalLegend;\n"],"names":["getItem","itemInfo","sections","sectionIdx","itemIdx","itemsLength","length","items","getNextItemInfo","item","actionable","getPrevItemInfo","getSectionalNavUtils","getDetailFromInfo","itemId","undefined","sectionId","data","id","getSectionalLegendLayoutInfo","width","getTextDimensions","resolvedVars","rootRef","orientation","legendFontStylesObj","symbolWidth","symbolHeight","maxWidth","maxHeight","totalWidth","containerWidth","current","Object","keys","unitLength","parseFloat","currentRowWidth","maxRowWidth","isSectionWrappedArray","isLegendWrappedArray","itemsPerRowArray","legendHeight","paddingTop","forEach","section","index","totalSectionalWidth","rowsAndCol","isSectionWrapped","isLegendWrapped","titleDims","title","fontWeight","titleHeight","height","titleWidth","maxItemWidth","maxItemHeight","horizontalSectionWidth","getMaxWidth","initialNumberOfItemsPerRow","rowGap","Math","max","rowPadding","floor","getSectionGridNums","itemsPerCol","itemsPerRow","push","ceil","min","itemSymbolWidth","itemSymbolHeight","paddingLeftRight","legendItem","text","itemTextWidth","SectionalLegend","forwardRef","sectionTitleHAlign","isReadOnly","onItemAction","onItemHover","onItemFocus","testId","contextMenuConfig","hideAndShowBehavior","hoverBehavior","valign","halign","props","ref","_jsx","jsx","TrackResizeContainer","class","classNames","styles","flexStyle","_height","testIdProps","useTestId","useRef","isTestEnv","rootDimsRef","cssContent","useCssVars","legendVars","getLegendTextStyle","fontStyle","textFontStyle","fontSize","textFontSize","toString","textFontWeight","fontFamily","textFontFamily","textMeasureContent","useTextDimensions","isLegendItemActionable","getIsLegendItemActionable","hasData","layoutInfo","touchResponse","touchResponseStyle","useVisTouchResponse","type","focusedItemInfo","hoveredItemInfo","onContextMenuDismissed","activeId","eventsProps","useVisEvent","getKeyUpHandler","isEqualItem","getItemInfo","focusedItemRef","useItemFocus","getDatatipText","datatipDisabled","setDatatipDisabled","useState","datatipContent","datatipProps","datatipAriaDescribedby","useLegendDatatip","isDisabled","ariaProps","getAriaProps","hiddenIds","merge","l","contextMenuContent","contextMenuProps","useSectionalLegendContextMenu","dragOver","setDragOver","draggable","dndProps","dndContent","useLegendDnd","onDrag","onDragStart","onDragEnd","onDragEnter","onDragLeave","onDragOver","onDrop","itemDraggable","mergedProps","mergeProps","titleStyle","sectionTitleFontFamily","sectionTitleFontSize","color","sectionTitleColor","sectionTitleFontStyle","sectionTitleFontWeight","textDecoration","sectionTitleTextDecoration","sectionalLegendBaseStyles","renderedLegendStyle","isHoriz","useImperativeHandle","_getPreferredSize","_width","legendLayoutInfo","_jsxs","jsxs","tabIndex","role","VisDndStyles","dndDragOverHTMLStyle","dndRejectedStyle","style","children","Flex","direction","wrap","gap","map","labelledById","getRandomId","isWrappedSection","flexDirection","alignItems","align","justify","LegendText","BaseLegend","labelledBy","itemWidth"],"mappings":"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"}