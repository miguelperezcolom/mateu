{"version":3,"file":"labelUtils-a0808e76.js","sources":["../../src/PRIVATE_Axis/utils/axisDefaults.ts","../../src/PRIVATE_Axis/utils/labelUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport const AXIS_DEFAULTS = {\n  titleGap: 6,\n  labelGap: 6\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { AXIS_DEFAULTS } from './axisDefaults';\nimport { VisTextStyle, isHeightOverlap, isWidthOverlap } from '#utils/UNSAFE_visUtils';\nimport { GetTextDimensionsType, TextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { getTextInfo } from '#PRIVATE_VisSVGText';\nimport { TextProps } from '#PRIVATE_VisSVGText/text.types';\n\n/**\n * Calculates the number of skips between axis labels and the dimensions of unskipped labels.\n * @param labels The labels to render.\n * @param getLabelInfo The function that returns dimension of given label.\n * @param isHoriz Whether the axis is horizontal.\n * @param numOfSafeSkips The no of labels to skip safely.\n * @returns\n */\nexport function skipLabelsUniform(\n  labels: (string | undefined)[],\n  getLabelInfo: (\n    label: string | undefined,\n    index: number,\n    isRotated: boolean,\n    allowTruncate: boolean,\n    wrapText: boolean\n  ) => {\n    text: string;\n    lineProps: TextDimensions[];\n    dims: TextDimensions;\n    isTruncated: boolean;\n    didNotFit: boolean;\n    lines: string[];\n    indexAtLevel: number;\n  },\n  isHoriz: boolean,\n  isRotated: boolean,\n  autoTruncate: boolean,\n  isWrapAllowed: boolean,\n  numOfSafeSkips?: number\n) {\n  let numOfSkips = numOfSafeSkips || 0;\n  let dimsA: TextDimensions;\n  let dimsB: TextDimensions;\n  const labelsInfo = [getLabelInfo(labels[0], 0, isRotated, autoTruncate, isWrapAllowed)];\n  const isOverlapping = isHoriz ? isWidthOverlap : isHeightOverlap;\n\n  let indexA = 0;\n  let indexB = numOfSkips + 1;\n  while (indexB < labels.length) {\n    const labelsInfoA =\n      labelsInfo[indexA] ||\n      getLabelInfo(labels[indexA], indexA, isRotated, autoTruncate, isWrapAllowed);\n    dimsA = labelsInfoA.dims;\n    if (!labelsInfo[indexA]) {\n      labelsInfo[indexA] = labelsInfoA;\n    }\n    const labelsInfoB =\n      labelsInfo[indexB] ||\n      getLabelInfo(labels[indexB], indexB, isRotated, autoTruncate, isWrapAllowed);\n    dimsB = labelsInfoB.dims;\n    if (!labelsInfo[indexB]) {\n      labelsInfo[indexB] = labelsInfoB;\n    }\n\n    if (isOverlapping(dimsA, dimsB)) {\n      numOfSkips += 1;\n      indexA = 0;\n      indexB = numOfSkips + 1;\n    } else {\n      indexA = indexB;\n      indexB = indexA + numOfSkips + 1;\n    }\n  }\n  return { numOfSkips, labelsInfo };\n}\n\n/**\n * Greedily skip labels. We will skip next label if it overlaps with the previous one.\n * This might not result in uniformly spaced labels.\n * @param labels\n * @param getLabelInfo\n * @param isHoriz\n * @returns\n */\nexport function skipLabelsGreedy(\n  labels: string[],\n  getLabelInfo: (\n    label: string | undefined,\n    index: number,\n    isRotated: boolean,\n    allowTruncate: boolean,\n    wrapText: boolean\n  ) => {\n    text: string;\n    lineProps: TextDimensions[];\n    dims: TextDimensions;\n    isTruncated: boolean;\n    lines: string[];\n    didNotFit: boolean;\n  },\n  isHoriz: boolean,\n  wrapText?: boolean\n) {\n  const isOverlapping = isHoriz ? isWidthOverlap : isHeightOverlap;\n  let currentInfo = getLabelInfo(labels[0], 0, false, false, !!wrapText);\n  const renderedLabels = [\n    {\n      text: currentInfo.text,\n      lines: [currentInfo.text],\n      index: 0,\n      lineProps: [currentInfo.dims],\n      dims: currentInfo.dims\n    }\n  ];\n  let maxWidth = currentInfo.dims.width;\n  let maxHeight = currentInfo.dims.height;\n  for (let j = 1; j < labels.length; j++) {\n    if (!labels[j]) continue;\n    const labelInfo = getLabelInfo(labels[j], j, false, false, !!wrapText);\n    if (!isOverlapping(currentInfo.dims, labelInfo.dims)) {\n      currentInfo = labelInfo;\n      renderedLabels.push({\n        text: labelInfo.text,\n        lines: [labelInfo.text],\n        index: j,\n        dims: labelInfo.dims,\n        lineProps: [labelInfo.dims]\n      });\n\n      maxWidth = Math.max(maxWidth, labelInfo.dims.width);\n      maxHeight = Math.max(maxHeight, labelInfo.dims.height);\n    }\n  }\n  return { tickLabels: renderedLabels, maxWidth, maxHeight };\n}\n\nexport function getDataAxisLabelsInfo(\n  labels: (string | undefined)[],\n  getLabelInfo: (\n    label: string | undefined,\n    index: number,\n    isRotated: boolean,\n    allowTruncate: boolean,\n    wrapText: boolean\n  ) => {\n    text: string;\n    lineProps: TextDimensions[];\n    dims: TextDimensions;\n    isTruncated: boolean;\n    didNotFit: boolean;\n    lines: string[];\n    indexAtLevel: number;\n  },\n  isHoriz: boolean\n) {\n  const { numOfSkips, labelsInfo } = skipLabelsUniform(\n    labels,\n    getLabelInfo,\n    isHoriz,\n    false,\n    false,\n    false,\n    0\n  );\n\n  const tickLabels: any[] = [];\n  let maxWidth = 0;\n  let maxHeight = 0;\n  let isLabelTruncated = false;\n\n  for (let i = 0; i < labels.length; i += numOfSkips + 1) {\n    maxWidth = Math.max(maxWidth, labelsInfo[i].dims.width);\n    maxHeight = Math.max(maxHeight, labelsInfo[i].dims.height);\n    isLabelTruncated = isLabelTruncated || labelsInfo[i].isTruncated;\n    tickLabels.push({\n      text: labelsInfo[i].text,\n      lines: labelsInfo[i].lines,\n      index: i,\n      dims: labelsInfo[i].dims,\n      lineProps: labelsInfo[i].lineProps\n    });\n  }\n  return {\n    maxWidth,\n    maxHeight,\n    numOfSkips,\n    isLabelTruncated,\n    tickLabels\n  };\n}\n\nexport function getGroupAxisLabelsInfo(\n  labels: (string | undefined)[],\n  getLabelInfo: (\n    label: string | undefined,\n    index: number,\n    isRotated: boolean,\n    allowTruncate: boolean,\n    wrapText: boolean\n  ) => {\n    text: string;\n    lineProps: TextDimensions[];\n    dims: TextDimensions;\n    isTruncated: boolean;\n    didNotFit: boolean;\n    lines: string[];\n    indexAtLevel: number;\n    dataProps?: Record<string, string | undefined>;\n  },\n  isHoriz: boolean,\n  autoRotate: boolean,\n  wrapText: boolean,\n  numOfSafeSkips?: number\n) {\n  let isRotated = false;\n\n  /**\n   * 1.First calculate dims of all the labels in horizontal position without\n   *   restriction and calculate the num of skips.\n   * 2.Check if the labels overlap, and hence if we have to skip some labels to\n   *   avoid overlap.\n   * 3.If we had to skip some labels and if wrapping the text is allowed, try\n   *   again horizontally with wrap enabled.\n   * 4.Check again if the labels overlap, or if some text got truncated.Truncation is\n   *   undesirable at this step if rotation is enabled.\n   * 5.If rotation is enabled, rotate the labels and check for overlap again.\n   * 6.After all the steps above, choose the setting that result in minimum number of skips.\n   */\n\n  let { numOfSkips, labelsInfo } = skipLabelsUniform(\n    labels,\n    getLabelInfo,\n    isHoriz,\n    false,\n    false,\n    false,\n    numOfSafeSkips\n  );\n  if (numOfSkips > 0 && wrapText && isHoriz) {\n    const wrapAllowedLabels = skipLabelsUniform(\n      labels,\n      getLabelInfo,\n      isHoriz,\n      false,\n      false,\n      true,\n      numOfSafeSkips\n    );\n\n    const isNotValid = wrapAllowedLabels.labelsInfo.some(\n      (info) => info.isTruncated || info.didNotFit\n    );\n\n    if (!isNotValid && wrapAllowedLabels.numOfSkips < numOfSkips) {\n      numOfSkips = wrapAllowedLabels.numOfSkips;\n      labelsInfo = wrapAllowedLabels.labelsInfo;\n    }\n  }\n\n  if (numOfSkips > 0 && autoRotate) {\n    const skipInfoRotated = skipLabelsUniform(\n      labels,\n      getLabelInfo,\n      isHoriz,\n      true,\n      true,\n      false,\n      numOfSafeSkips\n    );\n    if (skipInfoRotated.numOfSkips < numOfSkips) {\n      numOfSkips = skipInfoRotated.numOfSkips;\n      labelsInfo = skipInfoRotated.labelsInfo;\n      isRotated = true;\n    }\n  }\n\n  const tickLabels = [] as (TextProps & { index: number })[];\n  let maxWidth = 0;\n  let maxHeight = 0;\n\n  for (let i = 0; i < labels.length; i += numOfSkips + 1) {\n    maxWidth = Math.max(maxWidth, labelsInfo[i].dims.width);\n    maxHeight = Math.max(maxHeight, labelsInfo[i].dims.height);\n    tickLabels[labelsInfo[i].indexAtLevel] = {\n      text: labelsInfo[i].text,\n      lines: labelsInfo[i].lines,\n      index: labelsInfo[i].indexAtLevel,\n      dims: labelsInfo[i].dims,\n      lineProps: labelsInfo[i].lineProps,\n      isRotated,\n      isTruncated: labelsInfo[i].isTruncated\n    };\n  }\n\n  return {\n    maxWidth,\n    maxHeight,\n    isRotated,\n    numOfSkips,\n    tickLabels\n  };\n}\n\nexport function updateLabelsDims(\n  maxWidth: number,\n  maxHeight: number,\n  renderedLabelsInfo: any[],\n  getAxisPos: (index: number) => number,\n  availSpace: Dimension,\n  position: AxisPosition\n) {\n  renderedLabelsInfo.forEach((info) => {\n    info.lines.forEach((_: any, index: number) => {\n      const dim = info.lineProps[index];\n      let x: number;\n      let y: number;\n      if (position === 'left') {\n        x = availSpace.x + maxWidth;\n        y = getAxisPos(info.index);\n      } else if (position === 'right') {\n        x = availSpace.x + availSpace.width - maxWidth;\n        y = getAxisPos(info.index);\n      } else if (position === 'top') {\n        x = getAxisPos(info.index);\n        y = availSpace.y + maxHeight - dim.height / 2;\n      } else {\n        x = getAxisPos(info.index);\n        y = availSpace.y + availSpace.height - maxHeight + dim.height / 2 + dim.height * index;\n      }\n      dim.x = x;\n      dim.y = y;\n    });\n\n    const textDim = info.dims;\n\n    let x: number;\n    let y: number;\n    if (position === 'left') {\n      x = availSpace.x + maxWidth;\n      y = getAxisPos(info.index);\n    } else if (position === 'right') {\n      x = availSpace.x + availSpace.width - maxWidth;\n      y = getAxisPos(info.index);\n    } else if (position === 'top') {\n      x = getAxisPos(info.index);\n      y = availSpace.y + maxHeight - textDim.height / 2;\n    } else {\n      x = getAxisPos(info.index);\n      y = availSpace.y + availSpace.height - maxHeight + textDim.height / 2;\n    }\n    textDim.x = x;\n    textDim.y = y;\n  });\n}\n\n/**\n * Returns the enclosing rect for the label of given dimension.\n * @param dims The dimension\n * @param axisPosition The position of the axis.\n * @returns\n */\nexport function getEnclosingRectDims(dims: Dimension, axisPosition: AxisPosition, isRtl: boolean) {\n  let x: number;\n  let y: number;\n\n  const isVert = axisPosition === 'left' || axisPosition === 'right';\n\n  if (axisPosition === 'left') {\n    x = dims.x - dims.width;\n    y = dims.y - dims.height / 2;\n  } else if (axisPosition === 'right') {\n    x = dims.x;\n    y = dims.y - dims.height / 2;\n  } else {\n    x = dims.x - dims.width / 2;\n    y = dims.y - dims.height / 2;\n  }\n  const width = dims.width;\n  const height = dims.height;\n\n  if (isRtl && isVert) {\n    x -= width;\n  }\n\n  return { x, y, width, height };\n}\n\n/**\n * Retuns the unaligned label dimensions that can be used by skipLabels.\n * @returns\n */\nexport function getTickLabelInfo(\n  coord: number | undefined,\n  label: string | undefined,\n  indexAtLevel: number,\n  labelStyle: VisTextStyle,\n  isHoriz: boolean,\n  isRotated: boolean,\n  isWrapAllowed: boolean,\n  allowTruncate: boolean,\n  maxWidth: number,\n  maxHeight: number,\n  availSpace: Dimension,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  if (!getTextDimensions || !label || coord == null) {\n    return {\n      indexAtLevel,\n      text: '',\n      dims: { width: 0, height: 0, x: 0, y: 0 },\n      isTruncated: false,\n      lines: [],\n      didNotFit: false,\n      lineProps: []\n    };\n  }\n\n  const gap = AXIS_DEFAULTS.labelGap;\n  const availWidth = isRotated ? maxHeight : isWrapAllowed ? maxWidth - gap : maxWidth;\n\n  let width: number, height: number;\n  let isTruncated = false;\n  let lines: string[] = [];\n  let dims: Dimension[] = [];\n  let lineHeight: number;\n  let didNotFit = false;\n\n  const mxHeight = isWrapAllowed ? maxHeight : Infinity;\n\n  if (allowTruncate || isWrapAllowed) {\n    const textInfo = getTextInfo(\n      label,\n      labelStyle,\n      availWidth,\n      mxHeight,\n      isWrapAllowed,\n      1,\n      getTextDimensions\n    );\n    width = textInfo.width;\n    height = textInfo.height;\n    lines = textInfo.lines;\n    dims = textInfo.dims;\n    isTruncated = textInfo.isTruncated;\n    lineHeight = textInfo.lineHeight;\n    didNotFit = textInfo.didNotFit;\n  } else {\n    dims = [getTextDimensions(label, labelStyle)];\n    width = dims[0].width;\n    height = dims[0].height;\n    lines = [label];\n    isTruncated = false;\n    lineHeight = height;\n  }\n\n  const _labelWidth = isRotated ? height : width;\n  const _labelHeight = isRotated ? width : height;\n\n  const labelWidth = isHoriz ? _labelWidth + gap : _labelWidth;\n  const labelHeight = isHoriz ? _labelHeight : _labelHeight + gap;\n  return {\n    indexAtLevel,\n    text: label,\n    lines,\n    lineProps: dims.map((dim, i) => ({\n      x: isHoriz ? coord - dim.width / 2 : availSpace.x,\n      width: isRotated ? dim.height : dim.width,\n      height: isRotated ? dim.width : dim.height,\n      y: isHoriz ? availSpace.y + lineHeight * i : coord + dim.height / 2\n    })),\n    isTruncated,\n    didNotFit,\n    dims: {\n      x: isHoriz ? coord - labelWidth / 2 : availSpace.x,\n      width: labelWidth,\n      height: labelHeight,\n      y: isHoriz ? availSpace.y : coord + labelHeight / 2\n    }\n  };\n}\n"],"names":["AXIS_DEFAULTS","titleGap","labelGap","skipLabelsUniform","labels","getLabelInfo","isHoriz","isRotated","autoTruncate","isWrapAllowed","numOfSafeSkips","dimsA","dimsB","numOfSkips","labelsInfo","isOverlapping","isWidthOverlap","isHeightOverlap","indexA","indexB","length","labelsInfoA","dims","labelsInfoB","tickLabels","maxWidth","maxHeight","isLabelTruncated","i","Math","max","width","height","isTruncated","push","text","lines","index","lineProps","axisPosition","isRtl","x","y","isVert","autoRotate","wrapText","wrapAllowedLabels","some","info","didNotFit","skipInfoRotated","indexAtLevel","coord","label","labelStyle","allowTruncate","availSpace","getTextDimensions","gap","availWidth","lineHeight","mxHeight","Infinity","textInfo","getTextInfo","_labelWidth","_labelHeight","labelWidth","labelHeight","map","dim","currentInfo","renderedLabels","j","labelInfo","renderedLabelsInfo","getAxisPos","position","forEach","_","textDim"],"mappings":"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"}