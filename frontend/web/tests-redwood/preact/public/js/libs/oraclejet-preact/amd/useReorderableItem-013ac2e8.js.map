{"version":3,"file":"useReorderableItem-013ac2e8.js","sources":["../../src/hooks/PRIVATE_useReorderable/useReorderable.ts","../../src/hooks/PRIVATE_useReorderable/useReorderableItem.ts"],"sourcesContent":["import type { RefObject } from 'preact';\nimport { useRef, useCallback, useState } from 'preact/hooks';\nimport { useId } from '#hooks/UNSAFE_useId';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { getClientHints } from '#utils/PRIVATE_clientHints';\nimport { getItemKeysArray } from '#utils/PRIVATE_collectionUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport { ReorderProps } from '#UNSAFE_Collection/Reorderable.types';\n\ntype useReorderableProps<K> = ReorderProps<K> & {\n  rootRef: RefObject<HTMLDivElement>;\n  itemSelector: string;\n  isDisabled?: boolean;\n  columns?: number;\n};\n\n/**\n * Implements keyboard reorder behavior for list-like components, e.g. TabBar, ListView, CardView\n */\nexport function useReorderable<K extends string | number>(options: useReorderableProps<K>) {\n  const { onReorder, rootRef, itemSelector, isDisabled, columns } = options;\n\n  const currentItemKey = useRef<K | undefined>();\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const reorderInstructionsId = 'reorderable_' + useId();\n  const { deviceType, platform } = getClientHints();\n  const keyPressed =\n    platform === 'windows' ? translations.accControlKey() : translations.accCommandKey();\n  const reorderInstructions =\n    deviceType === 'phone' || deviceType === 'tablet'\n      ? ''\n      : translations.accReorderInstructions({\n          keyPressed: keyPressed\n        });\n  const [reorderStatus, setReorderStatus] = useState<string | undefined>('');\n\n  const onKeyDown = useCallback(\n    (e: KeyboardEvent) => {\n      const keyHandlers = ['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'];\n      if (\n        (e.metaKey || e.ctrlKey) &&\n        e.shiftKey &&\n        keyHandlers.includes(e.key) &&\n        onReorder &&\n        rootRef.current\n      ) {\n        if (e.metaKey) {\n          e.preventDefault();\n        }\n        const itemKeysArray = getItemKeysArray(rootRef.current, itemSelector);\n        const newArray = [...itemKeysArray];\n        const lastIndex = newArray.length - 1;\n        const currentItemIndex = newArray.indexOf(currentItemKey.current);\n        // get reference item index and reordered keys\n        const referenceItemIndex = getReferenceItemIndex(\n          e.key,\n          isRtl,\n          currentItemIndex,\n          lastIndex,\n          columns\n        );\n        if (referenceItemIndex !== undefined && currentItemIndex !== referenceItemIndex) {\n          const referenceKey = newArray[referenceItemIndex]?.toString();\n          newArray.splice(currentItemIndex, 1);\n          newArray.splice(referenceItemIndex as number, 0, currentItemKey.current);\n          onReorder?.({\n            reorderedKeys: newArray as K[],\n            itemKeys: [currentItemKey.current as K],\n            // If the dragged items were dropped at the very beginning, the referenceKey will be null.\n            referenceKey: referenceItemIndex === 0 ? null : (newArray[referenceItemIndex - 1] as K)\n          });\n          // set acc status\n          const isPrev = e.key === 'ArrowLeft' || e.key === 'ArrowUp' ? true : false;\n          const position = isPrev\n            ? translations.accPositionBefore()\n            : translations.accPositionAfter();\n          const itemKeyString = currentItemKey?.current?.toString();\n          if (referenceKey && position && itemKeyString) {\n            setReorderStatus(\n              translations.accAnnounceMovedKey({\n                itemKey: itemKeyString,\n                position: position,\n                referenceKey: referenceKey\n              })\n            );\n          }\n        }\n      }\n    },\n    [currentItemKey, onReorder, columns, isRtl, itemSelector, rootRef, translations]\n  );\n\n  const eventProps = isDisabled ? {} : { onKeyDown };\n\n  return {\n    reorderProps: eventProps,\n    reorderContext: {\n      currentItemKey\n    },\n    reorderInstructionsId,\n    reorderInstructions,\n    reorderStatus\n  } as const;\n}\n\n/**\n * A helper function to get referenceItemIndex during keyboard reordering\n *\n * @param eventKey the arrow event keys\n * @param isRtl whether RTL is enabled\n * @param currentItemIndex the index of current item\n * @param lastIndex the last index\n * @param columns optional param to specify the number of columns, for keyboard reordering by arrow up/down keys.\n */\nconst getReferenceItemIndex = (\n  eventKey: string,\n  isRtl: boolean,\n  currentItemIndex: number,\n  lastIndex: number,\n  columns?: number\n) => {\n  const leftDropIndex = currentItemIndex > 0 ? currentItemIndex - 1 : 0;\n  const rightDropIndex = currentItemIndex < lastIndex ? currentItemIndex + 1 : lastIndex;\n  switch (eventKey) {\n    case 'ArrowLeft':\n      return isRtl ? rightDropIndex : leftDropIndex;\n    case 'ArrowRight':\n      return isRtl ? leftDropIndex : rightDropIndex;\n    case 'ArrowUp':\n      if (columns) {\n        // if the current item is at the top row, arrow up should not move anywhere\n        return currentItemIndex < columns ? currentItemIndex : currentItemIndex - columns;\n      }\n    case 'ArrowDown':\n      if (columns) {\n        // if the current item is at the bottom row, arrow down should not move anywhere\n        return currentItemIndex > lastIndex - columns\n          ? currentItemIndex\n          : currentItemIndex + columns;\n      }\n    default:\n      return undefined;\n  }\n};\n","import type { RefObject } from 'preact';\nimport { useState, useRef, useCallback } from 'preact/hooks';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { createDragImage } from '#utils/PRIVATE_dndUtils';\nimport { getKey, getItemKeysArray } from '#utils/PRIVATE_collectionUtils';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { ReorderableItemProps } from '#UNSAFE_Collection/Reorderable.types';\nimport { styles } from './themes/ReorderableItemStyles.css';\nimport { isKeyDefined } from '#utils/UNSAFE_keys';\n\nexport type useReorderableOptions<K extends string | number> = Omit<\n  ReorderableItemProps<K>,\n  'children'\n> & {\n  isDisabled: boolean;\n  ref: RefObject<HTMLDivElement>;\n  getItem: () => Element | null | undefined; // a function to get the reorderable item\n  setTransferData: (event: DragEvent) => void; // a function to set the transfer data and type\n  itemStyles: {\n    // component specific style for two overlay divs, e.g. component has different gap sizes\n    itemOverlayFront: string;\n    itemOverlayRear: string;\n    itemDragger?: string; // component specific style for drag image\n  };\n  itemSelector: string;\n  isVertical?: boolean; // used when the component is vertical and has one column, e.g. ListView\n};\n\n/**\n * Implements mouse reorder behavior for list-like components, e.g. TabBar, ListView, CardView\n */\nexport function useReorderableItem<K extends string | number>(options: useReorderableOptions<K>) {\n  const {\n    isDisabled,\n    dragKey,\n    setDragKey,\n    onReorder,\n    ref,\n    rootRef,\n    itemStyles,\n    getItem,\n    setTransferData,\n    itemSelector,\n    isVertical\n  } = options;\n\n  const item = getItem();\n  const itemKey = item != null ? (getKey(item as HTMLElement) as K) : undefined;\n\n  const [position, setPosition] = useState<'before' | 'after' | undefined>();\n  const pendingPositionRef = useRef<typeof position>();\n  const dragImgRef = useRef<HTMLElement | undefined>(undefined);\n\n  const itemDraggerClasses = classNames([styles.itemDragger, itemStyles.itemDragger]);\n\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const handleDragStart = useCallback(\n    (e: DragEvent) => {\n      const item = getItem();\n      const currentDragKey = item != null ? (getKey(item as HTMLElement) as K) : undefined;\n      //create drag image clone of the item and show it\n      if (ref?.current && setDragKey) {\n        dragImgRef.current = createDragImage(ref.current, itemDraggerClasses);\n        //if there is drag icon, set the drag image at the drag icon position\n        const dragIcon = ref.current.querySelector('[draggable=true]') as HTMLElement;\n        if (dragIcon != null) {\n          e?.dataTransfer?.setDragImage(\n            dragImgRef.current,\n            dragIcon.offsetLeft + dragIcon.offsetWidth / 2,\n            dragIcon.offsetTop + dragIcon.offsetHeight / 2\n          );\n        } else {\n          e?.dataTransfer?.setDragImage(dragImgRef.current, 0, 0);\n        }\n        setTransferData(e);\n        setDragKey(currentDragKey as K);\n      }\n    },\n    [getItem, setTransferData, itemDraggerClasses, ref, setDragKey]\n  );\n\n  const handleDragOver = useCallback(\n    (e: DragEvent) => {\n      if (isKeyDefined(dragKey)) {\n        e.preventDefault();\n      }\n    },\n    [dragKey]\n  );\n\n  //Once drag is over, reset styling of dragged item to it's original styling\n  const handleDragEnd = useCallback(() => {\n    setDragKey?.(undefined);\n    document.body.removeChild(dragImgRef.current as HTMLElement);\n  }, [setDragKey]);\n\n  // detect drop target position on the overlay divs and render drop target\n  const handleDragEnterBeforeZone = () => {\n    setPosition('before');\n    pendingPositionRef.current = 'before';\n  };\n\n  const handleDragLeaveBeforeZone = () => {\n    if (pendingPositionRef.current === 'before') {\n      setPosition(undefined);\n    }\n  };\n\n  const handleDragEnterAfterZone = () => {\n    setPosition('after');\n    pendingPositionRef.current = 'after';\n  };\n\n  const handleDragLeaveAfterZone = () => {\n    if (pendingPositionRef.current === 'after') {\n      setPosition(undefined);\n    }\n  };\n\n  const handleDrop = useCallback(() => {\n    if (rootRef?.current) {\n      const item = getItem();\n      const currentDropKey = item != null ? (getKey(item as HTMLElement) as K) : undefined;\n      const reference = currentDropKey;\n      const itemKeys = getItemKeysArray(rootRef.current, itemSelector);\n      let insertPos;\n      const newArray = [...itemKeys];\n      const dragIndex = newArray.indexOf(dragKey);\n      if (reference != null) {\n        const dropIndex = newArray.indexOf(reference);\n        if (dragIndex != null && dropIndex != null && dragIndex != dropIndex) {\n          if (!isRtl) {\n            if (dragIndex < dropIndex) {\n              insertPos = position === 'before' ? dropIndex - 1 : dropIndex;\n            } else {\n              insertPos = position === 'before' ? dropIndex : dropIndex + 1;\n            }\n          } else {\n            if (dragIndex < dropIndex) {\n              insertPos = position === 'before' ? dropIndex : dropIndex - 1;\n            } else {\n              insertPos = position === 'before' ? dropIndex + 1 : dropIndex;\n            }\n          }\n        }\n      }\n      if (insertPos !== undefined && dragIndex !== insertPos) {\n        const sourceData = itemKeys[dragIndex];\n        newArray.splice(dragIndex, 1);\n        newArray.splice(insertPos as number, 0, sourceData);\n        onReorder?.({\n          reorderedKeys: newArray as K[],\n          itemKeys: [dragKey as K],\n          // If the dragged items were dropped at the very beginning, the referenceKey will be null.\n          referenceKey: insertPos === 0 ? null : (newArray[insertPos - 1] as K)\n        });\n        setPosition(undefined);\n        setDragKey(undefined);\n      }\n    }\n  }, [dragKey, position, getItem, isRtl, itemSelector, onReorder, rootRef, setDragKey]);\n\n  if (isDisabled) {\n    return {};\n  }\n\n  //change dragged item visual to appear disable\n  const isDragged = itemKey != null && itemKey === dragKey;\n\n  const dndItemClasses = classNames([styles.itemDnd, isDragged && styles.itemDragged]);\n\n  const itemOverlayClassesBefore = classNames([\n    itemStyles.itemOverlayFront,\n    isVertical ? styles.itemOverlayVertical : styles.itemOverlay,\n    position === 'before' && styles.itemOverlayBefore,\n    position === 'before' && isRtl && styles.itemOverlayBeforeRtl\n  ]);\n  const itemOverlayClassesAfter = classNames([\n    itemStyles.itemOverlayFront,\n    itemStyles.itemOverlayRear,\n    isVertical ? styles.itemOverlayVertical : styles.itemOverlay,\n    position === 'after' && styles.itemOverlayAfter,\n    position === 'after' && isRtl && styles.itemOverlayAfterRtl\n  ]);\n\n  return {\n    rootProps: mergeProps({\n      ref: ref,\n      onDragStart: handleDragStart,\n      onDragEnd: handleDragEnd,\n      onDragOver: handleDragOver,\n      onDrop: handleDrop,\n      isDisabled: isDisabled,\n      class: dndItemClasses\n    }),\n    isDragged: isDragged,\n    overlayZoneBeforeProps: mergeProps({\n      onDragEnter: handleDragEnterBeforeZone,\n      onDragLeave: handleDragLeaveBeforeZone,\n      class: itemOverlayClassesBefore\n    }),\n    overlayZoneAfterProps: mergeProps({\n      onDragEnter: handleDragEnterAfterZone,\n      onDragLeave: handleDragLeaveAfterZone,\n      class: itemOverlayClassesAfter\n    })\n  } as const;\n}\n"],"names":["getReferenceItemIndex","eventKey","isRtl","currentItemIndex","lastIndex","columns","leftDropIndex","rightDropIndex","options","onReorder","rootRef","itemSelector","isDisabled","currentItemKey","useRef","direction","useUser","translations","useTranslationBundle","reorderInstructionsId","useId","deviceType","platform","getClientHints","keyPressed","accControlKey","accCommandKey","reorderInstructions","accReorderInstructions","reorderStatus","setReorderStatus","useState","onKeyDown","useCallback","e","metaKey","ctrlKey","shiftKey","includes","key","current","preventDefault","newArray","getItemKeysArray","length","indexOf","referenceItemIndex","undefined","referenceKey","toString","splice","reorderedKeys","itemKeys","position","accPositionBefore","accPositionAfter","itemKeyString","accAnnounceMovedKey","itemKey","reorderProps","reorderContext","dragKey","setDragKey","ref","itemStyles","getItem","setTransferData","isVertical","item","getKey","setPosition","pendingPositionRef","dragImgRef","itemDraggerClasses","classNames","styles","itemDragger","handleDragStart","currentDragKey","createDragImage","dragIcon","querySelector","dataTransfer","setDragImage","offsetLeft","offsetWidth","offsetTop","offsetHeight","handleDragOver","isKeyDefined","handleDragEnd","document","body","removeChild","handleDrop","reference","insertPos","dragIndex","dropIndex","sourceData","isDragged","dndItemClasses","itemDnd","itemDragged","itemOverlayClassesBefore","itemOverlayFront","itemOverlayVertical","itemOverlay","itemOverlayBefore","itemOverlayBeforeRtl","itemOverlayClassesAfter","itemOverlayRear","itemOverlayAfter","itemOverlayAfterRtl","rootProps","mergeProps","onDragStart","onDragEnd","onDragOver","onDrop","class","overlayZoneBeforeProps","onDragEnter","onDragLeave","overlayZoneAfterProps"],"mappings":"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"}