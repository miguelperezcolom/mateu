{"version":3,"file":"DrawerPopup-8d62ed90.js","sources":["../../src/UNSAFE_DrawerPopup/DrawerPopup.tsx"],"sourcesContent":["import { JSX, RefObject } from 'preact';\nimport { useState, useRef, useEffect, useCallback, useMemo } from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { Layer } from '../UNSAFE_Layer';\nimport { Modal } from '../UNSAFE_Modal';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport {\n  getAutofocusFocusables,\n  focusOn,\n  focusWithin,\n  getActiveElement,\n  focusOnElementOrNearestAncestor\n} from '../utils/PRIVATE_tabbableUtils';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { RtlSide } from '../UNSAFE_Floating';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\n\n// Hooks\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\nimport { useAnimation } from '../hooks/UNSAFE_useAnimation';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useTestId, TestIdProps } from '../hooks/UNSAFE_useTestId';\nimport { useSwipe } from '../hooks/UNSAFE_useSwipe';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { DrawerPopupVariantOptions } from './themes/DrawerPopupStyles.css';\nimport { colorInterpolations, ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { DrawerPopupRedwoodTheme } from './themes/redwood/DrawerPopupTheme';\n\n// Types\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\ntype Placement = 'start' | 'end' | 'bottom';\ntype NormalizedPlacement = 'left' | 'right' | 'bottom';\ntype Status = 'unmounted' | 'initial' | 'opening' | 'closing';\ntype VisibilityStatus = 'hidden' | 'visible';\ntype DisplayModeHorizontal = 'overlay' | 'fullOverlay';\ntype OnCloseDetail = {\n  reason: 'outsideClick' | 'escapeKey' | 'swipe';\n};\n\ntype Props = IntrinsicProps &\n  Pick<ColorProps, 'backgroundColor'> & {\n    /**\n     * Specifies whether the Drawer is open.\n     */\n    isOpen: boolean;\n    /**\n     * Specifies at what edge the Drawer opens.\n     * Supported values are:\n     * <p><code>start</code>, <code>end</code>, <code>bottom</code></p>\n     * Default is <code>start</code>.\n     */\n    placement?: Placement;\n    /**\n     * Specifies modality of the Darwer.\n     * Supported values are:\n     * <p><code>modal</code>, <code>modeless</code></p>\n     * Default is <code>modal</code>.\n     */\n    modality?: 'modal' | 'modeless';\n    /**\n     * Specifies callback triggered when a user tries to close a Drawer through UI interaction.\n     * The parent should listen to this event and close the Drawer. If the parent fails to remove\n     * the Popup, then no change will be done in the UI by the component.\n     * Supported detail values are:\n     * <p><code>outsideClick</code>, <code>escapeKey</code></p>, <code>swipe</code>\n     */\n    onClose?: (detail: OnCloseDetail) => void;\n    /**\n     * Specifies callback triggered after the animation ends.\n     */\n    onTransitionEnd?: (value: boolean) => void;\n    /**\n     * Optional ref for an element to focus on when component mounts.\n     */\n    autoFocusRef?: RefObject<{ focus: () => void }>;\n    /**\n     * Specifies guidance for screen readers.\n     */\n    'aria-label'?: string;\n    /**\n     * Specifies ID of an element used for guidance for screen readers.\n     */\n    'aria-labelledby'?: string;\n    /**\n     * Specifies ID of an element (or space separated IDs of multiple elements) that\n     * describes the Drawer.\n     */\n    'aria-describedby'?: string;\n  } & TestIdProps;\n\n// Constants\nconst displayModefullWidthThreshold = 600;\nconst zero = '0px';\nconst duration = 250;\n\nconst getElementHeight = (element: HTMLDivElement): number => {\n  return Math.round(element.offsetHeight);\n};\n\nconst getElementWidth = (element: HTMLDivElement): number => {\n  return Math.round(element.getBoundingClientRect().width);\n};\n\n/**\n * A drawer popup adds a single slide-in side content alongside some primary content to an application window.\n *\n * This drawer always overlays the page and can be placed at the 'start', 'end' or 'bottom' edge.\n */\nexport const DrawerPopup = forwardRef(\n  (\n    {\n      children,\n      isOpen = false,\n      autoFocusRef,\n      placement = 'start',\n      modality = 'modal',\n      onClose,\n      onTransitionEnd,\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      testId,\n      ...props\n    }: Props,\n    ref: ForwardedRef<HTMLElement | null>\n  ) => {\n    // Initialize states\n    const [status, _setStatus] = useState<Status>(isOpen ? 'initial' : 'unmounted');\n    const _status = useRef<Status>(isOpen ? 'initial' : 'unmounted');\n    const setStatus = (s: Status) => {\n      _status.current = s;\n      _setStatus(s);\n    };\n    const [visibility, setVisibility] = useState<VisibilityStatus>('hidden');\n    const [isOutsideClickDisabled, setIsOutsideClickDisabled] = useState<boolean>(!isOpen);\n    const [displayModeHorizontal, setDisplayModeHorizontal] =\n      useState<DisplayModeHorizontal>('overlay');\n\n    const prevStatusRef = useRef<Status>('unmounted');\n\n    const rootRef = useRef<HTMLDivElement>(null);\n    const launcherRef = useRef<HTMLElement | null>(null);\n\n    const mergedRef = useMemo(() => mergeRefs(rootRef, ref), [rootRef, ref]);\n\n    const isBottomPlacement = placement === 'bottom';\n    const shouldReturnFocus = useRef<boolean>(false);\n\n    // Animation config\n    const animationStates = {\n      opening: () => {\n        if (isBottomPlacement) {\n          return {\n            from: {\n              translateY: getTranslateY()\n            },\n            to: {\n              translateY: zero\n            },\n            options: {\n              duration: duration\n            }\n          };\n        } else {\n          return {\n            from: {\n              translateX: getTranslateX()\n            },\n            to: {\n              translateX: zero\n            },\n            options: {\n              duration: duration\n            }\n          };\n        }\n      },\n      closing: () => {\n        if (isBottomPlacement) {\n          return {\n            from: {\n              translateY: zero\n            },\n            to: {\n              translateY: getTranslateY()\n            },\n            options: {\n              duration: duration\n            }\n          };\n        } else {\n          return {\n            from: {\n              translateX: zero\n            },\n            to: {\n              translateX: getTranslateX()\n            },\n            options: {\n              duration: duration\n            }\n          };\n        }\n      }\n    };\n\n    // testId support\n    const testIdProps = useTestId(testId);\n\n    // Normalizing position\n    const { direction } = useUser();\n    const getNormalizedPlacement = (): RtlSide => {\n      return normalizePosition(placement, direction);\n    };\n\n    const getTranslateX = (): string => {\n      return `${getNormalizedPlacement() === 'right' ? '' : '-'}${getElementWidth(\n        rootRef.current as HTMLDivElement\n      )}px`;\n    };\n\n    const getTranslateY = (): string => {\n      return `${getElementHeight(rootRef.current as HTMLDivElement)}px`;\n    };\n\n    const setInitialFocus = () => {\n      if (rootRef.current) {\n        // Set focus to the first match:\n        // 1. First element inside the drawer matching [autofocus]\n        const autofocusItems: HTMLElement[] = getAutofocusFocusables(\n          rootRef.current as HTMLElement\n        );\n        if (autofocusItems.length > 0) {\n          focusOn(autofocusItems[0]);\n          return;\n        }\n        // 2. Tabbable element inside the content element\n        // 3. The drawer itself\n        focusWithin(rootRef.current as HTMLElement);\n      }\n    };\n\n    const returnFocusToLauncher = (): void => {\n      if (shouldReturnFocus.current) {\n        focusOnElementOrNearestAncestor(launcherRef.current as HTMLElement);\n        shouldReturnFocus.current = false;\n      }\n    };\n\n    // Remove style attribute left on the element by the Animation util\n    const removeAnimationInlineStyles = useCallback(() => {\n      rootRef.current?.style?.removeProperty('transform');\n    }, []);\n\n    // Animation\n    const { nodeRef } = useAnimation<Status, HTMLDivElement>(status, {\n      animationStates,\n      isAnimatedOnMount: true,\n      onAnimationEnd: () => {\n        if (status === 'opening') {\n          removeAnimationInlineStyles();\n          setInitialFocus();\n          onTransitionEnd?.(true);\n        } else if (!isOpen) {\n          const activeElement = getActiveElement() as HTMLElement;\n\n          // We return focus to the launcher only if it is contained in drawer\n          // Historically we were able to return focus to launcher also in 'content destroy cases'.\n          // Case: if document.activeElement is removed from the DOM, browser moves focus to doucment body\n          // That's why we are checking body in the condition below\n          shouldReturnFocus.current =\n            rootRef.current?.contains(activeElement) || activeElement === document.body || false;\n          nodeRef(null);\n          setVisibility('hidden');\n          setStatus('unmounted');\n          onTransitionEnd?.(false);\n        }\n      }\n    });\n\n    useEffect(() => {\n      // 1. Ignore status update on initial render\n      if (status === 'unmounted' && !isOpen && status !== prevStatusRef.current) {\n        returnFocusToLauncher();\n      }\n\n      // 2. Mount visually hidden component\n      // Component gets mounted, but will be visually hidden to avoid flickering\n      // Flickering happens because it gets rendered before animation hook repositions\n      // it in next render cycle\n      else if (status === 'unmounted' && isOpen) {\n        setStatus('initial');\n      }\n\n      // 3. Setup animation\n      // Component has been mounted.\n      // We will kick out animation as node is already present in DOM.\n      // To avoid flickering, we still keep it visually hidden until the next render cycle.\n      else if (status === 'initial' && isOpen) {\n        nodeRef(rootRef.current);\n        setIsOutsideClickDisabled(false);\n        setStatus('opening');\n      }\n\n      // 3. Unhide component. It becomes visible.\n      else if (status === 'opening' && isOpen) {\n        setVisibility('visible');\n      }\n\n      // 4. Closing\n      else if (!isOpen && status !== 'unmounted') {\n        setIsOutsideClickDisabled(true);\n        if (_status.current !== 'unmounted') {\n          setStatus('closing');\n        }\n      }\n\n      return () => {\n        // remember the previous status\n        prevStatusRef.current = status;\n      };\n    }, [isOpen, status, nodeRef]);\n\n    // Destroy case handler\n    useEffect(() => {\n      return () => {\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        if (rootRef.current?.contains(getActiveElement() as HTMLElement) || false) {\n          // In destroy case ModalManager is blocking returning of the focus.\n          // We need to reschedule it to workaround that\n          setTimeout(() => {\n            focusOnElementOrNearestAncestor(launcherRef.current as HTMLElement);\n          }, 0);\n        }\n      };\n    }, []);\n\n    // Launcher handler\n    useEffect(() => {\n      if (status === 'opening') {\n        // Remember launcher\n        launcherRef.current = getActiveElement() as HTMLElement;\n\n        // Register F6 key handler. It is modeless only feature.\n        if (modality === 'modeless') {\n          launcherRef.current?.addEventListener('keydown', launcherKeyDownCallback);\n        }\n      }\n      if (status === 'closing' && modality === 'modeless') {\n        return () => {\n          // Deregister F6 key handler\n          launcherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);\n        };\n      }\n      return;\n    }, [modality, status]);\n\n    const launcherKeyDownCallback = (event: KeyboardEvent): void => {\n      // Moves focus from launcher (must have focus) back to the Drawer\n      if (launcherRef.current === getActiveElement() && event.code === 'F6') {\n        // Prevent default F6 handlers.\n        // F6 is a standard Chrome address bar shortcut on Windows.\n        event.preventDefault();\n        event.stopPropagation();\n\n        // Focus on first tabbable in a container or container itself if there is none\n        focusWithin(rootRef.current as HTMLElement);\n      }\n    };\n\n    const handleKeyDown = useCallback(\n      (event: KeyboardEvent) => {\n        const launcherEl = launcherRef.current;\n        switch (event.code) {\n          case 'Escape': {\n            onClose?.({ reason: 'escapeKey' });\n            break;\n          }\n          case 'F6':\n            if (modality === 'modeless') {\n              // Prevent default F6 handlers.\n              // F6 is a standard Chrome address bar shortcut on Windows.\n              event.preventDefault();\n              event.stopPropagation();\n              // Focus launcher\n              if (launcherEl) {\n                focusOn(launcherEl);\n              }\n              break;\n            }\n        }\n      },\n      [onClose, modality]\n    );\n\n    // OutsideClick handler\n    const handleOutsideClick = useCallback(() => {\n      // Trigger onClose event with outside click detail\n      onClose?.({ reason: 'outsideClick' });\n    }, [onClose]);\n\n    const insideRefs: RefObject<HTMLElement>[] = [rootRef];\n    // launcher should be considered an \"inside\" element\n    if (launcherRef.current && launcherRef.current !== document.body) {\n      insideRefs.push(launcherRef);\n    }\n\n    useOutsideClick({\n      isDisabled: isOutsideClickDisabled,\n      ref: insideRefs,\n      handler: handleOutsideClick\n    });\n\n    // Drawer placement\n    const getDrawerPlacement = (): NormalizedPlacement => {\n      if (isBottomPlacement) {\n        return placement;\n      } else {\n        if (direction === 'rtl') {\n          return placement === 'start' ? 'right' : 'left';\n        } else {\n          return placement === 'start' ? 'left' : 'right';\n        }\n      }\n    };\n\n    const clientHints = getClientHints();\n\n    const getViewportWidth = useCallback((): number => {\n      if (clientHints.platform === 'ios') {\n        // On ios window.innerWidth is not recommended way of measuring the viewport\n        return document.documentElement.clientWidth;\n      }\n      return window.innerWidth;\n    }, [clientHints.platform]);\n\n    // Window resize handler\n    // Handles display mode: Overlay <> Full overlay (full width side drawers)\n    const handleResize = useCallback(() => {\n      const viewportWidth = getViewportWidth();\n      if (displayModeHorizontal === 'overlay' && viewportWidth < displayModefullWidthThreshold) {\n        setDisplayModeHorizontal('fullOverlay');\n      }\n      if (\n        displayModeHorizontal === 'fullOverlay' &&\n        viewportWidth > displayModefullWidthThreshold\n      ) {\n        setDisplayModeHorizontal('overlay');\n      }\n    }, [getViewportWidth, displayModeHorizontal]);\n\n    useEffect(() => {\n      const root = rootRef.current;\n      if (root && status === 'opening') {\n        const resizeObserver = new ResizeObserver(() => {\n          handleResize();\n        });\n        resizeObserver.observe(document.body);\n        return () => {\n          resizeObserver.unobserve(document.body);\n        };\n      }\n      return undefined;\n    }, [status, handleResize]);\n\n    const dispatchSwipeOnClose = useCallback(() => {\n      onClose?.({ reason: 'swipe' });\n    }, [onClose]);\n\n    // OutsideClick handler\n    const swipeHandler = useCallback(\n      (event: any): void => {\n        const swipeDir = event.direction;\n        // LTR\n        if (direction === 'ltr') {\n          if (\n            (placement === 'start' && swipeDir === 'left') ||\n            (placement === 'end' && swipeDir === 'right')\n          ) {\n            dispatchSwipeOnClose();\n          }\n        }\n        // RTL\n        if (direction === 'rtl') {\n          if (\n            (placement === 'start' && swipeDir === 'right') ||\n            (placement === 'end' && swipeDir === 'left')\n          ) {\n            dispatchSwipeOnClose();\n          }\n        }\n        // Bottom\n        if (placement === 'bottom' && swipeDir === 'down') {\n          dispatchSwipeOnClose();\n        }\n      },\n      [direction, placement, dispatchSwipeOnClose]\n    );\n\n    const swipeOptions = {\n      threshold: 50,\n      maximumTime: 750,\n      tolerance: 40\n    };\n    const { swipeProps } = useSwipe(swipeHandler, swipeOptions);\n\n    // Styles\n    const { classes } = useComponentTheme<DrawerPopupVariantOptions>(DrawerPopupRedwoodTheme, {\n      placement: getDrawerPlacement(),\n      visibility,\n      displayModeHorizontal:\n        ['start', 'end'].indexOf(placement) > -1 ? displayModeHorizontal : undefined\n    });\n\n    const interpolations = [...Object.values(colorInterpolations)];\n    const styleInterpolations = mergeInterpolations<ColorProps>(interpolations);\n    const { ...styles } = styleInterpolations(props);\n\n    const renderDrawer = () => {\n      return (\n        <FocusTrap autoFocusRef={autoFocusRef} restoreFocusRef={false}>\n          <div\n            ref={mergedRef}\n            className={classes}\n            style={styles}\n            tabIndex={-1}\n            role=\"dialog\"\n            onKeyDown={handleKeyDown}\n            aria-label={ariaLabel}\n            aria-labelledby={ariaLabelledBy}\n            aria-describedby={ariaDescribedBy}\n            {...swipeProps}\n            {...testIdProps}>\n            {children}\n          </div>\n        </FocusTrap>\n      );\n    };\n\n    const isMounted = status !== 'unmounted';\n    if (isMounted) {\n      // Modal vs. modelss upper wrapper\n      if (modality === 'modal') {\n        return <Modal isOpen={isMounted}>{renderDrawer()}</Modal>;\n      } else {\n        return <Layer>{renderDrawer()}</Layer>;\n      }\n    }\n\n    return null;\n  }\n);\n"],"names":["zero","duration","DrawerPopup","forwardRef","children","isOpen","autoFocusRef","placement","modality","onClose","onTransitionEnd","ariaLabel","ariaLabelledBy","ariaDescribedBy","testId","props","ref","status","_setStatus","useState","_status","useRef","setStatus","s","current","visibility","setVisibility","isOutsideClickDisabled","setIsOutsideClickDisabled","displayModeHorizontal","setDisplayModeHorizontal","prevStatusRef","rootRef","launcherRef","mergedRef","useMemo","mergeRefs","isBottomPlacement","shouldReturnFocus","animationStates","opening","from","translateY","getTranslateY","to","options","translateX","getTranslateX","closing","testIdProps","useTestId","direction","useUser","normalizePosition","element","Math","round","getBoundingClientRect","width","offsetHeight","removeAnimationInlineStyles","useCallback","style","removeProperty","nodeRef","useAnimation","isAnimatedOnMount","onAnimationEnd","autofocusItems","getAutofocusFocusables","length","focusOn","focusWithin","setInitialFocus","activeElement","getActiveElement","contains","document","body","useEffect","focusOnElementOrNearestAncestor","setTimeout","addEventListener","launcherKeyDownCallback","removeEventListener","event","code","preventDefault","stopPropagation","handleKeyDown","launcherEl","reason","handleOutsideClick","insideRefs","push","useOutsideClick","isDisabled","handler","clientHints","getClientHints","getViewportWidth","platform","documentElement","clientWidth","window","innerWidth","handleResize","viewportWidth","resizeObserver","ResizeObserver","observe","unobserve","dispatchSwipeOnClose","swipeHandler","swipeDir","swipeProps","useSwipe","threshold","maximumTime","tolerance","classes","useComponentTheme","DrawerPopupRedwoodTheme","indexOf","undefined","interpolations","Object","values","colorInterpolations","styleInterpolations","mergeInterpolations","styles","renderDrawer","_jsx","FocusTrap","restoreFocusRef","className","tabIndex","role","onKeyDown","isMounted","jsx","Modal","Layer"],"mappings":"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"}