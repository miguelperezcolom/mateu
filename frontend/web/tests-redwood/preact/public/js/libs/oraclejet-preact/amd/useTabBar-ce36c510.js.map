{"version":3,"file":"useTabBar-ce36c510.js","sources":["../../src/hooks/PRIVATE_useTabBar/useTabBar.ts"],"sourcesContent":["import { useState, useRef, useEffect, useCallback } from 'preact/hooks';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport {\n  getPrevNextKeyUsingRef,\n  getFirstVisibleKey,\n  getKey,\n  keyExtractor,\n  findElementByKey\n} from '../../utils/PRIVATE_collectionUtils';\nimport { useCollectionFocusRing } from '../PRIVATE_useCollectionFocusRing';\nimport { useCurrentKey } from '../PRIVATE_useCurrentKey';\nimport { useId } from '../UNSAFE_useId';\nimport type { ComponentProps, ContextType, RefObject } from 'preact';\nimport type { TabBarContext, TabBarLayout } from '../../UNSAFE_TabBarCommon';\nimport { useReorderableContext } from '../../hooks/PRIVATE_useReorderable/useReorderableContext';\nimport { Menu } from '../../UNSAFE_Menu';\nimport { TabBarContextMenuConfig } from '../../UNSAFE_TabBarCommon';\nimport { useContextMenuGesture } from '../../hooks/UNSAFE_useContextMenuGesture';\nimport { getDefaultContextMenu } from '../../UNSAFE_TabBar/TabBarContextMenu';\nimport { TabBarItemContextMenuContext } from '../../UNSAFE_TabBarCommon/TabBar.types';\nimport { useUser } from '../../hooks/UNSAFE_useUser';\nimport { useTranslationBundle } from '../../hooks/UNSAFE_useTranslationBundle';\nimport { BundleType } from '../../resources/nls/bundle';\n\ntype TabBarContextValue = ContextType<typeof TabBarContext>;\n\nexport type useTabBarOptions<K extends string | number> = {\n  class?: string;\n  display?: TabBarContextValue['display'];\n  edge?: 'bottom' | 'top';\n  onRemove?: TabBarContextValue['onRemove'];\n  onSelect?: TabBarContextValue['onSelect'];\n  ref?: RefObject<HTMLDivElement>;\n  selection?: TabBarContextValue['selection'];\n  size?: TabBarContextValue['size'];\n  children?: ComponentProps<typeof TabBarLayout>['children'];\n  contextMenuConfig?: TabBarContextMenuConfig<K>;\n};\n\nconst ITEM_SELECTOR = '[role=\"tab\"]';\nconst REMOVABLE_ICON_SELECTOR = '[data-oj-tabbar-item-remove-icon=\"true\"]';\nexport const REMOVABLE_ITEM_ATTRIBUTE = 'data-oj-removable';\n\ntype MenuProps = Pick<\n  ComponentProps<typeof Menu>,\n  'anchorRef' | 'initialFocus' | 'placement' | 'offsetValue' | 'isOpen'\n>;\n\nconst TOUCH_OFFSET_VALUE = 40;\n\nconst menuPropGestureStates: Record<\n  'mouse' | 'keyboard' | 'touch',\n  Omit<Required<MenuProps>, 'anchorRef' | 'isOpen'>\n> = {\n  mouse: {\n    initialFocus: 'menu',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  keyboard: {\n    initialFocus: 'firstItem',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  touch: {\n    initialFocus: 'menu',\n    placement: 'end',\n    offsetValue: TOUCH_OFFSET_VALUE\n  }\n};\n\nconst initialMenuProps: MenuProps = {\n  isOpen: false,\n  initialFocus: 'menu',\n  placement: 'bottom-start',\n  offsetValue: 0,\n  anchorRef: { current: null }\n};\n\n/**\n * Implements TabBar behavior for focus and keyboad handling\n */\nexport function useTabBar<K extends string | number>(options: useTabBarOptions<K>) {\n  const {\n    children,\n    class: className,\n    display,\n    edge = 'top',\n    selection,\n    onSelect,\n    onRemove,\n    ref: userRef,\n    size,\n    contextMenuConfig\n  } = options;\n\n  const { direction } = useUser();\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const internalRef = useRef<HTMLDivElement>(null);\n  const rootRef = userRef || internalRef;\n\n  const tabId = useId();\n  const [currentKey, setCurrentKey] = useState<K | undefined>(selection as K);\n  const [hideTooltip, setHideTooltip] = useState(false);\n\n  const tabItemPrefix = tabId + '_';\n\n  const contextMenuDescriptionId = 'contextMenu_' + useId();\n  const contextMenuDescription = translations.tabbar_labelContextMenu();\n\n  /**\n   * A reference to the previous set of tab keys that this TabBar\n   * contains before children were re-rendered. In the event the \"current\" tab\n   * is removed and the \"currentKey\" reference is broken, we can redirect\n   * the \"currentKey\" to another tab based on the index of the removed tab.\n   */\n  const prevTabKeys = useRef<(string | number | undefined)[]>();\n\n  useEffect(() => {\n    if (rootRef.current) {\n      const tabKeys = Array.from(rootRef.current.querySelectorAll(ITEM_SELECTOR)).map((elem) =>\n        getKey(elem as HTMLElement)\n      );\n      if (currentKey == null) {\n        if (selection != null && tabKeys.includes(selection as K)) {\n          setCurrentKey(selection as K);\n        } else if (tabKeys.length > 0) {\n          setCurrentKey(tabKeys[0] as K);\n        }\n      }\n      if (currentKey && !tabKeys.includes(currentKey as K)) {\n        //If prevTabs does not exist set the first visible key as currentKey\n        prevTabKeys.current\n          ? setCurrentKey(findNextValidKey(currentKey, tabKeys, prevTabKeys.current) as K)\n          : setCurrentKey(tabKeys[0] as K);\n      }\n      prevTabKeys.current = tabKeys;\n    }\n  }, [children, currentKey, rootRef, selection]);\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(rootRef, [\n    'ArrowRight',\n    'ArrowLeft',\n    'Home',\n    'End'\n  ]);\n\n  const reorderableContext = useReorderableContext();\n  const { currentKeyProps } = useCurrentKey(\n    (element) =>\n      onRemove\n        ? extractOnlyItemKey(element, ITEM_SELECTOR, REMOVABLE_ICON_SELECTOR)\n        : keyExtractor(element, ITEM_SELECTOR),\n    false,\n    undefined,\n    undefined,\n    getPrevNextKeyUsingRef(rootRef, currentKey, true, ITEM_SELECTOR),\n    getPrevNextKeyUsingRef(rootRef, currentKey, false, ITEM_SELECTOR),\n    currentKey,\n    (detail) => {\n      const key = detail.value as K;\n      setCurrentKey(key);\n      setHideTooltip(false);\n    }\n  );\n\n  useEffect(() => {\n    if (reorderableContext) {\n      reorderableContext.currentItemKey.current = currentKey;\n    }\n  }, [currentKey, reorderableContext]);\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    if (rootRef.current && currentKey) {\n      if (event.key === 'Home' || event.key === 'End') {\n        const tabBarItemKey = Array.from(rootRef.current.querySelectorAll(ITEM_SELECTOR), (elem) =>\n          getKey(elem as HTMLElement)\n        );\n        event.preventDefault();\n        setCurrentKey?.(tabBarItemKey[event.key === 'Home' ? 0 : tabBarItemKey.length - 1] as K);\n      }\n      if (event.key === 'Enter' || event.key === ' ') {\n        event.preventDefault();\n        onSelect?.({ value: currentKey });\n      }\n      if (event.key === 'Delete') {\n        const tabBarItem = findElementByKey(\n          rootRef.current,\n          currentKey,\n          ITEM_SELECTOR\n        ) as HTMLElement;\n        if (tabBarItem.hasAttribute(REMOVABLE_ITEM_ATTRIBUTE)) {\n          onRemove?.({ value: currentKey });\n        }\n      }\n      if (event.key === 'Escape') {\n        setHideTooltip(true);\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (rootRef.current && currentKey === undefined) {\n      const key = getFirstVisibleKey(rootRef.current, ITEM_SELECTOR);\n      if (key) {\n        setCurrentKey(key as K);\n      }\n    }\n  };\n\n  const [contextMenuContext, setContextMenuContext] = useState<TabBarItemContextMenuContext<K>>();\n\n  const [menuProps, setMenuProps] = useState<MenuProps>(initialMenuProps);\n  const [accStatusInfo, setAccStatusInfo] = useState<string>();\n\n  const { triggerProps } = useContextMenuGesture(\n    ({ gesture, anchor, target }) => {\n      let anchorBasedOnGesture = anchor;\n      let itemKey = currentKey as K;\n      if (gesture === 'keyboard') {\n        //We find the element where the position of the menu is going to be based of\n        const elem = findElementByKey(\n          rootRef.current as HTMLElement,\n          currentKey as K,\n          ITEM_SELECTOR\n        );\n        //We set the correct anchor\n        anchorBasedOnGesture = elem ? elem : anchor;\n      } else {\n        //We search for the key using the target of the event\n        const key = keyExtractor(target as HTMLElement, ITEM_SELECTOR);\n\n        //On touch devices, the keyExtractor returns null because target of touch event is the entire tabbar. Hence we make use of currentkey since the context menu is always launched from selected item and its key is currentKey\n        itemKey = key != null ? (key as K) : (currentKey as K);\n      }\n      let tabKeysArray;\n      let isRemovableItem = false;\n      const isReorderable = reorderableContext?.onReorder != null;\n      if (rootRef.current) {\n        tabKeysArray = isReorderable\n          ? Array.from(rootRef.current.querySelectorAll(ITEM_SELECTOR)).map(\n              (elem) => getKey(elem as HTMLElement) as K\n            )\n          : undefined;\n        isRemovableItem =\n          getItemAttribute(itemKey, rootRef.current, REMOVABLE_ITEM_ATTRIBUTE) != null;\n      }\n      const isRemovable = onRemove != null && isRemovableItem;\n      const defaultContext = getDefaultContextMenu<K>({\n        // For default menu items the existence of REMOVABLE_ICON_SELECTOR is the indicator that it is removable because we render the default menu in touch devices not the application.\n        // Furthermore in corepack due to delegations onRemove is always defined as it is a even handler hence not a good check for isRemovable.\n        isRemovable: isRemovable,\n        handleRemove: onRemove,\n        handleReorder: isReorderable ? reorderableContext.onReorder : undefined,\n        itemKey: itemKey,\n        tabKeys: tabKeysArray,\n        direction: direction,\n        itemLabels: {\n          labelRemove: isRemovable ? translations.tabbar_labelRemove() : undefined,\n          labelMoveLeft: isReorderable ? translations.tabbar_labelMoveLeft() : undefined,\n          labelMoveRight: isReorderable ? translations.tabbar_labelMoveRight() : undefined\n        },\n        handleAccStatus: (detail) => {\n          const removeItemLabel = getItemLabel(detail.removedKey!, rootRef.current!) as string;\n          const removeStatus =\n            isRemovable && detail.removedKey\n              ? translations.tabbar_accAnnounceRemovedKey({ itemKey: removeItemLabel })\n              : '';\n          const destinationItemLabel = getItemLabel(\n            detail.destinationKey!,\n            rootRef.current!\n          ) as string;\n          const reorderStatus =\n            isReorderable && detail.destinationKey\n              ? translations.accAnnounceMovedKey({\n                  // This acc info is for reordering using context menu hence as per spec source item key is not required.\n                  itemKey: '',\n                  position: detail.position!,\n                  referenceKey: destinationItemLabel\n                })\n              : '';\n          setAccStatusInfo(removeStatus + reorderStatus);\n        }\n      });\n      setContextMenuContext(defaultContext);\n\n      setMenuProps({\n        ...menuPropGestureStates[gesture],\n        anchorRef: { current: anchorBasedOnGesture },\n        // This is set so that when no contextMenuConfig is available we need not open it. Example: Apps may choose to open only for removable items and return contextMenuConfig as undefined for non removable ones in such cases it will prevent it from opening.\n        isOpen: contextMenuConfig != null\n      });\n    },\n    {\n      isDisabled: !contextMenuConfig //If there is no a context menu renderer we disable the hook\n    }\n  );\n\n  const handleCloseContextMenu = useCallback<Required<ComponentProps<typeof Menu>>['onClose']>(\n    (detail) => {\n      //Focus has to be set on the current target that was obtained\n      //during context menu gesture when menu is dismissed or item is \"selected\"\n      if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {\n        setCurrentKey(contextMenuContext?.itemKey);\n        rootRef.current?.focus();\n      }\n      // We close the menu.The only prop that matters here is isOpen\n      setMenuProps({ ...initialMenuProps });\n    },\n    [rootRef, contextMenuContext?.itemKey]\n  );\n\n  const eventProps = mergeProps({ onKeyDown, onFocus }, triggerProps);\n\n  return {\n    rootProps: mergeProps(\n      {\n        'aria-activedescendant': currentKey ? tabItemPrefix + currentKey : '',\n        'aria-multiselectable': false,\n        class: className,\n        ref: rootRef,\n        role: 'tablist',\n        tabIndex: 0\n      },\n      currentKeyProps,\n      focusRingProps,\n      eventProps\n    ),\n    tabBarContext: {\n      currentKey,\n      display,\n      isEdgeBottom: edge === 'bottom',\n      layout: 'condense',\n      onRemove,\n      onSelect,\n      showFocusRing,\n      hideTooltip,\n      selection,\n      size,\n      tabItemPrefix\n    },\n    menuProps: { ...menuProps, onClose: handleCloseContextMenu },\n    contextMenuContext,\n    contextMenuDescriptionId,\n    contextMenuDescription,\n    accStatusInfo\n  } as const;\n}\n\n//useCurrentKey use click capture that captures first click, which is on remove button\n//when we remove and sets the item being removed to currentKey. So we should not allow\n//this if click is on remove button\nconst extractOnlyItemKey = (element: HTMLElement, itemSelector: string, itemEliminator: string) => {\n  const tabBarItem = element.closest(itemSelector);\n  if (tabBarItem) {\n    if (tabBarItem.hasAttribute(REMOVABLE_ITEM_ATTRIBUTE)) {\n      const removeButton = element.closest(itemEliminator);\n      if (removeButton && tabBarItem?.contains(removeButton)) {\n        return null;\n      }\n    }\n    return getKey(tabBarItem as HTMLElement);\n  }\n  return null;\n};\n\nconst findNextValidKey = <K>(currentKey: K, currTabs: K[], prevTabs: K[]) => {\n  const index = prevTabs.indexOf(currentKey);\n  // update current key to be the first one if currentKey is invalid\n  if (index === -1) {\n    return currTabs[0];\n  }\n  let nextIndex = 0;\n  let isLastKey = false;\n  if (index === prevTabs.length - 1) {\n    nextIndex = index - 1;\n    isLastKey = true;\n  } else {\n    nextIndex = index + 1;\n  }\n  while (nextIndex !== index && nextIndex > -1 && nextIndex < prevTabs.length) {\n    const nextKey = prevTabs[nextIndex];\n    if (currTabs.indexOf(nextKey) !== -1) {\n      return nextKey;\n    }\n    isLastKey ? nextIndex-- : nextIndex++;\n  }\n  // update current key to be the first one if we can't find a suitable next key\n  return currTabs[0];\n};\n\n// Utility that returns the value for a attribute related to the role=\"tab\" item.\nexport const getItemAttribute = <K extends string | number>(\n  itemKey: K,\n  root: HTMLElement,\n  attribute: string\n) => {\n  const tabBarItem = findElementByKey(root, itemKey as K, ITEM_SELECTOR) as HTMLElement;\n  if (tabBarItem) {\n    const tabBarItemAttribute = tabBarItem.hasAttribute(attribute)\n      ? tabBarItem.getAttribute(attribute)\n      : null;\n    return tabBarItemAttribute;\n  }\n  return;\n};\n\n// Utility that returns the visible inner text inside the role=\"tab\" item.\nconst getItemLabel = <K extends string | number>(itemKey: K, root: HTMLElement) => {\n  const tabBarItem = findElementByKey(root, itemKey as K, ITEM_SELECTOR) as HTMLElement;\n  if (tabBarItem) {\n    return tabBarItem.innerText;\n  }\n  return;\n};\n"],"names":["ITEM_SELECTOR","REMOVABLE_ITEM_ATTRIBUTE","menuPropGestureStates","mouse","initialFocus","placement","offsetValue","keyboard","touch","initialMenuProps","isOpen","anchorRef","current","extractOnlyItemKey","element","itemSelector","itemEliminator","tabBarItem","closest","hasAttribute","removeButton","contains","getKey","findNextValidKey","currentKey","currTabs","prevTabs","index","indexOf","nextIndex","isLastKey","length","nextKey","getItemAttribute","itemKey","root","attribute","findElementByKey","getAttribute","getItemLabel","innerText","options","children","class","className","display","edge","selection","onSelect","onRemove","ref","userRef","size","contextMenuConfig","direction","useUser","translations","useTranslationBundle","internalRef","useRef","rootRef","tabId","useId","setCurrentKey","useState","hideTooltip","setHideTooltip","tabItemPrefix","contextMenuDescriptionId","contextMenuDescription","tabbar_labelContextMenu","prevTabKeys","useEffect","tabKeys","Array","from","querySelectorAll","map","elem","includes","showFocusRing","focusRingProps","useCollectionFocusRing","reorderableContext","useReorderableContext","currentKeyProps","useCurrentKey","keyExtractor","undefined","getPrevNextKeyUsingRef","detail","key","value","currentItemKey","contextMenuContext","setContextMenuContext","menuProps","setMenuProps","accStatusInfo","setAccStatusInfo","triggerProps","useContextMenuGesture","gesture","anchor","target","tabKeysArray","anchorBasedOnGesture","isRemovableItem","isReorderable","onReorder","isRemovable","defaultContext","getDefaultContextMenu","handleRemove","handleReorder","itemLabels","labelRemove","tabbar_labelRemove","labelMoveLeft","tabbar_labelMoveLeft","labelMoveRight","tabbar_labelMoveRight","handleAccStatus","removeItemLabel","removedKey","removeStatus","tabbar_accAnnounceRemovedKey","destinationItemLabel","destinationKey","reorderStatus","accAnnounceMovedKey","position","referenceKey","isDisabled","handleCloseContextMenu","useCallback","reason","focus","eventProps","mergeProps","onKeyDown","event","tabBarItemKey","preventDefault","onFocus","getFirstVisibleKey","rootProps","role","tabIndex","tabBarContext","isEdgeBottom","layout","onClose"],"mappings":"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"}