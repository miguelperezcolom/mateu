{"version":3,"file":"useContextMenu-4bd1c23a.js","sources":["../../src/hooks/PRIVATE_useVisContextMenu/util.ts","../../src/hooks/PRIVATE_useVisContextMenu/ContextMenu.tsx","../../src/hooks/PRIVATE_useVisContextMenu/useContextMenu.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentProps } from 'preact';\n\nimport { Menu } from '#UNSAFE_Menu';\n\nexport const initialMenuProps: MenuProps = {\n  isOpen: false,\n  initialFocus: 'menu',\n  placement: 'bottom-start',\n  offsetValue: 0,\n  anchorRef: { current: null }\n};\n\nexport type MenuProps = Pick<\n  ComponentProps<typeof Menu>,\n  'anchorRef' | 'initialFocus' | 'placement' | 'offsetValue' | 'isOpen'\n>;\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { ComponentProps, RefObject } from 'preact';\nimport { Menu } from '#UNSAFE_Menu';\nimport { initialMenuProps, MenuProps } from './util';\nimport { useCallback, Dispatch, StateUpdater } from 'preact/hooks';\nimport { ContextMenuConfig } from '#utils/UNSAFE_visTypes/common';\nimport type { gestureTypes } from './useContextMenu';\n\nexport type Props<T> = Omit<ComponentProps<typeof Menu>, 'children'> & {\n  contextMenuConfig: ContextMenuConfig<T>;\n} & { contextMenuContext: T } & { rootRef: RefObject<HTMLElement> } & {\n  setMenuProps: Dispatch<StateUpdater<MenuProps>>;\n} & { onContextMenuDismissed?: (gesture: gestureTypes) => void } & {\n  gestureRef: RefObject<gestureTypes>;\n};\n\n/**\n * The internal component used to render a custom context menu\n */\nexport function ContextMenu<T>({\n  contextMenuConfig,\n  contextMenuContext,\n  rootRef,\n  setMenuProps,\n  onContextMenuDismissed,\n  gestureRef,\n  ...menuProps\n}: Props<T>) {\n  const handleCloseContextMenu = useCallback<Required<ComponentProps<typeof Menu>>['onClose']>(\n    (detail) => {\n      /*\n      TODO: Focus ring should be visible when context menu was closed because of selecting an item using keyboard,\n      but should not be visible when the selection was done using mouse or touch. This would probably means menu\n      onClose API is going to be changed a little bit so we can satisfy this requirement. JET-62372\n      */\n      //Focus has to be set on the current target that was obtained\n      //during context menu gesture when menu is dismissed or item is \"selected\"\n      if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {\n        rootRef.current?.focus({ preventScroll: true });\n        onContextMenuDismissed?.(gestureRef.current);\n      }\n      // We close the menu.The only prop that matters here is isOpen\n      setMenuProps(initialMenuProps);\n    },\n    [rootRef, gestureRef, setMenuProps, onContextMenuDismissed]\n  );\n  return (\n    <Menu\n      {...menuProps}\n      onClose={handleCloseContextMenu}\n      aria-label={contextMenuConfig.accessibleLabel}>\n      {menuProps.isOpen && contextMenuConfig.itemsRenderer(contextMenuContext)}\n    </Menu>\n  );\n}\n","import type { RefObject } from 'preact';\nimport { useCallback, useRef, useState } from 'preact/hooks';\n\nimport { ContextMenu } from './ContextMenu';\nimport { useContextMenuGesture } from '#hooks/UNSAFE_useContextMenuGesture';\nimport { Coords } from '#UNSAFE_Floating';\n\nimport { ContextMenuConfig } from '#utils/UNSAFE_visTypes/common';\nimport { MenuProps, initialMenuProps } from './util';\n\nexport type gestureTypes = 'mouse' | 'touch' | 'keyboard' | null;\nconst TOUCH_OFFSET_VALUE = 30;\n\nconst menuPropGestureStates: Record<\n  'mouse' | 'keyboard' | 'touch',\n  Omit<Required<MenuProps>, 'anchorRef' | 'isOpen'>\n> = {\n  mouse: {\n    initialFocus: 'menu',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  keyboard: {\n    initialFocus: 'firstItem',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  touch: {\n    initialFocus: 'menu',\n    placement: 'end',\n    offsetValue: TOUCH_OFFSET_VALUE\n  }\n};\n\ntype ContextMenuEventDetail = ({ gesture: 'mouse' | 'touch' } | { gesture: 'keyboard' }) & {\n  target: Element;\n};\n\ntype ContextMenuHandler<Context> = (detail: ContextMenuEventDetail) => {\n  context: Context;\n} & (\n  | {\n      type: 'element';\n      elem: Element | null;\n    }\n  | {\n      type: 'offset';\n      offsetValue: { mainAxis: number; crossAxis: number };\n      width: number;\n      isRtl: boolean;\n    }\n  | {\n      type: 'pointer';\n    }\n);\n\ntype ContextMenuOptions = {\n  isDisabled?: boolean;\n};\ntype Props<Context> = {\n  onContextMenuHandler: ContextMenuHandler<Context>;\n  contextMenuOptions: ContextMenuOptions;\n  rootRef: RefObject<HTMLElement>;\n  contextMenuConfig?: ContextMenuConfig<Context>;\n  onContextMenuDismissed?: (gesture: gestureTypes) => void;\n};\n\nexport function useContextMenu<Context>({\n  onContextMenuHandler,\n  contextMenuOptions,\n  rootRef,\n  contextMenuConfig,\n  onContextMenuDismissed\n}: Props<Context>) {\n  const [contextMenuContext, setContextMenuContext] = useState<Context>();\n\n  const [menuProps, setMenuProps] = useState<MenuProps>(initialMenuProps);\n\n  type ContextMenuEventDetail = (\n    | { gesture: 'mouse' | 'touch'; anchor: Coords }\n    | { gesture: 'keyboard'; anchor: Element }\n  ) & { currentTarget: Element; target: Element };\n\n  const gestureRef = useRef<gestureTypes>(null);\n  const onVisContextMenuHandler = useCallback(\n    ({ gesture, anchor, target }: ContextMenuEventDetail) => {\n      gestureRef.current = gesture;\n      const { context, ...launcherInfo } = onContextMenuHandler({\n        gesture,\n        target\n      });\n      let menuAnchor;\n      switch (launcherInfo.type) {\n        case 'offset': {\n          const { offsetValue, isRtl, width } = launcherInfo;\n          const rootRefDims = rootRef.current?.getBoundingClientRect()!;\n          menuAnchor = {\n            x: isRtl\n              ? width + rootRefDims.x - Math.abs(offsetValue.crossAxis)\n              : rootRefDims.x + Math.abs(offsetValue.crossAxis),\n            y: rootRefDims.y + Math.abs(offsetValue.mainAxis)\n          };\n          break;\n        }\n        case 'element':\n          menuAnchor = launcherInfo.elem;\n          break;\n        case 'pointer':\n          menuAnchor = anchor;\n          break;\n      }\n      setContextMenuContext(context);\n      setMenuProps({\n        ...menuPropGestureStates[gesture],\n        anchorRef: { current: menuAnchor },\n        isOpen: true\n      });\n    },\n    [onContextMenuHandler, rootRef]\n  );\n\n  const contextMenuContent = contextMenuConfig && (\n    <ContextMenu\n      {...menuProps}\n      onContextMenuDismissed={onContextMenuDismissed}\n      gestureRef={gestureRef}\n      setMenuProps={setMenuProps}\n      rootRef={rootRef}\n      contextMenuConfig={contextMenuConfig}\n      contextMenuContext={contextMenuContext!}\n    />\n  );\n\n  const { triggerProps } = useContextMenuGesture(onVisContextMenuHandler, {\n    ...contextMenuOptions,\n    isTouchHoldReleaseGesture: true\n  });\n\n  return { contextMenuProps: triggerProps, contextMenuContent };\n}\n"],"names":["initialMenuProps","isOpen","initialFocus","placement","offsetValue","anchorRef","current","ContextMenu","contextMenuConfig","contextMenuContext","rootRef","setMenuProps","onContextMenuDismissed","gestureRef","menuProps","handleCloseContextMenu","useCallback","detail","reason","focus","preventScroll","_jsx","Menu","onClose","accessibleLabel","itemsRenderer","menuPropGestureStates","mouse","keyboard","touch","onContextMenuHandler","contextMenuOptions","setContextMenuContext","useState","useRef","onVisContextMenuHandler","gesture","anchor","target","context","launcherInfo","menuAnchor","type","isRtl","width","rootRefDims","getBoundingClientRect","x","Math","abs","crossAxis","y","mainAxis","elem","contextMenuContent","triggerProps","useContextMenuGesture","isTouchHoldReleaseGesture","contextMenuProps"],"mappings":"0yBAWO,MAAMA,EAA8B,CACzCC,QAAQ,EACRC,aAAc,OACdC,UAAW,eACXC,YAAa,EACbC,UAAW,CAAEC,QAAS,gBCSRC,GAAeC,kBAC7BA,EAAiBC,mBACjBA,EAAkBC,QAClBA,EAAOC,aACPA,EAAYC,uBACZA,EAAsBC,WACtBA,KACGC,IAEH,MAAMC,EAAyBC,eAC5BC,IAQuB,cAAlBA,EAAOC,QAA4C,eAAlBD,EAAOC,SAC1CR,EAAQJ,SAASa,MAAM,CAAEC,eAAe,IACxCR,IAAyBC,EAAWP,UAGtCK,EAAaX,EAAiB,GAEhC,CAACU,EAASG,EAAYF,EAAcC,IAEtC,OACES,EAAAA,IAACC,EAAAA,KACK,IAAAR,EACJS,QAASR,EACG,aAAAP,EAAkBgB,yBAC7BV,EAAUb,QAAUO,EAAkBiB,cAAchB,IAG3D,CCjDA,MAEMiB,EAGF,CACFC,MAAO,CACLzB,aAAc,OACdC,UAAW,eACXC,YAAa,GAEfwB,SAAU,CACR1B,aAAc,YACdC,UAAW,eACXC,YAAa,GAEfyB,MAAO,CACL3B,aAAc,OACdC,UAAW,MACXC,YAnBuB,sCAwDX,UAAwB0B,qBACtCA,EAAoBC,mBACpBA,EAAkBrB,QAClBA,EAAOF,kBACPA,EAAiBI,uBACjBA,IAEA,MAAOH,EAAoBuB,GAAyBC,EAAQA,YAErDnB,EAAWH,GAAgBsB,EAAQA,SAAYjC,GAOhDa,EAAaqB,SAAqB,MAClCC,EAA0BnB,EAAAA,aAC9B,EAAGoB,UAASC,SAAQC,aAClBzB,EAAWP,QAAU8B,EACrB,MAAMG,QAAEA,KAAYC,GAAiBV,EAAqB,CACxDM,UACAE,WAEF,IAAIG,EACJ,OAAQD,EAAaE,MACnB,IAAK,SAAU,CACb,MAAMtC,YAAEA,EAAWuC,MAAEA,EAAKC,MAAEA,GAAUJ,EAChCK,EAAcnC,EAAQJ,SAASwC,wBACrCL,EAAa,CACXM,EAAGJ,EACCC,EAAQC,EAAYE,EAAIC,KAAKC,IAAI7C,EAAY8C,WAC7CL,EAAYE,EAAIC,KAAKC,IAAI7C,EAAY8C,WACzCC,EAAGN,EAAYM,EAAIH,KAAKC,IAAI7C,EAAYgD,WAE1C,KACD,CACD,IAAK,UACHX,EAAaD,EAAaa,KAC1B,MACF,IAAK,UACHZ,EAAaJ,EAGjBL,EAAsBO,GACtB5B,EAAa,IACRe,EAAsBU,GACzB/B,UAAW,CAAEC,QAASmC,GACtBxC,QAAQ,GACR,GAEJ,CAAC6B,EAAsBpB,IAGnB4C,EAAqB9C,GACzBa,MAACd,EACK,IAAAO,EACJF,uBAAwBA,EACxBC,WAAYA,EACZF,aAAcA,EACdD,QAASA,EACTF,kBAAmBA,EACnBC,mBAAoBA,KAIlB8C,aAAEA,GAAiBC,EAAqBA,sBAACrB,EAAyB,IACnEJ,EACH0B,2BAA2B,IAG7B,MAAO,CAAEC,iBAAkBH,EAAcD,qBAC3C"}