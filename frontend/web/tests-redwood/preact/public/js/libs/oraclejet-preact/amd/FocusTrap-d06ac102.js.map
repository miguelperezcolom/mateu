{"version":3,"file":"FocusTrap-d06ac102.js","sources":["../../src/UNSAFE_FocusTrap/FocusTrap.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { ComponentChildren, RefObject } from 'preact';\nimport { useCallback, useRef } from 'preact/compat';\nimport { FocusableElement, focusOn, isTabbableElement } from '../utils/PRIVATE_tabbableUtils';\nimport { FocusTracker, type FocusGuardCallbackDetail } from '../PRIVATE_FocusTracker';\n\ntype Props = {\n  children: ComponentChildren;\n  /**\n   * Optional Ref to an element to focus on when component mounts\n   * @default - undefined - behavior is to focus on first tabbableElement\n   */\n  autoFocusRef?: RefObject<{ focus: () => void }>;\n\n  /**\n   * Sets whether focus is managed and whether guards are present\n   * @default false\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Why a isDisabled prop as compared to ONLY supporting conditional rendering?\n   *\n   *   1) We need an actual HTML Element for the trap, conditional rendering an element potentially breaks consumer CSS\n   *   2) Conditional rendering can short-circuit event bubbling in preact and lead to expected events not bubbling.\n   */\n\n  /**\n   * Optional Ref to element to focus on when component un-mounts, false to disable.\n   * @default - undefined - behavior is to focus on the original activeElement when focus trap was enabled\n   */\n  restoreFocusRef?: RefObject<{ focus: () => void }> | false;\n};\n\n/**\n * Trap focus within a DOM node.  When a user hits Tab or Shift+Tab, focus remains in the focus trap.\n */\nexport const FocusTrap = ({\n  autoFocusRef,\n  children,\n  isDisabled = false,\n  restoreFocusRef\n}: Props) => {\n  const originalActiveElementRef = useRef<FocusableElement | null>(null);\n  const lastActiveElementRef = useRef<FocusableElement | null>(null);\n\n  /**\n   * contain focus if trap is enabled, and target is not already contained\n   *\n   * calling cases for side-effect of setting focus\n   *   - on initial mount of (enabled) trap, where target is not inside trap\n   *   - on enabling of a disabled trap, where target is not inside trap\n   *   - target of click event is outside of trap.\n   */\n  const conditionallyContainFocus = useCallback(\n    (\n      hasFocusWithin: boolean,\n      currentActiveElement: FocusableElement | null,\n      tabbableElements: FocusableElement[]\n    ) => {\n      //  short-circuit, currentActiveElement not valid\n      if (isDisabled || !currentActiveElement) return;\n\n      // just update ref if currentActiveElement is a child of the tracker\n      if (hasFocusWithin) {\n        lastActiveElementRef.current = currentActiveElement;\n        return;\n      }\n\n      // set focus to last active tab-stop if lastElement is defined and inside trap\n      if (lastActiveElementRef.current) {\n        focusOn(lastActiveElementRef.current);\n      } else if (tabbableElements.length > 0) {\n        // otherwise just contain focus within trap as target is outside enabled trap and we have no last-known tab-stop\n        focusOn(tabbableElements[0]);\n      }\n    },\n    [isDisabled]\n  );\n\n  // loop focus from start edge\n  const handleFocusStartEdge = useCallback((detail: FocusGuardCallbackDetail) => {\n    const tabbableCount = detail.tabbableElements.length;\n    if (tabbableCount > 0) {\n      focusOn(detail.tabbableElements[tabbableCount - 1]);\n    }\n  }, []);\n\n  // loop focus from end edge\n  const handleFocusEndEdge = useCallback((detail: FocusGuardCallbackDetail) => {\n    const tabbableCount = detail.tabbableElements.length;\n    if (tabbableCount > 0) {\n      focusOn(detail.tabbableElements[0]);\n    }\n  }, []);\n\n  // handle enable case and initial render\n  const handleStartTracking = useCallback(\n    (detail: {\n      activeElement: FocusableElement;\n      hasFocusWithin: boolean;\n      tabbableElements: FocusableElement[];\n    }) => {\n      originalActiveElementRef.current = detail.activeElement;\n\n      // init focus\n      if (autoFocusRef && autoFocusRef.current) {\n        focusOn(autoFocusRef.current);\n      } else {\n        conditionallyContainFocus(\n          detail.hasFocusWithin,\n          detail.activeElement,\n          detail.tabbableElements\n        );\n      }\n    },\n    [autoFocusRef, conditionallyContainFocus]\n  );\n\n  // handle disable case\n  const handleStopTracking = useCallback(\n    (detail: { hasFocusWithin: boolean; lastActiveElement: FocusableElement | null }) => {\n      lastActiveElementRef.current = detail.lastActiveElement;\n      if (restoreFocusRef !== false) {\n        restoreFocusForCleanup(restoreFocusRef?.current || originalActiveElementRef.current);\n      }\n    },\n    [restoreFocusRef]\n  );\n\n  return (\n    <FocusTracker\n      isDisabled={isDisabled}\n      onStartTracking={handleStartTracking}\n      onStopTracking={handleStopTracking}\n      onFocusStartEdge={handleFocusStartEdge}\n      onFocusEndEdge={handleFocusEndEdge}>\n      {children}\n    </FocusTracker>\n  );\n};\n\n// setTimeout ensures that unmount lifecycle has completed\nconst restoreFocusForCleanup = (focusTarget: { focus: () => void } | null) => {\n  if (focusTarget) {\n    const isElement = focusTarget instanceof HTMLElement || focusTarget instanceof SVGElement;\n    if (!isElement || isTabbableElement(focusTarget)) {\n      setTimeout(() => {\n        focusOn(focusTarget);\n      }, 0);\n    }\n  }\n};\n"],"names":["restoreFocusForCleanup","focusTarget","HTMLElement","SVGElement","isTabbableElement","setTimeout","focusOn","autoFocusRef","children","isDisabled","restoreFocusRef","originalActiveElementRef","useRef","lastActiveElementRef","conditionallyContainFocus","useCallback","hasFocusWithin","currentActiveElement","tabbableElements","current","length","handleFocusStartEdge","detail","tabbableCount","handleFocusEndEdge","handleStartTracking","activeElement","handleStopTracking","lastActiveElement","_jsx","FocusTracker","onStartTracking","onStopTracking","onFocusStartEdge","onFocusEndEdge"],"mappings":"+IA2Ca,MA0GPA,EAA0BC,IAC9B,GAAIA,EAAa,EACGA,aAAuBC,aAAeD,aAAuBE,cAC7DC,oBAAkBH,IAClCI,YAAW,KACTC,EAAOA,QAACL,EAAY,GACnB,EAEN,eAlHsB,EACvBM,eACAC,WACAC,cAAa,EACbC,sBAEA,MAAMC,EAA2BC,SAAgC,MAC3DC,EAAuBD,SAAgC,MAUvDE,EAA4BC,EAAWA,aAC3C,CACEC,EACAC,EACAC,MAGIT,GAAeQ,IAGfD,EACFH,EAAqBM,QAAUF,EAK7BJ,EAAqBM,QACvBb,UAAQO,EAAqBM,SACpBD,EAAiBE,OAAS,GAEnCd,UAAQY,EAAiB,IAC1B,GAEH,CAACT,IAIGY,EAAuBN,eAAaO,IACxC,MAAMC,EAAgBD,EAAOJ,iBAAiBE,OAC1CG,EAAgB,GAClBjB,EAAAA,QAAQgB,EAAOJ,iBAAiBK,EAAgB,GACjD,GACA,IAGGC,EAAqBT,eAAaO,IAChBA,EAAOJ,iBAAiBE,OAC1B,GAClBd,EAAAA,QAAQgB,EAAOJ,iBAAiB,GACjC,GACA,IAGGO,EAAsBV,eACzBO,IAKCX,EAAyBQ,QAAUG,EAAOI,cAGtCnB,GAAgBA,EAAaY,QAC/Bb,UAAQC,EAAaY,SAErBL,EACEQ,EAAON,eACPM,EAAOI,cACPJ,EAAOJ,iBAEV,GAEH,CAACX,EAAcO,IAIXa,EAAqBZ,eACxBO,IACCT,EAAqBM,QAAUG,EAAOM,mBACd,IAApBlB,GACFV,EAAuBU,GAAiBS,SAAWR,EAAyBQ,QAC7E,GAEH,CAACT,IAGH,OACEmB,EAAAA,IAACC,EAAAA,aACC,CAAArB,WAAYA,EACZsB,gBAAiBN,EACjBO,eAAgBL,EAChBM,iBAAkBZ,EAClBa,eAAgBV,EACfhB,SAAAA,GAEH"}