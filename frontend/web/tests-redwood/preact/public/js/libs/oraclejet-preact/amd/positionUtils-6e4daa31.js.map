{"version":3,"file":"positionUtils-6e4daa31.js","sources":["../../src/utils/PRIVATE_floatingUtils/positionUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { RtlSide } from '../../UNSAFE_Floating';\n\n/**\n * Returns the normalized Position depending on the reading direction\n * @param side The side that should be normalized\n * @param direction The reading direction\n * @returns The normalized 'right' or 'left' position if the side was 'start' or 'end', otherwise returns unchanged position\n */\nexport const normalizePosition = (side: RtlSide, direction: 'rtl' | 'ltr'): RtlSide => {\n  const sideHashLtr = {\n    start: 'left',\n    end: 'right'\n  };\n  const sideHashRtl = {\n    start: 'right',\n    end: 'left'\n  };\n  if (direction === 'rtl') {\n    return side.replace(/start|end/g, (matched) => (sideHashRtl as any)[matched]) as RtlSide;\n  } else {\n    return side.replace(/start|end/g, (matched) => (sideHashLtr as any)[matched]) as RtlSide;\n  }\n};\n/**\n * Returns the reversed normalized Position depending on the reading direction\n * @param side The side that should be reversed\n * @param direction The reading direction\n * @returns The 'start' or 'end' position if the side was 'right' or 'left', otherwise returns unchanged position\n */\nexport const reverseNormalizePosition = (side: RtlSide, direction: 'rtl' | 'ltr'): RtlSide => {\n  const sideHashLtr = {\n    left: 'start',\n    right: 'end'\n  };\n  const sideHashRtl = {\n    right: 'start',\n    left: 'end'\n  };\n  if (direction === 'rtl') {\n    return side.replace(/left|right/g, (matched) => (sideHashRtl as any)[matched]) as RtlSide;\n  } else {\n    return side.replace(/left|right/g, (matched) => (sideHashLtr as any)[matched]) as RtlSide;\n  }\n};\n\n/**\n * Check is 'window' is available\n */\nconst hasWindow = () => {\n  return typeof window !== 'undefined';\n};\n\n/**\n * Returns the window object for the node\n */\nconst getWindow = (node: any): typeof window => {\n  return node?.ownerDocument?.defaultView || window;\n};\n\n/**\n * Checks if the value is a valid node\n */\nconst isNode = (value: unknown): value is Node => {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n};\n\n/**\n * Checks if the node is the last traversable ancestor\n */\nconst isLastTraversableNode = (node: Node): boolean => {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n};\n\n/**\n * Returns document element for the node\n */\nconst getDocumentElement = (node: Node | Window): HTMLElement => {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document)?.documentElement;\n};\n\n/**\n * Returns normalized node name\n */\nconst getNodeName = (node: Node | Window): string => {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  return '#document';\n};\n\n/**\n * Returns node's parent\n */\nconst getParentNode = (node: Node): Node => {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  return node.parentNode || getDocumentElement(node);\n};\n\n/**\n * Checks if the value is an HTMLElement\n */\nconst isHTMLElement = (value: unknown): value is HTMLElement => {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n};\n\n/**\n * Checks if the element is a containing block\n */\nconst isContainingBlock = (element: HTMLElement) => {\n  const css = getComputedStyle(element);\n\n  return (\n    css.transform !== 'none' ||\n    css.perspective !== 'none' ||\n    (css.containerType ? css.containerType !== 'normal' : false) ||\n    ['transform', 'perspective', 'filter'].some((value) =>\n      (css.willChange || '').includes(value)\n    ) ||\n    ['paint', 'layout', 'strict', 'content'].some((value) => (css.contain || '').includes(value))\n  );\n};\n\n/**\n * Returns element's containg block or null (if no containing block exists)\n */\nexport const getContainingBlockElem = (element: HTMLElement) => {\n  let currentNode: Node | null = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n};\n"],"names":["hasWindow","window","getWindow","node","ownerDocument","defaultView","isNode","value","Node","getNodeName","nodeName","toLowerCase","getParentNode","parentNode","document","documentElement","getDocumentElement","isContainingBlock","element","css","getComputedStyle","transform","perspective","containerType","some","willChange","includes","contain","currentNode","HTMLElement","side","direction","sideHashLtr","start","end","sideHashRtl","replace","matched","left","right"],"mappings":"mDAwDMA,EAAY,IACS,oBAAXC,OAMVC,EAAaC,GACVA,GAAMC,eAAeC,aAAeJ,OAMvCK,EAAUC,KACTP,MAGEO,aAAiBC,MAAQD,aAAiBL,EAAUK,GAAOC,MAoB9DC,EAAeN,GACfG,EAAOH,IACDA,EAAKO,UAAY,IAAIC,cAExB,YAMHC,EAAiBT,GACK,SAAtBM,EAAYN,GACPA,EAEFA,EAAKU,YArBa,CAACV,KACjBG,EAAOH,GAAQA,EAAKC,cAAgBD,EAAKW,WAAab,OAAOa,WAAWC,gBAoBvDC,CAAmBb,GAgBzCc,EAAqBC,IACzB,MAAMC,EAAMC,iBAAiBF,GAE7B,MACoB,SAAlBC,EAAIE,WACgB,SAApBF,EAAIG,eACHH,EAAII,eAAsC,WAAtBJ,EAAII,eACzB,CAAC,YAAa,cAAe,UAAUC,MAAMjB,IAC1CY,EAAIM,YAAc,IAAIC,SAASnB,MAElC,CAAC,QAAS,SAAU,SAAU,WAAWiB,MAAMjB,IAAWY,EAAIQ,SAAW,IAAID,SAASnB,IACtF,2BAMmCW,IACrC,IAAIU,EAA2BhB,EAAcM,GAE7C,KA9BqBX,EA8BAqB,EA7BhB5B,MAGEO,aAAiBsB,aAAetB,aAAiBL,EAAUK,GAAOsB,eArClE,CAAC,OAAQ,OAAQ,aAAaH,SAASjB,EA+DcmB,KAAc,CACxE,GAAIX,EAAkBW,GACpB,OAAOA,EAETA,EAAchB,EAAcgB,EAC7B,CArE2B,IAkCPrB,EAoCrB,OAAO,IAAI,sBAtIoB,CAACuB,EAAeC,KAC/C,MAAMC,EAAc,CAClBC,MAAO,OACPC,IAAK,SAEDC,EAAc,CAClBF,MAAO,QACPC,IAAK,QAEP,MAAkB,QAAdH,EACKD,EAAKM,QAAQ,cAAeC,GAAaF,EAAoBE,KAE7DP,EAAKM,QAAQ,cAAeC,GAAaL,EAAoBK,IACrE,6BAQqC,CAACP,EAAeC,KACtD,MAAMC,EAAc,CAClBM,KAAM,QACNC,MAAO,OAEHJ,EAAc,CAClBI,MAAO,QACPD,KAAM,OAER,MAAkB,QAAdP,EACKD,EAAKM,QAAQ,eAAgBC,GAAaF,EAAoBE,KAE9DP,EAAKM,QAAQ,eAAgBC,GAAaL,EAAoBK,IACtE"}