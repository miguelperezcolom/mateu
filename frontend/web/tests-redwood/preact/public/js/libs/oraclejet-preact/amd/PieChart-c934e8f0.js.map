{"version":3,"file":"PieChart-c934e8f0.js","sources":["../../src/UNSAFE_PieChart/utils.ts","../../src/UNSAFE_PieChart/PieSlice.tsx","../../src/UNSAFE_PieChart/usePieChartContextMenu.ts","../../src/UNSAFE_PieChart/labelUtils.ts","../../src/UNSAFE_PieChart/PieChartLabel.tsx","../../src/UNSAFE_PieChart/PieChartWithDimensions.tsx","../../src/UNSAFE_PieChart/pieNavUtils.ts","../../src/UNSAFE_PieChart/PieChart.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ItemInfo } from '#hooks/PRIVATE_usePieChartNav';\nimport { arcTo, closePath, lineTo, moveTo } from '#utils/PRIVATE_visSVGUtils';\nimport type { PieChartItemData, PieSliceInfo } from './pieChart.types';\ntype Bounds = {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n};\n\nconst RADIUS_RATIO = 0.45;\nconst RADIUS_RATIO_WITH_LABELS = 0.38;\nconst SLICE_GAP_RATIO = 3;\nconst MIN_ARC_LENGTH = 1.5;\nconst START_ANGLE = 90;\n\n/**\n * Converts the angle from degrees to radians.\n * @param degree The angle in degrees\n * @returns\n */\nexport function degreesToRads(degree: number) {\n  return degree * (Math.PI / 180);\n}\n\n/**\n * Calculates the angle between two vectors.\n * @param vector1X The x component of first vector.\n * @param vector1Y The y component of first vector.\n * @param vector2X The x component of second vector.\n * @param vector2Y The y component of second vector.\n * @returns\n */\nexport function calculateAngleBetweenTwoVectors(\n  vector1X: number,\n  vector1Y: number,\n  vector2X: number,\n  vector2Y: number\n) {\n  const angle = Math.atan2(vector2Y, vector2X) - Math.atan2(vector1Y, vector1X);\n  return angle < 0 ? angle + 2 * Math.PI : angle;\n}\n\n/**\n * Get the center coord of the pie chart.\n * @param availSpace The available space.\n * @returns\n */\nexport function getPieCenter(availSpace: Bounds) {\n  return {\n    cx: availSpace.x + Math.floor(availSpace.width / 2),\n    cy: availSpace.y + Math.floor(availSpace.height / 2)\n  };\n}\n\n/**\n * Returns the radius of the pie chart.\n * @param availSpace The available space.\n * @param labelPosition The position of labels.\n * @returns\n */\nexport function getRadius(availSpace: Bounds, isLabelOutside: boolean) {\n  const radiusScale = isLabelOutside ? RADIUS_RATIO_WITH_LABELS : RADIUS_RATIO;\n  return Math.floor(Math.min(availSpace.width, availSpace.height) * radiusScale);\n}\n\n/**\n * Returns the total value of the pie chart.\n * @param items\n */\nexport function getPieChartInfo<K>(items: PieChartItemData<K>[]) {\n  return items.reduce(\n    ({ totalValue, isLabelOutside }, item) => {\n      return {\n        totalValue: totalValue + item.value,\n        isLabelOutside: isLabelOutside || (!!item.label && (item.labelPosition === 'outside' || item.labelPosition === 'auto'))\n      };\n    },\n    { totalValue: 0, isLabelOutside: false }\n  );\n}\n\n/**\n * Returns the startAngle and angleOffset for the rendered items.\n * @param items\n * @param totalValue\n */\nexport function getSliceInfo<K, D extends PieChartItemData<K>>(  items: D[], \n  totalValue: number,\n  colors: string[],\n  isRtl: boolean) {\n  let anchorOffset = START_ANGLE;\n  let percentage;\n  const sliceInfo = [];\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const value = item.value;\n    if (value === totalValue) {\n      percentage = 100;\n    } else if (totalValue === 0) {\n      percentage = 0;\n    } else {\n      // if value is not 100%, cap it at 99.99%\n      percentage = Math.min((value / totalValue) * 100, 99.99);\n    }\n    const arc = percentage * 3.6;\n    let angle = anchorOffset - arc;\n    if (angle < 0) angle += 360;\n    sliceInfo.push({\n      color: colors[(isRtl ? items.length - 1 - i : i) %colors.length],\n      index: i,\n      startAngle: angle,\n      angleExtent: arc,\n      ...item\n    });\n\n    anchorOffset = angle;\n  }\n  return sliceInfo;\n}\n\n/**\n * Returns the pie slice gaps.\n * @param  pieSliceGap The ratio of maximum supported pie slice gap.\n * @returns\n */\nexport function getPieSliceGap(pieSliceGap: number) {\n  return SLICE_GAP_RATIO * pieSliceGap;\n}\n\n/**\n * Returns the array of layouts to render without skipping.\n * @param layouts\n * @param hasLargeItemCount\n * @param radius\n * @returns\n */\nexport function getRenderedSlices<K>(\n  itemInfo: PieSliceInfo<K>[],\n  hasLargeItemCount: boolean,\n  radius: number\n): PieSliceInfo<K>[] {\n  if (!hasLargeItemCount) {\n    return itemInfo;\n  }\n\n  const perimeter = 2 * Math.PI * radius;\n  let prevEndCoord = 0;\n\n  return itemInfo.filter(({ startAngle, angleExtent }) => {\n    const arcLength = (angleExtent / 360) * perimeter;\n    const endCoord = ((angleExtent + startAngle) / 360) * perimeter;\n    if (arcLength < MIN_ARC_LENGTH && Math.abs(prevEndCoord - endCoord) < MIN_ARC_LENGTH) {\n      return false;\n    } else {\n      prevEndCoord = endCoord;\n      return true;\n    }\n  });\n}\n\n/**\n * Returns the path of the pie slice wedge.\n * @param inset The inset.\n * @param cx The x coordinate of the center of the pie chart.\n * @param cy The y coordinate of the center of the pie chart.\n * @param radiusX The x radius of the slice.\n * @param radiusY The y radius of the slice.\n * @param innerRadius The inner radius.\n * @param angleExtent The angle extent.\n * @param wedgeGap The gap beteen the pie slices.\n * @param startAngle The start angle of the pie slice.\n * @returns\n */\nexport function makeWedgePath(\n  inset: number,\n  cx: number,\n  cy: number,\n  radiusX: number,\n  radiusY: number,\n  innerRadius: number,\n  angleExtent: number,\n  wedgeGap: number,\n  startAngle: number\n) {\n  const rx = Math.max(radiusX - inset, 0);\n  const ry = Math.max(radiusY - inset, 0);\n  const gap = angleExtent == 360 || rx < inset ? 0 : wedgeGap + 2 * inset;\n\n  const ir = innerRadius ? innerRadius + inset : 0;\n  // if angle extent is not 360, cap it  at 359.99\n  const angleExtentRads = angleExtent == 360 ? degreesToRads(359.99) : degreesToRads(angleExtent);\n\n  const startAngleRads = degreesToRads(startAngle);\n  const dataItemGaps = gap / 2;\n\n  const gapAngle = dataItemGaps < rx ? Math.asin(dataItemGaps / rx) : 0;\n  const centerLineAngle = -angleExtentRads / 2 - startAngleRads;\n\n  // cap at 5* dataItemsGap. logic from legacy dvt toolkit\n  const distanceToStartPointX = Math.min(\n    dataItemGaps * 5,\n    angleExtentRads > 0 ? Math.abs(dataItemGaps / Math.sin(angleExtentRads / 2)) : 0\n  );\n  const distanceToStartPointY = rx == 0 ? distanceToStartPointX : (distanceToStartPointX * ry) / rx;\n\n  const startPointX = cx + Math.cos(centerLineAngle) * distanceToStartPointX;\n  const startPointY = cy + Math.sin(centerLineAngle) * distanceToStartPointY;\n\n  const arcPointX = cx + Math.cos(-gapAngle - startAngleRads) * rx;\n  const arcPointY = cy + Math.sin(-gapAngle - startAngleRads) * ry;\n\n  const arcPoint2X = cx + Math.cos(-startAngleRads - angleExtentRads + gapAngle) * rx;\n  const arcPoint2Y = cy + Math.sin(-startAngleRads - angleExtentRads + gapAngle) * ry;\n\n  let outerAngle = calculateAngleBetweenTwoVectors(\n    arcPoint2X - cx,\n    arcPoint2Y - cy,\n    arcPointX - cx,\n    arcPointY - cy\n  );\n  outerAngle = Math.min(outerAngle, angleExtentRads);\n  let pathCommands: string;\n  if (ir > 0) {\n    const innerGapAngle = dataItemGaps < ir ? Math.asin(dataItemGaps / ir) : 0;\n    const innerPointX = cx + Math.cos(-innerGapAngle - startAngleRads) * ir;\n    const innerPointY = cy + Math.sin(-innerGapAngle - startAngleRads) * ir;\n\n    const innerPoint2X = cx + Math.cos(-startAngleRads - angleExtentRads + innerGapAngle) * ir;\n    const innerPoint2Y = cy + Math.sin(-startAngleRads - angleExtentRads + innerGapAngle) * ir;\n\n    let innerAngle = calculateAngleBetweenTwoVectors(\n      innerPoint2X - cx,\n      innerPoint2Y - cy,\n      innerPointX - cx,\n      innerPointY - cy\n    );\n    innerAngle = Math.min(innerAngle, outerAngle, angleExtentRads);\n\n    if (angleExtent == 360) {\n      pathCommands = moveTo(arcPoint2X, arcPoint2Y);\n      pathCommands += arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);\n      pathCommands += lineTo(arcPoint2X, arcPoint2Y);\n      pathCommands += moveTo(innerPointX, innerPointY);\n      pathCommands += arcTo(ir, ir, angleExtentRads, 0, innerPoint2X, innerPoint2Y);\n    } else {\n      pathCommands = moveTo(innerPoint2X, innerPoint2Y);\n      pathCommands += lineTo(arcPoint2X, arcPoint2Y);\n      pathCommands += arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);\n      pathCommands += lineTo(innerPointX, innerPointY);\n      pathCommands += arcTo(ir, ir, innerAngle, 0, innerPoint2X, innerPoint2Y);\n    }\n  } else {\n    if (angleExtent == 360) {\n      pathCommands = moveTo(arcPoint2X, arcPoint2Y);\n      pathCommands += arcTo(rx, ry, angleExtentRads, 1, arcPointX, arcPointY);\n    } else {\n      pathCommands = moveTo(startPointX, startPointY);\n      pathCommands += lineTo(arcPoint2X, arcPoint2Y);\n      pathCommands += arcTo(rx, ry, outerAngle, 1, arcPointX, arcPointY);\n    }\n  }\n\n  pathCommands += closePath();\n  return pathCommands;\n}\n\n/**\n * Returns the pie chart center context.\n * @param cx The x coordinate of the center of the pie chart.\n * @param cy The y coordinate of the center of the pie chart.\n * @param innerRadius The inner radius of the pie chart.\n * @returns\n */\nexport function getCenterContext(cx: number, cy: number, innerRadius: number) {\n  return {\n    innerBounds: {\n      width: Math.sqrt(2) * innerRadius,\n      height: Math.sqrt(2) * innerRadius,\n      x: cx - innerRadius / Math.sqrt(2),\n      y: cy - innerRadius / Math.sqrt(2)\n    },\n    outerBounds: {\n      width: 2 * innerRadius,\n      height: 2 * innerRadius,\n      x: cx - innerRadius,\n      y: cy - innerRadius\n    }\n  };\n}\n\n/**\n * Returns the position of the datatip for a given slice.\n * @param startAngle The start angle of the pie slice.\n * @param angleExtent The angle extent of the pie slice.\n * @param cx The x coordinate of the center of the pie slice.\n * @param cy The y coordinate of the center of the pie slice.\n * @param innerRadius The inner radius.\n * @param radius The radius of the pie slice.\n * @returns\n */\nexport function getPieItemCenterCoord(\n  startAngle: number,\n  angleExtent: number,\n  cx: number,\n  cy: number,\n  innerRadius: number,\n  radius: number\n) {\n  const angle = startAngle + angleExtent / 2;\n  const theta = (angle / 180) * Math.PI;\n  const r = (innerRadius + radius) / 2;\n\n  return {\n    x: cx + r * Math.cos(theta),\n    y: cy - r * Math.sin(theta),\n    width: 0,\n    height: 0\n  };\n}\n\n/**\n * Returns the element bound for active item.\n * @param renderedSlices The array of info for rendered slices.\n * @param cx The x coordinate of pie chart center.\n * @param cy The y coordinate of pie chart center.\n * @param ir The inner radius of the pie chart.\n * @param radius The radius of the pie chart.\n * @param activeItem The active item.\n * @returns\n */\nexport function getElementBounds<K>(\n  renderedSlices: PieSliceInfo<K>[],\n  cx: number,\n  cy: number,\n  ir: number,\n  radius: number,\n  activeItem?: ItemInfo\n) {\n  return activeItem\n    ? getPieItemCenterCoord(\n        renderedSlices[activeItem.itemIndex].startAngle,\n        renderedSlices[activeItem.itemIndex].angleExtent,\n        cx,\n        cy,\n        ir,\n        radius\n      )\n    : undefined;\n}\n\n/**\n * Returns default border color for datatip.\n * @param colors The color ramp.\n * @param activeItem The active item info.\n * @param activeData The active pie chart data item.\n * @returns\n */\nexport function getDefaultBorderColor<K>(\n  colors: string[],\n  activeItem?: ItemInfo,\n  activeData?: PieChartItemData<K>\n) {\n  return activeData?.color || activeItem?.itemIndex != undefined\n    ? colors[activeItem!.itemIndex]\n    : undefined;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '#utils/UNSAFE_interpolations/colors';\nimport { makeWedgePath } from './utils';\nimport { styles } from './themes/PieChartStyles.css';\nimport { classNames } from '#utils/UNSAFE_classNames';\n\n/**\n * The props for pie slice.\n */\ntype PieSliceProps = {\n  /**\n   * The x coordinate of the center of the slice.\n   */\n  cx: number;\n\n  /**\n   * The y coordinate of the center of the slice.\n   */\n  cy: number;\n\n  /**\n   * The radius of the pie slice.\n   */\n  r: number;\n\n  /**\n   * The start angle of the pie slice.\n   */\n  startAngle: number;\n\n  /**\n   * The angle extent of the pie slice.\n   */\n  angleExtent: number;\n\n  /**\n   * The gaps to keep between the pie slice items.\n   */\n  gap: number;\n\n  /**\n   * The inner radius of the pie slice.\n   */\n  innerRadius: number;\n\n  /**\n   * The color of the pie slice.\n   */\n  color: ColorProps['color'];\n\n  /**\n   * Whether the slice is focused.\n   */\n  isFocused?: boolean;\n\n  /**\n   * Whether the slice is hovered.\n   */\n  isHovered?: boolean;\n\n  /**\n   * The id of the pie slice.\n   */\n  id?: string;\n\n  /**\n   * The index of the item among rendered series.\n   */\n  itemIndex: number;\n\n  /**\n   * The aria label of the pie slice.\n   */\n  accessibleLabel?: string;\n\n  /**\n   * Whether the  pie slice is intercative.\n   */\n  isInteractive?: boolean;\n};\n\n/**\n * The Pie Slice component.\n */\nexport function PieSlice({\n  cx,\n  cy,\n  r,\n  startAngle,\n  angleExtent,\n  gap,\n  innerRadius,\n  color,\n  id,\n  itemIndex,\n  isFocused = false,\n  isInteractive,\n  ...props\n}: PieSliceProps) {\n  const { interactiveItemStyle, contrastBorder, innerShapes } = styles;\n  const itemClasses = classNames([\n    isInteractive && interactiveItemStyle,\n    contrastBorder,\n    innerShapes\n  ]);\n  const path = makeWedgePath(0, cx, cy, r, r, innerRadius, angleExtent, gap, startAngle);\n  let innerPath;\n  if (isFocused) {\n    innerPath = makeWedgePath(2, cx, cy, r, r, innerRadius, angleExtent, gap, startAngle);\n    return (\n      <g\n        id={id}\n        role={props.accessibleLabel ? 'img' : undefined}\n        data-oj-private-item-index={itemIndex}\n        data-oj-private-object=\"pieSlice\"\n        aria-label={props.accessibleLabel}>\n        <path d={path} fill={color} stroke={color} className={styles.innerShapes} />\n        <path d={innerPath} fill={color} className={itemClasses} />\n      </g>\n    );\n  }\n  return (\n    <path\n      role={props.accessibleLabel ? 'img' : undefined}\n      aria-label={props.accessibleLabel}\n      d={path}\n      data-oj-private-object=\"pieSlice\"\n      fill={color}\n      id={id}\n      data-oj-private-item-index={itemIndex}\n      className={isInteractive ? interactiveItemStyle : undefined}\n    />\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { type gestureTypes, useContextMenu } from '#hooks/PRIVATE_useVisContextMenu';\nimport type {\n  PieChartContextMenuContext,\n  PieChartContextMenuConfig,\n  PieChartItemData\n} from './pieChart.types';\nimport { ItemInfo } from '#hooks/PRIVATE_usePieChartNav';\n\nimport { getInfo } from '#utils/UNSAFE_visUtils';\n\ntype Props<D> = {\n  offset: {\n    mainAxis: number;\n    crossAxis: number;\n  };\n  rootRef: RefObject<HTMLDivElement>;\n  contextMenuConfig?: PieChartContextMenuConfig<D>;\n  focusedItemInfo: ItemInfo;\n  items: D[];\n  onContextMenuDismissed?: (gesture: gestureTypes) => void;\n  width: number;\n  isRtl: boolean;\n};\n\nexport const usePieChartContextMenu = <K, D extends PieChartItemData<K>>({\n  offset,\n  rootRef,\n  contextMenuConfig,\n  focusedItemInfo,\n  items,\n  onContextMenuDismissed,\n  width,\n  isRtl\n}: Props<D>) => {\n  const { contextMenuProps, contextMenuContent } = useContextMenu<PieChartContextMenuContext<D>>({\n    onContextMenuHandler: ({ gesture, target }) => {\n      if (gesture === 'keyboard') {\n        const itemIndex = focusedItemInfo.itemIndex;\n        const data = items[itemIndex];\n        const context = {\n          type: 'item' as const,\n          data\n        };\n        return {\n          type: 'offset',\n          context,\n          offsetValue: offset,\n          isRtl,\n          width\n        };\n      }\n\n      const itemIndex = getInfo(rootRef, target as HTMLElement)?.itemIndex;\n      const data = itemIndex !== undefined ? items[itemIndex] : null;\n\n      let context;\n      if (data) {\n        context = {\n          type: 'item' as const,\n          data: data\n        };\n      } else if (rootRef.current?.children[1].contains(target)) {\n        context = { type: 'centerLabel' as const };\n      } else {\n        context = { type: 'background' as const };\n      }\n      return {\n        type: 'pointer',\n        context\n      };\n    },\n    contextMenuOptions: {\n      isDisabled: !contextMenuConfig //If there is no context menu renderer, we disable the hook\n    },\n    rootRef,\n    contextMenuConfig,\n    onContextMenuDismissed\n  });\n\n  return { contextMenuContent, contextMenuProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Font, GetTextDimensionsType, TextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { getTextInfo } from '#PRIVATE_VisSVGText';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { PieSliceInfo } from './pieChart.types';\nimport { degreesToRads } from './utils';\n\ntype TextInfo = {\n  lines: string[];\n  dims: TextDimensions[];\n  didNotFit: boolean;\n  height: number;\n  width: number;\n  isMultiline: boolean;\n  lineHeight: number;\n  isTruncated: boolean;\n};\n\nexport type PieLabelInfo<K> = {\n  position: number;\n  angle: number;\n  slice: PieSliceInfo<K>;\n  width: number;\n  height: number;\n  x?: number;\n  y?: number;\n  minY?: number;\n  maxY?: number;\n  startPt?: {\n    x: number;\n    y: number;\n  };\n  endPt?: {\n    x: number;\n    y: number;\n  };\n  midPt?: {\n    x: number;\n    y: number;\n  };\n  textInfo?: TextInfo;\n};\n\nconst OUTSIDE_LABEL_DISTANCE = 1.04;\nconst _COLLISION_MARGIN = 1;\nconst _FEELER_RAD_MINSIZE = 0.1;\nconst _FEELER_HORIZ_MINSIZE = 0.1;\nconst _LABEL_TO_FEELER_OFFSET = 0.5;\nconst _ALL_COLLISION = 2;\nconst _HALF_COLLISION = 1;\nconst _NO_COLLISION = 0;\nconst _LABEL_TO_FEELER_DISTANCE = 3;\n\nfunction degreesToRadians(degrees: number) {\n  return degrees * (Math.PI / 180);\n}\n\nfunction reflectAngleOverYAxis(angle: number, cx: number, cy: number, rx: number, ry: number) {\n  const radian = degreesToRadians(360 - angle);\n  const cosine = Math.cos(radian);\n  const sine = Math.sin(radian);\n\n  return { x: cx + cosine * rx, y: cy + sine * ry };\n}\n\nfunction skipSliceLabel<K>(slice: PieSliceInfo<K>, seriesCount: number) {\n  const { angleExtent } = slice;\n  return angleExtent < 3 && seriesCount > 120;\n}\n\n/**\n * Returns true if this slice contains the given coordinates.\n * @param {number} x\n * @param {number} y\n * @return {boolean}\n */\nexport function sliceContainsPoint<K>(\n  slice: PieSliceInfo<K>,\n  x: number,\n  y: number,\n  cx: number,\n  cy: number,\n  innerRadius: number,\n  radius: number\n) {\n  const { angleExtent, startAngle } = slice;\n  const ir = innerRadius;\n  const c = { x: cx, y: cy };\n  const cos = (x - c.x) / radius;\n  const sin = (y - c.y) / radius;\n\n  // Compute the angle\n  let angle = -Math.atan2(sin, cos) * (180 / Math.PI); // in degrees\n  // First adjust angle to be greater than the start angle.\n  while (angle < startAngle) angle += 360;\n  // Then adjust to be within 360 degrees of it\n  while (angle - startAngle >= 360) angle -= 360;\n\n  const distance = Math.pow(cos, 2) + Math.pow(sin, 2);\n  const containsRadius = Math.sqrt(distance) > ir / radius && distance <= 1;\n  const containsAngle = angle <= startAngle + angleExtent;\n  return containsRadius && containsAngle;\n}\n\nexport function getInsideLabelsInfo<K>(\n  slices: PieSliceInfo<K>[],\n  innerRadius: number,\n  radius: number,\n  pieCenter: { cx: number; cy: number },\n  defaultFontSize: string,\n  getTextDimensions: GetTextDimensionsType\n): [PieLabelInfo<K>[], Set<number>] {\n  const insideLabels: PieLabelInfo<K>[] = [];\n\n  const outsideLabelsIndex = new Set<number>();\n\n  const { cx, cy } = pieCenter;\n\n  for (const slice of slices) {\n    const { labelPosition: l, startAngle, angleExtent, label, labelStyle } = slice;\n    const labelPosition = l || 'auto';\n\n    if (labelPosition === 'none') {\n      continue;\n    }\n\n    if (labelPosition === 'outside' || skipSliceLabel(slice, slices.length) || label == null) {\n      outsideLabelsIndex.add(slice.index);\n      continue;\n    }\n\n    const midAngle = startAngle + angleExtent / 2;\n    const ir = innerRadius;\n    const center = pieCenter;\n    let posX, posY;\n\n    if (slices.length === 1) {\n      posX = center.cx;\n      posY = center.cy;\n    } else {\n      const offset = Math.max(0.45, 0.65 - (0.45 * ir) / Math.max(radius, 0.001));\n      const midPt = reflectAngleOverYAxis(\n        midAngle,\n        center.cx,\n        center.cy,\n        ir + (radius - ir) * offset,\n        ir + (radius - ir) * offset\n      );\n\n      posX = midPt.x;\n      posY = midPt.y;\n    }\n\n    const sliceLabelPosition = {\n      x: posX,\n      y: posY\n    };\n\n    const sliceLabelDims = getTextDimensions(label, { fontSize: defaultFontSize, ...labelStyle });\n\n    let x1 = posX;\n    let x2 = posX;\n    const y1 = posY - sliceLabelDims.height / 2;\n    const y2 = posY + sliceLabelDims.height / 2;\n\n    while (\n      sliceContainsPoint(slice, x1, y1, cx, cy, innerRadius, radius) &&\n      sliceContainsPoint(slice, x1, y2, cx, cy, innerRadius, radius)\n    ) {\n      x1--;\n    }\n\n    while (\n      sliceContainsPoint(slice, x2, y1, cx, cy, innerRadius, radius) &&\n      sliceContainsPoint(slice, x2, y2, cx, cy, innerRadius, radius)\n    ) {\n      x2++;\n    }\n\n    x1 = Math.ceil(x1 + 3);\n    x2 = Math.floor(x2 - 3);\n\n    let usableSpace = 2 * Math.min(posX - x1, x2 - posX);\n    if (usableSpace < sliceLabelDims.width) {\n      sliceLabelPosition.x = (x1 + x2) / 2;\n      usableSpace = x2 - x1;\n    }\n\n    if (labelPosition === 'inside') {\n      const textWidth = sliceLabelDims.width;\n      if (textWidth < usableSpace) {\n        insideLabels.push({\n          position: midAngle,\n          angle: midAngle,\n          slice,\n          textInfo: getTextInfo(\n            label,\n            { fontSize: defaultFontSize, ...labelStyle },\n            usableSpace,\n            sliceLabelDims.height,\n            false,\n            label.length,\n            getTextDimensions\n          ),\n          ...sliceLabelDims,\n          ...sliceLabelPosition\n        });\n      }\n    } else {\n      const minChars = label.length;\n      const textInfo = getTextInfo(\n        label,\n        { fontSize: defaultFontSize, ...labelStyle },\n        usableSpace,\n        sliceLabelDims.height,\n        false,\n        minChars,\n        getTextDimensions\n      );\n\n      if (!textInfo.didNotFit) {\n        insideLabels.push({\n          position: midAngle,\n          angle: midAngle,\n          slice,\n          textInfo,\n          ...sliceLabelDims,\n          ...sliceLabelPosition\n        });\n      } else {\n        outsideLabelsIndex.add(slice.index); // Indicates outside label is needed\n      }\n    }\n  }\n  return [insideLabels, outsideLabelsIndex];\n}\n\nexport const layoutPieChartLabels = <K>(\n  slices: PieSliceInfo<K>[],\n  pieCenter: { cx: number; cy: number },\n  innerRadius: number,\n  radius: number,\n  availSpace: Dimension,\n  getTextDimensions: GetTextDimensionsType,\n  defaultFontSize: string\n) => {\n  const [insideLabels, outsideLabels] = getInsideLabelsInfo(\n    slices,\n    innerRadius,\n    radius,\n    pieCenter,\n    defaultFontSize,\n    getTextDimensions\n  );\n\n  const { leftLabels, rightLabels } = generateInitialLayout(\n    slices,\n    outsideLabels,\n    availSpace,\n    pieCenter,\n    radius,\n    defaultFontSize,\n    getTextDimensions\n  );\n\n  const leftColl = _refineInitialLayout(slices, radius, pieCenter, availSpace, leftLabels, 'left');\n  const rightColl = _refineInitialLayout(\n    slices,\n    radius,\n    pieCenter,\n    availSpace,\n    rightLabels,\n    'right'\n  );\n\n  if (leftColl === _HALF_COLLISION && rightColl !== _NO_COLLISION) {\n    _columnLabels(slices, availSpace, pieCenter, radius, leftLabels, true, true, true);\n  }\n\n  if (leftColl !== _NO_COLLISION && rightColl === _HALF_COLLISION) {\n    _columnLabels(slices, availSpace, pieCenter, radius, rightLabels, false, true, true);\n  }\n\n  setLabelsAndFeelers(\n    leftLabels,\n    availSpace,\n    pieCenter,\n    radius,\n    'left',\n    { fontSize: defaultFontSize },\n    getTextDimensions\n  );\n\n  setLabelsAndFeelers(\n    rightLabels,\n    availSpace,\n    pieCenter,\n    radius,\n    'right',\n    { fontSize: defaultFontSize },\n    getTextDimensions\n  );\n\n  return { insideLabels, rightLabels, leftLabels };\n};\n\nexport function generateInitialLayout<K>(\n  slices: PieSliceInfo<K>[],\n  outsideLabels: Set<number>,\n  availSpace: Dimension,\n  center: { cx: number; cy: number },\n  radius: number,\n  defaultFontSize: string,\n  getTextDimensions: GetTextDimensionsType\n) {\n  const leftLabels: PieLabelInfo<K>[] = [];\n  const rightLabels: PieLabelInfo<K>[] = [];\n  const { cx, cy } = center;\n\n  for (let i = 0; i < slices.length; i++) {\n    const slice = slices[i];\n    const { labelPosition, startAngle, angleExtent, label, labelStyle } = slice;\n\n    if (\n      label == null ||\n      labelPosition == 'none' ||\n      labelPosition == 'inside' ||\n      skipSliceLabel(slices[i], slices.length) ||\n      !outsideLabels.has(slice.index)\n    ) {\n      continue;\n    }\n\n    let middleAngle = startAngle + angleExtent / 2;\n    if (middleAngle > 360) middleAngle -= 360;\n    if (middleAngle < 0) middleAngle += 360;\n\n    const labelPt = reflectAngleOverYAxis(\n      middleAngle,\n      cx,\n      cy,\n      radius * OUTSIDE_LABEL_DISTANCE,\n      radius * OUTSIDE_LABEL_DISTANCE\n    );\n\n    const isLeftSide = middleAngle >= 90 && middleAngle < 270;\n    const maxLabelWidth = getMaxLabelWidth(availSpace, labelPt.x, isLeftSide);\n\n    const textInfo = getTextInfo(\n      label,\n      { fontSize: defaultFontSize, ...labelStyle },\n      maxLabelWidth,\n      Infinity,\n      true,\n      1,\n      getTextDimensions\n    );\n    const tmDimPt = { x: textInfo.width, y: textInfo.height };\n\n    const midArea = 15;\n\n    if (middleAngle < 180 - midArea && middleAngle > midArea) {\n      //upper half\n      labelPt.y -= tmDimPt.y * 1;\n    } else if (middleAngle < midArea || middleAngle > 360 - midArea) {\n      //right side, near horizontal\n      labelPt.y -= tmDimPt.y * 0.5;\n      labelPt.x += tmDimPt.y * 0.2;\n    } else if (middleAngle > 180 - midArea && middleAngle < 180 + midArea) {\n      //left side, near horizontal\n      labelPt.y -= tmDimPt.y * 0.5;\n      labelPt.x -= tmDimPt.y * 0.2;\n    }\n\n    if (slices.length == 1)\n      // only 1 label\n      labelPt.x -= tmDimPt.x / 2; //position the label at the center\n\n    if (labelPt.y < availSpace.y || labelPt.y + tmDimPt.y > availSpace.y + availSpace.height)\n      // label will not fit with appropriate spacing\n      continue;\n\n    let pa;\n    if (middleAngle >= 90.0 && middleAngle < 270.0) {\n      pa = middleAngle - 90.0;\n      createLabelInfo(slice, middleAngle, pa, tmDimPt, labelPt, textInfo, leftLabels);\n    } else {\n      // right side\n      // normalize from 0 to 180\n      pa = middleAngle <= 90.0 ? Math.abs(90 - middleAngle) : 180 - (middleAngle - 270);\n      createLabelInfo(slice, middleAngle, pa, tmDimPt, labelPt, textInfo, rightLabels);\n    }\n  }\n\n  return { leftLabels, rightLabels };\n}\n\nexport function getMaxLabelWidth(availSpace: Dimension, labelX: number, isLeftSide: boolean) {\n  return isLeftSide ? labelX - availSpace.x : availSpace.x + availSpace.width - labelX;\n}\n\nexport function createLabelInfo<K>(\n  slice: PieSliceInfo<K>,\n  midAngle: number,\n  position: number,\n  tmDimPt: { x: number; y: number },\n  labelPt: { x: number; y: number },\n  textInfo: TextInfo,\n  labelInfoArray: PieLabelInfo<K>[]\n) {\n  let insertPos = -1;\n\n  // insertion \"sort\"\n  for (let j = 0; j < labelInfoArray.length; j++) {\n    const labelInfo = labelInfoArray[j];\n    if (labelInfo['position'] && labelInfo['position'] > position) {\n      insertPos = j;\n      break;\n    }\n  }\n\n  if (insertPos == -1) insertPos = labelInfoArray.length;\n\n  const labelInfo = {\n    position,\n    angle: midAngle,\n    width: tmDimPt.x,\n    height: tmDimPt.y,\n    x: labelPt.x,\n    y: labelPt.y,\n    slice,\n    textInfo\n  };\n\n  labelInfoArray.splice(insertPos, 0, labelInfo);\n}\n\nexport function _refineInitialLayout<K>(\n  slices: PieSliceInfo<K>[],\n  radius: number,\n  center: { cx: number; cy: number },\n  availableSpace: Dimension,\n  labelInfoArray: PieLabelInfo<K>[],\n  side: 'left' | 'right'\n) {\n  if (labelInfoArray.length < 1) {\n    return;\n  }\n\n  let lastY = availableSpace.y; //think again!!\n  let collisionTop = false;\n  let collisionCentral = false;\n  let collisionBottom = false;\n  let labelBottom = 0;\n\n  let labelInfo;\n\n  let bottomQuarter = false;\n  let prevBottomQuarter;\n  let collide = false;\n  const isLeftSideLabels = side == 'left';\n\n  for (let i = 0; i < labelInfoArray.length; i++) {\n    labelInfo = labelInfoArray[i];\n\n    prevBottomQuarter = bottomQuarter;\n    if (labelInfo.position! > 90) bottomQuarter = true;\n\n    labelBottom = labelInfo.y! + labelInfo.height!;\n\n    collide = lastY - labelInfo.y! > _COLLISION_MARGIN;\n\n    if (collide) {\n      if (!bottomQuarter) {\n        collisionTop = true;\n      } else if (!prevBottomQuarter) {\n        collisionCentral = true;\n      } else {\n        collisionBottom = true;\n      }\n    }\n\n    if (labelBottom > lastY) {\n      lastY = labelBottom;\n    }\n  }\n\n  if ((collisionTop && collisionBottom) || collisionCentral) {\n    _columnLabels(\n      slices,\n      availableSpace,\n      center,\n      radius,\n      labelInfoArray,\n      isLeftSideLabels,\n      true,\n      true\n    );\n    return _ALL_COLLISION;\n  } else if (collisionTop) {\n    _columnLabels(\n      slices,\n      availableSpace,\n      center,\n      radius,\n      labelInfoArray,\n      isLeftSideLabels,\n      true,\n      false\n    );\n    return _HALF_COLLISION;\n  } else if (collisionBottom) {\n    _columnLabels(\n      slices,\n      availableSpace,\n      center,\n      radius,\n      labelInfoArray,\n      isLeftSideLabels,\n      false,\n      true\n    );\n    return _HALF_COLLISION;\n  }\n  return _NO_COLLISION;\n}\n\nexport function _getRadFeelerAngle<K>(\n  labelInfo: PieLabelInfo<K>,\n  x: number,\n  y: number,\n  radius: number,\n  center: { cx: number; cy: number }\n) {\n  const ma = labelInfo.angle;\n  const startPt = reflectAngleOverYAxis(ma, center.cx, center.cy, radius, radius);\n  return Math.atan2(Math.abs(x - startPt.x), startPt.y - y);\n}\n\nexport function getMiddleLabel<K>(alabels: PieLabelInfo<K>[]) {\n  let bestAngle = 91;\n  let bestIndex = -1;\n  for (let i = 0; i < alabels.length; i++) {\n    const pa = alabels[i]['position']!;\n    if (Math.abs(pa - 90) < bestAngle) {\n      bestAngle = Math.abs(pa - 90);\n      bestIndex = i;\n    }\n  }\n  return bestIndex;\n}\n\nexport function setOptimalLabelPos<K>(\n  radius: number,\n  labelInfo: PieLabelInfo<K>,\n  vertX: number,\n  center: { cx: number; cy: number }\n) {\n  //set optimal X\n  labelInfo['x'] = vertX;\n\n  const b = radius * (1 + _FEELER_RAD_MINSIZE);\n  const angleInRad = degreesToRads(labelInfo['position']);\n  const heightFromCenter = b * Math.cos(angleInRad);\n  const tilt = 0;\n  let optimalY = center.cy - heightFromCenter - labelInfo.height * _LABEL_TO_FEELER_OFFSET + tilt;\n  const _minY = labelInfo['minY']!;\n  const _maxY = labelInfo['maxY']!;\n  if (_minY <= _maxY) {\n    optimalY = Math.max(optimalY, _minY);\n    optimalY = Math.min(optimalY, _maxY);\n  }\n  labelInfo['y'] = optimalY;\n}\n\nexport function _columnLabels<K>(\n  slices: PieSliceInfo<K>[],\n  availableSpace: Dimension,\n  center: { cx: number; cy: number },\n  radius: number,\n  alabels: PieLabelInfo<K>[],\n  isLeft: boolean,\n  isTop: boolean,\n  isBottom: boolean\n) {\n  const frame = availableSpace;\n  let minY = frame.y;\n  let maxY = frame.y + frame.height;\n  let i;\n  let labelInfo;\n  let pa = 0;\n  let radFeelerAngle;\n\n  //determine the position where the column will be aligned\n  let vertX = center.cx;\n  let feelerX;\n  const minFeelerDist = radius * (1 + _FEELER_RAD_MINSIZE + _FEELER_HORIZ_MINSIZE);\n\n  if (isLeft) {\n    vertX -= minFeelerDist;\n    feelerX = vertX + radius * _FEELER_HORIZ_MINSIZE;\n  } else {\n    vertX += minFeelerDist;\n    feelerX = vertX - radius * _FEELER_HORIZ_MINSIZE;\n  }\n\n  //set the minimum heights that ensures as many labels as possible are displayed\n  for (i = 0; i < alabels.length; i++) {\n    labelInfo = alabels[i];\n    pa = degreesToRads(labelInfo.position);\n    radFeelerAngle = _getRadFeelerAngle(labelInfo, feelerX, minY, radius, center);\n\n    // Remove labels that are more than a certain angle away from the slice.\n    if (radFeelerAngle - pa > 0.45 * Math.PI || skipSliceLabel(alabels[i].slice, slices.length)) {\n      alabels.splice(i, 1);\n      i--;\n    } else {\n      alabels[i].minY = minY;\n      minY += alabels[i].height;\n    }\n  }\n\n  //set the maximum heights that ensures as many labels as possible are displayed\n  for (i = alabels.length - 1; i >= 0; i--) {\n    labelInfo = alabels[i];\n    const position = labelInfo['position'];\n    pa = degreesToRads(position);\n    radFeelerAngle = _getRadFeelerAngle(labelInfo, feelerX, maxY, radius, center);\n\n    // Remove labels that are more than a certain angle away from the slice.\n    if (pa - radFeelerAngle > 0.45 * Math.PI || skipSliceLabel(alabels[i].slice, slices.length)) {\n      alabels.splice(i, 1);\n    } else {\n      maxY -= alabels[i].height;\n      alabels[i].maxY = maxY;\n    }\n  }\n\n  if (alabels.length == 0) return;\n\n  const startIndex = getMiddleLabel(alabels);\n  const startLabel = alabels[startIndex];\n\n  //if the column is only partial but there are too many labels, then set the whole side as column\n  if (isTop && !isBottom) {\n    if (startLabel.minY! + startLabel.height > center.cy) {\n      isBottom = true;\n    }\n  }\n  if (isBottom && !isTop) {\n    if (startLabel.maxY! < center.cy) {\n      isTop = true;\n    }\n  }\n\n  const labelPostion = startLabel['position'];\n  if ((isBottom && isTop) || (labelPostion > 90 && isBottom) || (labelPostion <= 90 && isTop)) {\n    setOptimalLabelPos(radius, startLabel, vertX, center);\n    startLabel.slice.hasFeelers = true;\n  }\n\n  let highestY = startLabel.y!;\n  let lowestY = startLabel.y! + startLabel.height;\n\n  let optimalY;\n  let labelHeight;\n\n  if (isTop) {\n    //labels above the start label\n    for (i = startIndex - 1; i >= 0; i--) {\n      labelInfo = alabels[i];\n      labelHeight = labelInfo.height;\n      setOptimalLabelPos(radius, labelInfo, vertX, center);\n      labelInfo.slice.hasFeelers = true;\n\n      //avoid collision with the label below\n      optimalY = labelInfo.y!;\n      if (optimalY + labelHeight < highestY) {\n        highestY = optimalY;\n      } else {\n        highestY -= labelHeight;\n      }\n      labelInfo.y = highestY;\n    }\n  }\n\n  if (isBottom) {\n    //labels below the start label\n    for (i = startIndex + 1; i < alabels.length; i++) {\n      labelInfo = alabels[i];\n      labelHeight = labelInfo.height;\n      setOptimalLabelPos(radius, labelInfo, vertX, center);\n      labelInfo.slice.hasFeelers = true;\n\n      //avoid collision with the label above\n      optimalY = labelInfo.y!;\n      if (optimalY > lowestY) {\n        lowestY = optimalY + labelHeight;\n      } else {\n        lowestY += labelHeight;\n      }\n      labelInfo.y = lowestY - labelHeight;\n    }\n  }\n}\n\nexport function setLabelsAndFeelers<K>(\n  alabels: PieLabelInfo<K>[],\n  availSpace: Dimension,\n  center: { cx: number; cy: number },\n  radius: number,\n  side: 'left' | 'right',\n  labelStyle: Font,\n  getTextDimension: GetTextDimensionsType\n) {\n  if (alabels == null || alabels.length <= 0) return;\n\n  let i;\n  let slice;\n  let sliceLabel;\n  const isLeftSide = side === 'left';\n  const frame = availSpace;\n\n  let excessWidth = Infinity;\n  let excessLength;\n\n  // Determine how much the horizontal feelers can be shortened\n  for (i = 0; i < alabels.length; i++) {\n    const labelInfo = alabels[i];\n\n    const style = { ...labelStyle, ...labelInfo.slice.labelStyle };\n    if (labelInfo.slice['hasFeelers']) {\n      excessLength = _calculateFeeler(labelInfo, center, radius, isLeftSide);\n\n      const fontHeight = getTextDimension('MW', style).height;\n      const labelWidth = labelInfo['width'];\n      const minLabelWidth = Math.min(2 * fontHeight, labelWidth);\n\n      const maxLabelWidth = getMaxLabelWidth(availSpace, labelInfo['x']!, isLeftSide);\n\n      // Remove feelers for labels that will not be rendered and ignore for excess width calculation\n      if (maxLabelWidth + excessLength < minLabelWidth || labelInfo['width'] == 0) {\n        labelInfo.textInfo = undefined;\n        labelInfo.slice.hasFeelers = false;\n        continue;\n      }\n      excessWidth = Math.min(excessWidth, excessLength);\n    } else {\n      labelInfo.slice.hasFeelers = false;\n    }\n  }\n\n  for (i = 0; i < alabels.length; i++) {\n    const labelInfo = alabels[i];\n    slice = labelInfo.slice;\n    sliceLabel = labelInfo.slice.label;\n    if (!sliceLabel) continue;\n\n    if (labelInfo.slice.hasFeelers) {\n      // shorten the horizontal feelers\n      if (isLeftSide) {\n        labelInfo.x = labelInfo.x! + excessWidth;\n      } else {\n        labelInfo.x = labelInfo.x! - excessWidth;\n      }\n      // setup the feeler line (let it clip if needed)\n      _calculateFeeler(labelInfo, center, radius, isLeftSide);\n    }\n\n    // perform 'logical' clipping ourselves\n    if (labelInfo.y! < frame.y || labelInfo.y! + labelInfo.height > frame.y + frame.height) {\n      slice.label = '';\n      slice.hasFeelers = false;\n    } else {\n      const maxLabelWidth = getMaxLabelWidth(availSpace, labelInfo.x!, isLeftSide);\n      const textInfo =\n        labelInfo.textInfo &&\n        getTextInfo(\n          labelInfo.slice.label!,\n          { ...labelStyle, ...labelInfo.slice.labelStyle },\n          maxLabelWidth,\n          labelInfo.textInfo.height!,\n          true,\n          1,\n          getTextDimension\n        );\n      labelInfo.textInfo = textInfo;\n      if (labelInfo.height === 0 || labelInfo.width === 0) {\n        slice.label = '';\n        slice.hasFeelers = false;\n      }\n    }\n  }\n}\n\nexport function _calculateFeeler<K>(\n  labelInfo: PieLabelInfo<K>,\n  center: { cx: number; cy: number },\n  radius: number,\n  isLeft: boolean\n) {\n  const { x, y, height } = labelInfo;\n  let targetX = x!;\n  const targetY = y! + height * _LABEL_TO_FEELER_OFFSET;\n  const minHorizLength = _FEELER_HORIZ_MINSIZE * radius;\n\n  let midX;\n  if (isLeft) {\n    targetX += _LABEL_TO_FEELER_DISTANCE;\n    midX = targetX + minHorizLength;\n  } else {\n    targetX -= _LABEL_TO_FEELER_DISTANCE;\n    midX = targetX - minHorizLength;\n  }\n\n  const midPt = {\n    x: midX,\n    y: targetY\n  };\n  const endPt = {\n    x: targetX,\n    y: targetY\n  };\n  const ma = labelInfo.angle;\n\n  const startPt = reflectAngleOverYAxis(ma, center.cx, center.cy, radius, radius);\n\n  // make set the first section of the feeler radial if possible\n  const pa = degreesToRads(labelInfo['position']);\n  const radFeelerAngle = Math.abs(Math.atan2(midPt.x - startPt.x, startPt.y - midPt.y));\n  const horizOffset = (startPt.y - midPt.y) * Math.tan(pa); // * pieChart.getRadiusX() / pieChart.getRadiusY();\n  if (\n    (pa > Math.PI / 2 && radFeelerAngle > Math.PI / 2 && radFeelerAngle < pa) ||\n    (pa < Math.PI / 2 && radFeelerAngle < Math.PI / 2 && radFeelerAngle > pa)\n  ) {\n    if (isLeft) {\n      midPt.x = startPt.x - horizOffset;\n    } else {\n      midPt.x = startPt.x + horizOffset;\n    }\n  }\n\n  //store outside feeler points on slice\n  //and let slice draw the feeler so that we can\n  //easily redraw it when selecting\n  labelInfo['startPt'] = startPt;\n  labelInfo['midPt'] = midPt;\n  labelInfo['endPt'] = endPt;\n  return Math.abs(endPt.x - midPt.x) - minHorizLength;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getContrastingTextColor } from '#utils/PRIVATE_colorUtils';\nimport { PieLabelInfo } from './labelUtils';\nimport { styles } from './themes/PieChartStyles.css';\n\ntype LabelProps<K> = {\n  pieLabelInfo: PieLabelInfo<K>;\n  labelPos: 'inside' | 'left' | 'right';\n  fontSize: string;\n  isRtl: boolean;\n};\n\nexport function PieChartLabel<K>({ pieLabelInfo, labelPos, fontSize, isRtl }: LabelProps<K>) {\n  const { x, y, textInfo, slice, startPt, midPt, endPt } = pieLabelInfo;\n  const color = slice.color as string;\n  const fill = labelPos === 'inside' ? getContrastingTextColor(color) : undefined;\n  return (\n    <>\n      {textInfo?.lines.map((line: any, i: number) => {\n        const lineX = x!;\n        const lineY = y! + (i + 0.5) * textInfo.dims[i].height;\n        const textAnchor =\n          (isRtl && labelPos === 'left') || (!isRtl && labelPos === 'right')\n            ? 'start'\n            : labelPos === 'inside'\n            ? 'middle'\n            : 'end';\n        return (\n          <>\n            {slice.label && (\n              <text\n                className={styles.labelStyle}\n                x={lineX}\n                y={lineY}\n                textAnchor={textAnchor}\n                dominantBaseline={labelPos === 'inside' ? 'center' : 'middle'}\n                style={{\n                  fill,\n                  fontSize\n                }}>\n                {line}\n              </text>\n            )}\n            {slice.hasFeelers && startPt && midPt && endPt && (\n              <>\n                <line\n                  x1={startPt.x}\n                  x2={midPt.x}\n                  y1={startPt.y}\n                  y2={midPt.y}\n                  className={styles.fillerLineStyle}></line>\n                <line\n                  x1={endPt.x}\n                  x2={midPt.x}\n                  y1={endPt.y}\n                  y2={midPt.y}\n                  className={styles.fillerLineStyle}></line>\n              </>\n            )}\n          </>\n        );\n      })}\n    </>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { styles } from './themes/PieChartStyles.css';\nimport {\n  getDefaultBorderColor,\n  getElementBounds,\n  getPieCenter,\n  getRadius,\n  getRenderedSlices,\n  getPieChartInfo,\n  getPieSliceGap,\n  getSliceInfo\n} from './utils';\nimport { getAvailSpace } from '#utils/PRIVATE_chartUtils/layoutUtils';\nimport { PieSlice } from './PieSlice';\nimport { getCenterContext } from './utils';\nimport { getPieChartNavUtils } from './pieNavUtils';\nimport { ItemInfo, usePieChartNav } from '#hooks/PRIVATE_usePieChartNav';\nimport { useDatatip } from '#hooks/PRIVATE_useDatatip';\nimport { calculateOffset } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { VisTabularDatatip } from '#PRIVATE_VisTabularDatatip';\nimport type { PieChartProps, PieChartItemData } from './pieChart.types';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { useTestId } from '#hooks/UNSAFE_useTestId';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { useRef } from 'preact/hooks';\nimport { merge } from '@oracle/oraclejet-internal-utilities/stringUtils';\nimport { usePieChartContextMenu } from './usePieChartContextMenu';\nimport { layoutPieChartLabels, PieLabelInfo } from './labelUtils';\nimport { useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { useCssVars } from '#hooks/PRIVATE_useCssVars';\nimport { getChartVars } from '#utils/PRIVATE_chartUtils';\nimport { PieChartLabel } from './PieChartLabel';\n\ntype PieChartWithDimensionsProps<K, D> = Omit<PieChartProps<K, D>, 'width' | 'height'> & {\n  width: number;\n  height: number;\n};\n\nconst NUM_PIE_SLICE_THRESHOLD = 100;\n\nconst chartVars = getChartVars();\n\nexport function PieChartWithDimensions<\n  K extends string | number,\n  D extends PieChartItemData<K> = PieChartItemData<K>\n>({\n  width,\n  height,\n  testId,\n  innerRadius = 0,\n  contextMenuConfig,\n  drilling = 'off',\n  selectionMode = 'none',\n  onItemDrill,\n  onItemHover,\n  onItemFocus,\n  ...props\n}: PieChartWithDimensionsProps<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n\n  const { resolvedVars, cssContent } = useCssVars(chartVars);\n  const colors = Array.from(Array(12)).map((_, index) => {\n    return resolvedVars[`color${index + 1}`];\n  });\n\n  const data = isRtl ? props.data.slice().reverse() : props.data;\n  const { totalValue, isLabelOutside } = getPieChartInfo(data);\n  const sliceInfos = getSliceInfo(data, totalValue, colors, isRtl);\n  const hasData = data.length > 0;\n\n  // default data item gaps is 0.5. TODO: replace 0.5 with pie dataItemGaps/pieSliceGaps\n  const pieSliceGap = getPieSliceGap(0.5);\n  const hasLargeSeriesCount = data.length > NUM_PIE_SLICE_THRESHOLD;\n\n  const testIdProps = useTestId(testId);\n  const availSpace = getAvailSpace(width, height, false);\n  const { cx, cy } = getPieCenter(availSpace);\n  const radius = getRadius(availSpace, isLabelOutside);\n  const ir = innerRadius * radius;\n  const renderedSlices = getRenderedSlices(sliceInfos, hasLargeSeriesCount, radius);\n  const { getDetailFromInfo, getNextChartItem } = getPieChartNavUtils<K, D>(\n    data,\n    direction === 'rtl'\n  );\n\n  const { textMeasureContent, getTextDimensions } = useTextDimensions();\n\n  const supportsSelection = !!(selectionMode && selectionMode !== 'none');\n  const supportsDrill = drilling === 'on';\n  // const isReadOnly = !supportsSelection && !supportsDrill && onItemHover === null && onItemFocus === null;\n  const { touchResponse, touchResponseStyle } = useVisTouchResponse({\n    type: 'auto',\n    supportsTouchDragGestures: false,\n    rootRef\n  });\n\n  const { activeId, focusedItemInfo, hoveredItemInfo, eventsProps, onContextMenuDismissed } =\n    usePieChartNav<K, D>(touchResponse, getDetailFromInfo, getNextChartItem, drilling, onItemDrill);\n  const activeItem = focusedItemInfo.isFocusVisible ? focusedItemInfo : hoveredItemInfo;\n  const activeData = activeItem ? data[renderedSlices[activeItem.itemIndex].index] : undefined;\n\n  const defaultDatatip = (activeData?: PieChartItemData<K>, activeItem?: ItemInfo) => {\n    if (!activeData) {\n      return {\n        content: undefined,\n        borderColor: undefined\n      };\n    }\n    if (activeData.accessibleLabel) {\n      return {\n        content: activeData.accessibleLabel,\n        borderColor: getDefaultBorderColor(colors, activeItem, activeData)\n      };\n    }\n    return {\n      content: (\n        <VisTabularDatatip\n          tableData={[\n            {\n              key: 'Value',\n              value: activeData.value\n            }\n          ]}\n        />\n      ),\n      borderColor: getDefaultBorderColor(colors, activeItem, activeData)\n    };\n  };\n\n  const { content: datatipString, borderColor } =\n    activeData && props.datatip\n      ? props.datatip({ data: activeData })\n      : defaultDatatip(activeData, activeItem);\n\n  const anchor = focusedItemInfo.isFocusVisible ? 'element' : 'pointer';\n\n  const elementBounds = activeItem?.isFocusVisible\n    ? getElementBounds(renderedSlices, cx, cy, ir, radius, activeItem)\n    : undefined;\n\n  const offset = calculateOffset(isRtl, width, elementBounds);\n  const { datatipContent, datatipProps } = useDatatip({\n    content: datatipString,\n    offset,\n    anchor,\n    placement: 'top-start',\n    borderColor,\n    touchResponse\n  });\n\n  datatipProps['aria-describedby'] = merge([\n    props['aria-describedby'],\n    datatipProps['aria-describedby']\n  ]);\n\n  const { contextMenuContent, contextMenuProps } = usePieChartContextMenu<K, D>({\n    offset,\n    rootRef,\n    contextMenuConfig: hasData ? contextMenuConfig : undefined,\n    onContextMenuDismissed,\n    focusedItemInfo,\n    items: sliceInfos,\n    width,\n    isRtl\n  });\n\n  const mergedProps = mergeProps(eventsProps, datatipProps, contextMenuProps);\n\n  let insideLabels: PieLabelInfo<K>[] = [];\n  let rightLabels: PieLabelInfo<K>[] = [];\n  let leftLabels: PieLabelInfo<K>[] = [];\n\n  const defaultFontSize = resolvedVars['labelFontSize'];\n\n  if (getTextDimensions) {\n    const labels = layoutPieChartLabels(\n      renderedSlices,\n      { cx, cy },\n      ir,\n      radius,\n      availSpace,\n      getTextDimensions,\n      defaultFontSize\n    );\n    insideLabels = labels.insideLabels;\n    rightLabels = labels.rightLabels;\n    leftLabels = labels.leftLabels;\n  }\n\n  return (\n    <div\n      ref={rootRef}\n      tabIndex={0}\n      aria-label={props['aria-label']}\n      aria-labelledby={props['aria-labelledby']}\n      aria-activedescendant={activeId}\n      role=\"application\"\n      {...mergedProps}\n      {...testIdProps}\n      className={styles.chart}\n      style={{\n        width,\n        height,\n        ...touchResponseStyle\n      }}>\n      {renderedSlices.length > 0 && (\n        <svg className={styles.svg}>\n          {renderedSlices.map((item, index: number) => {\n            return (\n              <PieSlice\n                isInteractive={supportsSelection || supportsDrill}\n                cx={cx}\n                cy={cy}\n                itemIndex={index}\n                id={activeItem?.itemIndex === index ? activeId : undefined}\n                isFocused={focusedItemInfo?.itemIndex === index && focusedItemInfo?.isFocusVisible}\n                isHovered={hoveredItemInfo?.itemIndex === index}\n                r={radius}\n                startAngle={item.startAngle}\n                gap={pieSliceGap}\n                innerRadius={ir}\n                angleExtent={item.angleExtent}\n                color={item.color}\n                key={item.id}\n                accessibleLabel={item.accessibleLabel}\n              />\n            );\n          })}\n          {insideLabels?.map((v) => {\n            return (\n              <PieChartLabel\n                isRtl={isRtl}\n                pieLabelInfo={v}\n                labelPos=\"inside\"\n                fontSize={defaultFontSize}\n              />\n            );\n          })}\n          {leftLabels?.map((v) => {\n            return (\n              <PieChartLabel\n                isRtl={isRtl}\n                pieLabelInfo={v}\n                labelPos=\"left\"\n                fontSize={defaultFontSize}\n              />\n            );\n          })}\n          {rightLabels?.map((v) => {\n            return (\n              <PieChartLabel\n                isRtl={isRtl}\n                pieLabelInfo={v}\n                labelPos=\"right\"\n                fontSize={defaultFontSize}\n              />\n            );\n          })}\n        </svg>\n      )}\n      {props.children?.(getCenterContext(cx, cy, ir))}\n      {datatipContent}\n      {cssContent}\n      {contextMenuContent}\n      {textMeasureContent}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type {\n  ItemFocusDetail,\n  ItemHoverDetail,\n  ItemInfo,\n  PieChartItemData\n} from './pieChart.types';\n\n/**\n * Returns the item based on item info in a pie chart.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getItem<K, D extends PieChartItemData<K>>(itemInfo: ItemInfo, items: D[]) {\n  const { itemIndex } = itemInfo;\n  return items[itemIndex];\n}\n\n/**\n * Returns the nav util for pie chart.\n * @param data\n * @param isRtl\n * @returns\n */\nexport function getPieChartNavUtils<K, D extends PieChartItemData<K>>(data: D[], isRtl: boolean) {\n  return {\n    getNextChartItem: (\n      { itemIndex }: { itemIndex: number },\n      arrow: 'ArrowLeft' | 'ArrowRight' | 'ArrowDown' | 'ArrowUp'\n    ): { itemIndex: number } => {\n      let newItemIndex = itemIndex;\n      if (\n        (isRtl && (arrow === 'ArrowRight' || arrow === 'ArrowUp')) ||\n        (!isRtl && (arrow === 'ArrowLeft' || arrow === 'ArrowDown'))\n      ) {\n        newItemIndex = itemIndex - 1;\n      } else {\n        newItemIndex = itemIndex + 1;\n      }\n      return {\n        itemIndex: ((newItemIndex % data.length) + data.length) % data.length\n      };\n    },\n    getDetailFromInfo: (itemInfo?: ItemInfo): ItemHoverDetail<K, D> | ItemFocusDetail<K, D> => {\n      if (!itemInfo) {\n        return { id: undefined, data: undefined };\n      }\n      const item = getItem(itemInfo, data);\n      return { id: item ? item.id : undefined, data: item };\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { dimensionStyle } from './themes/PieChartStyles.css';\nimport { TrackResizeContainer } from '#UNSAFE_TrackResizeContainer';\nimport { PieChartWithDimensions } from './PieChartWithDimensions';\nimport type { PieChartItemData, PieChartProps } from './pieChart.types';\n\n/**\n * Pie charts are useful for visualizing parts of a whole, but do not display zero or negative values so they are not recommended for data sets that may have negative or null data\n */\nexport function PieChart<\n  K extends string | number,\n  D extends PieChartItemData<K> = PieChartItemData<K>\n>({ width, height, ...props }: PieChartProps<K, D>) {\n  return (\n    <TrackResizeContainer width={width} height={height} class={dimensionStyle}>\n      {(width, height) => <PieChartWithDimensions width={width} height={height} {...props} />}\n    </TrackResizeContainer>\n  );\n}\n"],"names":["degreesToRads","degree","Math","PI","calculateAngleBetweenTwoVectors","vector1X","vector1Y","vector2X","vector2Y","angle","atan2","makeWedgePath","inset","cx","cy","radiusX","radiusY","innerRadius","angleExtent","wedgeGap","startAngle","rx","max","ry","gap","ir","angleExtentRads","startAngleRads","dataItemGaps","gapAngle","asin","centerLineAngle","distanceToStartPointX","min","abs","sin","distanceToStartPointY","startPointX","cos","startPointY","arcPointX","arcPointY","arcPoint2X","arcPoint2Y","pathCommands","outerAngle","innerGapAngle","innerPointX","innerPointY","innerPoint2X","innerPoint2Y","innerAngle","moveTo","arcTo","lineTo","closePath","getCenterContext","innerBounds","width","sqrt","height","x","y","outerBounds","getElementBounds","renderedSlices","radius","activeItem","theta","r","getPieItemCenterCoord","itemIndex","undefined","getDefaultBorderColor","colors","activeData","color","PieSlice","id","isFocused","isInteractive","props","interactiveItemStyle","contrastBorder","innerShapes","styles","itemClasses","classNames","path","innerPath","_jsxs","jsxs","role","accessibleLabel","children","_jsx","d","fill","stroke","className","OUTSIDE_LABEL_DISTANCE","_FEELER_HORIZ_MINSIZE","reflectAngleOverYAxis","radian","skipSliceLabel","slice","seriesCount","sliceContainsPoint","distance","pow","layoutPieChartLabels","slices","pieCenter","availSpace","getTextDimensions","defaultFontSize","insideLabels","outsideLabels","outsideLabelsIndex","Set","labelPosition","l","label","labelStyle","length","add","index","midAngle","center","posX","posY","offset","midPt","sliceLabelPosition","sliceLabelDims","fontSize","x1","x2","y1","y2","ceil","floor","usableSpace","push","position","textInfo","getTextInfo","minChars","didNotFit","getInsideLabelsInfo","leftLabels","rightLabels","i","has","middleAngle","labelPt","isLeftSide","maxLabelWidth","getMaxLabelWidth","Infinity","tmDimPt","midArea","pa","createLabelInfo","generateInitialLayout","leftColl","_refineInitialLayout","rightColl","_columnLabels","setLabelsAndFeelers","labelX","labelInfoArray","insertPos","j","labelInfo","splice","availableSpace","side","prevBottomQuarter","lastY","collisionTop","collisionCentral","collisionBottom","labelBottom","bottomQuarter","collide","isLeftSideLabels","_getRadFeelerAngle","startPt","setOptimalLabelPos","vertX","b","angleInRad","heightFromCenter","optimalY","_minY","_maxY","alabels","isLeft","isTop","isBottom","frame","radFeelerAngle","feelerX","minY","maxY","minFeelerDist","startIndex","bestAngle","bestIndex","getMiddleLabel","startLabel","labelPostion","hasFeelers","labelHeight","highestY","lowestY","getTextDimension","sliceLabel","excessLength","excessWidth","style","_calculateFeeler","fontHeight","labelWidth","minLabelWidth","targetX","targetY","minHorizLength","midX","endPt","horizOffset","tan","PieChartLabel","pieLabelInfo","labelPos","isRtl","getContrastingTextColor","jsx","_Fragment","lines","map","line","lineX","lineY","dims","textAnchor","dominantBaseline","fillerLineStyle","chartVars","getChartVars","PieChartWithDimensions","testId","contextMenuConfig","drilling","selectionMode","onItemDrill","onItemHover","onItemFocus","rootRef","useRef","direction","useUser","resolvedVars","cssContent","useCssVars","Array","from","_","data","reverse","totalValue","isLabelOutside","reduce","item","value","sliceInfos","items","percentage","anchorOffset","sliceInfo","arc","getSliceInfo","hasData","pieSliceGap","getPieSliceGap","hasLargeSeriesCount","testIdProps","useTestId","getAvailSpace","getPieCenter","radiusScale","getRadius","itemInfo","hasLargeItemCount","perimeter","prevEndCoord","filter","endCoord","getRenderedSlices","getDetailFromInfo","getNextChartItem","arrow","newItemIndex","getItem","getPieChartNavUtils","textMeasureContent","useTextDimensions","supportsSelection","supportsDrill","touchResponse","touchResponseStyle","useVisTouchResponse","type","supportsTouchDragGestures","activeId","focusedItemInfo","hoveredItemInfo","eventsProps","onContextMenuDismissed","usePieChartNav","isFocusVisible","content","datatipString","borderColor","datatip","VisTabularDatatip","tableData","key","defaultDatatip","anchor","elementBounds","calculateOffset","datatipContent","datatipProps","useDatatip","placement","merge","contextMenuContent","contextMenuProps","useContextMenu","onContextMenuHandler","gesture","target","context","offsetValue","getInfo","current","contains","contextMenuOptions","isDisabled","usePieChartContextMenu","mergedProps","mergeProps","labels","ref","tabIndex","chart","svg","isHovered","v","TrackResizeContainer","class","dimensionStyle"],"mappings":"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"}