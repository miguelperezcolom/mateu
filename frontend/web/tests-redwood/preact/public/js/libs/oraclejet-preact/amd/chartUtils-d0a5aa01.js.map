{"version":3,"file":"chartUtils-d0a5aa01.js","sources":["../../src/utils/PRIVATE_visSVGUtils/areaUtils.ts","../../src/PRIVATE_LineAreaComponents/AreaSeries.tsx","../../src/PRIVATE_LineAreaComponents/utils/chartUtils.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getCmdPoints } from '#utils/PRIVATE_chartUtils/utils';\nimport { AllLineType } from '#utils/UNSAFE_visTypes/common/common.types';\nimport { fixCoord, Point } from './lineUtils';\nimport { curveThroughPoints } from './pathUtils';\n\n/**\n * Returns a straight area path command.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @return {string} Straight area path commands.\n */\nexport function getNonCurveAreaPath(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  areaType: AllLineType,\n  isHoriz: boolean,\n  isRtl: boolean,\n  groupWidth?: number,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n) {\n  // Create the path data string\n  const highCoords = getCmdPoints(\n    lineSegmentCoords,\n    areaType,\n    isHoriz,\n    isRtl,\n    groupWidth,\n    timeAxisType,\n    true\n  ).split(',');\n  const lowCoords = getCmdPoints(\n    bottomCoords,\n    areaType,\n    isHoriz,\n    isRtl,\n    groupWidth,\n    timeAxisType,\n    true\n  ).split(',');\n\n  // Reverse the lowArray\n  const revLowArray = [];\n  for (let i = 0; i < lowCoords.length; i += 2) {\n    revLowArray.unshift(lowCoords[i], lowCoords[i + 1]);\n  }\n  return revLowArray.concat(highCoords);\n}\n\n/**\n * Returns a curved area path command, based on cubic hermite splines, that goes through the points in the points array.\n * @param {array} lineSegmentCoords Polyline top points array.\n * @param {array} bottomCoords Polyline bottom points array.\n * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.\n * @param {string} splineType The spline type.\n * @return {string} Curved area path commands.\n */\nexport function getCurveAreaPath(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  connectWithLine: boolean,\n  splineType: string,\n  isBottomSegmentCurved?: boolean\n) {\n  let pathData;\n  if (lineSegmentCoords.length > 0) {\n    if (!isBottomSegmentCurved) {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, connectWithLine, splineType) +\n        [...bottomCoords]\n          .reverse()\n          .map((bottomCoord) => {\n            return `L ${bottomCoord[0]} ${bottomCoord[1]}`;\n          })\n          .join(' ') +\n        'Z';\n    } else {\n      pathData =\n        curveThroughPoints(lineSegmentCoords, false, splineType) +\n        ' ' +\n        curveThroughPoints([...bottomCoords].reverse(), true, splineType) +\n        ' Z';\n    }\n  }\n  return pathData;\n}\n\nexport function getCmdsForArea(\n  lineSegmentCoords: Point[],\n  bottomCoords: Point[],\n  areaType: AllLineType,\n  isHoriz: boolean,\n  isBottomSegmentCurved: boolean,\n  isRtl: boolean,\n  groupWidth?: number,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n) {\n  const l = lineSegmentCoords.map((coord) => fixCoord(coord, isHoriz));\n  const b = bottomCoords.map((coord) => fixCoord(coord, isHoriz));\n  if (areaType === 'curved') {\n    return getCurveAreaPath(l, b, false, isHoriz ? 'mh' : 'mv', isBottomSegmentCurved);\n  } else {\n    return getNonCurveAreaPath(\n      lineSegmentCoords,\n      bottomCoords,\n      areaType,\n      isHoriz,\n      isRtl,\n      groupWidth,\n      timeAxisType\n    ).join(' ');\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ColorProps } from '#utils/UNSAFE_interpolations/colors';\nimport { isNonCurvedLine } from '#utils/PRIVATE_chartUtils/utils';\nimport { Point } from '#utils/PRIVATE_visSVGUtils';\nimport { Scale } from '#utils/UNSAFE_visTypes/chart';\nimport { dvtVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\nimport { AllLineType } from '#utils/UNSAFE_visTypes/common/common.types';\nimport { getCmdsForArea } from '#utils/PRIVATE_visSVGUtils/areaUtils';\n\ntype AreaSeriesProps = {\n  yScale: Scale;\n  color: ColorProps['color'];\n  lineType?: AllLineType;\n  isHorizontal: boolean;\n  isLog: boolean;\n  areaColorOpacity: number;\n  lineSegments: Point[][];\n  bottomCoords?: Point[];\n  isHighlighted: boolean;\n  isBottomSegmentCurved: boolean;\n  seriesIndex: number;\n  isRtl: boolean;\n  groupWidth?: number;\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency';\n  plotAreaClipPathId?: string;\n};\n\nexport function AreaSeries({\n  yScale,\n  lineType = 'straight',\n  color,\n  isHorizontal,\n  isLog,\n  areaColorOpacity,\n  lineSegments,\n  bottomCoords,\n  isHighlighted,\n  isBottomSegmentCurved,\n  seriesIndex,\n  groupWidth,\n  isRtl,\n  timeAxisType,\n  plotAreaClipPathId\n}: AreaSeriesProps) {\n  const style = {\n    fill: color,\n    opacity: isHighlighted\n      ? areaColorOpacity\n      : `calc(${dvtVars.dimmedOpacity} * ${areaColorOpacity})`\n  };\n  return (\n    <g clip-path={`url(#${plotAreaClipPathId})`}>\n      {lineSegments.map((lineSegment: Point[]) => {\n        if (lineSegment.length < 2) {\n          return;\n        }\n\n        let baseCoords;\n        if (bottomCoords) {\n          // custom bottom coords. eg: top of last series in stacked area\n          baseCoords = bottomCoords;\n        } else {\n          // TODO: make this more generic when we support apps setting baseline\n          // for log assume domain min is the baseline, otherwise use 0 baseline\n          const baselineCoord = yScale.transform(isLog ? yScale.domain()[0] : 0);\n          baseCoords = [\n            [lineSegment[0][0], baselineCoord],\n            [lineSegment[lineSegment.length - 1][0], baselineCoord]\n          ] as Point[];\n        }\n        const cmds = getCmdsForArea(\n          lineSegment,\n          baseCoords,\n          lineType,\n          isHorizontal,\n          isBottomSegmentCurved,\n          isRtl,\n          groupWidth,\n          timeAxisType\n        );\n        return isNonCurvedLine(lineType) ? (\n          <polygon\n            points={cmds}\n            style={style}\n            data-oj-private-series-index={seriesIndex}\n            data-oj-private-object={'area'}\n          />\n        ) : lineType === 'curved' ? (\n          <path\n            d={cmds}\n            style={style}\n            data-oj-private-series-index={seriesIndex}\n            data-oj-private-object={'area'}\n          />\n        ) : undefined;\n      })}\n    </g>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Group, Scale } from '#utils/UNSAFE_visTypes/chart';\n\nexport const getLineAreaChartItemPosition = (\n  seriesIndex: number,\n  groupIndex: number,\n  // TODO: JET-71332 ; should only be (number | undefined)[][]\n  // scatter chart does not call this function\n  renderedSeries: (number | undefined)[][] | (number[] | { x: number; y: number }[])[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => { x?: any } | undefined,\n  groups: Group[],\n  isHoriz: boolean,\n  xScale: Scale,\n  yScale: Scale,\n  timeAxisType?: string\n) => {\n  // TODO: JET-71332; remove as number after JET-71332 is fixed\n  const value = renderedSeries[seriesIndex][groupIndex] as number;\n  if (value == null) {\n    return undefined;\n  }\n\n  let xVal = groupIndex;\n  if (timeAxisType) {\n    const val =\n      timeAxisType === 'mixedFrequency'\n        ? getDataItem(seriesIndex, groupIndex)?.x\n        : groups[groupIndex].id;\n    xVal = new Date(val).getTime();\n  }\n\n  const x = isHoriz ? yScale.transform(value) : xScale.transform(xVal);\n  const y = isHoriz ? xScale.transform(xVal) : yScale.transform(value);\n\n  return { x, y, height: 0, width: 0 };\n};\n"],"names":["getCmdsForArea","lineSegmentCoords","bottomCoords","areaType","isHoriz","isBottomSegmentCurved","isRtl","groupWidth","timeAxisType","l","map","coord","fixCoord","b","connectWithLine","splineType","pathData","length","curveThroughPoints","reverse","bottomCoord","join","getCurveAreaPath","highCoords","getCmdPoints","split","lowCoords","revLowArray","i","unshift","concat","getNonCurveAreaPath","yScale","lineType","color","isHorizontal","isLog","areaColorOpacity","lineSegments","isHighlighted","seriesIndex","plotAreaClipPathId","style","fill","opacity","dvtVars","dimmedOpacity","_jsx","jsx","children","lineSegment","baseCoords","baselineCoord","transform","domain","cmds","isNonCurvedLine","points","d","undefined","groupIndex","renderedSeries","getDataItem","groups","xScale","value","xVal","val","x","id","Date","getTime","y","height","width"],"mappings":"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"}