{"version":3,"file":"useTextFieldInputHandlers-d401bba6.js","sources":["../../src/hooks/UNSAFE_useTextFieldInputHandlers/useTextFieldInputHandlers.ts"],"sourcesContent":["import { MutableRef, useCallback, useReducer, useRef } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { ValueUpdateDetail } from '../../utils/UNSAFE_valueUpdateDetail';\n\ntype Selection = { start: number | null; end: number | null };\n\ntype TextFieldInputProps = {\n  currentCommitValue?: string;\n  isCommitOnEnter?: boolean;\n  value?: string;\n  onInput?: (detail: ValueUpdateDetail<string>) => void;\n  onCommit?: (detail: ValueUpdateDetail<string>) => void;\n  onKeyDown?: (event: KeyboardEvent) => void;\n  selectionRef?: MutableRef<Selection>;\n};\n\nexport function useTextFieldInputHandlers({\n  currentCommitValue,\n  isCommitOnEnter = true,\n  value,\n  onInput,\n  onCommit,\n  onKeyDown,\n  selectionRef\n}: TextFieldInputProps) {\n  const isComposing = useRef(false);\n\n  // preactjs/preact #1899 - https://github.com/preactjs/preact/issues/1899\n  // Preact does not force the native input to be controlled, so we need to\n  // trigger a rerender in order to keep it fully controlled.\n  // Force update hack is from https://reactjs.org/docs/hooks-faq.html#is-there-something-like-forceupdate\n  const [, forceUpdate] = useReducer((x) => x + 1, 0);\n\n  // TODO: Currently, this assumes that the input field is a text field\n  // so that the change event can be simulated by capturing blur and enter keydown\n  // event. We might have to make this generic to handle other input types\n  // as well like radio, select, checkbox.\n  const handleChange = useCallback(\n    (event: Event) => {\n      const currentValue = (event.target as HTMLInputElement).value;\n      // When do we *not* want to call onCommit?\n      // When the input's value\n      // is the same as the currentCommitValue (like if the user hits Enter over and over,\n      // or if the user focuses and blurs over and over).\n      // Or when the component's value is programmatically changed.\n      // (currentCommitValue is updated whenever we commit or get a programmatic change.\n      // See component code and useCurrentValueReducer hook)\n\n      // We only need to trigger an onCommit for user interacted changes, not programmatic changes\n      if (currentCommitValue !== currentValue) {\n        onCommit?.({ previousValue: currentCommitValue, value: currentValue });\n      }\n    },\n    [onCommit, currentCommitValue]\n  );\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      onKeyDown?.(event);\n\n      if (event.key === 'Enter' && isCommitOnEnter) {\n        handleChange(event);\n      }\n    },\n    [isCommitOnEnter, handleChange, onKeyDown]\n  );\n  const handleInput = useCallback(\n    (event: Event) => {\n      // In android device we need to update input value even for composition events\n      // See JET-39086 for more details.\n      if (isComposing.current && getClientHints().platform !== 'android') return;\n\n      const eventTarget = event.target as HTMLInputElement;\n      const newValue = eventTarget.value;\n      if (value === newValue) return;\n\n      // Save the selection so that we can restore it after the value changes.\n      // This helps avoid the cursor jumping to the end because the browser thinks that\n      // the value has been updated programmatically. See JET-62763 for more info.\n      if (selectionRef) {\n        selectionRef.current = {\n          start: eventTarget.selectionStart,\n          end: eventTarget.selectionEnd\n        };\n      }\n\n      onInput?.({ previousValue: value, value: newValue });\n\n      // preactjs/preact #1899 - https://github.com/preactjs/preact/issues/1899\n      // Preact does not force the native input to be controlled, so we need to\n      // trigger a rerender in order to keep it fully controlled.\n      // Force a rerender here, so if the value was not pushed back, the input\n      // will be reset to the old value mimicking a controlled input.\n      // One minor issue here is that the cursor position will also be reverted\n      // back to the end due to the forced value update. But this behavior should\n      // be fine as it happens in our oj-input-text as well.\n      forceUpdate(null);\n    },\n    [value, onInput, selectionRef]\n  );\n  const handleCompositionStart = useCallback(() => {\n    isComposing.current = true;\n  }, []);\n  const handleCompositionEnd = useCallback(\n    (event: Event) => {\n      isComposing.current = false;\n      // On some browsers, compositionend event is fired before the final input event,\n      // while it's the other way around on other browsers. Just call handleInput here\n      // anyway since handleInput will compare the value before actually calling it.\n      // When all browsers support the input event's isComposing property, we can use that.\n      // https://w3c.github.io/uievents/#dom-inputevent-iscomposing\n      handleInput(event);\n    },\n    [handleInput]\n  );\n\n  return {\n    // With preact/compat, we will not have an onChange event.\n    // \"If you're using preact/compat, most onChange events are internally converted to onInput\n    // to emulate React's behavior. This is one of the tricks we use to ensure maximum\n    // compatibility with the React ecosystem.\"\n    // Since we need the onChange event, we will be simulating this to match the native event\n    // as best as we can. To do this, we will be capturing `blur` event and Enter `keydown` event.\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/change_event\n    onBlur: handleChange,\n    onKeyDown: handleKeyDown,\n    // Since, preact does not support onCompositionStart and onCompositionEnd events\n    // we need to use all lowercase event name to use the native DOM events. Also,\n    // currently we do not have any need for the event object in these two handlers\n    // so ignored the arguments here.\n    oncompositionstart: handleCompositionStart,\n    oncompositionend: handleCompositionEnd,\n    onInput: handleInput\n  };\n}\n"],"names":["currentCommitValue","isCommitOnEnter","value","onInput","onCommit","onKeyDown","selectionRef","isComposing","useRef","forceUpdate","useReducer","x","handleChange","useCallback","event","currentValue","target","previousValue","handleKeyDown","key","handleInput","current","getClientHints","platform","eventTarget","newValue","start","selectionStart","end","selectionEnd","handleCompositionStart","handleCompositionEnd","onBlur","oncompositionstart","oncompositionend"],"mappings":"+HAgB0CA,mBACxCA,EAAkBC,gBAClBA,GAAkB,EAAIC,MACtBA,EAAKC,QACLA,EAAOC,SACPA,EAAQC,UACRA,EAASC,aACTA,IAEA,MAAMC,EAAcC,UAAO,IAMlB,CAAAC,GAAeC,cAAYC,GAAMA,EAAI,GAAG,GAM3CC,EAAeC,eAClBC,IACC,MAAMC,EAAgBD,EAAME,OAA4Bd,MAUpDF,IAAuBe,GACzBX,IAAW,CAAEa,cAAejB,EAAoBE,MAAOa,GACxD,GAEH,CAACX,EAAUJ,IAEPkB,EAAgBL,eACnBC,IACCT,IAAYS,GAEM,UAAdA,EAAMK,KAAmBlB,GAC3BW,EAAaE,EACd,GAEH,CAACb,EAAiBW,EAAcP,IAE5Be,EAAcP,eACjBC,IAGC,GAAIP,EAAYc,SAAyC,YAA9BC,mBAAiBC,SAAwB,OAEpE,MAAMC,EAAcV,EAAME,OACpBS,EAAWD,EAAYtB,MACzBA,IAAUuB,IAKVnB,IACFA,EAAae,QAAU,CACrBK,MAAOF,EAAYG,eACnBC,IAAKJ,EAAYK,eAIrB1B,IAAU,CAAEc,cAAef,EAAOA,MAAOuB,IAUzChB,EAAY,MAAK,GAEnB,CAACP,EAAOC,EAASG,IAEbwB,EAAyBjB,EAAAA,aAAY,KACzCN,EAAYc,SAAU,CAAI,GACzB,IACGU,EAAuBlB,eAC1BC,IACCP,EAAYc,SAAU,EAMtBD,EAAYN,EAAM,GAEpB,CAACM,IAGH,MAAO,CAQLY,OAAQpB,EACRP,UAAWa,EAKXe,mBAAoBH,EACpBI,iBAAkBH,EAClB5B,QAASiB,EAEb"}