{"version":3,"file":"calendarDateUtils-dd5b75ee.js","sources":["../../src/utils/UNSAFE_calendarDateUtils/calendarDateUtils.ts"],"sourcesContent":["import {\n  CalendarDate,\n  CalendarDateRequired,\n  CalendarMonth,\n  CalendarMonthRequired,\n  DateGranularity,\n  DatePlaceholders,\n  MonthYearPlaceholders,\n  IsoDay,\n  IsoMonth\n} from './types';\n\nimport {\n  BCP47Locale,\n  DateISOStr,\n  DateTimeUtils,\n  NativeDateTimeOptions,\n  getFormatParse\n} from '#UNSAFE_IntlDateTime';\n\nconst MAX_ISO_YEAR = 9999;\nconst MIN_ISO_YEAR = 0;\nconst MIN_ISO_DAY = 1;\nconst MIN_ISO_MONTH = 1;\n\nconst checkNoCalendarExtension = (locale: BCP47Locale) => {\n  if (locale.indexOf('-u-ca-') !== -1) {\n    throw new Error('Calendar not allowed in locale');\n  }\n};\n\nconst toJSDate = (year: number, month: IsoMonth, day: IsoDay) => {\n  // Date uses 0-based index for month.\n  const date = new Date(year, month - 1, day);\n  if (year < 100) {\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years\n    date.setFullYear(year);\n  }\n  return date;\n};\n\nconst toIsoCalendarDate = (jsDate: Date): CalendarDateRequired => {\n  const year = jsDate.getFullYear();\n  const month = jsDate.getMonth() + 1;\n  const day = jsDate.getDate();\n  return { year, month: month as IsoMonth, day: day as IsoDay };\n};\n\n// only one duration type can be specified at a time.\ntype Duration =\n  | { years: number; months?: never; days?: never }\n  | { years?: never; months: number; days?: never }\n  | { years?: never; months?: never; days: number };\n\n/**\n * This function can add and subtract years/months/days to an existing CalendarDateRequired object.\n * You can only add/subtract one duration type (years, months, days) at a time.\n * Note: When adding/subtracting years or months, the end of the month is constrained. Examples:\n * e.g. if adding 1 month: 1/31/2024 -> 2/29/2024\n * e.g. if adding 1 year: 2/29/2024 -> 2/28/2025\n * @param calendarDate\n * @param Duration Object containing the optional years/months/days you want to add to the calendarDate. Positive and negative integers are allowed.\n * @returns CalendarDateRequired\n *\n * @example\n * // To add one month:\n * addToCalendarDate({ year: 2024, month: 1, day: 31 }, { months: 1 });\n * returns: { year: 2024, month: 2, day: 29 }\n * // To subtract 7 days (go back one week):\n * addToCalendarDate({ year: 2024, month: 1, day: 31 }, { days: -7 });\n * returns: { year: 2024, month: 1, day: 24 }\n * // To add 10 years:\n * addToCalendarDate({ year: 2024, month: 1, day: 31 }, { years: 10 });\n * returns: { year: 2034, month: 1, day: 31 }\n *\n * NOTE: When Temporal is available and supported, we can be using Temporal.add() instead of\n * js Date() to do the addition / subtraction.\n * See https://tc39.es/proposal-temporal/docs/plaindate.html. For instance, to add one month:\n * const plainDate = new Temporal.PlainDate(isoYear, isoMonth, isoDay);\n * const adjustedDate = plainDate.add({months: 1}); // constrains to end of month if needed, e.g. Jan 31 -> Feb 28\n */\nconst addToCalendarDate = (\n  calendarDate: CalendarDateRequired,\n  { years, months, days }: Duration\n): CalendarDateRequired => {\n  // Verify years, months and days are integers if defined.\n  throwIfNotInteger(years, 'years');\n  throwIfNotInteger(months, 'months');\n  throwIfNotInteger(days, 'days');\n  const YEAR_MIN = 1; // the lowest year we support\n  // According to the Date jsdoc, years < 100 (two-digit) have a bug that we need to workaround.\n  const TWO_DIGIT_YEAR_BROWSER_OFFSET = new Date(0, 1, 2).getFullYear(); // usually 1900, but the Date jsdoc says this could be 2000.\n\n  // First, we adjust the year or month, using the first of the month so that we don't roll\n  // over to the next month based on the current day.\n  const newYear = calendarDate.year + (years ? years : 0);\n  let jsDateOnFirstOfMonth;\n  if (newYear < 100) {\n    // Deal with this:\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years\n    // do not let new year be < the cap\n    const cappedYear = newYear < YEAR_MIN ? YEAR_MIN : newYear;\n    jsDateOnFirstOfMonth = new Date(cappedYear, calendarDate.month - 1 + (months ? months : 0), 1);\n    // E.g., let's say cappedYear is 4. And we are subtracting 1 month, and we are on January, so we go to the previous year when we move back one month.\n    // e.g., const mydate = new Date(4, -1, 1) => Tue Dec 01 1903\n    // mydate.getFullYear() => 1903 (It should be 3, so we have to work around that browser offset for 2-digit years)\n    // diff will be 1903 - (1900+4) => -1, so we want to set full year to 4-1, 3.\n    const diff = jsDateOnFirstOfMonth.getFullYear() - (TWO_DIGIT_YEAR_BROWSER_OFFSET + cappedYear);\n    jsDateOnFirstOfMonth.setFullYear(cappedYear + diff);\n  } else {\n    jsDateOnFirstOfMonth = new Date(newYear, calendarDate.month - 1 + (months ? months : 0), 1);\n  }\n\n  const adjYear = jsDateOnFirstOfMonth.getFullYear();\n  if (adjYear < YEAR_MIN) {\n    // do not adjust the calendarDate if doing so would make the year < the cap.\n    return calendarDate;\n  }\n  const adjMonth = jsDateOnFirstOfMonth.getMonth();\n  // Now we determine the current day of the month based on the number of days in the current\n  // month and year before we add the days\n  const adjDay = Math.min(calendarDate.day, getDaysInMonth((adjMonth + 1) as IsoMonth, adjYear));\n  // now, we adjust for the days\n  const adjustedJsDate = new Date(adjYear, adjMonth, adjDay + (days ? days : 0));\n\n  // again, handle if adjYear is < 100.\n  if (adjYear < 100) {\n    const diff = adjustedJsDate.getFullYear() - (TWO_DIGIT_YEAR_BROWSER_OFFSET + adjYear);\n    adjustedJsDate.setFullYear(adjYear + diff);\n  }\n\n  // this is the adjusted year after we adjust for days.\n  const adjYear2 = adjustedJsDate.getFullYear();\n  if (adjYear2 < YEAR_MIN) {\n    return calendarDate;\n  }\n\n  return {\n    year: adjustedJsDate.getFullYear(),\n    month: (adjustedJsDate.getMonth() + 1) as IsoMonth,\n    day: adjustedJsDate.getDate() as IsoDay\n  };\n};\n\n/**\n * This function can add or subtract months to the existing month. When the end is reached\n * it goes to the beginning when adding and end when subtracting.\n *\n * @example\n * // adds one month\n * addToMonth(5, 1); // returns 6.\n * // subtracts one month\n * addToMonth(5, -1); // returns 4.\n * // adds one month from december\n * addToMonth(12, 1); // returns 1.\n * // subtracts one month from january\n * addToMonth(1, -1); // returns 12.\n *\n * @param month\n * @param months Duration of months that need to be added\n * @returns the result month of type IsoMonth\n */\nconst addToMonth = (month: IsoMonth, months: number) => {\n  const resultMonth = month - 1 + months;\n  if (resultMonth >= 12) return ((resultMonth % 12) + 1) as IsoMonth;\n  if (resultMonth < 0) return (12 + (resultMonth % 12) + 1) as IsoMonth;\n  return (resultMonth + 1) as IsoMonth;\n};\n\n/**\n * This function can add or subtract years to the existing year. The resulting year\n * cannot be greater than the MAX_ISO_YEAR (9999) or less than MIN_ISO_YEAR (0).\n *\n * @example\n * // adds one year\n * addToYear(2025, 1); // returns 2026.\n * // subtracts one year\n * addToYear(2025, -1); // returns 2024.\n * // adds one year to ISO_MAX_YEAR\n * addToYear(9999, 1); // returns 9999.\n * // subtracts one year from ISO_MIN_YEAR\n * addToYear(0, -1); // returns 0.\n *\n * @param year\n * @param years Duration of years that need to be added\n * @returns the result year\n */\nconst addToYear = (year: number, years: number) => {\n  const resultYear = year + years;\n  if (resultYear < MIN_ISO_YEAR) return MIN_ISO_YEAR;\n  if (resultYear > MAX_ISO_YEAR) return MAX_ISO_YEAR;\n  return resultYear;\n};\n\n// Throws an error of the value exists and is not an integer.\nconst throwIfNotInteger = (value: number | undefined, valueName: string) => {\n  if (value && !Number.isInteger(value)) {\n    throw new Error(`Internal error. Argument '${valueName}' is not an integer.`);\n  }\n};\n\n/**\n * This function formats a test date using Intl.DateTimeFormat for the given locale.\n * It then uses Intl.DateTimeFormat.formatToParts to get the parts of the date in a\n * locale specific order, substitutes translated placeholders, and filters out\n * unwanted parts of the date. If granularity = month, then the placeholder for day\n * is removed. The shape of the return value matches what is returned by formatToParts.\n *\n * @param locale The BCP47Locale\n * @param granularity Specifies whether you want placeholders for month, year OR day, month, year\n * @param monthPlaceholder The translated month placeholder\n * @param dayPlaceholder The translated day placeholder\n * @param yearPlaceholder The translated year placeholder\n */\nconst getDatePlaceholderMasks = (\n  locale: BCP47Locale,\n  granularity: 'month' | 'day',\n  monthPlaceholder: string,\n  dayPlaceholder: string,\n  yearPlaceholder: string\n): DatePlaceholders => {\n  checkNoCalendarExtension(locale);\n  const testDate = new Date('2022-11-30');\n  const formatter = new Intl.DateTimeFormat(locale, { dateStyle: 'short' });\n\n  // Filter out anything that is not month, day, year, or literal (e.g. a separator).\n  const filterByType = (p: Intl.DateTimeFormatPart) => {\n    return (\n      (granularity === 'day' && p.type === 'day') ||\n      p.type === 'month' ||\n      p.type === 'year' ||\n      p.type === 'literal'\n    );\n  };\n\n  // Substitute translated placeholders. Trim literals for visual consistency (they can include whitespace)\n  // so the date looks more like a string when the placeholders are rendered next to each other.\n  const mapTranslatedPlaceholders = (p: Intl.DateTimeFormatPart) => {\n    switch (p.type) {\n      case 'month':\n        return { ...p, value: monthPlaceholder };\n      case 'day':\n        return { ...p, value: dayPlaceholder };\n      case 'year':\n        return { ...p, value: yearPlaceholder };\n      default:\n        return { ...p, value: p.value.trim() };\n    }\n  };\n\n  const parts = formatter.formatToParts(testDate).filter(filterByType);\n  let placeholders = parts.map(mapTranslatedPlaceholders);\n\n  // Remove any repeated literals, which can occur after filtering (such as mm//yyyy).\n  placeholders = removeExcessiveLiteralsFromPlaceholders(placeholders);\n\n  return placeholders as DatePlaceholders;\n};\n\n/**\n * Return the number of days in a given month and year. Pass '*' if you don't know a value.\n * If neither month or year are known, then return the maximum number of days in any month in any year.\n * If only month is known, return the maximum number of days for that month in any year.\n * For Gregorian calendar:\n *   getDaysInMonth(2, *) => returns 29\n *   getDaysInMonth(*, *) => returns 31\n *   getDaysInMonth(*, 2023) => returns 31\n */\nconst getDaysInMonth = (month: IsoMonth | '*', year: number | '*') => {\n  if (month === '*') {\n    return 31;\n  } else if (year === '*') {\n    return getDaysInMonthGregorian(month);\n  } else {\n    checkIsValidIsoYear(year);\n    // DateTimeUtils.getDaysInMonth uses a 0-based index.\n    return DateTimeUtils.getDaysInMonth(year, month - 1);\n  }\n};\n\n/**\n * Return the number of months in a given year. Pass '*' if you don't know the year.\n * In a Gregorian calendar the number of months is always 12. We'll have to revisit this\n * when multiple calendars are supported; in some cases the number of months can vary by year.\n */\nconst getMonthsInYear = (year: number | '*') => {\n  if (year !== '*') {\n    checkIsValidIsoYear(year);\n  }\n  return 12;\n};\n\n/**\n * Return the number of days in a month in the Gregorian calendar, without knowing the year.\n */\nconst getDaysInMonthGregorian = (month: IsoMonth) => {\n  switch (month) {\n    case 1:\n    case 3:\n    case 5:\n    case 7:\n    case 8:\n    case 10:\n    case 12:\n      return 31;\n    case 2:\n      return 29; // Since we don't know the year, return the maximum possible number of days.\n    default:\n      return 30;\n  }\n};\n\n/**\n * Throw an error if year is not a valid ISO year (0-9999).\n * The allowed range is too large to express using Typescript.\n */\nconst checkIsValidIsoYear = (year: number) => {\n  if (year < MIN_ISO_YEAR || year > MAX_ISO_YEAR) {\n    throw new Error('Invalid year value');\n  }\n};\n\n/**\n * This utility method uses Intl.DateTimeFormat directly to format with month: long and\n * year: numeric. It returns something like 'May 2025'.\n */\nconst getLongFormattedYearMonth = (locale: BCP47Locale, year: number, month: IsoMonth) => {\n  checkNoCalendarExtension(locale);\n  const formatter = new Intl.DateTimeFormat(locale, { month: 'long', year: 'numeric' });\n  return formatter.format(toJSDate(year, month, 1));\n};\n\n/**\n * This utility method uses Intl.DateTimeFormat directly to format with year: numeric.\n * It returns something like '2025'.\n * @param locale the locale for formatting the year\n * @param year the year of the date to be formatted\n * @param month the month of the date to be formatted\n * @returns the numeric formatted year\n */\nconst getNumericFormattedYear = (locale: BCP47Locale, year: number, month: IsoMonth) => {\n  checkNoCalendarExtension(locale);\n  const formatter = new Intl.DateTimeFormat(locale, { year: 'numeric' });\n  return formatter.format(toJSDate(year, month, 1));\n};\n\n/**\n * Construct and return an IS0 date string from year, month, and day.\n */\nconst getIsoDateStr = (year: number, month: IsoMonth, day: IsoDay) => {\n  checkIsValidIsoYear(year);\n\n  // Month and day must be 2 digits and year must be 4 digits to be a valid ISO 8601 string.\n  const parts = [\n    year.toString().padStart(4, '0'),\n    month.toString().padStart(2, '0'),\n    day.toString().padStart(2, '0')\n  ];\n  return parts.join('-');\n};\n\n/**\n * Parse a DateIsoStr and return an equivalent CalendarDate.\n */\nconst getCalendarDateFromIso = (str: DateISOStr) => {\n  if (!DateTimeUtils.isDateOnlyIsoString(str)) {\n    return undefined;\n  }\n\n  const parts = str.split('-');\n  return { year: +parts[0], month: +parts[1], day: +parts[2] } as unknown as CalendarDate;\n};\n\n/**\n * Returns the CalendarDateRequired object that represents the current CalendarDate for today\n * in the timeZone specified, or if not specified, in the default system timezone.\n *\n * @param timeZone the timeZone name\n * @returns CalendarDateRequired\n *\n * @example\n * // Return today's date in New York for the current time\n * getCalendarDateToday('America/New_York');\n */\nconst getCalendarDateToday = (timeZone?: Intl.DateTimeFormatOptions['timeZone']) =>\n  toIsoCalendarDate(\n    // If a timezone is passed in, then create a date adjusted with the timezone, otherwise just get the date with the default timezone.\n    timeZone ? new Date(new Intl.DateTimeFormat('en', { timeZone }).format(new Date())) : new Date()\n  );\n\n/**\n * Return the calendar date for year, month, and day formatted using the specified date style\n * in the given locale.\n */\nconst getFormattedYearMonthDay = (\n  locale: BCP47Locale,\n  year: number,\n  month: IsoMonth,\n  day: IsoDay,\n  style: NonNullable<Intl.DateTimeFormatOptions['dateStyle']>\n) => {\n  checkNoCalendarExtension(locale);\n  const dateIsoStr = getIsoDateStr(year, month, day);\n\n  const dateFormatOptions: NativeDateTimeOptions = {\n    locale,\n    dateStyle: style,\n    dateStyleShortYear: style === 'short' ? 'numeric' : undefined\n  };\n  const { format } = getFormatParse(dateFormatOptions);\n  return format(dateIsoStr);\n};\n\n/**\n * Format and return the calendar date as a string. If the date is not a complete\n * date, i.e. any of its segments are missing, return an empty string.\n */\nconst formatCalendarDateAsString = (\n  locale: BCP47Locale,\n  calendarDate: CalendarDate,\n  style: NonNullable<Intl.DateTimeFormatOptions['dateStyle']>\n) => {\n  if (!calendarDate.year || !calendarDate.month || !calendarDate.day) {\n    return '';\n  }\n  return getFormattedYearMonthDay(\n    locale,\n    calendarDate.year,\n    calendarDate.month,\n    calendarDate.day,\n    style\n  );\n};\n\n/**\n * Format an example DateISOStr in short format.\n */\nconst formatIsoDateStrAsExample = (\n  locale: BCP47Locale,\n  str: DateISOStr,\n  masks?: DatePlaceholders,\n  granularity?: DateGranularity\n) => {\n  const calDate = getCalendarDateFromIso(str);\n  // The placeholders aren't used for formatting, so use dummy values.\n  const dateMasks =\n    masks ?? getDatePlaceholderMasks(locale, granularity ?? 'day', 'mm', 'dd', 'yyyy');\n  return calDate === undefined\n    ? ''\n    : formatShortCalendarDate(calDate, granularity ?? 'day', dateMasks);\n};\n\n/**\n * Format an example CalendarMonthRequired in short format.\n */\nconst formatCalendarMonthRequiredAsExample = (\n  locale: BCP47Locale,\n  calMonth: CalendarMonthRequired,\n  masks?: DatePlaceholders\n) => {\n  // The placeholders aren't used for formatting, so use dummy values.\n  const dateMasks = masks ?? getDatePlaceholderMasks(locale, 'month', 'mm', 'dd', 'yyyy');\n  return calMonth === undefined ? '' : formatShortCalendarDate(calMonth, 'month', dateMasks);\n};\n\n/**\n * Format a CalendarDate in short format.\n */\nconst formatShortCalendarDate = (\n  cd: CalendarDate,\n  granularity: DateGranularity,\n  masks: DatePlaceholders\n) => {\n  if (!cd.year || !cd.month || (granularity === 'day' && !cd.day)) {\n    return '';\n  }\n  const dateValues = masks.map(({ type, value }) =>\n    type === 'year' ? cd.year : type === 'month' ? cd.month : type === 'day' ? cd.day : value.trim()\n  );\n  return dateValues.join('');\n};\n\n/**\n * Format a CalendarDate in full format.\n */\nconst formatFullCalendarDate = (\n  locale: BCP47Locale,\n  cd: CalendarDate,\n  granularity: DateGranularity\n) => {\n  if (!cd.year || !cd.month || (granularity === 'day' && !cd.day)) {\n    return '';\n  }\n  checkNoCalendarExtension(locale);\n\n  return granularity === 'day'\n    ? getFormattedYearMonthDay(locale, cd.year, cd.month, cd.day!, 'full')\n    : getLongFormattedYearMonth(locale, cd.year, cd.month);\n};\n\n// returns true if undefined or null, or if the value has a year and month property that are valid.\n// This is used to check if the value, min and max properties are valid in input-month-mask.\n// This is equivalent to DateTimeUtils.isDateOnlyIsoString that is used for input-date-mask.\nconst isValidCalendarMonthRequired = (value?: CalendarMonthRequired | null) => {\n  if (value === undefined || value === null) return true;\n  const { year, month } = value;\n\n  const isValidNumber = (num: number | undefined, max: number | undefined): boolean => {\n    return (\n      typeof num === 'number' &&\n      Number.isInteger(num) &&\n      num > 0 &&\n      (max === undefined || num <= max)\n    );\n  };\n\n  // Check if the value is a complete object and its month is valid\n  if (isValidNumber(year, MAX_ISO_YEAR) && isValidNumber(month, getMonthsInYear(year))) {\n    return true;\n  }\n  return false;\n};\n\nconst isCompleteCalendarDate = (value: CalendarDate) => {\n  const { year, month, day } = value;\n\n  // Check if the value is a complete object\n  return year !== undefined && month !== undefined && day !== undefined;\n};\n\nconst isCompleteCalendarMonth = (value: CalendarMonth) => {\n  const { year, month } = value;\n\n  // Check if the value is a complete object\n  return year !== undefined && month !== undefined;\n};\n\n// Given a pattern, return a DatePlaceholder array.\nconst getDatePlaceholdersFromPattern = (pattern: string) => {\n  const arr = getMaskArrayFromPattern(pattern);\n  const datePlaceholders = convertMaskArrayToDatePlaceholders(arr);\n  return datePlaceholders;\n};\n\n// Given a pattern, like 'd-m-yyyy', return an array like ['d', '-', 'm', '-', 'yyyy']\nconst getMaskArrayFromPattern = (pattern: string) => {\n  const result: Array<string> = [];\n  let currentSegmentStr = '';\n  let currentLiteral = '';\n\n  const addSegment = () => {\n    if (currentSegmentStr !== '') {\n      result.push(currentSegmentStr);\n      currentSegmentStr = '';\n    }\n  };\n\n  const addLiteral = () => {\n    if (currentLiteral !== '') {\n      // InputDateMask does not want spaces in its literals. Even if InputDateMask\n      // trims its literals for the masks property, we do so here as well\n      // since we could end up using this for things that are\n      // outside of InputDateMasks masks property.\n      result.push(currentLiteral.trim());\n      currentLiteral = '';\n    }\n  };\n\n  for (let i = 0; i < pattern.length; i++) {\n    const char = pattern[i];\n\n    if (char.toLowerCase() === 'm' || char.toLowerCase() === 'd' || char.toLowerCase() === 'y') {\n      addLiteral();\n      currentSegmentStr += char;\n    } else {\n      addSegment();\n      currentLiteral += char;\n    }\n  }\n\n  // Add the last components\n  addSegment();\n  addLiteral();\n\n  return result;\n};\n\nconst getMonthYearPlaceholdersFromDatePlaceholders = (\n  datePlaceholders: DatePlaceholders\n): MonthYearPlaceholders => {\n  // filter out day\n  const noDay = datePlaceholders.filter((part) => part.type !== 'day');\n  // now filter out the extra literal\n  const monthYearPlaceholders = removeExcessiveLiteralsFromPlaceholders(noDay);\n  return monthYearPlaceholders as MonthYearPlaceholders;\n};\n\n// converts an array into the object that is needed to set on the InputDateMask's masks property, DatePlaceholder[];\nconst convertMaskArrayToDatePlaceholders = (array: Array<string>) => {\n  return array.map((item) => {\n    if (item.toLowerCase()[0] === 'd') {\n      return { type: 'day', value: item };\n    } else if (item.toLowerCase()[0] === 'm') {\n      return { type: 'month', value: item };\n    } else if (item.toLowerCase()[0] === 'y') {\n      return { type: 'year', value: item };\n    } else {\n      // Default to literal for anything else\n      return { type: 'literal', value: item };\n    }\n  }) as DatePlaceholders;\n};\n\nconst removeExcessiveLiteralsFromPlaceholders = (\n  placeholders: { value: string; type: keyof Intl.DateTimeFormatPartTypesRegistry }[]\n) => {\n  const index = placeholders.findIndex((element, index, array) => {\n    return element.type === 'literal' && index > 0 && array[index - 1].type === 'literal';\n  });\n  if (index !== -1) {\n    placeholders = placeholders.slice(0, index).concat(placeholders.slice(index + 1));\n  }\n\n  // Remove any leading or trailing literals. Leading literals can occur after filtering,\n  // and certain locales include trailing literals such as mm.dd.yyyy. which we don't want.\n  if (placeholders[placeholders.length - 1].type === 'literal') {\n    placeholders = placeholders.slice(0, -1);\n  }\n  if (placeholders[0].type === 'literal') {\n    placeholders = placeholders.slice(1);\n  }\n  return placeholders;\n};\n\n/**\n * Computes the closest decade that is before the provided year.\n * @param year the current year\n * @returns the closest decade before the provided year\n */\nconst getClosestDecade = (year: number) => Math.floor(year / 10) * 10;\n\n/**\n * Compares two CalendarDateRequired objects and returns a number indicating their relative order.\n * @param {CalendarDateRequired} date1 The first date to compare.\n * @param {CalendarDateRequired} date2 The second date to compare.\n * @returns {number} A negative number if date1 is before date2, a positive number if date1 is after date2, or 0 if they are the same.\n */\nconst compareDates = (date1: CalendarDateRequired, date2: CalendarDateRequired) => {\n  if (date1.year !== date2.year) {\n    return date1.year - date2.year;\n  }\n  if (date1.month !== date2.month) {\n    return date1.month - date2.month;\n  }\n  return date1.day - date2.day;\n};\n\n/**\n * Checks if one CalendarDateRequired object is before another CalendarDateRequired object.\n * @param date1\n * @param date2\n * @returns {boolean} True if date1 is before date2, otherwise false.\n */\nconst isCalendarDateBefore = (date1: CalendarDateRequired, date2: CalendarDateRequired) => {\n  return compareDates(date1, date2) < 0;\n};\n\n/**\n * Checks if one CalendarDateRequired object is after another CalendarDateRequired object.\n * @param date1\n * @param date2\n * @returns {boolean} True if date1 is after date2, otherwise false.\n */\nconst isCalendarDateAfter = (date1: CalendarDateRequired, date2: CalendarDateRequired) => {\n  return compareDates(date1, date2) > 0;\n};\n\n/**\n * Constrains a given CalendarDateRequired object within the specified date range (inclusive).\n * If the date is before the min, constrain it to the min. If the date is after the max, constrain it to the max.\n * This function creates a new CalendarDateRequired object and does not modify the incoming objects.\n * @param {CalendarDateRequired} date The date to be constrained.\n * @param {CalendarDateRequired} [min] The minimum date allowed (inclusive)\n * @param {CalendarDateRequired} [max] The maximum date allowed (inclusive)\n * @returns {CalendarDateRequired} A new CalendarDateObject constrained within the specified min and max dates (inclusive).\n */\nconst constrainCalendarDate = (\n  date: CalendarDateRequired,\n  min?: CalendarDateRequired,\n  max?: CalendarDateRequired\n) => {\n  let constrainedDate = { ...date }; // Create a new object to avoid modifying the original date objects that are passed in.\n\n  if (min && isCalendarDateBefore(constrainedDate, min)) {\n    constrainedDate = { ...min };\n  }\n\n  if (max && isCalendarDateAfter(constrainedDate, max)) {\n    constrainedDate = { ...max };\n  }\n\n  return constrainedDate;\n};\n\n/**\n * Check if a given CalendarDateRequired object is outside of the specified min/max date range.\n * @param {CalendarDateRequired} date The date to check\n * @param {CalendarDateRequired} [min] The minimum date allowed (inclusive)\n * @param {CalendarDateRequired} [max] The maximum date allowed (inclusive)\n * @returns {boolean} True if the date is outside of the min/max range, otherwise false.\n */\nconst isDateOutOfRange = (\n  date: CalendarDateRequired,\n  min?: CalendarDateRequired,\n  max?: CalendarDateRequired\n) => {\n  return (min && isCalendarDateBefore(date, min)) || (max && isCalendarDateAfter(date, max));\n};\n\nexport {\n  MIN_ISO_DAY,\n  MIN_ISO_MONTH,\n  MIN_ISO_YEAR,\n  MAX_ISO_YEAR,\n  addToCalendarDate,\n  addToMonth,\n  addToYear,\n  checkIsValidIsoYear,\n  checkNoCalendarExtension,\n  compareDates,\n  constrainCalendarDate,\n  formatCalendarDateAsString,\n  formatShortCalendarDate,\n  formatFullCalendarDate,\n  formatCalendarMonthRequiredAsExample,\n  formatIsoDateStrAsExample,\n  getCalendarDateFromIso,\n  getCalendarDateToday,\n  getClosestDecade,\n  getDatePlaceholderMasks,\n  getFormattedYearMonthDay,\n  getDaysInMonth,\n  getDatePlaceholdersFromPattern,\n  getLongFormattedYearMonth,\n  getNumericFormattedYear,\n  getMonthYearPlaceholdersFromDatePlaceholders,\n  getIsoDateStr,\n  getMonthsInYear,\n  isCalendarDateAfter,\n  isCalendarDateBefore,\n  isCompleteCalendarDate,\n  isCompleteCalendarMonth,\n  isDateOutOfRange,\n  isValidCalendarMonthRequired,\n  removeExcessiveLiteralsFromPlaceholders,\n  toIsoCalendarDate,\n  toJSDate\n};\n"],"names":["MAX_ISO_YEAR","checkNoCalendarExtension","locale","indexOf","Error","toJSDate","year","month","day","date","Date","setFullYear","toIsoCalendarDate","jsDate","getFullYear","getMonth","getDate","throwIfNotInteger","value","valueName","Number","isInteger","getDatePlaceholderMasks","granularity","monthPlaceholder","dayPlaceholder","yearPlaceholder","testDate","placeholders","Intl","DateTimeFormat","dateStyle","formatToParts","filter","p","type","map","trim","removeExcessiveLiteralsFromPlaceholders","getDaysInMonth","getDaysInMonthGregorian","checkIsValidIsoYear","DateTimeUtils.getDaysInMonth","getMonthsInYear","getLongFormattedYearMonth","format","getIsoDateStr","toString","padStart","join","getCalendarDateFromIso","str","DateTimeUtils.isDateOnlyIsoString","parts","split","getFormattedYearMonthDay","style","dateIsoStr","dateFormatOptions","dateStyleShortYear","undefined","getFormatParse","formatShortCalendarDate","cd","masks","getMaskArrayFromPattern","pattern","result","currentSegmentStr","currentLiteral","addSegment","push","addLiteral","i","length","char","toLowerCase","convertMaskArrayToDatePlaceholders","array","item","index","findIndex","element","slice","concat","compareDates","date1","date2","isCalendarDateBefore","isCalendarDateAfter","calendarDate","years","months","days","TWO_DIGIT_YEAR_BROWSER_OFFSET","newYear","jsDateOnFirstOfMonth","cappedYear","diff","adjYear","adjMonth","adjDay","Math","min","adjustedJsDate","resultMonth","resultYear","max","constrainedDate","calMonth","dateMasks","calDate","timeZone","floor","arr","datePlaceholders","noDay","part","isValidNumber","num"],"mappings":"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"}