/**
 * @license
 * Copyright (c) 2014, 2025, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define(["exports","preact/jsx-runtime","ojs/ojvcomponent","preact","jquery","ojs/ojanimation","ojs/ojcore-base","ojs/ojpopup","ojs/ojpopupcore","ojs/ojdrawerutils","hammerjs","ojs/ojcustomelement-utils","ojs/ojcontext"],function(e,t,s,r,o,i,n,a,l,p,d,c,h){"use strict";o=o&&Object.prototype.hasOwnProperty.call(o,"default")?o.default:o,n=n&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n,d=d&&Object.prototype.hasOwnProperty.call(d,"default")?d.default:d,h=h&&Object.prototype.hasOwnProperty.call(h,"default")?h.default:h;var u,w=function(e,t,s,r){var o,i=arguments.length,n=i<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,s):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)n=Reflect.decorate(e,t,s,r);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(n=(i<3?o(n):i>3?o(t,s,n):o(t,s))||n);return i>3&&n&&Object.defineProperty(t,s,n),n};const O=window;e.DrawerPopup=u=class extends r.Component{constructor(){super(...arguments),this.state={opened:this.props.opened,viewportResolvedDisplayMode:this.getViewportResolvedDisplayMode(),viewportResolvedDisplayModeVertical:this.getViewportResolvedDisplayModeVertical()},this.rootRef=r.createRef(),this.windowResizeHandler=null,this.ignoreUpdate=!1,this.handleGuardFocus=(e,t)=>{if("modal"===this.props.modality){const s=p.DrawerUtils.getFocusables(this.rootRef.current),{length:r,0:o,[r-1]:i}=s;if(t.preventDefault(),!r)return void this.rootRef.current.focus();"start"===e?i.focus():o.focus()}},this.handleOnStartGuardFocus=e=>{this.handleGuardFocus("start",e)},this.handleOnEndGuardFocus=e=>{this.handleGuardFocus("end",e)},this.handleKeyDown=e=>{e.defaultPrevented||e.key!==p.DrawerConstants.keys.ESC||this.selfClose()},this.autoDismissHandler=e=>{p.DrawerUtils.getFocusables(this.rootRef.current);const t=this.rootRef.current.parentNode,s=t.parentElement,r=this.isTargetDescendantOfOwnZorderLayerOrItsNextSiblings(t,e.target),o=s.contains(e.target),i=this.drawerOpener!==document.body&&this.drawerOpener.contains(e.target);if("focus-loss"===this.props.autoDismiss){if("modal"===this.props.modality&&!o)return;r||i||this.selfClose()}else"none"!==this.props.autoDismiss||"modal"!==this.props.modality||r||e.preventDefault()},this.refreshHandler=e=>{l.PopupService.getInstance().triggerOnDescendents(o(this.rootRef.current),l.PopupService.EVENT.POPUP_REFRESH)},this.destroyHandler=()=>{const e=o(this.rootRef.current);if(l.ZOrderUtils.getStatus(e)===l.ZOrderUtils.STATUS.OPEN){c.CustomElementUtils.cleanComponentBindings(e[0]),e.remove();const t={};t[l.PopupService.OPTION.POPUP]=e,this.ignoreUpdate=!0,l.PopupService.getInstance().close(t)}},this.isTargetDescendantOfOwnZorderLayerOrItsNextSiblings=(e,t)=>{const s=[e];let r=e.nextSibling;for(;r;)s.push(r),r=r.nextSibling;return s.some(e=>e.contains(t))},this.windowResizeCallback=()=>{const e={},t=this.state.viewportResolvedDisplayMode,s=this.getViewportResolvedDisplayMode();t!==s&&(e.viewportResolvedDisplayMode=s);const r=this.state.viewportResolvedDisplayModeVertical,o=this.getViewportResolvedDisplayModeVertical();r!==o&&(e.viewportResolvedDisplayModeVertical=o),this.isDrawerOpened()&&t===p.DrawerConstants.stringFullOverlay&&s===p.DrawerConstants.stringOverlay&&(this.isIOSspecificScrollCase()?this.applyPopupServiceModalChanges("modeless"):this.isAndroidSpecificScrollCase()&&p.DrawerUtils.enableBodyOverflow()),this.isDrawerOpened()&&t===p.DrawerConstants.stringOverlay&&s===p.DrawerConstants.stringFullOverlay&&(this.isIOSspecificScrollCase()?this.applyPopupServiceModalChanges("modal"):this.isAndroidSpecificScrollCase()&&p.DrawerUtils.disableBodyOverflow()),Object.keys(e).length>0&&this.setState(e)},this.handleSwipeAction=()=>{this.selfClose()}}static getDerivedStateFromProps(e,t){return e.opened!==t.opened?{opened:e.opened}:null}render(e){return this.ignoreUpdate||!this.isDrawerOpened()&&!this.wasDrawerOpenedInPrevState()?t.jsx(s.Root,{}):t.jsx(s.Root,{ref:this.rootRef,class:this.getPopupStyleClasses(this.props.edge),tabIndex:-1,role:this.props.role||"dialog",onKeyDown:this.handleKeyDown,children:t.jsxs("div",{class:"oj-drawer-full-height",children:[t.jsx("div",{class:"oj-drawer-focus-guard",onFocus:this.handleOnStartGuardFocus,tabIndex:0}),e.children,t.jsx("div",{class:"oj-drawer-focus-guard",onFocus:this.handleOnEndGuardFocus,tabIndex:0})]})})}isDrawerOpened(){return this.state[p.DrawerConstants.stringOpened]}wasDrawerOpenedInPrevState(){return this.openedPrevState}async selfClose(){try{await(this.props.onOjBeforeClose?.())}catch(e){return}this.props.onOpenedChanged?.(!1)}openOrCloseDrawer(e){this.isDrawerOpened()!=e.opened&&(this.openedPrevState=this.isDrawerOpened());const t=o(this.rootRef.current),s=l.PopupService.getInstance(),r=this.getPopupServiceOptions(e);this.isDrawerOpened()?[l.ZOrderUtils.STATUS.CLOSE,l.ZOrderUtils.STATUS.UNKNOWN].indexOf(l.ZOrderUtils.getStatus(t)>-1)&&s.open(r):l.ZOrderUtils.getStatus(t)===l.ZOrderUtils.STATUS.OPEN&&(this.isIOSspecificScrollCase()&&this.getViewportResolvedDisplayMode()===p.DrawerConstants.stringFullOverlay&&this.applyPopupServiceModalChanges("modeless"),s.close(r))}getPopupServiceOptions(e){const t=this.props.edge,s=o(this.rootRef.current),r={},i=l.PopupService.OPTION;r[i.POPUP]=s,r[i.LAUNCHER]=o(document.activeElement),r[i.MODALITY]=this.props.modality,r[i.LAYER_SELECTORS]=this.getDrawerSurrogateLayerSelectors(),r[i.LAYER_LEVEL]=l.PopupService.LAYER_LEVEL.TOP_LEVEL,r[i.POSITION]=null,r[i.CUSTOM_ELEMENT]=!0;const n=l.PopupService.EVENT;return r[i.EVENTS]={[n.POPUP_BEFORE_OPEN]:()=>this.beforeOpenHandler(t,r),[n.POPUP_AFTER_OPEN]:()=>this.afterOpenHandler(t,e),[n.POPUP_BEFORE_CLOSE]:()=>this.beforeCloseHandler(t),[n.POPUP_AFTER_CLOSE]:()=>this.afterCloseHandler(e),[n.POPUP_AUTODISMISS]:e=>this.autoDismissHandler(e),[n.POPUP_REFRESH]:()=>this.refreshHandler(t),[n.POPUP_REMOVE]:()=>this.destroyHandler()},r}beforeOpenHandler(e,t){p.DrawerUtils.disableBodyOverflow(),this.drawerOpener=document.activeElement,t[l.PopupService.OPTION.POPUP].show();const s=h.getContext(this.rootRef.current).getBusyContext().addBusyState({description:"Animation in progress"}),r=i.slideIn(this.rootRef.current,p.DrawerUtils.getAnimationOptions(p.DrawerConstants.stringSlideIn,e));return r.then(s),r}afterOpenHandler(e,t){p.DrawerUtils.enableBodyOverflow(),this.isIOSspecificScrollCase()&&this.getViewportResolvedDisplayMode()===p.DrawerConstants.stringFullOverlay&&this.applyPopupServiceModalChanges("modal"),this.isAndroidSpecificScrollCase()&&this.getViewportResolvedDisplayMode()===p.DrawerConstants.stringFullOverlay&&p.DrawerUtils.disableBodyOverflow(),this.handleFocus(t);const s=o(this.rootRef.current);if(l.ZOrderUtils.getStatus(s)===l.ZOrderUtils.STATUS.OPEN&&!this.isDrawerOpened()){const e=l.PopupService.getInstance(),s=this.getPopupServiceOptions(t);e.close(s)}}handleFocus(e){if(this.state.opened&&e.opened!==this.state.opened){const e=this.rootRef.current,t=p.DrawerUtils.getAutofocusFocusables(e),{length:s,0:r}=t;if(s>0)return void r.focus({preventScroll:!0});const o=p.DrawerUtils.getFocusables(e);let i=e;o.length&&(i=o[0]),i.focus({preventScroll:!0})}}beforeCloseHandler(e){if(p.DrawerUtils.disableBodyOverflow(),this.elementWithFocusBeforeDrawerCloses=document.activeElement,this.ignoreUpdate)return null;const t=h.getContext(this.rootRef.current).getBusyContext().addBusyState({description:"Animation in progress"});return i.slideOut(this.rootRef.current,p.DrawerUtils.getAnimationOptions(p.DrawerConstants.stringSlideOut,e)).then(t)}afterCloseHandler(e){if(p.DrawerUtils.enableBodyOverflow(),this.rootRef.current.contains(this.elementWithFocusBeforeDrawerCloses)&&p.DrawerUtils.moveFocusToElementOrNearestAncestor(this.drawerOpener),this.ignoreUpdate)return;const t=o(this.rootRef.current);if(l.ZOrderUtils.getStatus(t)===l.ZOrderUtils.STATUS.CLOSE&&this.isDrawerOpened()){const t=l.PopupService.getInstance(),s=this.getPopupServiceOptions(e);t.open(s)}else this.wasDrawerOpenedInPrevState()||window.queueMicrotask(()=>{this.forceUpdate()});this.props.onOjClose?.()}getDrawerSurrogateLayerSelectors(){let e=p.DrawerConstants.DrawerPopupStyleSurrogate;const t="modal";return this.props.modality===t&&(e+=` ${p.DrawerConstants.stringOjDrawer}${p.DrawerConstants.charDash}${t}`),e}getPopupStyleClasses(e){const t={};return e===p.DrawerConstants.stringBottom?this.getViewportResolvedDisplayModeVertical()!==p.DrawerConstants.stringFullOverlay&&this.getViewportResolvedDisplayMode()!==p.DrawerConstants.stringFullOverlay||(t[p.DrawerConstants.styleDisplayMode(p.DrawerConstants.stringFullOverlay)]=!0):this.getViewportResolvedDisplayMode()===p.DrawerConstants.stringFullOverlay&&(t[p.DrawerConstants.styleDisplayMode(p.DrawerConstants.stringFullOverlay)]=!0),p.DrawerUtils.getStyleClassesMapAsString(Object.assign(t,p.DrawerUtils.getCommonStyleClasses(e)))}componentDidUpdate(e,t){this.ignoreUpdate||this.handleComponentUpdate(t)}componentDidMount(){if(null===this.windowResizeHandler&&(this.windowResizeHandler=this.windowResizeCallback.bind(this)),window.addEventListener(p.DrawerConstants.stringResize,this.windowResizeHandler),this.openedPrevState=this.props.opened,u.defaultProps.opened!=this.props.opened){const e=Object.assign({},this.state);e.opened=!1,this.handleComponentUpdate(e)}}componentWillUnmount(){window.removeEventListener(p.DrawerConstants.stringResize,this.windowResizeHandler),this.windowResizeHandler=null}getViewportResolvedDisplayMode(){return p.DrawerUtils.getViewportWidth()>=p.DrawerConstants.fullWidthDrawerChangeThreshold?p.DrawerConstants.stringOverlay:p.DrawerConstants.stringFullOverlay}getViewportResolvedDisplayModeVertical(){return p.DrawerUtils.getViewportHeight()>=p.DrawerConstants.fullHeightDrawerChangeThreshold?p.DrawerConstants.stringOverlay:p.DrawerConstants.stringFullOverlay}handleComponentUpdate(e){this.openOrCloseDrawer(e),this.isDrawerOpened()&&"swipe"===this.props.closeGesture&&this.registerCloseWithSwipeListener(),!1===this.isDrawerOpened()&&e.opened&&this.unregisterCloseWithSwipeListener()}registerCloseWithSwipeListener(){this.hammerInstance=new d(O),this.props.edge===p.DrawerConstants.stringBottom&&this.hammerInstance.get("swipe").set({direction:d.DIRECTION_DOWN}),this.hammerInstance.on(this.getSwipeCloseDirection(this.props.edge),this.handleSwipeAction)}getSwipeCloseDirection(e){const t="swipeleft",s="swiperight";switch(e){case p.DrawerConstants.stringStart:return p.DrawerUtils.isRTL()?s:t;case p.DrawerConstants.stringEnd:return p.DrawerUtils.isRTL()?t:s;case p.DrawerConstants.stringBottom:return"swipedown"}}unregisterCloseWithSwipeListener(){this.hammerInstance&&(this.hammerInstance.off(this.getSwipeCloseDirection(this.props.edge),this.handleSwipeAction),this.hammerInstance.destroy(),this.hammerInstance=null)}isIOSspecificScrollCase(){return n.AgentUtils.getAgentInfo().os===n.AgentUtils.OS.IOS&&"modeless"===this.props.modality}isAndroidSpecificScrollCase(){return n.AgentUtils.getAgentInfo().os===n.AgentUtils.OS.ANDROID&&"modeless"===this.props.modality}applyPopupServiceModalChanges(e){const t={},s=l.PopupService.OPTION;t[s.POPUP]=o(this.rootRef.current),t[s.MODALITY]=e,l.PopupService.getInstance().changeOptions(t)}},e.DrawerPopup.defaultProps={autoDismiss:"focus-loss",edge:"start",modality:"modal",opened:!1,closeGesture:"swipe"},e.DrawerPopup._metadata={slots:{"":{}},properties:{opened:{type:"boolean",writeback:!0},edge:{type:"string",enumValues:["end","start","bottom"]},modality:{type:"string",enumValues:["modal","modeless"]},autoDismiss:{type:"string",enumValues:["none","focus-loss"]},closeGesture:{type:"string",enumValues:["none","swipe"]}},events:{ojBeforeClose:{cancelable:!0},ojClose:{}},extension:{_WRITEBACK_PROPS:["opened"],_READ_ONLY_PROPS:[],_OBSERVED_GLOBAL_PROPS:["role"]}},e.DrawerPopup=u=w([s.customElement("oj-drawer-popup")],e.DrawerPopup),Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=ojdrawerpopup.js.map