/**
 * @license
 * Copyright (c) 2014, 2025, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
define(["exports","ojs/ojcore-base","ojs/ojdataprovider","ojs/ojmap"],function(t,e,a,s){"use strict";e=e&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e,s=s&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s;class i{static fetchByKeysFromBuffer(t,e){const a=new s,i=new Set;return t.keys.forEach(t=>{const s=e.getItem(t);if(s)switch(s.operation){case"add":case"update":a.set(t,s.item)}else i.add(t)}),{results:a,unresolvedKeys:i}}static compareItem(t,e,s){for(const i of s){let s=a.SortUtils.getNaturalSortComparator();const d="descending"===i.direction?-1:1,r=s(this.getVal(t,i.attribute),this.getVal(e,i.attribute))*d;if(0!==r)return r}return 0}static getVal(t,e){if(null==t)return t;if("string"==typeof e){const a=e.indexOf(".");if(a>0){const s=e.substring(0,a),i=e.substring(a+1),d=t[s];if(d)return this.getVal(d,i)}}return"function"==typeof t[e]?t[e]():t[e]}static insertAddEdits(t,e,a,s,i,d,r,n){t.forEach(async(t,m)=>{if("add"===t.operation)e&&!e.filter(t.item.data)||n.totalFilteredRowCount++;else{let a=null;if(e)if(n.dataBeforeUpdated.has(m))a=n.dataBeforeUpdated.get(m);else{let t=new Set;t.add(m),a=(await n.dataProvider.fetchByKeys({keys:t})).results.get(m).data,n.dataBeforeUpdated.set(m,a)}"remove"===t.operation?e&&!e.filter(a)||n.totalFilteredRowCount--:"update"===t.operation&&e&&(e.filter(a)&&!e.filter(t.item.data)?n.totalFilteredRowCount--:!e.filter(a)&&e.filter(t.item.data)&&n.totalFilteredRowCount++)}if(("add"===t.operation||"update"===t.operation)&&!i.has(m)&&(!e||e.filter(t.item.data)))if(a&&a.length){let e=!1;for(let d=0;d<s.length;d++)if("update"!==t.operation||r.isUpdateTransformed(m)||m!==s[d].metadata.key||s.splice(d,1),this.compareItem(t.item.data,s[d].data,a)<0){s.splice(d,0,t.item),i.add(m),e=!0;break}!e&&d&&(s.push(t.item),i.add(m))}else if("add"===t.operation||"update"===t.operation&&r.isUpdateTransformed(m)){const e=void 0===t.addDetail?0:this.findKeyInItems(t.addDetail.addBeforeKey,s);e>-1?(s.splice(e,0,t.item),i.add(m)):d&&(s.push(t.item),i.add(m))}})}static mergeAddEdits(t,e,a,s,i,d,r){const n=d.getUnsubmittedItems();this.insertAddEdits(n,t,e,a,s,i,d,r);const m=d.getSubmittingItems();this.insertAddEdits(m,t,e,a,s,i,d,r)}static mergeEdits(t,e,s,i,d,r,n,m){let o;s&&(o=s.filter?s:a.FilterFactory.getFilter({filterDef:s,filterOptions:m.options}));const u=0!==e.length;for(const a of t){const t=n.getItem(a.metadata.key,u);t?"remove"===t.operation?e.push(a):"update"!==t.operation||n.isUpdateTransformed(t.item.metadata.key)||o&&!o.filter(t.item.data)||i&&0!==i.length||e.push(t.item):e.push(a)}this.mergeAddEdits(o,i,e,d,r,n,m)}static async fetchFromOffset(t,e,s){const i=t?.signal;return a.wrapWithAbortHandling(i,async a=>{const i=t.offset,d=null==t.size||-1===t.size,r=t.size,n=[],{submitting:m,submitted:o,unsubmitted:u}=this.getEditBufferCounts(s),l=u.numAdds+m.numAdds+o.numAdds,h=u.numAddsAtTop+m.numAddsAtTop+o.numAddsAtTop;let f,c=!1,p=!0;const y=s.getSubmittingItems(),g=s.getUnsubmittedItems(),I=s.getSubmittedAddItems();if(0===y.size&&0===g.size&&0===I.size){f={...t};return a(await e.fetchByOffset(t))}if(i<h&&n.push(...this.getAllAddsAtTop(s).slice(i,d?void 0:i+r)),!d&&i+r<=h)return a({fetchParameters:t,results:n,done:c});const b=u.numRemoves+m.numRemoves,A=u.numMoveAdds+m.numMoveAdds,v=m.numAdds+o.numAdds;let K={offset:i},k={size:r},S=0;b>0||A>0||v>0||l-h>0?(K={offset:0},A>0?(n.length=0,S=i,p=!1):S=Math.max(0,i-h),d||(k={size:i+r+b+A+v-Math.max(u.numAddsAtTop-i,0)})):u.numAddsAtTop>0&&(K={offset:Math.max(i-u.numAddsAtTop,0)},d||(k={size:r-Math.max(u.numAddsAtTop-i,0)}));const B=Math.max(k.size,r);for(;!c&&(d||n.length<B);){f={...t,...K,...k};let a=await e.fetchByOffset(f),i=a.results;if(0===i.length){c=!0;break}c=a.done,i.forEach(t=>{s.isSubmittingOrSubmittedAdd(t.metadata.key)||n.push(t)}),K.offset+=i.length,k.size=d?r:r-n.length}return this.performEdits(n,s.getAllTransactions(),p,c),a({fetchParameters:t,results:n.slice(S,d?void 0:S+r),done:c})},!0)}static performEdits(t,e,a,s){e.forEach(e=>{if("add"===e.operation)if(e.addDetail)if(null!==e.addDetail.addBeforeKey){const a=this.findKeyInItems(e.addDetail.addBeforeKey,t);a>-1?t.splice(a,0,e.item):s&&t.push(e.item)}else s&&t.push(e.item);else a||t.unshift(e.item);else if("remove"===e.operation){const a=this.findKeyInItems(e.item.metadata.key,t);a>-1&&t.splice(a,1)}else if("update"===e.operation){const a=this.findKeyInItems(e.item.metadata.key,t);a>-1&&t.splice(a,1,e.item)}})}static calculateSizeChange(t,e){let a=0;return t.forEach((t,s)=>{e.getEditItemStatus(s)||("add"===t.operation?++a:"remove"===t.operation&&--a)}),a}static getEditBufferCounts(t){return{submitting:this.getCounts(t.getSubmittingItems(),t),unsubmitted:this.getCounts(t.getUnsubmittedItems(),t),submitted:this.getCounts(t.getSubmittedAddItems(),t)}}static getCounts(t,e){let a=0,s=0,i=0,d=0;return t.forEach((t,r)=>{"add"===t.operation?(++a,t.addDetail||++d):"remove"===t.operation?++s:"update"===t.operation&&e.isUpdateTransformed(r)&&++i}),{numAdds:a,numAddsAtTop:d,numRemoves:s,numMoveAdds:i}}static getAllAddsAtTop(t){const e=t.getAddItemOrder(),a=new Array;return e.forEach(e=>{const s=t.getItem(e,!0);s&&!s.addDetail&&a.push(s.item)}),a}static isItemRemoved(t,e){const a=e.getItem(t);return null!=a&&"remove"===a.operation}static addToMergedArrays(t,e,a,s,i=null,d=!1){let r=i,n=null;if(e)r=this.getNextKey(i,a,s,!1);else if(a){if(d){n=0;for(let t=0;t<a.mergedItemArray.length;t++){const e=a.mergedItemArray[t].metadata.key;if(!this.isItemRemoved(e,s)){r=e;break}}}else null!==i&&(n=this.findKeyInItems(i,a.mergedItemArray),-1===n&&(n=null));let e=null!==n&&a.nextOffset>n;if(s.isUpdateTransformed(t.metadata.key)){let s=this.findKeyInItems(t.metadata.key,a.mergedItemArray);-1!==s&&(e&&(e=a.nextOffset<=s),a.mergedItemArray.splice(s,1))}null!==n&&(a.mergedItemArray.splice(n,0,t),a.mergedAddKeySet.add(t.metadata.key)),e&&a.nextOffset++}else d&&(n=0);return{addBeforeKey:r,index:n}}static getNextKey(t,e,a,s=!1){let i=t;if(e){const d=e.mergedItemArray;let r=this.findKeyInItems(t,d);for(;null!==i&&(s||this.isItemRemoved(i,a));)s&&(s=!1),i=-1===r||r+1===d.length?null:d[r+1].metadata.key,r++}return i}static generateKey(t,e){return e?e(t):crypto.randomUUID?crypto.randomUUID():([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,t=>(t^crypto.getRandomValues(new Uint8Array(1))[0]&15>>t/4).toString(16))}static removeFromMergedArrays(t,e,a,s){if(a){const i=a.mergedItemArray,d=a.mergedAddKeySet,r=this.findKeyInItems(t,i);if(-1!==r){(e||d.has(t))&&(i.splice(r,1),d.delete(t));for(let t=a.nextOffset-1;t>=0;t--){let e=i[t]?.metadata.key;if(null!=e&&!this.isItemRemoved(e,s))break;a.nextOffset=t}}}}static addEventDetail(t,e,a,s){null==t[e]&&(t[e]="add"===e?{data:[],keys:new Set,metadata:[],addBeforeKeys:[]}:{data:[],keys:new Set,metadata:[]}),t[e].keys.add(a.metadata.key),t[e].data.push(a.data),t[e].metadata.push(a.metadata),"add"===e&&t[e].addBeforeKeys.push(s)}static findKeyInMetadata(t,a){if(a)for(let s=0;s<a.length;s++)if(e.KeyUtils.equals(t,a[s].key))return s;return-1}static findKeyInItems(t,a){if(a)for(let s=0;s<a.length;s++)if(e.KeyUtils.equals(t,a[s].metadata.key))return s;return-1}static initDetailProp(t,e,a,s){t[a]&&(e[a]=s)}static initDetail(t,e,a,s=!1){a?(this.initDetailProp(t,e,"data",[]),this.initDetailProp(t,e,"metadata",[]),s&&this.initDetailProp(t,e,"addBeforeKeys",[]),this.initDetailProp(t,e,"indexes",[]),this.initDetailProp(t,e,"parentKeys",[])):(this.initDetailProp(t,e,"data",t.data),this.initDetailProp(t,e,"metadata",t.metadata),s&&this.initDetailProp(t,e,"addBeforeKeys",t.addBeforeKeys),this.initDetailProp(t,e,"indexes",t.indexes),this.initDetailProp(t,e,"parentKeys",t.parentKeys))}static initDetails(t,e,a){t.add&&(e.add={keys:new Set},this.initDetail(t.add,e.add,a,!0)),t.remove&&(e.remove={keys:new Set},this.initDetail(t.remove,e.remove,a)),t.update&&(e.update={keys:new Set},this.initDetail(t.update,e.update,a))}static pushDetailProp(t,e,a,s){t[a]&&e[a].push(t[a][s])}static pushDetail(t,e,a){if(a.keys.add(t),e.metadata){const s=this.findKeyInMetadata(t,e.metadata);s>-1&&(this.pushDetailProp(e,a,"data",s),this.pushDetailProp(e,a,"metadata",s),e.addBeforeKeys&&0!==e.addBeforeKeys.length&&this.pushDetailProp(e,a,"addBeforeKeys",s),e.indexes&&0!==e.indexes.length&&this.pushDetailProp(e,a,"indexes",s),this.pushDetailProp(e,a,"parentKeys",s))}}static isSkipItem(t,e,a){let s=null!=e.get(t);if(!s){const e=a.get(t);s=e&&"remove"===e.operation}return s}static isSortFieldUpdated(t,e,a,s){let i=!1;if(a&&s&&s.length){const d=this.findKeyInItems(t,a.mergedItemArray);if(d<0)return!1;const r=[];let n=0;if(a&&s)for(const t of s)r[n++]=t.attribute;for(const s of r){const r=this.findKeyInMetadata(t,e.metadata);a.mergedItemArray[d][s]!==e.data[r]&&(i=!0)}}return i}static getOperationDetails(t,e,a){if(t&&(t.add||t.remove||t.update)){let s={};const i=a.getSubmittingItems(),d=a.getUnsubmittedItems();if(0===i.size&&0===d.size)s=t;else{let a;this.initDetails(t,s,!0),this.processAdd(s,t,e),t.remove&&t.remove.keys.forEach(e=>{a=this.isSkipItem(e,i,d),a||this.pushDetail(e,t.remove,s.remove);const r=d.get(e);!r||"remove"!==r.operation&&"update"!==r.operation||d.delete(e)}),t.update&&t.update.keys.forEach(e=>{a=this.isSkipItem(e,i,d),a||this.pushDetail(e,t.update,s.update)})}return s}return t}static processAdd(t,e,a){if(e.add)return t.add={...e.add},void(null!=a&&(t.add.addBeforeKeys=a))}static cleanUpSubmittedItem(t,e){const a=e.getSubmittingItems().get(t);a&&e.setItemMutated(a)}static checkGeneratedKeys(t,e,a){if(t.add?.keys){let s=0;t.add.keys.forEach(i=>{((s,i,d)=>{if(e.has(s)){const r=e.get(s);if((!t.remove||!t.remove.keys?.has(s))&&(t.remove||(t.remove={keys:new Set}),t.remove.keys.add(r),i)){const t=a?.mergedItemArray?.[0]?.metadata?.key;null!==t&&(i.addBeforeKeys||(i.addBeforeKeys=[]),i.addBeforeKeys[d]=t)}}})(i,t.add,s),s++})}}static containsKeys(t,e,a){const s=i.fetchByKeysFromBuffer(t,e),d=s.unresolvedKeys,r=new Set;return s.results.forEach((t,e)=>{r.add(e)}),0===d.size?Promise.resolve({containsParameters:t,results:r}):a.containsKeys({attributes:t.attributes,keys:d,scope:t.scope}).then(e=>r.size>0?(e.results.forEach((t,e)=>{r.add(e)}),{containsParameters:t,results:r}):e)}static fetchByKeys(t,e,s){const d=i.fetchByKeysFromBuffer(t,e),r=d.unresolvedKeys,n=d.results,m=t?.signal;return a.wrapWithAbortHandling(m,e=>0===r.size?e({fetchParameters:t,results:n}):e(s.fetchByKeys({attributes:t.attributes,keys:r,scope:t.scope,signal:m}).then(e=>n.size>0?(e.results.forEach((t,e)=>{n.set(e,t)}),{fetchParameters:t,results:n}):e)),!1)}static removeItem(t,e,s){s.removeItem(t),i.removeFromMergedArrays(t.metadata.key,!1,e,s);const d={remove:{data:t.data?[t.data]:null,keys:(new Set).add(t.metadata.key),metadata:[t.metadata]}};return new a.DataProviderMutationEvent(d)}static updateItem(t,e){e.updateItem(t);const s={update:{data:[t.data],keys:(new Set).add(t.metadata.key),metadata:[t.metadata]}};return new a.DataProviderMutationEvent(s)}static addItem(t,e,s,d){e.addItem(t,d);const r=i.addToMergedArrays(t,!1,s,e,null!=d?.addBeforeKey?d.addBeforeKey:null,void 0===d),n={add:{data:[t.data],keys:(new Set).add(t.metadata.key),metadata:[t.metadata],addBeforeKeys:[r.addBeforeKey],indexes:null===r.index?null:[r.index]}};return new a.DataProviderMutationEvent(n)}static fetchByOffset(t,e,a){return i.fetchFromOffset(t,a,e)}static getCapability(t,e){return e.getCapability(t)}static getTotalSize(t,e){return t.getTotalSize().then(t=>(t>-1&&(t+=i.calculateSizeChange(e.getSubmittingItems(),e),t+=i.calculateSizeChange(e.getUnsubmittedItems(),e)),t))}static isEmpty(t,e){const a=t.getUnsubmittedItems(),s=t.getSubmittingItems();a.forEach((t,e)=>{if("add"===t.operation||"update"===t.operation)return"no"}),s.forEach((t,e)=>{if("add"===t.operation||"update"===t.operation)return"no"});const i=e.isEmpty();return"no"===i&&(a.size>0||s.size>0)?"unknown":i}static getSubmittableItems(t){const e=t.getUnsubmittedItems(),a=t.getSubmittingItems(),s=[];return e.forEach((t,e)=>{a.has(e)||s.push(t)}),s}static resetAllUnsubmittedItems(t){t.resetAllUnsubmittedItems()}static async resetUnsubmittedItem(t,e,s,d,r){return s.fetchByKeys({keys:r}).then(s=>{const r={};let n;const m=e.getAllTransactions(),o=t.item.metadata.key;if("add"===t.operation)i.removeFromMergedArrays(o,!1,d,e),i.addEventDetail(r,"remove",t.item),m.push({...t,operation:"remove"});else if("remove"===t.operation){if(n=s.results.get(o),n){let t=null;if(d){const a=d.mergedItemArray,s=i.findKeyInItems(o,a);if(-1!==s)for(let d=s+1;d<a.length;d++)if(!i.isItemRemoved(a[d].metadata.key,e)){t=a[d].metadata.key;break}}i.addEventDetail(r,"add",n,t),m.push({operation:"add",item:n,addDetail:{addBeforeKey:t}})}}else n=s.results.get(o),n?i.addEventDetail(r,"update",n):i.addEventDetail(r,"remove",t.item),m.push({operation:"update",item:n});return new a.DataProviderMutationEvent(r)})}static setItemStatus(t,e,a,s,i,d){return t?(null!=d&&a.set(d,t.item.metadata.key),s.setItemStatus(t,e,i),s):null}static async handleRefreshEvent(t,e,a){const s=e.getUnsubmittedItems(),i=new Set;return s.forEach(t=>{"remove"!==t.operation&&"update"!==t.operation||i.add(t.item.metadata.key)}),i.size>0?await a.fetchByKeys({keys:i}).then(t=>{t.results.forEach((t,e)=>{i.delete(e)}),i.forEach(t=>{s.delete(t)})}):t?.detail?.keys&&e.getSubmittingItems().forEach((a,s)=>{const i=s[0];t.detail.keys.has(i)&&this.cleanUpSubmittedItem(s,e)}),t}static handleMutateEvent(t,e,s,i,d){const r=t.detail.add;let n;r&&r.metadata&&r.data&&(n=r.addBeforeKeys?[...r.addBeforeKeys]:null,r.metadata.forEach((t,a)=>{let i;if(r.addBeforeKeys&&void 0!==r.addBeforeKeys[a])i=this.addToMergedArrays({metadata:r.metadata[a],data:r.data[a]},!0,s,e,r.addBeforeKeys[a]).addBeforeKey,null!=r.addBeforeKeys[a]&&null==i&&s&&s.mergedItemArray&&s.mergedItemArray.splice(s.mergedItemArray.length,0,{data:r.data[a],metadata:r.metadata[a]}),n[a]=i;else if(r.indexes&&null!=r.indexes[a]){let t=r.indexes[a];for(;s&&t<s.mergedItemArray.length&&this.isItemRemoved(s.mergedItemArray[t].metadata.key,e);)t++;s&&t>=s.mergedItemArray.length&&s.mergedItemArray.splice(s.mergedItemArray.length,0,{data:r.data[a],metadata:r.metadata[a]})}this.cleanUpSubmittedItem(t.key,e)}));const m=t.detail.remove;m&&m.keys.forEach(t=>{this.removeFromMergedArrays(t,!0,s,e),this.cleanUpSubmittedItem(t,e)});const o=[],u=t.detail.update;if(u){let t=[];u.data.forEach((a,i)=>{o[i]=this.isSortFieldUpdated(u.metadata[i].key,u,s,d),o[i]&&(this.removeFromMergedArrays(u.metadata[i].key,!0,s,e),t[i]=this.addToMergedArrays({data:a,metadata:u.metadata[i]},!0,s,e,null).addBeforeKey,null==t[i]&&s&&s.mergedItemArray&&s.mergedItemArray.splice(s.mergedItemArray.length,0,{data:a,metadata:u.metadata[i]})),this.cleanUpSubmittedItem(u.metadata[i].key,e)})}const l=this.getOperationDetails(t.detail,n,e);return this.checkGeneratedKeys(l,i,s),new a.DataProviderMutationEvent(l)}static fetchNext(t,e,s,d,r,n){const m=t?.signal,o=s.mergedAddKeySet,u=s.mergedItemArray;return a.wrapWithAbortHandling(m,a=>a(e.next().then(async a=>{a.value.fetchParameters&&a.value.fetchParameters.sortCriteria&&(d=a.value.fetchParameters.sortCriteria);const m=a.value.data.map((t,e)=>({data:a.value.data[e],metadata:a.value.metadata[e]}));n.totalFilteredRowCount=a.value.totalFilteredRowCount,await i.mergeEdits(m,u,t.filterCriterion,d,o,a.done,r,n);let l=u.length-s.nextOffset;for(let t=s.nextOffset;t<u.length;t++){const e=u[t];i.isItemRemoved(e.metadata.key,r)&&--l}const h=t||{};if((h.size&&l<h.size||null==h.size&&0===l)&&!a.done)return this.fetchNext(t,e,s,d,r,n);const f=[],c=[];let p;for(p=s.nextOffset;p<u.length;p++){const t=u[p];if(!i.isItemRemoved(t.metadata.key,r)&&(s.nextOffset=p+1,f.push(t.data),c.push(t.metadata),h.size&&f.length===h.size))break}return{done:a.done&&0===f.length,value:{fetchParameters:null==a.value?.fetchParameters?.sortCriteria?h:{...h,sortCriteria:a.value.fetchParameters.sortCriteria},data:f,metadata:c,totalFilteredRowCount:"enabled"===t?.includeFilteredRowCount?n.totalFilteredRowCount:null}}})),!1)}}t.BufferingDataProviderUtils=i,t.EditBuffer=class{constructor(){this.unsubmittedItems=new s,this.submittingItems=new s,this.submittedAddItems=new s,this.addItemOrder=[],this.mapOpTransform=new s,this.mapEditItemStatus=new s,this.transactions=[]}addItem(t,e){const a=t.metadata.key,s=this.unsubmittedItems.get(a),i=this.submittingItems.get(a);if(s&&("add"===s.operation||"update"===s.operation)||i&&("add"===i.operation||"update"===i.operation))throw new Error("Cannot add item with same key as an item being added or updated");const d={operation:"add",item:t,...e&&{addDetail:e}};if(this.transactions.push(d),s&&"remove"===s.operation){this.unsubmittedItems.delete(a);const t={...d,operation:"update"};return this.unsubmittedItems.set(a,t),this.mapOpTransform.set(a,t),void this.addItemOrder.unshift(a)}this.unsubmittedItems.set(a,d),this.addItemOrder.unshift(a)}removeItem(t){const e=t.metadata.key,a=this.unsubmittedItems.get(e),s=this.submittingItems.get(e);if(a&&"remove"===a.operation||s&&"remove"===s.operation)throw new Error("Cannot remove item with same key as an item being removed");const i={operation:"remove",item:t};return this.transactions.push(i),a&&"add"===a.operation?(this.unsubmittedItems.delete(e),void this._removeFromAddItemOrder(e)):a&&"update"===a.operation?(this.unsubmittedItems.delete(e),this.unsubmittedItems.set(e,i),this.mapOpTransform.delete(e),void this._removeFromAddItemOrder(e)):(this._removeFromAddItemOrder(e),void this.unsubmittedItems.set(e,i))}updateItem(t){const e=this.unsubmittedItems.get(t.metadata.key),a=this.submittingItems.get(t.metadata.key);if(e&&"remove"===e.operation||a&&"remove"===a.operation)throw new Error("Cannot update item with same key as an item being removed");const s={operation:"update",item:t};this.transactions.push(s),!e||"add"!==e.operation&&"update"!==e.operation?this.unsubmittedItems.set(t.metadata.key,s):this.unsubmittedItems.set(t.metadata.key,{operation:e.operation,item:t})}setItemMutated(t){const e=t.item.metadata.key,a=this.submittingItems.get(e);if(a){"submitted"===this.mapEditItemStatus.get(e)?(this.submittingItems.delete(e),"remove"===t.operation?this.submittedAddItems.delete(e):this._isAddOrMoveAdd(a)&&this.submittedAddItems.set(e,a)):(this.mapEditItemStatus.set(e,"mutated"),this.submittingItems.set(e,a))}}setItemStatus(t,e,a){const s=t.item.metadata.key;if("submitting"===e)this.unsubmittedItems.delete(s),this.submittingItems.set(s,t);else if("submitted"===e){if(t){"mutated"===this.mapEditItemStatus.get(s)?(this.submittingItems.delete(s),this._isAddOrMoveAdd(t)&&this.submittedAddItems.set(s,t)):this.mapEditItemStatus.set(s,"submitted")}}else if("unsubmitted"===e){let e;this.submittingItems.delete(s),e=a?{operation:t.operation,item:{data:t.item.data,metadata:{key:t.item.metadata.key,message:a}}}:t,this.unsubmittedItems.set(s,e)}}getUnsubmittedItems(){return this.unsubmittedItems}getSubmittingItems(){return this.submittingItems}getSubmittedAddItems(){return this.submittedAddItems}isEmpty(t){return 0===this.unsubmittedItems.size&&0===this.submittingItems.size&&(!t||0===this.submittedAddItems.size)}getItem(t,e){let a=this.unsubmittedItems.get(t);return a||(a=this.submittingItems.get(t)),e&&!a&&(a=this.submittedAddItems.get(t)),a}isUpdateTransformed(t){return!!this.mapOpTransform.get(t)}getEditItemStatus(t){return this.mapEditItemStatus.get(t)}isSubmittingOrSubmittedAdd(t){return"add"===this.submittingItems.get(t)?.operation||this.submittedAddItems.has(t)}resetAllUnsubmittedItems(){this._clearAddItemOrder(),this.unsubmittedItems.clear(),this.submittingItems.clear(),this.mapOpTransform.clear(),this.transactions=[]}_clearAddItemOrder(){this.unsubmittedItems.forEach((t,e)=>{this._isAddOrMoveAdd(t)&&this._removeFromAddItemOrder(e)}),this.submittingItems.forEach((t,e)=>{this._isAddOrMoveAdd(t)&&this._removeFromAddItemOrder(e)})}_removeFromAddItemOrder(t){let a=this.addItemOrder.findIndex(a=>e.KeyUtils.equals(a,t));-1!==a&&this.addItemOrder.splice(a,1)}_isAddOrMoveAdd(t){return"add"===t.operation||this._isMoveAdd(t)}_isMoveAdd(t){return"update"===t.operation&&this.isUpdateTransformed(t.item.metadata.key)}getAddItemOrder(){return this.addItemOrder}getAllTransactions(){return this.transactions}},t.TreeEditBuffer=class{constructor(t,e,a){this.editBuffer=t,this.parentKey=e,this.bufferingTreeDataProvider=a}filterByParentKey(t){const a=new s;return t.forEach((t,s)=>{const i=this.getParentKeyFromKey(s);e.KeyUtils.equals(i,this.parentKey)&&a.set(s,t)}),a}getParentKeyFromKey(t){return t.slice(0,t.length-1)}addItem(t,e){return this.editBuffer.addItem(t,e)}removeItem(t){return this.editBuffer.removeItem(t)}updateItem(t){return this.editBuffer.updateItem(t)}setItemMutated(t){return this.editBuffer.setItemMutated(t)}setItemStatus(t,e,a){return this.editBuffer.setItemStatus(t,e,a)}getUnsubmittedItems(){const t=this.editBuffer.getUnsubmittedItems();return void 0!==this.parentKey?this.filterByParentKey(t):t}getSubmittingItems(){const t=this.editBuffer.getSubmittingItems();return void 0!==this.parentKey?this.filterByParentKey(t):t}getSubmittedAddItems(){const t=this.editBuffer.getSubmittedAddItems();return void 0!==this.parentKey?this.filterByParentKey(t):t}isEmpty(t){return 0===this.getUnsubmittedItems().size&&0===this.getSubmittingItems().size&&(!t||0===this.getSubmittedAddItems().size)}getItem(t,e){return this.editBuffer.getItem(t,e)}isUpdateTransformed(t){return this.editBuffer.isUpdateTransformed(t)}getEditItemStatus(t){return this.editBuffer.getEditItemStatus(t)}isSubmittingOrSubmittedAdd(t){return this.editBuffer.isSubmittingOrSubmittedAdd(t)}resetAllUnsubmittedItems(){return this.editBuffer.resetAllUnsubmittedItems()}getAddItemOrder(){return this.editBuffer.getAddItemOrder().filter(t=>{const a=this.bufferingTreeDataProvider.convertKeyToKeyPath(t),s=this.bufferingTreeDataProvider.getParentKey(a);return e.KeyUtils.equals(s,this.parentKey)})}getAllTransactions(){const t=this.editBuffer.getAllTransactions();return void 0!==this.parentKey?t.filter(t=>{const a=this.getParentKeyFromKey(t.item.metadata.key);return e.KeyUtils.equals(a,this.parentKey)}):t}},Object.defineProperty(t,"__esModule",{value:!0})});
//# sourceMappingURL=ojbufferingutils.js.map