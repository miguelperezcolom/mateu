{"version":3,"file":"scale-2f3251e1.js","sources":["../../src/utils/PRIVATE_chartUtils/scale.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport class ScaleLinear {\n  private _domain: [number, number];\n  private _range: [number, number];\n  // y = mx + c; store m and c param\n  private m: number;\n  private c: number;\n\n  constructor(domain: [number, number], range: [number, number]) {\n    this._domain = domain;\n    this._range = range;\n    this.m = (this._range[1] - this._range[0]) / (this._domain[1] - this._domain[0]);\n    this.c = this._range[0] - this.m * this._domain[0];\n  }\n\n  transform(value: number) {\n    return this.m * value + this.c;\n  }\n\n  invert(value: number) {\n    return (value - this.c) / this.m;\n  }\n\n  domain() {\n    return this._domain;\n  }\n\n  range() {\n    return this._range;\n  }\n}\n\nexport class ScaleLog {\n  private _domain: [number, number];\n  private _linearDomain: [number, number];\n  private _range: [number, number];\n  private linearScale: ScaleLinear;\n\n  constructor(domain: [number, number], range: [number, number]) {\n    this._linearDomain = [Math.log(domain[0]), Math.log(domain[1])];\n    this._domain = domain;\n    this._range = range;\n    this.linearScale = new ScaleLinear(this._linearDomain, this._range);\n  }\n\n  transform(value: number) {\n    const v = Math.log(value);\n    return this.linearScale.transform(v);\n  }\n\n  invert(value: number) {\n    const v = this.linearScale.invert(value);\n    return Math.pow(10, v);\n  }\n\n  domain() {\n    return this._domain;\n  }\n\n  range() {\n    return this._range;\n  }\n}\n\nexport class VariableWidthScale {\n  private _domain: [number, number];\n  private _range: [number, number];\n  private _groupWidthRatios: number[] | null;\n\n  private _borderValues?: number[];\n  private _borderCoords?: number[];\n  private _groupWidths?: number[];\n  private _groupCount?: number;\n  private MinValue: number;\n  private MaxValue: number;\n  private StartCoord: number;\n  private EndCoord: number;\n\n  constructor(\n    domain: [number, number],\n    range: [number, number],\n    groupWidthRatios: number[] | null,\n    groupCount: number\n  ) {\n    this._domain = domain;\n    this._range = range;\n    this._groupWidthRatios = groupWidthRatios;\n    this.MinValue = this._domain[0];\n    this.MaxValue = this._domain[1];\n    this.StartCoord = this._range[0];\n    this.EndCoord = this._range[1];\n    this._groupCount = groupCount;\n    this._processGroupWidthRatios();\n  }\n\n  _processGroupWidthRatios() {\n    // Edge case: less than two groups\n    if (!this._groupWidthRatios || this._groupWidthRatios.length < 2) {\n      this._groupWidthRatios = [];\n      return;\n    }\n\n    // Compute the sums of the group widths that are contained within the viewport\n    let sum = 0;\n    let groupMin, groupMax;\n    for (let g = 0; g < this._groupCount!; g++) {\n      groupMin = g == 0 ? this.MinValue : Math.max(g - 0.5, this.MinValue);\n      groupMax = g == this._groupCount! - 1 ? this.MaxValue : Math.min(g + 0.5, this.MaxValue);\n      if (groupMax > groupMin) {\n        sum += (groupMax - groupMin) * this._groupWidthRatios[g];\n      }\n    }\n\n    // Divide the total viewport length (in pixels) proportionally based on the group width ratios.\n    const totalWidth = this.EndCoord - this.StartCoord;\n    this._groupWidths = this._groupWidthRatios.map((ratio) => {\n      return (ratio * totalWidth) / sum;\n    });\n\n    // Construct borderValues array which stores the the value location of the group boundaries.\n    this._borderValues = [];\n    for (let g = 0; g < this._groupWidthRatios.length - 1; g++) {\n      this._borderValues.push(g + 0.5);\n    }\n\n    // Construct borderCoords array which stores the coord location of the group boundaries.\n    this._borderCoords = [];\n    const anchor = Math.min(Math.max(Math.round(this.MinValue), 0), this._borderValues.length - 1);\n    this._borderCoords[anchor] =\n      this.StartCoord + (this._borderValues[anchor] - this.MinValue) * this._groupWidths[anchor];\n    for (\n      let g = anchor + 1;\n      g < this._borderValues.length;\n      g++ // compute borderCoords after the anchor\n    ) {\n      this._borderCoords[g] = this._borderCoords[g - 1] + this._groupWidths[g];\n    }\n    for (\n      let g = anchor - 1;\n      g >= 0;\n      g-- // compute borderCoords before the anchor\n    ) {\n      this._borderCoords[g] = this._borderCoords[g + 1] - this._groupWidths[g + 1];\n    }\n  }\n\n  transform(value: number) {\n    if (this._groupWidthRatios) {\n      // Find the anchor, i.e. the group boundary closest to the value.\n      let anchor = this._borderValues!.length;\n      for (let g = 0; g < this._borderValues!.length; g++) {\n        if (value <= this._borderValues![g]) {\n          anchor = g;\n          break;\n        }\n      }\n\n      // Compute the coord based on the group width at the anchor.\n      if (anchor == 0) {\n        return this._borderCoords![0] - this._groupWidths![0] * (this._borderValues![0] - value);\n      } else {\n        return (\n          this._borderCoords![anchor - 1] +\n          this._groupWidths![anchor] * (value - this._borderValues![anchor - 1])\n        );\n      }\n    }\n    return 0;\n  }\n\n  invert(coord: number) {\n    if (this._groupWidthRatios) {\n      // Find the anchor, i.e. the group boundary closest to the coord.\n      let anchor = this._borderCoords!.length;\n      for (let g = 0; g < this._borderCoords!.length; g++) {\n        if (coord <= this._borderCoords![g]) {\n          anchor = g;\n          break;\n        }\n      }\n      // Compute the value based on the group width at the anchor.\n      if (anchor == 0) {\n        return this._borderValues![0] - (this._borderCoords![0] - coord) / this._groupWidths![0];\n      } else {\n        return (\n          this._borderValues![anchor - 1] +\n          (coord - this._borderCoords![anchor - 1]) / this._groupWidths![anchor]\n        );\n      }\n    }\n    return 0;\n  }\n\n  domain() {\n    return this._domain;\n  }\n\n  range() {\n    return this._range;\n  }\n}\n"],"names":["ScaleLinear","constructor","domain","range","this","_domain","_range","m","c","transform","value","invert","_linearDomain","Math","log","linearScale","v","pow","groupWidthRatios","groupCount","_groupWidthRatios","MinValue","MaxValue","StartCoord","EndCoord","_groupCount","_processGroupWidthRatios","length","groupMin","groupMax","sum","g","max","min","totalWidth","_groupWidths","map","ratio","_borderValues","push","_borderCoords","anchor","round","coord"],"mappings":"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"}