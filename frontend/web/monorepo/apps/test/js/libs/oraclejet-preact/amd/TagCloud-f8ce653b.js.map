{"version":3,"file":"TagCloud-f8ce653b.js","sources":["../../src/UNSAFE_TagCloud/tagCloudNavUtils.ts","../../src/UNSAFE_TagCloud/tagCloudUtils.ts","../../src/UNSAFE_TagCloud/TagCloudItem.tsx","../../src/UNSAFE_TagCloud/useTagCloudDatatip.ts","../../src/UNSAFE_TagCloud/TagCloudWithDimensions.tsx","../../src/UNSAFE_TagCloud/useTagCloudContextMenu.ts","../../src/UNSAFE_TagCloud/TagCloud.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  ItemActionDetail,\n  ItemFocusDetail,\n  ItemHoverDetail,\n  ItemInfo,\n  TagCloudItemData\n} from './tagCloud.type';\n\n/**\n * Returns the item based on item info in a tag cloud.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getItem<K, D extends TagCloudItemData<K>>(itemInfo: ItemInfo, items: D[]) {\n  const { idx } = itemInfo;\n  return items[idx];\n}\n\nexport function getItemPadding(height: number | undefined) {\n  return height != null ? 0.15 * height : 0;\n}\n\n/**\n * Returns the next item's info in a tag cloud.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getNextItemInfo<K>(itemInfo: ItemInfo, items: TagCloudItemData<K>[]) {\n  let idx = itemInfo.idx;\n\n  idx = Math.min(items.length - 1, idx + 1);\n  return { idx, id: items[idx].id };\n}\n\n/**\n * Returns the previous item's info in a tag cloud.\n * @param itemInfo\n * @param items\n * @returns\n */\nfunction getPrevItemInfo<K>(itemInfo: ItemInfo, items: TagCloudItemData<K>[]) {\n  let idx = itemInfo.idx;\n\n  idx = Math.max(0, idx - 1);\n  return { idx, id: items[idx].id };\n}\n\n/**\n * Returns utils functions for navigation in a tag cloud.\n * @param items\n * @returns\n */\nexport function getTagCloudNavUtils<K, D extends TagCloudItemData<K>>(items: D[]) {\n  return {\n    getItem: (itemInfo: ItemInfo) => {\n      return getItem(itemInfo, items);\n    },\n    getDetailFromInfo: (\n      itemInfo?: ItemInfo\n    ): ItemFocusDetail<K, D> | ItemHoverDetail<K, D> | ItemActionDetail<K, D> => {\n      if (!itemInfo) {\n        return { id: undefined, data: undefined };\n      }\n      const item = getItem(itemInfo, items);\n      return { id: item.id, data: item };\n    },\n    getPrevItemInfo: (itemInfo: ItemInfo) => {\n      return getPrevItemInfo(itemInfo, items);\n    },\n    getNextItemInfo: (itemInfo: ItemInfo) => {\n      return getNextItemInfo(itemInfo, items);\n    }\n  };\n}\n","import { ItemInfo, TagCloudItemData } from './tagCloud.type';\nimport { getContrastingTextColor } from '#utils/PRIVATE_colorUtils/colorUtils';\nimport { getUnion, intersects, type Rect } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport { TagItemProps } from './TagCloudItem';\nimport { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { getItemPadding } from './tagCloudNavUtils';\nimport { DatatipType } from './tagCloud.type';\nimport { cancelEvent } from '#utils/UNSAFE_visUtils';\nimport { generateAriaLabel } from '#utils/UNSAFE_visUtils/accUtils';\nimport type { JSX } from 'preact';\n\nconst BOTTOM_PADDING = 20;\nconst DEFAULT_FONT_SIZE = 12;\n\n/**\n * helper layout functions for font size calc\n * @param {number} minValue\n * @param {number} maxValue\n * @param {number} range\n * @return {number}\n */\nexport const fontSizeCalc = (value: number, minValue: number, maxValue: number, range: number) => {\n  return minValue === maxValue\n    ? DEFAULT_FONT_SIZE\n    : DEFAULT_FONT_SIZE +\n        Math.ceil((((range - 1) * (value - minValue)) / (maxValue - minValue)) * DEFAULT_FONT_SIZE);\n};\n\n/**\n * returns initial font size arr of items for layout\n * @param {Array} items\n * @return {Array}\n */\nexport function getInitialFontSize<K>(items: TagCloudItemData<K>[]): TagItemProps<K>[] {\n  const fontSizeArr = [];\n  let minValue = Number.MAX_VALUE;\n  let maxValue = -Number.MAX_VALUE;\n  // First iterate thru data items to find the min and max values\n  for (let i = 0; i < items.length; i++) {\n    minValue = Math.min(minValue, items[i].value);\n    maxValue = Math.max(maxValue, items[i].value);\n  }\n\n  for (let i = 0; i < items.length; i++) {\n    const x = fontSizeCalc(items[i].value, minValue, maxValue, 3);\n    fontSizeArr.push({ ...items[i], fontSize: x });\n  }\n  return fontSizeArr;\n}\n\n/**\n * Calculates the line breaks for rectangular layout\n * @param {Array} arDims an array of Dimension objects for each tag\n * @param {number} width the available width\n * @return {Array} an array containing the starting tag index for each line in the layout\n * @private\n */\nexport function calculateLineBreaks(arDims: Rect[], width: number) {\n  const hPadding = 2;\n  const lines = [0];\n  let curWidth = arDims[0].w + hPadding;\n  if (arDims.length > 1) {\n    for (let i = 1; i < arDims.length; i++) {\n      if (curWidth + arDims[i].w > width) {\n        lines.push(i);\n        curWidth = 0;\n      }\n      curWidth += arDims[i].w + hPadding;\n    }\n  }\n  return lines;\n}\n\n/**\n * Returns the items position and font size in cloud layout.\n * @param items\n * @param tagcloudH\n * @param tagcloudW\n */\nexport function getCloudLayout<K>(\n  items: TagCloudItemData<K>[],\n  tagcloudW: number,\n  tagcloudH: number,\n  isRTL: boolean,\n  getTextDimensions: GetTextDimensionsType\n): TagItemProps<K>[] {\n  const positions = [];\n  const steps = 180;\n  let xrStep = 10 / steps;\n  let yrStep = 10 / steps;\n  if (tagcloudW > tagcloudH) xrStep *= tagcloudW / tagcloudH;\n  else yrStep *= tagcloudH / tagcloudW;\n  const thetaStep = (2 * Math.PI) / steps;\n  let bounds = null;\n  let maxFontSize = 0;\n  const cosCache = [];\n  const sinCache = [];\n  const tagWordData = [];\n  const tagCloudX = 0; // availSpace.x\n  const tagCloudY = 0; // availSpace.y\n\n  const initialFontItems = getInitialFontSize(items);\n\n  for (let i = 0; i < initialFontItems.length; i++) {\n    let placed = false;\n    let step = 0;\n    let stepIncrement = 4;\n    const tag = initialFontItems[i];\n    const tagDimensions = getTextDimensions(tag.label, {\n      fontSize: tag.fontSize + 'px'\n    });\n    maxFontSize = Math.max(maxFontSize, tag.fontSize);\n    let lastCollisionIndex = -1;\n    while (!placed) {\n      // cache sin/cos values because Chrome is slow at these calculations\n      const lookup = step % steps;\n      if (cosCache[lookup] === undefined) cosCache[lookup] = Math.cos(step * thetaStep);\n      if (sinCache[lookup] === undefined) sinCache[lookup] = Math.sin(step * thetaStep);\n      const _x = xrStep * step * cosCache[lookup];\n      const _y = yrStep * step * sinCache[lookup];\n      const padding = getItemPadding(tagDimensions.height);\n      const tagCloudDiv = {\n        x: _x,\n        y: _y,\n        w: tagDimensions.width + 2 * padding,\n        h: tagDimensions.height + 2 * padding\n      }; // this needs to change\n      placed = true;\n      if (lastCollisionIndex !== -1) {\n        if (intersects(positions[lastCollisionIndex], tagCloudDiv)) {\n          placed = false;\n        }\n      }\n\n      if (placed) {\n        for (let j = 0; j < i; j++) {\n          if (intersects(positions[j], tagCloudDiv)) {\n            lastCollisionIndex = j;\n            placed = false;\n            break;\n          }\n        }\n      }\n\n      if (placed) {\n        if (!bounds) {\n          bounds = tagCloudDiv;\n        } else {\n          bounds = getUnion(bounds, tagCloudDiv);\n        }\n        lastCollisionIndex = -1;\n        positions[i] = tagCloudDiv;\n        tag.x = _x; // tag.setX(x)\n        tag.y = _y; // tag.setY(-tagCloudDiv.y + y);\n        tag.w = tagDimensions.width;\n        tag.h = tagDimensions.height;\n      }\n      // Adjust stepIncrement so we check smaller degrees as spiral loops out\n      if (step == 3600) {\n        // 20 loops\n        stepIncrement = 3;\n      } else if (step == 5400) {\n        // 30 loops\n        stepIncrement = 2;\n      } else if (step == 10800) {\n        // 60 loops\n        stepIncrement = 1;\n      }\n      step += stepIncrement;\n    }\n  }\n\n  if (bounds) {\n    const scale = Math.max(bounds.w / tagcloudW, bounds.h / tagcloudH);\n    const cx = bounds.x + bounds.w / 2;\n    const cy = bounds.y + bounds.h / 2;\n\n    for (let k = 0; k < initialFontItems.length; k++) {\n      let tagItemX;\n      const tagItem = initialFontItems[k];\n      if (!isRTL) {\n        tagItemX =\n          tagItem.x != null ? tagCloudX + tagItem.x / scale + (tagcloudW / 2 - cx / scale) : 0;\n      } else {\n        tagItemX =\n          tagItem.x != null ? tagCloudX - tagItem.x / scale - (tagcloudW / 2 - cx / scale) : 0;\n      }\n\n      const tagItemY =\n        tagItem.y != null ? tagCloudY + tagItem.y / scale + (tagcloudH / 2 - cy / scale) : 0;\n      const tagItemW = tagItem.w != null ? tagItem.w / scale : 0;\n      const tagItemH = tagItem.h != null ? tagItem.h / scale : 0;\n      const fontSize = tagItem.fontSize;\n      const tagItemFontSize = fontSize / scale;\n      tagWordData.push({\n        ...tagItem,\n        x: tagItemX,\n        y: tagItemY,\n        fontSize: tagItemFontSize,\n        w: tagItemW,\n        h: tagItemH\n      });\n    }\n  }\n  return tagWordData;\n}\n/**\n * Returns the items position and font size in rectangle layout.\n * @param items\n * @param tagcloudH\n * @param tagcloudW\n * @param isRTL\n * @param getTextDimensions\n */\nexport function getRectangleLayout<K>(\n  items: TagCloudItemData<K>[],\n  tagcloudW: number,\n  tagcloudH: number,\n  isRTL: boolean,\n  getTextDimensions: GetTextDimensionsType\n) {\n  const tagWordData = [];\n  const arDims = [];\n  let maxWidth = 0;\n  let maxHeight = 0;\n  let maxFontSize = 0;\n  const vPadding = 2;\n  const margin = 0;\n  const tagCloudX = 0; // availSpace.x\n  const tagCloudY = 0; // availSpace.y\n\n  // initial items processing\n  const initialFontItems = getInitialFontSize(items);\n\n  // Get the unscaled dimensions\n  for (let i = 0; i < initialFontItems.length; i++) {\n    const tag = initialFontItems[i];\n    const tagDimensions = getTextDimensions(tag.label, {\n      fontSize: tag.fontSize + 'px'\n    });\n    maxWidth = Math.max(maxWidth, tagDimensions.width);\n    maxHeight = Math.max(maxHeight, tagDimensions.height);\n    maxFontSize = Math.max(maxFontSize, tag.fontSize);\n    arDims.push({\n      w: tagDimensions.width,\n      h: tagDimensions.height,\n      x: tagDimensions.x,\n      y: tagDimensions.y\n    });\n  }\n\n  // Iteratively calculate the ideal font scale\n  let minScale = 0;\n  let maxScale = (tagcloudW - 2 * margin) / maxWidth; // This is the max scale that can be applied before the longest word will no longer fit\n  let scale;\n  let arLines;\n  while (maxScale - minScale > 0.001) {\n    scale = (minScale + maxScale) / 2;\n    arLines = calculateLineBreaks(arDims, (tagcloudW - 2 * margin) / scale);\n    const h = arLines.length * (scale * maxHeight + vPadding) - vPadding;\n    if (h > tagcloudH - 2 * margin) {\n      maxScale = scale;\n    } else {\n      minScale = scale;\n    }\n  }\n\n  // Calculate final line breaks\n  scale = minScale;\n  arLines = calculateLineBreaks(arDims, (tagcloudW - 2 * margin) / scale);\n  arLines.push(initialFontItems.length);\n  for (let k = 0; k < arLines.length - 1; k++) {\n    const lineStart = arLines[k];\n    const lineEnd = arLines[k + 1];\n    let hPadding = 5;\n    let maxLineHeight = 0;\n    let justified = true;\n    if (lineEnd - lineStart > 1) {\n      let lineWidth = 0;\n      for (let j = lineStart; j < lineEnd; j++) {\n        lineWidth += arDims[j].w * scale;\n        maxLineHeight = Math.max(maxLineHeight, arDims[j].h * scale);\n      }\n      hPadding = (tagcloudW - 2 * margin - lineWidth) / (lineEnd - lineStart - 1);\n\n      if (k == arLines.length - 2) {\n        // Don't justify the last line unless flowing it with a gap of .5 * maxLineHeight fills more than\n        // 90% of the width\n        const flowPadding = 0.5 * maxLineHeight;\n        if (\n          flowPadding < hPadding &&\n          lineWidth + (lineEnd - lineStart) * flowPadding < 0.9 * (tagcloudW - 2 * margin)\n        ) {\n          hPadding = flowPadding;\n          justified = false;\n        }\n      }\n    }\n\n    const bottomY = margin + (k + 1) * (maxHeight * scale + vPadding) - vPadding;\n    let curX = margin;\n    for (let m = lineStart; m < lineEnd; m++) {\n      const tagLine = initialFontItems[m];\n      const fontSize = tagLine.fontSize;\n      const tagItemFontSize = fontSize * scale;\n      tagLine.fontSize = tagItemFontSize;\n      const tagDimensionsWidth = arDims[m].w * scale;\n      tagLine.y = tagCloudY + bottomY + arDims[m].y * scale - BOTTOM_PADDING;\n      if (justified && m === lineEnd - 1 && m !== lineStart) {\n        if (!isRTL) tagLine.x = tagCloudX + tagcloudW - tagDimensionsWidth - margin;\n        else tagLine.x = tagCloudX + tagDimensionsWidth + margin - tagcloudW;\n        // alignRight(tagLine);\n      } else {\n        // alignLeft(tagLine);\n        tagLine.x = tagCloudX + curX;\n        if (!isRTL) {\n          curX += arDims[m].w * scale + hPadding;\n        } else {\n          // tagLine.alignRight();\n          curX -= arDims[m].w * scale + hPadding;\n        }\n      }\n      tagWordData.push({ ...tagLine, w: tagDimensionsWidth, h: arDims[m].h * scale });\n    }\n  }\n  return tagWordData;\n}\n\n/**\n * Calls the right layout algorithm based on tagcloud type.\n * @param layout cloud or rectangle. cloud if not defined.\n * @param items\n * @param tagcloudW tagcloud width\n * @param tagcloudH tagcloud height\n * @param isRTL\n * @param getTextDimensions\n */\nexport function getLayout<K>(\n  layout: string | undefined,\n  items: TagCloudItemData<K>[],\n  tagcloudW: number,\n  tagcloudH: number,\n  isRTL: boolean,\n  getTextDimensions: GetTextDimensionsType\n) {\n  let layoutTagCloud;\n  if (layout === 'cloud' || !layout) {\n    layoutTagCloud = getCloudLayout(items, tagcloudW, tagcloudH, isRTL, getTextDimensions);\n  } else {\n    layoutTagCloud = getRectangleLayout(items, tagcloudW, tagcloudH, isRTL, getTextDimensions);\n  }\n  return layoutTagCloud;\n}\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param highlighted The set of highlighted item\n */\nexport function isItemHighlighted<K>(id: K, highlightedIds?: K[]) {\n  if (!highlightedIds) {\n    return;\n  }\n  if (highlightedIds.length === 0) {\n    return true;\n  }\n  return new Set(highlightedIds).has(id);\n}\n\n/**\n * Checks if the item is highlighted.\n * @param id Id of the item\n * @param selectedIds The set of highlighted item\n */\nexport function isItemSelected<K>(id: K, selectedIds?: K[]) {\n  if (!selectedIds || selectedIds.length === 0) {\n    return false;\n  }\n  return new Set(selectedIds).has(id);\n}\n\n/**\n * Returns the aria properties for the tag cloud.\n * @param isReadOnly { boolean } If the tag cloud is readonly.\n * @param accessibleLabel { string } The aria-label set by the app.\n * @returns The aria props.\n */\nexport function getAriaProps(\n  translations: BundleType,\n  hasData?: boolean,\n  accessibleLabel?: string,\n  ariaDescribedBy?: string,\n  ariaLabelledBy?: string\n): {\n  'aria-label': UnpackSignals<JSX.AriaAttributes>['aria-label'];\n  role: UnpackSignals<JSX.HTMLAttributes>['role'];\n  'aria-describedby': UnpackSignals<JSX.AriaAttributes>['aria-describedby'];\n  'aria-labelledby': UnpackSignals<JSX.AriaAttributes>['aria-labelledby'];\n} {\n  return {\n    'aria-label': `${accessibleLabel || ''} ${hasData ? '' : translations.vis_noData()}`,\n    role: 'application',\n    'aria-describedby': ariaDescribedBy,\n    'aria-labelledby': ariaLabelledBy\n  };\n}\n\n/**\n * Returns the aria properties for the tag cloud.\n * @param isReadOnly { boolean } If the tag cloud is readonly.\n * @param accessibleLabel { string } The aria-label set by the app.\n * @returns The aria props.\n */\nexport function getItemAriaProps(\n  supportsSelection: boolean,\n  translations?: BundleType,\n  isSelected?: boolean,\n  accessibleLabel?: string,\n  role?: UnpackSignals<JSX.HTMLAttributes['role']>\n): {\n  'aria-label': UnpackSignals<JSX.AriaAttributes>['aria-label'];\n  role: UnpackSignals<JSX.HTMLAttributes['role']>;\n} {\n  return {\n    'aria-label':\n      generateAriaLabel(translations!, accessibleLabel!, {\n        isSelected: !supportsSelection ? undefined : isSelected\n      }) || undefined,\n    role: role || 'img'\n  };\n}\n\n/**\n * Returns the item props for BaseTagCloudItem.\n * @param item The tagcloud item.\n * @param itemIdx The item index of the item.\n * @param supportsSelection Whether the tagcloud supports selection\n * @param isReadOnly Whether the tagcloud is readonly.\n * @param hoveredItem The info of the currently hovered item.\n * @param selectedIds The selected ids.\n * @param focusedItem The info of currently focused item.\n * @param highlightedIds The highlighted ids.\n * @param activeId The active Id\n */\nexport function getItemProps<K>(\n  item: TagCloudItemData<K>,\n  itemIdx: number,\n  supportsSelection: boolean,\n  isReadOnly: boolean,\n  hoveredItem?: ItemInfo,\n  selectedIds?: Array<K>,\n  focusedItem?: ItemInfo,\n  highlightedIds?: Array<K>,\n  activeId?: string\n) {\n  let isCurrent = false;\n  let style;\n  if (!isReadOnly) {\n    const isFocusedItem = itemIdx === focusedItem?.idx;\n    const isHoveredItem = itemIdx === hoveredItem?.idx;\n    isCurrent = !!(\n      (isFocusedItem && focusedItem?.isCurrent) ||\n      (isHoveredItem && hoveredItem?.isCurrent)\n    );\n  }\n  const isHighlighted = isItemHighlighted<K>(item.id, highlightedIds);\n  const isSelected = isItemSelected(item.id, selectedIds);\n\n  if (item.color) {\n    let color, backgroundColor, backgroundImage;\n\n    if (isSelected) {\n      backgroundColor = item.color;\n      color = getContrastingTextColor(backgroundColor);\n    }\n    // hovered and selection supported\n    else color = item.color;\n\n    style = {\n      color,\n      backgroundColor,\n      backgroundImage\n    };\n  } else if (!supportsSelection) {\n    style = {\n      backgroundColor: 'none'\n    };\n  }\n\n  return {\n    isCurrent,\n    isHighlighted: isHighlighted,\n    isSelected: isSelected,\n    isFocused: focusedItem ? hasFocusRing(focusedItem, itemIdx) : false,\n    key: item.id,\n    itemIdx,\n    style,\n    activeId: isCurrent ? activeId : undefined,\n    isReadOnly,\n    ...item\n  };\n}\n\n/**\n * Returns the text for the tag cloud datatip.\n * @param items The tag cloud items data.\n * @param focusedItem The item currently keyboard focused.\n * @param hoveredItem The item that is currently hovered.\n * @param datatip The datatip.\n */\nexport function getDatatipContent<D extends TagCloudItemData<number | string>>(\n  items: D[],\n  getItem: (itemInfo: ItemInfo, items: D[]) => D | undefined,\n  focusedItem: ItemInfo,\n  hoveredItem?: ItemInfo,\n  datatip?: DatatipType<D>\n) {\n  const activeItem = focusedItem.isCurrent\n    ? focusedItem\n    : hoveredItem?.isCurrent && hoveredItem.idx != null\n    ? hoveredItem\n    : undefined;\n\n  if (!activeItem) {\n    return {\n      content: undefined,\n      borderColor: undefined\n    };\n  }\n  const item = getItem(activeItem, items);\n  if (datatip && item) {\n    return datatip({ data: item });\n  }\n\n  return {\n    content: item?.accessibleLabel,\n    borderColor: undefined\n  };\n}\n\n/**\n * Returns the value of the data-oj-private-item-index attribute for a given element.\n * @param element The HTML element.\n */\nexport function getItemInfo(element: HTMLElement) {\n  const itemIdx = element.dataset['idx'];\n  if (itemIdx == null) return;\n\n  return {\n    idx: Number(itemIdx)\n  };\n}\n\n/**\n * Compares if two ItemInfo are equal\n * @param item1\n * @param item2\n * @returns\n */\nexport function isEqualItem(item1?: ItemInfo, item2?: ItemInfo) {\n  return item1?.idx === item2?.idx;\n}\n\n/**\n * Checks if the item is the currentItem and if the focus ring\n * is visible.\n * @param itemInfo ItemInfo\n * @param itemId Item index\n */\nexport function hasFocusRing(itemInfo: ItemInfo, itemIdx: number) {\n  if (!itemInfo.isFocusVisible) return false;\n  const { idx: idx } = itemInfo;\n\n  return idx === itemIdx;\n}\n\n/**\n * Returns KeyUp handler for Tagcloud.\n * @param triggerOnAction\n * @param updatefocusedItemInfo\n * @param focusedItemInfo\n * @returns\n */\nexport function getKeyUpHandler(\n  triggerOnAction: () => void,\n  updatefocusedItemInfo: (itemInfo: ItemInfo) => void,\n  focusedItemInfo: ItemInfo\n) {\n  return (event: KeyboardEvent) => {\n    const key = event.code;\n    switch (key) {\n      case 'Space': {\n        triggerOnAction();\n        cancelEvent(event);\n        break;\n      }\n      case 'Enter': {\n        triggerOnAction();\n        cancelEvent(event);\n        break;\n      }\n      case 'Tab': {\n        updatefocusedItemInfo({\n          ...focusedItemInfo,\n          isCurrent: true,\n          isFocusVisible: true\n        });\n        cancelEvent(event);\n        break;\n      }\n    }\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { JSX } from 'preact';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { BundleType } from '#resources/nls/bundle';\nimport { getItemAriaProps } from './tagCloudUtils';\nimport { styles } from './themes/TagCloudStyles.css';\nimport { getItemPadding } from './tagCloudNavUtils';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\n\nexport type TagItemProps<K> = {\n  id: K;\n  label: string;\n  accessibleLabel?: string;\n  value: number;\n  fontSize: number;\n  role?: UnpackSignals<JSX.HTMLAttributes['role']>;\n  itemIdx?: number;\n  supportsSelection?: boolean;\n  supportsAction?: boolean;\n  translations?: BundleType;\n  x?: number;\n  y?: number;\n  w?: number;\n  h?: number;\n  isHighlighted?: boolean;\n  isSelected?: boolean;\n  isCurrent?: boolean;\n  isFocused?: boolean;\n  isReadonly?: boolean;\n  class?: string;\n  style?: JSX.CSSProperties;\n  activeId?: string;\n};\n\nconst TagCloudItem = <K,>(props: TagItemProps<K>) => {\n  const {\n    itemBase,\n    itemStyle,\n    hoverUnselectedItemStyle,\n    selectedItemStyle,\n    hoveredSelectedItemStyle,\n    dimmedItemStyle,\n    interactiveCursorStyle\n  } = styles;\n  const isNotDimmed = props.isHighlighted || props.isHighlighted == null; // null means no highlighting feature\n\n  const itemClasses = classNames([\n    itemBase,\n    props.isSelected ? selectedItemStyle : itemStyle,\n    props.isCurrent\n      ? props.isSelected\n        ? hoveredSelectedItemStyle\n        : props.isFocused || props.supportsSelection\n        ? hoverUnselectedItemStyle\n        : ''\n      : '',\n    isNotDimmed ? '' : dimmedItemStyle,\n    props.supportsAction || props.supportsSelection ? interactiveCursorStyle : ''\n  ]);\n\n  const itemAriaProps = getItemAriaProps(\n    !!props.supportsSelection,\n    props.translations,\n    props.isSelected,\n    props.accessibleLabel,\n    props.role\n  );\n\n  const padding = getItemPadding(props.h);\n\n  return (\n    <div\n      key={props.id}\n      class={itemClasses}\n      data-id={`${props.id}`}\n      data-idx={props.itemIdx}\n      style={{\n        ...props.style,\n        transform: `translate(${(props.x || 0) - padding}px,${(props.y || 0) - padding}px)`,\n        fontSize: props.fontSize,\n        padding: `${padding}px`,\n        lineHeight: props.fontSize + 'px'\n      }}\n      id={props.activeId}\n      {...itemAriaProps}>\n      {props.label}\n    </div>\n  );\n};\n\nexport { TagCloudItem };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useLayoutEffect, useState } from 'preact/hooks';\nimport { ItemInfo } from './tagCloud.type';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { TagItemProps } from './TagCloudItem';\nimport { ComponentChildren } from 'preact';\nimport { useDatatip } from '#hooks/PRIVATE_useDatatip';\nimport { calculateOffset } from '#utils/PRIVATE_visLayoutUtils/layoutUtils';\nimport { Property } from 'csstype';\n\ntype props<K> = {\n  touchResponse: 'touchStart' | 'touchHold';\n  datatip?: { content?: ComponentChildren; borderColor?: Property.BorderColor };\n  borderColor?: Property.BorderColor;\n  rootRef: RefObject<HTMLDivElement>;\n  focusedItemInfo: ItemInfo;\n  focusedItemRef: RefObject<TagItemProps<K> | null>;\n};\n\n/**\n * Calculate the datatip offset for datatip when keyboard focus is active.\n * @param rootRef The ref for root of the tag cloud.\n * @param currentItem The ItemInfo of the current keyboard focused item.\n * @param isRtl The direction.\n * @param focusedItemRef The ref for currentItem node.\n * @returns\n */\nconst calculateTagcloudOffset = <K>(\n  rootRef: RefObject<HTMLDivElement>,\n  currentItem: ItemInfo,\n  isRtl: boolean,\n  focusedItemRef: RefObject<TagItemProps<K> | null>\n) => {\n  if (\n    focusedItemRef?.current &&\n    currentItem.isCurrent &&\n    rootRef.current &&\n    focusedItemRef?.current.x != null &&\n    focusedItemRef?.current.w != null &&\n    focusedItemRef?.current.y != null &&\n    focusedItemRef?.current.h != null\n  ) {\n    const bounds = {\n      x: focusedItemRef.current.x,\n      y: focusedItemRef.current.y,\n      width: focusedItemRef.current.w,\n      height: focusedItemRef.current.h\n    };\n\n    const rootDims = rootRef.current.getBoundingClientRect();\n    return calculateOffset(isRtl, rootDims.width, bounds);\n  }\n  // fallback to default\n  return calculateOffset(isRtl, 0, undefined);\n};\n\n/**\n * Returns the datatip.\n * @param text The text string for the tag cloud item.\n * @param rootRef The ref for root of the tag cloud.\n * @param focusedItemRef The ref for focused item node.\n * @param focusedItemInfo The ItemInfo for focused item node.\n * @returns\n */\nexport const useTagCloudDatatip = <K>({\n  touchResponse,\n  datatip,\n  rootRef,\n  focusedItemRef,\n  focusedItemInfo\n}: props<K>) => {\n  const { direction } = useUser();\n  const isRtl = direction === 'rtl';\n  const [offset, setOffset] = useState<{ mainAxis?: number; crossAxis?: number }>(\n    calculateTagcloudOffset(rootRef, focusedItemInfo, isRtl, focusedItemRef)\n  );\n\n  useLayoutEffect(() => {\n    setOffset(calculateTagcloudOffset(rootRef, focusedItemInfo, isRtl, focusedItemRef));\n  }, [focusedItemInfo, focusedItemRef, isRtl, rootRef]);\n\n  const anchor = focusedItemInfo?.isCurrent ? 'element' : 'pointer';\n  const placement = 'top-start' as const;\n\n  const { datatipContent, datatipProps } = useDatatip({\n    content: datatip?.content,\n    borderColor: datatip?.borderColor,\n    anchor,\n    placement,\n    offset: offset,\n    touchResponse\n  });\n  return { datatipContent, datatipProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type {\n  ItemActionDetail,\n  ItemFocusDetail,\n  TagCloudItemData,\n  TagCloudProps\n} from './tagCloud.type';\nimport { TagCloudItem, TagItemProps } from './TagCloudItem';\nimport {\n  getAriaProps,\n  getDatatipContent,\n  getItemProps,\n  getLayout,\n  isEqualItem,\n  getKeyUpHandler\n} from './tagCloudUtils';\nimport { getTagCloudNavUtils } from './tagCloudNavUtils';\nimport { useVisEvent } from '#hooks/PRIVATE_useVisEvents/useVisEvents';\nimport { useTagCloudDatatip } from './useTagCloudDatatip';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { useMemo, useRef } from 'preact/hooks';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '#resources/nls/bundle';\nimport { useTextDimensions } from '#hooks/PRIVATE_useTextDimensions';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { baseStyles } from './themes/TagCloudStyles.css';\nimport { useSelection } from '#hooks/PRIVATE_useVisSelection';\nimport { getItemInfo } from './tagCloudUtils';\nimport { useTestId } from '#hooks/UNSAFE_useTestId';\nimport { useTagCloudContextMenu } from './useTagCloudContextMenu';\nimport { ItemInfo } from './tagCloud.type';\nimport { useVisTouchResponse } from '#hooks/PRIVATE_useVisTouchResponse';\nimport { merge } from '@oracle/oraclejet-internal-utilities/stringUtils';\n\ntype TagCloudWithDimensionsProps<K, D> = Omit<TagCloudProps<K, D>, 'width' | 'height'> & {\n  width: number;\n  height: number;\n};\n\nexport function TagCloudWithDimensions<K extends string | number, D extends TagCloudItemData<K>>({\n  selectionMode = 'none',\n  layout = 'cloud',\n  width,\n  height,\n  items,\n  onItemAction,\n  onItemHover,\n  onItemFocus,\n  testId,\n  contextMenuConfig,\n  ...props\n}: TagCloudWithDimensionsProps<K, D>) {\n  const testIdProps = useTestId(testId);\n  const rootRef = useRef<HTMLDivElement>(null);\n  const focusedItemRef = useRef<TagItemProps<K> | null>(null);\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const hasData = items.length > 0;\n  const supportsSelection = !!(selectionMode && selectionMode !== 'none');\n  const supportsAction = onItemAction != null;\n  const isReadOnly = supportsAction && onItemHover === null && onItemFocus === null;\n  const idToDataMap = new Map(items.map((obj) => [obj.id, obj]));\n\n  const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getTagCloudNavUtils<\n    K,\n    D\n  >(items);\n\n  const { touchResponse, touchResponseStyle } = useVisTouchResponse({\n    type: 'auto',\n    supportsTouchDragGestures: false,\n    rootRef\n  });\n\n  const { focusedItemInfo, hoveredItemInfo, onContextMenuDismissed, activeId, eventsProps } =\n    useVisEvent<ItemInfo, ItemActionDetail<K, D>, ItemFocusDetail<K, D>, D>(\n      touchResponse,\n      !isReadOnly && hasData,\n      () => !isReadOnly,\n      getKeyUpHandler,\n      getDetailFromInfo,\n      getPrevItemInfo,\n      getNextItemInfo,\n      onItemAction,\n      onItemHover,\n      onItemFocus,\n      isEqualItem,\n      getItemInfo,\n      { idx: 0 }\n    );\n\n  const content = getDatatipContent<D>(\n    items,\n    getItem as (itemInfo: ItemInfo) => D,\n    focusedItemInfo,\n    hoveredItemInfo,\n    props.datatip\n  );\n  const {\n    datatipContent,\n    datatipProps: { 'aria-describedby': datatipAriaDescribedby, ...datatipProps }\n  } = useTagCloudDatatip({\n    touchResponse,\n    datatip: content,\n    rootRef,\n    focusedItemInfo,\n    focusedItemRef\n  });\n\n  const ariaProps = getAriaProps(\n    translations,\n    hasData,\n    props.accessibleLabel,\n    merge([props['aria-describedby'], datatipAriaDescribedby]),\n    props['aria-labelledby']\n  );\n\n  const idExtracter = (event: Event) => {\n    // return focused item for keyboard event.\n    // eventsProps should have already updated the focused item\n    const info =\n      event.type === 'keyup' ? focusedItemInfo : getItemInfo(event.target as HTMLElement);\n    return getDetailFromInfo(info).id;\n  };\n\n  const { selectionContent, selectionProps } = useSelection<K, D>({\n    idExtracter,\n    selection: props.selectedIds,\n    selectionMode: selectionMode,\n    onChange: props.onSelectionChange,\n    getDataById: (id) => idToDataMap.get(id)\n  });\n\n  const { direction } = useUser();\n\n  const { textMeasureContent, getTextDimensions } = useTextDimensions();\n  const layoutTags = useMemo(() => {\n    return getTextDimensions && hasData\n      ? getLayout(layout, items, width, height, direction === 'rtl', getTextDimensions)\n      : [];\n  }, [layout, items, hasData, width, height, direction, getTextDimensions]);\n\n  const { contextMenuContent, contextMenuProps } = useTagCloudContextMenu<D>({\n    getItemInfo,\n    focusedItemInfo,\n    rootRef,\n    contextMenuConfig: hasData ? contextMenuConfig : undefined,\n    items,\n    onContextMenuDismissed\n  });\n\n  const mergedProps = mergeProps(eventsProps, datatipProps, selectionProps, contextMenuProps);\n\n  return (\n    <div\n      ref={rootRef}\n      tabIndex={isReadOnly ? undefined : 0}\n      style={{ width, height, ...touchResponseStyle }}\n      class={baseStyles}\n      {...testIdProps}\n      {...ariaProps}\n      {...mergedProps}\n      aria-activedescendant={activeId}>\n      {layoutTags.map((item, itemIndex) => {\n        const itemProps = getItemProps(\n          item,\n          itemIndex,\n          supportsSelection,\n          isReadOnly,\n          hoveredItemInfo,\n          props.selectedIds,\n          focusedItemInfo,\n          props.highlightedIds,\n          activeId\n        );\n        const isFocusedItem = focusedItemInfo.idx === itemIndex;\n        isFocusedItem ? (focusedItemRef.current = item) : null;\n        return (\n          <TagCloudItem\n            fontSize={item.fontSize}\n            x={item.x}\n            y={item.y}\n            accessibleLabel={item.accessibleLabel}\n            supportsSelection={supportsSelection}\n            supportsAction={supportsAction}\n            translations={translations}\n            {...itemProps}\n          />\n        );\n      })}\n      {textMeasureContent}\n      {datatipContent}\n      {contextMenuContent}\n      {selectionContent}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { TagCloudContextMenuContext, TagCloudContextMenuConfig, ItemInfo } from './tagCloud.type';\nimport { type gestureTypes, useContextMenu } from '#hooks/PRIVATE_useVisContextMenu';\n\ntype Props<D> = {\n  focusedItemInfo: ItemInfo;\n  items: D[];\n  rootRef: RefObject<HTMLDivElement>;\n  contextMenuConfig?: TagCloudContextMenuConfig<D>;\n  onContextMenuDismissed?: (gesture: gestureTypes) => void;\n  getItemInfo: (element: HTMLElement) =>\n    | {\n        idx: number;\n      }\n    | undefined;\n};\n\nexport const useTagCloudContextMenu = <D>({\n  getItemInfo,\n  focusedItemInfo,\n  rootRef,\n  contextMenuConfig,\n  items,\n  onContextMenuDismissed\n}: Props<D>) => {\n  const { contextMenuProps, contextMenuContent } = useContextMenu<TagCloudContextMenuContext<D>>({\n    onContextMenuHandler: ({ gesture, target }) => {\n      if (gesture === 'keyboard') {\n        const idx = focusedItemInfo.idx;\n        const elem = rootRef.current?.querySelector(`[data-idx=\"${idx}\"]`) || null;\n        const data = items[idx];\n        const context = {\n          type: 'item' as const,\n          data\n        };\n        return {\n          type: 'element',\n          context,\n          elem\n        };\n      }\n\n      const idx = getItemInfo(target as HTMLElement)?.idx;\n      const data = idx !== undefined ? items[idx] : null;\n      let context;\n      if (data) {\n        context = {\n          type: 'item' as const,\n          data\n        };\n      } else {\n        context = { type: 'background' as const };\n      }\n      return {\n        type: 'pointer',\n        context\n      };\n    },\n    contextMenuOptions: {\n      isDisabled: !contextMenuConfig //If there is no context menu renderer we disable the hook\n    },\n    rootRef,\n    contextMenuConfig,\n    onContextMenuDismissed\n  });\n\n  return { contextMenuContent, contextMenuProps };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { TagCloudItemData, TagCloudProps } from './tagCloud.type';\nimport { TrackResizeContainer } from '#UNSAFE_TrackResizeContainer';\nimport { TagCloudWithDimensions } from './TagCloudWithDimensions';\nimport { dimensionStyle } from './themes/TagCloudStyles.css';\n/**\n * Tag clouds are used to display text data with the importance of each tag shown with font size and/or color.\n */\nexport function TagCloud<K extends string | number, D extends TagCloudItemData<K>>({\n  height,\n  width,\n  ...props\n}: TagCloudProps<K, D>) {\n  return (\n    <TrackResizeContainer width={width} height={height} class={dimensionStyle}>\n      {(tagCloudWidth, tagCloudHeight) => (\n        <TagCloudWithDimensions width={tagCloudWidth} height={tagCloudHeight} {...props} />\n      )}\n    </TrackResizeContainer>\n  );\n}\n"],"names":["getItem","itemInfo","items","idx","getItemPadding","height","getTagCloudNavUtils","getDetailFromInfo","id","undefined","data","item","getPrevItemInfo","Math","max","getNextItemInfo","min","length","fontSizeCalc","value","minValue","maxValue","range","ceil","getInitialFontSize","fontSizeArr","Number","MAX_VALUE","i","x","push","fontSize","calculateLineBreaks","arDims","width","lines","curWidth","w","getLayout","layout","tagcloudW","tagcloudH","isRTL","getTextDimensions","layoutTagCloud","tagWordData","maxWidth","maxHeight","maxFontSize","initialFontItems","tag","tagDimensions","label","h","y","scale","arLines","minScale","maxScale","k","lineStart","lineEnd","hPadding","maxLineHeight","justified","lineWidth","j","flowPadding","bottomY","curX","m","tagLine","tagItemFontSize","tagDimensionsWidth","getRectangleLayout","positions","steps","xrStep","yrStep","thetaStep","PI","bounds","cosCache","sinCache","placed","step","stepIncrement","lastCollisionIndex","lookup","cos","sin","_x","_y","padding","tagCloudDiv","intersects","getUnion","cx","cy","tagItemX","tagItem","tagItemY","tagItemW","tagItemH","getCloudLayout","getItemProps","itemIdx","supportsSelection","isReadOnly","hoveredItem","selectedIds","focusedItem","highlightedIds","activeId","style","isCurrent","isFocusedItem","isHoveredItem","isHighlighted","Set","has","isItemHighlighted","isSelected","isItemSelected","color","backgroundColor","backgroundImage","getContrastingTextColor","isFocused","hasFocusRing","key","getItemInfo","element","dataset","isEqualItem","item1","item2","isFocusVisible","getKeyUpHandler","triggerOnAction","updatefocusedItemInfo","focusedItemInfo","event","code","cancelEvent","TagCloudItem","props","itemBase","itemStyle","hoverUnselectedItemStyle","selectedItemStyle","hoveredSelectedItemStyle","dimmedItemStyle","interactiveCursorStyle","styles","isNotDimmed","itemClasses","classNames","supportsAction","itemAriaProps","translations","accessibleLabel","role","generateAriaLabel","_jsx","jsx","class","transform","lineHeight","children","calculateTagcloudOffset","rootRef","currentItem","isRtl","focusedItemRef","current","rootDims","getBoundingClientRect","calculateOffset","TagCloudWithDimensions","selectionMode","onItemAction","onItemHover","onItemFocus","testId","contextMenuConfig","testIdProps","useTestId","useRef","useTranslationBundle","hasData","idToDataMap","Map","map","obj","touchResponse","touchResponseStyle","useVisTouchResponse","type","supportsTouchDragGestures","hoveredItemInfo","onContextMenuDismissed","eventsProps","useVisEvent","content","datatip","activeItem","borderColor","getDatatipContent","datatipContent","datatipProps","datatipAriaDescribedby","direction","useUser","offset","setOffset","useState","useLayoutEffect","anchor","useDatatip","placement","useTagCloudDatatip","ariaProps","ariaDescribedBy","ariaLabelledBy","vis_noData","getAriaProps","merge","l","selectionContent","selectionProps","useSelection","idExtracter","info","target","selection","onChange","onSelectionChange","getDataById","get","textMeasureContent","useTextDimensions","layoutTags","useMemo","contextMenuContent","contextMenuProps","useContextMenu","onContextMenuHandler","gesture","elem","querySelector","context","contextMenuOptions","isDisabled","useTagCloudContextMenu","mergedProps","mergeProps","_jsxs","ref","tabIndex","baseStyles","itemIndex","itemProps","TrackResizeContainer","dimensionStyle","tagCloudWidth","tagCloudHeight"],"mappings":"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"}