{"version":3,"file":"useAdditiveSelection-9135c06c.js","sources":["../../src/hooks/PRIVATE_useSelection/useAdditiveSelection.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useRef } from 'preact/hooks';\nimport { Keys, containsKey, addKey, removeKey, addKeys, removeKeys } from '#utils/UNSAFE_keys';\nimport { getIsSelectionPending } from '#utils/PRIVATE_textSelectionUtils';\nimport { SelectionDetail, SelectionMode } from '#UNSAFE_Collection';\nimport { SelectionRangeDetail } from './Selection.types';\n\n/**\n * The hook for handling selection for collection ListView that is used as itemRenderer inside SelectSingle/SelectMultiple.\n *\n * @param keyExtractor function to extract the key based on provided element\n * @param selectedKeys the currently selected keys\n * @param selectionMode the selection mode\n * @param isSelectionRequired true if empty selected key is not allowed, false otherwise\n * @param getIndexByKey function to get the index based on the given key\n * @param getKeysByRange function to get the keys based on the given startIndex and endIndex\n * @param getPrevNextKey function to get the previous/next key in the vertical direction based on the current key\n * @param currentKey the current key\n * @param onChange callback function that is invoked when selection has changed.\n * @param onRangeChange callback function that is invoked when the selection range has changed.\n */\nexport function useAdditiveSelection<K>(\n  keyExtractor: (element: HTMLElement) => K | null,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  isSelectionRequired: boolean,\n  getIndexByKey: (key: K) => number,\n  getKeysByRange: (startIndex: number, endIndex: number) => K[],\n  getPrevNextKey: (currentKey: K | undefined, isPrev: boolean) => () => K | null,\n  currentKey?: K,\n  onChange?: (detail: SelectionDetail<K>) => void,\n  onRangeChange?: (detail: SelectionRangeDetail<K>) => void,\n  allowEnterKey = true\n) {\n  // the start key of the range selection\n  const anchorKey = useRef<K>();\n  // the previous end key of the range selection, i.e. the last key during shift+click/arrow keys\n  const cursorKey = useRef<K>();\n\n  // reset anchorKey and cursorKey when a new range happen (e.g. after arrow key, click on item/selector)\n  const setAdditiveSelectionACKey = (key: K | undefined) => {\n    anchorKey.current = key;\n    cursorKey.current = undefined;\n  };\n\n  const onClick = useCallback(\n    (event: MouseEvent) => {\n      if (getIsSelectionPending()) {\n        return;\n      }\n\n      const itemKey = keyExtractor(event.target as HTMLElement);\n      if (itemKey == null) {\n        return;\n      }\n\n      if (selectionMode === 'single') {\n        toggleSelection(event, selectedKeys, selectionMode, isSelectionRequired, itemKey, onChange);\n      } else if (selectionMode === 'multiple') {\n        // when anchorKey is undefined, i.e. shift+click is the first interaction, we should do toggle selection instead\n        if (!event.shiftKey || anchorKey.current === undefined) {\n          // reset anchorKey and cursorKey, a new range could happen after the click\n          setAdditiveSelectionACKey(itemKey);\n\n          toggleSelection(\n            event,\n            selectedKeys,\n            selectionMode,\n            isSelectionRequired,\n            itemKey,\n            onChange\n          );\n        } else {\n          const newCursorKey = rangeSelection(\n            event,\n            selectedKeys,\n            isSelectionRequired,\n            anchorKey.current,\n            cursorKey.current,\n            itemKey,\n            getIndexByKey,\n            getKeysByRange,\n            onChange,\n            onRangeChange\n          );\n\n          if (newCursorKey !== undefined) {\n            cursorKey.current = itemKey;\n          }\n        }\n      }\n    },\n    [\n      keyExtractor,\n      selectedKeys,\n      selectionMode,\n      isSelectionRequired,\n      getIndexByKey,\n      getKeysByRange,\n      onChange,\n      onRangeChange\n    ]\n  );\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      // prevent default (propagation) for keyDown to space bar causing container to scroll\n      if (event.key === ' ') {\n        event.preventDefault();\n        return;\n      }\n\n      if (selectionMode === 'multiple') {\n        if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {\n          return;\n        }\n\n        const itemKey = getPrevNextKey(currentKey, event.key === 'ArrowUp')();\n        if (itemKey == null) {\n          return;\n        }\n\n        if (!event.shiftKey) {\n          // reset anchorKey and cursorKey, a new range could happen after the arrow keys\n          setAdditiveSelectionACKey(itemKey);\n        } else {\n          // Avoid increasing range of selection text selection with arrow keys\n          event.preventDefault();\n\n          // when anchorKey is undefined, i.e. shift+arrow was the first interaction\n          if (anchorKey.current === undefined) {\n            anchorKey.current = currentKey;\n          }\n\n          const newCursorKey = rangeSelection(\n            event,\n            selectedKeys,\n            isSelectionRequired,\n            anchorKey.current,\n            cursorKey.current,\n            itemKey,\n            getIndexByKey,\n            getKeysByRange,\n            onChange,\n            onRangeChange\n          );\n\n          if (newCursorKey !== undefined) {\n            cursorKey.current = newCursorKey;\n          }\n        }\n      }\n    },\n    [\n      getPrevNextKey,\n      currentKey,\n      selectedKeys,\n      selectionMode,\n      isSelectionRequired,\n      getIndexByKey,\n      getKeysByRange,\n      onChange,\n      onRangeChange\n    ]\n  );\n\n  const onKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.key === ' ' || (allowEnterKey && event.key === 'Enter')) {\n        const itemKey = keyExtractor(event.target as HTMLElement);\n        if (itemKey == null) {\n          return;\n        }\n\n        toggleSelection(event, selectedKeys, selectionMode, isSelectionRequired, itemKey, onChange);\n      }\n    },\n    [keyExtractor, allowEnterKey, selectedKeys, selectionMode, isSelectionRequired, onChange]\n  );\n\n  const onPointerDown = useCallback(\n    (event: PointerEvent) => {\n      if (anchorKey.current !== undefined && event.shiftKey && selectionMode === 'multiple') {\n        // Avoid text selection during shift+click, unless when anchorKey is undefined, i.e. shift+click\n        // is the first interaction, which should do toggle selection and update currentKey during initial focus\n        event.preventDefault();\n      }\n    },\n    [selectionMode]\n  );\n\n  const additiveSelectionProps =\n    selectionMode === 'none' || onChange == null\n      ? {}\n      : { onClick, onKeyDown, onKeyUp, onPointerDown };\n  return {\n    eventProps: additiveSelectionProps,\n    setAdditiveSelectionACKey\n  };\n}\n\n/**\n * The helper function for range selection\n */\nconst rangeSelection = <K>(\n  event: MouseEvent | KeyboardEvent,\n  selectedKeys: Keys<K>,\n  isSelectionRequired: boolean,\n  anchorKey: K | undefined,\n  cursorKey: K | undefined,\n  itemKey: K,\n  getIndexByKey: (key: K) => number,\n  getKeysByRange: (startIndex: number, endIndex: number) => K[],\n  onChange?: (detail: SelectionDetail<K>) => void,\n  onRangeChange?: (detail: SelectionRangeDetail<K>) => void\n) => {\n  if (anchorKey !== undefined) {\n    if (cursorKey !== undefined && cursorKey !== itemKey) {\n      let keySet = selectedKeys;\n\n      const startIndex = getIndexByKey(anchorKey);\n      const endIndex = getIndexByKey(itemKey);\n      const previousEndIndex = getIndexByKey(cursorKey);\n      if (startIndex === -1 || endIndex === -1 || previousEndIndex === -1) {\n        return undefined;\n      }\n\n      const minIndex = Math.min(startIndex, endIndex);\n      const maxIndex = Math.max(startIndex, endIndex);\n\n      // add keys that are within the range\n      const keys = getKeysByRange(minIndex, maxIndex + 1);\n      keySet = addKeys(keySet, keys);\n\n      // only remove keys when previousEndIndex is out of range\n      if (previousEndIndex < minIndex || previousEndIndex > maxIndex) {\n        const keys =\n          previousEndIndex < minIndex\n            ? getKeysByRange(previousEndIndex, minIndex)\n            : getKeysByRange(maxIndex + 1, previousEndIndex + 1);\n        keySet = removeKeys(keySet, keys, isSelectionRequired);\n      }\n\n      if (selectedKeys != keySet && onChange) {\n        onChange({ value: keySet, target: event.target });\n        if (event.type === 'click') {\n          event.stopPropagation();\n        }\n      }\n    } else {\n      // if no cursorKey was set, meaning the previous interaction was not shift+click/arrow,\n      // we can do range selection directly\n      onRangeChange?.({\n        value: { start: anchorKey, end: itemKey },\n        eventType: event.type === 'click' ? 'shiftClick' : 'shiftArrowKeys'\n      });\n    }\n    return itemKey;\n  }\n\n  return undefined;\n};\n\nconst toggleSelection = <K>(\n  event: MouseEvent | KeyboardEvent,\n  selectedKeys: Keys<K>,\n  selectionMode: SelectionMode,\n  isSelectionRequired: boolean,\n  itemKey: K,\n  onChange?: (detail: SelectionDetail<K>) => void\n) => {\n  let keySet = selectedKeys;\n  const selected = containsKey(keySet, itemKey);\n  if (!selected) {\n    if (selectionMode === 'single') {\n      keySet = { all: false, keys: new Set([itemKey]) };\n    } else {\n      keySet = addKey(keySet, itemKey);\n    }\n  } else {\n    keySet = removeKey(keySet, itemKey, isSelectionRequired);\n  }\n\n  if (selectedKeys != keySet && onChange) {\n    onChange({ value: keySet, target: event.target });\n    if (event.type === 'click') {\n      event.stopPropagation();\n    }\n  }\n};\n"],"names":["rangeSelection","event","selectedKeys","isSelectionRequired","anchorKey","cursorKey","itemKey","getIndexByKey","getKeysByRange","onChange","onRangeChange","undefined","keySet","startIndex","endIndex","previousEndIndex","minIndex","Math","min","maxIndex","max","keys","addKeys","removeKeys","value","target","type","stopPropagation","start","end","eventType","toggleSelection","selectionMode","containsKey","removeKey","all","Set","addKey","keyExtractor","getPrevNextKey","currentKey","allowEnterKey","useRef","setAdditiveSelectionACKey","key","current","onClick","useCallback","getIsSelectionPending","shiftKey","onKeyDown","preventDefault","newCursorKey","onKeyUp","onPointerDown","eventProps"],"mappings":"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"}