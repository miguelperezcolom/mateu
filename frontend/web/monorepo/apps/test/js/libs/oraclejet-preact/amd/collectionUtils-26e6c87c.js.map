{"version":3,"file":"collectionUtils-26e6c87c.js","sources":["../../src/utils/PRIVATE_collectionUtils/collectionUtils.ts"],"sourcesContent":["import type { RefObject } from 'preact';\nimport { ViewportConfig } from '../../hooks/UNSAFE_useViewportIntersect';\nimport { SelectionRangeDetail } from '../../hooks/PRIVATE_useSelection';\nimport { ListItemRendererContext } from '../../UNSAFE_Collection';\nimport { isKeyDefined } from '../UNSAFE_keys';\nimport { getClientHints } from '../PRIVATE_clientHints';\nimport { FocusableElement } from '../PRIVATE_tabbableUtils';\n\n/**\n * Item selector for collection components\n */\nexport const ITEM_SELECTOR = '[data-oj-key]';\n\n/**\n * Returns the key from the item element\n */\nexport const getKey = (item: HTMLElement) => {\n  return item.dataset['ojKeyType'] === 'number'\n    ? Number(item.dataset['ojKey'])\n    : item.dataset['ojKey'];\n};\n\n/**\n * A helper function that return the key of the first available item.\n */\nexport const getFirstVisibleKey = (root: HTMLElement, itemSelector: string) => {\n  if (root) {\n    const firstItem = root.querySelector(itemSelector);\n    if (firstItem) {\n      const key = getKey(firstItem as HTMLElement);\n      return key;\n    }\n  }\n  return null;\n};\n\n/**\n * A helper function to find the element with the specified key.\n * Returns null if the element with key is not found.\n */\nexport const findElementByKey = <K extends string | number>(\n  root: HTMLElement,\n  key: K,\n  itemSelector: string\n) => {\n  if (root) {\n    const items = root.querySelectorAll(itemSelector);\n    for (let i = 0; i < items.length; i++) {\n      const thisKey = getKey(items[i] as HTMLElement);\n      if (key == (thisKey as K)) {\n        return items[i];\n      }\n    }\n  }\n  return null;\n};\n\n/**\n * A helper function that returns the key of the previous or the next item\n * given the specified current key by traversing indices instead of sibling elements.\n */\nexport const getPrevNextKey = <K extends string | number>(\n  root: HTMLElement | null,\n  currentKey: K | undefined,\n  isPrev: boolean,\n  itemSelector: string\n) => {\n  return (): K | null => {\n    let currItem, currIndex;\n    if (isKeyDefined(currentKey) && root) {\n      const items = root.querySelectorAll(itemSelector);\n      for (let i = 0; i < items.length; i++) {\n        if (getKey(items[i] as HTMLElement) === currentKey) {\n          currItem = items[i];\n          currIndex = i;\n          break;\n        }\n      }\n      if (currItem) {\n        currIndex = currIndex ? currIndex : 0;\n        const nextItem = isPrev ? items[currIndex - 1] : items[currIndex + 1];\n        if (nextItem) {\n          const key = getKey(nextItem as HTMLElement) as K;\n          if (key != null) {\n            return key;\n          }\n        }\n        // no next item or next item is not a valid item\n        return null;\n      }\n      const firstItem = items[0] as HTMLElement;\n      return getKey(firstItem) as K;\n    }\n    return null;\n  };\n};\n\n/**\n * A helper wrapper function so we use ref as root instead of a HTMLElement for prev/next currentKey behavior.\n * Used in comps that have a initialSelection due to this bug: JET-59240\n */\nexport const getPrevNextKeyUsingRef = <K extends string | number>(\n  root: RefObject<HTMLElement>,\n  currentKey: K | undefined,\n  isPrev: boolean,\n  itemSelector: string\n) => {\n  return (): K | null => {\n    return getPrevNextKey(root.current, currentKey, isPrev, itemSelector)();\n  };\n};\n\n/**\n * A helper function that returns the key of the previous or the next item by count,\n * given the specified current key\n */\nexport const getPrevNextKeyByCount = <K, D>(\n  data: D[] | null,\n  getRowKey: (data: D) => K,\n  currentKey?: K,\n  count = 0\n) => {\n  return (): K | null => {\n    if (data && currentKey != undefined) {\n      const currIndex = data.findIndex((d) => {\n        return getRowKey(d) === currentKey;\n      });\n      const nextIndex = currIndex + count;\n      if (0 <= nextIndex && nextIndex < data.length) {\n        return getRowKey(data[nextIndex]);\n      }\n      return null;\n    }\n    return null;\n  };\n};\n\n/**\n * A helper function to get the key from an element\n */\nexport const keyExtractor = <K extends string | number>(\n  element: HTMLElement,\n  itemSelector: string\n): K | null => {\n  const item = element.closest(itemSelector);\n  if (item) {\n    const key = getKey(item as HTMLElement) as K;\n    return key === undefined ? null : key;\n  }\n  return null;\n};\n\n/**\n * If excludeSelf is true, returns a function that determines if a given element is a descendent\n * of the root element. Otherwise, returns a function that determines if a given element is the\n * root element or is a descendant of the root element.\n */\nexport const getElementContainsFunc = (root?: HTMLElement | null, excludeSelf?: boolean) => {\n  return (elem: Element | null) => {\n    if (root != null) {\n      return excludeSelf ? root !== elem && root.contains(elem) : root.contains(elem);\n    }\n    return false;\n  };\n};\n\n/**\n * A helper function to that return viewPortConfig to collection components\n */\nexport const getViewportConfig = (rootRef: RefObject<HTMLElement>, config?: ViewportConfig) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return rootRef.current;\n      }\n    }\n  );\n};\n\n/**\n * A helper function to handle range selection\n */\nexport const handleSelectionRange = <K, D>(\n  detail: SelectionRangeDetail<K>,\n  data: D[],\n  getRowKey: (data: D) => K\n) => {\n  const keys = data.map((value: D) => {\n    return getRowKey(value);\n  });\n  const startIndex = keys.indexOf(detail.value.start);\n  const endIndex = keys.indexOf(detail.value.end);\n  const minIndex = Math.min(startIndex, endIndex);\n  const maxIndex = Math.max(startIndex, endIndex);\n  if (minIndex === -1) {\n    // return a range to fetch so we can find all the keys, maxIndex should not be -1\n    return { offset: 0, count: -1 };\n  } else {\n    // range of keys are in the current viewport, return them\n    return keys.slice(minIndex, maxIndex + 1);\n  }\n};\n\n/**\n * Helper function to determine whether the current device is a mobile device\n * @returns true if running on a mobile device, false otherwise\n */\nexport function isMobile() {\n  const deviceType = getClientHints().deviceType;\n  return deviceType === 'phone' || deviceType === 'tablet';\n}\n\n/**\n * Handle setting focus where required when entering actionable mode, or exiting actionable mode if\n * no tabbable children are found.\n */\nexport function handleEnterActionableMode<K>(\n  hasFocusWithin: boolean,\n  tabbableElements: FocusableElement[],\n  setCurrentTabbableKey: (key?: K) => void,\n  isPreventScroll?: boolean\n) {\n  if (!hasFocusWithin) {\n    const tabbableCount = tabbableElements.length;\n    if (tabbableCount > 0) {\n      tabbableElements[0].focus({ preventScroll: isPreventScroll ? isPreventScroll : false });\n    } else {\n      // exit actionable mode as there are no tabbable children\n      setCurrentTabbableKey(undefined);\n    }\n  }\n}\n\n/**\n * Handle wrapping focus to the correct tabbable child when either trap edge is focused. Will also\n * exit actionable mode if no tabbable children are found, though that should not happen in practice.\n */\nexport function handleWrapActionableFocus<K>(\n  isStart: boolean,\n  tabbableElements: FocusableElement[],\n  setCurrentTabbableKey: (key?: K) => void\n) {\n  const tabbableCount = tabbableElements.length;\n  if (tabbableCount > 0) {\n    if (isStart) {\n      tabbableElements[tabbableCount - 1].focus();\n    } else {\n      tabbableElements[0].focus();\n    }\n  } else {\n    // exit actionable mode as there are no tabbable children\n    setCurrentTabbableKey(undefined);\n  }\n}\n\n/**\n * Compare the equality between two ListItemRendererContexts, especially useful for memoized items\n */\nexport const compareListItemContext = <K, D>(\n  ctx1: ListItemRendererContext<K, D>,\n  ctx2: ListItemRendererContext<K, D>\n) => {\n  // deliberately leave out index as that would change when an item is inserted/removed/moved\n  return (\n    ctx1.data === ctx2.data &&\n    ctx1.isSelected === ctx2.isSelected &&\n    ctx1.metadata.key === ctx2.metadata.key\n  );\n};\n\n/**\n * A helper function that returns an array of keys for the items.\n */\nexport const getItemKeysArray = (root: HTMLElement, itemSelector: string) => {\n  return Array.from(root.querySelectorAll(itemSelector)).map((elem) => getKey(elem as HTMLElement));\n};\n\n/**\n * A helper function that is used in reorder feature to allow auto scrolling during dragging an item\n */\nexport const dragToScroll = (\n  event: DragEvent,\n  isDragging: boolean,\n  rootElement: HTMLElement | null\n) => {\n  const speed = 10;\n  const threshold = 50;\n  if (rootElement != null && isDragging) {\n    const rootElementTop = rootElement.getBoundingClientRect().top;\n    if (event.clientY < rootElementTop + threshold) {\n      rootElement.scrollBy(0, -speed);\n    } else if (event.clientY > rootElementTop + rootElement.clientHeight - threshold) {\n      rootElement.scrollBy(0, speed);\n    }\n  }\n};\n"],"names":["getKey","item","dataset","Number","getPrevNextKey","root","currentKey","isPrev","itemSelector","currItem","currIndex","isKeyDefined","items","querySelectorAll","i","length","nextItem","key","firstItem","ctx1","ctx2","data","isSelected","metadata","event","isDragging","rootElement","rootElementTop","getBoundingClientRect","top","clientY","scrollBy","clientHeight","excludeSelf","elem","contains","querySelector","Array","from","map","getRowKey","count","undefined","nextIndex","findIndex","d","current","rootRef","config","scroller","hasFocusWithin","tabbableElements","setCurrentTabbableKey","isPreventScroll","focus","preventScroll","detail","keys","value","startIndex","indexOf","start","endIndex","end","minIndex","Math","min","maxIndex","max","offset","slice","isStart","tabbableCount","deviceType","getClientHints","element","closest"],"mappings":"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"}