{"version":3,"file":"InlineSelectSingle-c8a5cba5.js","sources":["../../src/UNSAFE_InlineSelectSingle/InlineSelectSingle.tsx","../../src/UNSAFE_InlineSelectSingle/useInlineSelectSingle.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ContextType, JSX, Ref } from 'preact';\nimport { forwardRef } from 'preact/compat';\nimport { useCallback } from 'preact/hooks';\n\nimport {\n  DefaultList,\n  DropdownList,\n  EmptyResults,\n  type SelectSingleCollectionRendererContext\n} from '#PRIVATE_SelectCommon';\nimport { Flex } from '#UNSAFE_Flex';\nimport { Label } from '#UNSAFE_Label';\nimport { SelectSingleField } from '#UNSAFE_SelectSingle/SelectSingleField';\nimport { SelectSingleFieldInput } from '#UNSAFE_SelectSingle/SelectSingleFieldInput';\nimport { Separator } from '#UNSAFE_Separator';\nimport { InlineUserAssistance } from '#UNSAFE_UserAssistance';\nimport { View } from '#UNSAFE_View';\nimport { FormFieldContext } from '#hooks/UNSAFE_useFormFieldContext';\nimport { TabbableModeContext } from '#hooks/UNSAFE_useTabbableMode';\nimport type { Data, InlineSelectHandle, InlineSelectSingleProps, Key } from './types';\nimport { useInlineSelectSingle } from './useInlineSelectSingle';\n\nconst PREVENT_TABBING = { isTabbable: false } satisfies ContextType<typeof TabbableModeContext>;\n\n/**\n * A InlineSelectSingle is a text field with an inline list that supports single selection and search filtering.\n * Note: This is only meant to be used by the Spectra Smart Search component. As such, it only has limited features\n * needed for the Smart Search component.\n */\nfunction InlineSelectSingleImpl<K extends Key, D extends Data>(\n  props: InlineSelectSingleProps<K, D>,\n  ref: Ref<InlineSelectHandle>\n) {\n  const {\n    data,\n    itemRenderer,\n    itemText,\n    label,\n    onLoadRange,\n    testId,\n    userAssistancePosition = 'belowList'\n  } = props;\n  const {\n    collectionRendererContext,\n    formFieldContext,\n    hasUserAssistance,\n    isEmptyResults,\n    isUserFiltering,\n    labelProps,\n    listContainerProps,\n    selectSingleFieldProps,\n    selectFieldInputProps,\n    userAssistanceProps\n  } = useInlineSelectSingle(props, ref);\n\n  const defaultCollectionRenderer = useCallback(\n    ({\n      onPersistCurrentRowKey,\n      onRowAction,\n      selected,\n      searchText,\n      currentRowKeyOverride\n    }: SelectSingleCollectionRendererContext<K, D>) => (\n      <DefaultList\n        aria-label={label}\n        currentItemVariant=\"highlight\"\n        currentKey={currentRowKeyOverride}\n        data={data}\n        itemRenderer={itemRenderer}\n        itemText={itemText}\n        onCurrentKeyChange={onPersistCurrentRowKey}\n        onItemAction={onRowAction}\n        onLoadRange={onLoadRange}\n        searchText={isUserFiltering ? searchText : undefined}\n        selectedKeys={selected}\n        selectionMode=\"single\"\n      />\n    ),\n    [data, isUserFiltering, itemRenderer, itemText, label, onLoadRange]\n  );\n\n  const userAssistance = (\n    <View minWidth=\"100%\" padding=\"2x\">\n      <InlineUserAssistance\n        testId={testId && `${testId}_userAssistance`}\n        {...userAssistanceProps}\n      />\n    </View>\n  );\n\n  return (\n    <Flex direction=\"column\" gap=\"2x\" maxHeight=\"100%\" width=\"100%\">\n      <FormFieldContext.Provider value={formFieldContext}>\n        <View flex={0}>\n          <SelectSingleField\n            {...selectSingleFieldProps}\n            label={<Label {...labelProps} />}\n            testId={testId && `${testId}_selectSingleField`}>\n            <SelectSingleFieldInput {...selectFieldInputProps} />\n          </SelectSingleField>\n          {/* Render separator & UA without gaps when we are configured for UA between the field and the dropdown */}\n          {userAssistancePosition === 'aboveList' && <Separator />}\n          {userAssistancePosition === 'aboveList' && hasUserAssistance && (\n            <>\n              {userAssistance}\n              <Separator />\n            </>\n          )}\n        </View>\n        {/* Render separator with gaps when we are not configured for UA between the field and the dropdown */}\n        {userAssistancePosition !== 'aboveList' && <Separator />}\n        <DropdownList\n          {...listContainerProps}\n          // Add bottom gap only when we are configured to show UA above the list\n          hasBottomGap={userAssistancePosition === 'aboveList'}\n          hasTopGap={false}>\n          <TabbableModeContext.Provider value={PREVENT_TABBING}>\n            {isEmptyResults ? (\n              <EmptyResults />\n            ) : (\n              defaultCollectionRenderer(collectionRendererContext)\n            )}\n          </TabbableModeContext.Provider>\n        </DropdownList>\n        {userAssistancePosition === 'belowList' && hasUserAssistance && (\n          <div>\n            <Separator />\n            {userAssistance}\n          </div>\n        )}\n      </FormFieldContext.Provider>\n    </Flex>\n  );\n}\n\nexport const InlineSelectSingle = forwardRef(InlineSelectSingleImpl) as {\n  <K extends Key, D extends Data>(\n    props: InlineSelectSingleProps<K, D> & { ref?: Ref<InlineSelectHandle> }\n  ): JSX.Element;\n}; // forwardRef will remove generics, so we cast it explicitly to preserve generics.;\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ComponentProps, Ref } from 'preact';\nimport { useCallback, useEffect, useImperativeHandle, useRef, useState } from 'preact/hooks';\n\nimport {\n  type DropdownList,\n  isBeforeDataFetch,\n  isPhone,\n  isSearchTextEmptyOrUndefined,\n  useCollectionRenderer,\n  UseCollectionRendererSelectSingleParams,\n  useSelectCommon\n} from '#PRIVATE_SelectCommon';\nimport type { Label } from '#UNSAFE_Label';\nimport type { SelectSingleField } from '#UNSAFE_SelectSingle/SelectSingleField';\nimport type { SelectSingleFieldInput } from '#UNSAFE_SelectSingle/SelectSingleFieldInput';\nimport { useDisplayValue } from '#UNSAFE_SelectSingle/useDisplayValue';\nimport type { InlineUserAssistance } from '#UNSAFE_UserAssistance';\nimport { useFormContext } from '#hooks/UNSAFE_useFormContext';\nimport { useLoadingIndicatorTimer } from '#hooks/UNSAFE_useLoadingIndicatorTimer';\nimport { useTextField } from '#hooks/UNSAFE_useTextField';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '#resources/nls/bundle';\nimport { isControlOrFunctionKey, KEYS } from '#utils/PRIVATE_keyboardUtils';\nimport { allTabbableElements } from '#utils/PRIVATE_tabbableUtils';\nimport type { ValueUpdateDetail } from '#utils/UNSAFE_valueUpdateDetail';\nimport type {\n  CommitMetadata,\n  Data,\n  InlineSelectHandle,\n  InlineSelectSingleProps,\n  Key\n} from './types';\nimport { UNSAFE_DOM_ACCESS } from '#utils/UNSAFE_unsafeDomAccess';\n\ntype UseInlineSelectSingleOptions<K extends Key, D extends Data> = InlineSelectSingleProps<K, D>;\n\n/**\n * A custom hook for determining prop values for the InlineSelectSingle's child\n * components from its own props.\n * @param param0 options\n * @param ref The ref handle of the component.\n */\nexport function useInlineSelectSingle<K extends Key, D extends Data>(\n  {\n    'aria-describedby': ariaDescribedBy,\n    assistiveText,\n    data,\n    hasBackIcon = 'never',\n    hasClearIcon = 'never',\n    helpSourceLink,\n    helpSourceText,\n    isLoading: propIsLoading,\n    itemText,\n    label,\n    onBackIconAction,\n    onCommit: propOnCommit,\n    onFilter,\n    placeholder,\n    textAlign: propTextAlign,\n    valueItem,\n    virtualKeyboard\n  }: UseInlineSelectSingleOptions<K, D>,\n  ref: Ref<InlineSelectHandle>\n) {\n  const inputRef = useRef<HTMLInputElement>(null);\n  const { textAlign: formTextAlign } = useFormContext();\n  const textAlign = propTextAlign ?? formTextAlign ?? 'start';\n  const isDataFetched = data != null && !isBeforeDataFetch<K, D>(data);\n  const isEmptyResults = isDataFetched && data?.totalSize === 0;\n\n  // Refs to keep track of prop changes and sync internal state\n  const prevDataRef = useRef(data);\n  const prevValueItemRef = useRef(valueItem);\n  const isInitialRender = useRef(true);\n\n  // State for holding the selected keys in the list\n  const [selectedKeys, setSelectedKeys] = useState(\n    valueItem === undefined ? undefined : new Set([valueItem.key])\n  );\n\n  // The incoming propIsLoading tells us that we are in a loading state, but we don't want to\n  // show the loading indicator until after a delay, because showing it immediately could result\n  // in unwanted flashing.  The isLoading var below will be set to true by useLoadingIndicatorTimer\n  // after the delay, when the timer expires, at which point we should show the loading indicator.\n  // If propIsLoading is set to false before the timer expires, then the timer will be cancelled\n  // and no loading indicator will be shown.\n  // (ListView detects its loading state by checking data === null.  While it would be nice for\n  // us to be consistent and check valueItems === null, we need to use a separate isLoading prop.\n  // If valueItems === null triggers our loading state, then the selections in the dropdown\n  // are cleared for that period of time, which is undesirable.)\n  const isLoading = useLoadingIndicatorTimer(propIsLoading ?? false);\n  const displayValue = useDisplayValue(itemText, valueItem);\n\n  // add methods to the ref\n  useImperativeHandle(\n    ref,\n    () => ({\n      focus: () => inputRef.current?.focus(),\n      blur: () => inputRef.current?.blur(),\n      [UNSAFE_DOM_ACCESS]: inputRef.current!\n    }),\n    []\n  );\n\n  const {\n    currentRowKeyRef,\n    currentRowOverride,\n    dropdownRef,\n    isFocused,\n    isUserFiltering,\n    onCurrentKeyChange,\n    searchText,\n    setCurrentRowOverride,\n    stopFiltering,\n    updateFiltering,\n    userInput\n  } = useSelectCommon<K, D>({\n    data,\n    inputRef,\n    // The component can only be in a focused visual state\n    isFocused: true,\n    onFilter\n  });\n\n  const { baseId, formFieldContext, inputProps, labelProps, userAssistanceProps } = useTextField({\n    ariaDescribedBy,\n    helpSourceLink,\n    helpSourceText,\n    isFocused,\n    isLoading,\n    value: valueItem !== undefined ? true : undefined\n  });\n  const listId = `${baseId}-list`;\n\n  // If we're waiting for the selected values to load, the component should look like it\n  // has a value in the meantime.\n  // Use the original propIsLoading instead of isLoading because we don't want to delay\n  // the inside label position by a timer like we do the progressive loading indicator.\n  formFieldContext.hasValue = propIsLoading || formFieldContext.hasValue;\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const liveRegionText = isDataFetched\n    ? data?.totalSize === 0\n      ? translations.select_noMatchesFound()\n      : data?.totalSize === 1\n      ? translations.select_oneMatchFound()\n      : data?.sizePrecision === 'exact'\n      ? translations.select_sizeMatchesFound({ TOTAL_SIZE: `${data?.totalSize}` })\n      : translations.select_sizeOrMoreMatchesFound({ TOTAL_SIZE: `${data?.totalSize}` })\n    : '';\n\n  /**\n   * Lifecycle updates\n   */\n  // When the valueItem changes, save the new selectedKeys\n  if (prevValueItemRef.current !== valueItem) {\n    prevValueItemRef.current = valueItem;\n    setSelectedKeys(valueItem === undefined ? undefined : new Set([valueItem.key]));\n  }\n\n  // When data changes, highlight the first result\n  if (prevDataRef.current !== data) {\n    prevDataRef.current = data;\n    // when filtering, set the first result of the filtered data set to be the current item\n    // (check the data offset so we don't try to highlight again if the user scrolls through\n    // the list and more data is fetched)\n    if (isUserFiltering && data != null && data.offset === 0 && data.data.length > 0) {\n      // if there are results and search text, highlight the first row, otherwise clear\n      // an existing highlight\n      setCurrentRowOverride({\n        rowKey: !isSearchTextEmptyOrUndefined(searchText) ? data.data[0].metadata.key : undefined\n      });\n    }\n  }\n\n  // During the initial render, set the current row override if we have selected values.\n  // This way pressing DOWN arrow will start the navigation from the selected row.\n  if (isInitialRender.current) {\n    isInitialRender.current = false;\n    setCurrentRowOverride({ rowKey: [...(selectedKeys ?? [undefined])][0] });\n  }\n\n  /**\n   * A helper onCommit wrapper that consumes the metadata and calls the\n   * propOnCommit with only the necessary information.\n   * (Similar to onCommit in useSelectSingle.ts)\n   */\n  const onCommit = useCallback(\n    (value: K | undefined, metadata: CommitMetadata) => {\n      propOnCommit?.({\n        value: value,\n        previousValue: valueItem !== undefined ? valueItem.key : undefined,\n        reason: metadata.reason\n      });\n    },\n    [propOnCommit, valueItem]\n  );\n\n  /**\n   * A helper function to clear the selectedKeys and commits empty value.\n   * (Similar to clearValue in useSelectSingle.ts but without dropdown related logic)\n   */\n  const clearValue = useCallback(\n    (metadata: CommitMetadata) => {\n      setSelectedKeys(new Set<K>());\n      // call the onCommit callback so that the consuming code can update the valueItem\n      onCommit(undefined, metadata);\n    },\n    [onCommit]\n  );\n\n  /**\n   * Determine if we need to clear the value because the user has deleted all the text.\n   * (Similar to isClearValueNeeded in useSelectSingle.ts)\n   */\n  const isClearValueNeeded = useCallback(() => {\n    return isUserFiltering && userInput === '' && valueItem !== undefined;\n  }, [isUserFiltering, userInput, valueItem]);\n\n  /**\n   * Handler for List.onItemAction\n   * (Similar to useSelectSingle.ts's onItemAction but without dropdown related logic)\n   * This is used for handling:\n   * - Commits value when one performs an action on the list\n   */\n  const handleItemAction = useCallback<\n    UseCollectionRendererSelectSingleParams<K, D>['onItemAction']\n  >(\n    (detail) => {\n      // after selecting a value, the user is no longer actively filtering, so update related\n      // state accordingly so that the newly selected value appears in the field\n      stopFiltering();\n\n      const newKey = detail.context.key;\n      // update the selectedKeys so that the selection visual state of the collection\n      // updates immediately while waiting for a new valueItem to be set\n      setSelectedKeys(new Set([newKey]));\n      // call the onCommit callback so that the consuming code can update the valueItem\n      onCommit(newKey, { reason: 'itemAction' });\n    },\n    [onCommit, stopFiltering]\n  );\n\n  /**\n   * Handler for SelectSingleFieldInput.onInput\n   * This is used for handling:\n   * - Typing in text in the field should filter the results (i.e. invoke onFilter with the text)\n   */\n  const handleFieldInput = useCallback(\n    ({ value }: ValueUpdateDetail<string>) => {\n      updateFiltering(value);\n      onFilter?.({ searchText: value });\n    },\n    [onFilter, updateFiltering]\n  );\n\n  /**\n   * Handler for SelectSingleFieldInput.onKeyDown\n   * This is used for handling:\n   * - Prevents default browser behavior on UP/DOWN to avoid scrolling\n   * - Clears value or selects current row on ENTER\n   * - Clears value or selects current row on TAB\n   */\n  const handleFieldKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      // ignore ctrl and fn key events\n      if (isControlOrFunctionKey(event)) return;\n\n      switch (event.code) {\n        case KEYS.UP:\n        case KEYS.DOWN:\n          // prevent the default action, since we do not want the page to scroll\n          event.preventDefault();\n          break;\n        case KEYS.ENTER:\n        case KEYS.TAB: {\n          // if this is on a mobile device (only phone and not in tablet devices), do not do anything\n          if (isPhone()) return;\n\n          // Otherwise, proceed\n          const commitMetadata: CommitMetadata = {\n            reason: event.code === KEYS.TAB ? 'tabKey' : 'itemAction'\n          };\n          // check to see if we need to clear the value\n          if (isClearValueNeeded()) {\n            // in this case, clear the value and return.\n            clearValue(commitMetadata);\n            return;\n          }\n\n          // if there is no data to select, no need to handle this event\n          if (data == null || data.data.length === 0) return;\n\n          // If we will be making a selection, the user is no longer actively filtering,\n          // so update related state accordingly so that the newly selected value appears in the field.\n          stopFiltering();\n\n          // Current design have this component in a dropdown/modal. So, pressing Tab from\n          // the main field without doing any other interaction is still considered a selection\n          // unlike SelectSingle (see JET-68215). So, we handle both Enter and Tab similarly.\n          // If there is a currentRow in the dropdown (meaning a highlighted item that would\n          // have keyboard focus if the dropdown list had physical focus, which may be different\n          // from the currently selected item), select it and commit it.\n          if (currentRowKeyRef.current !== undefined && data != null && data.data.length > 0) {\n            setSelectedKeys(new Set<K>([currentRowKeyRef.current]));\n            onCommit(currentRowKeyRef.current, commitMetadata);\n            return;\n          }\n          // Otherwise commit the currently selected value again so that a valueAction event\n          // can be fired from the core-pack side.\n          onCommit(valueItem?.key ?? undefined, commitMetadata);\n          break;\n        }\n      }\n    },\n    [clearValue, currentRowKeyRef, data, isClearValueNeeded, onCommit, stopFiltering, valueItem]\n  );\n\n  /**\n   * Handler for SelectSingleFieldInput.onKeyUp\n   * This is used for handling:\n   * - Pressing UP/DOWN from the main field should move the focus to the list\n   * - If Ctrl or Fn key is pressed, then ignore the event\n   */\n  const handleFieldKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      // ignore ctrl and fn key events\n      if (isControlOrFunctionKey(event)) return;\n\n      switch (event.code) {\n        case KEYS.UP:\n        case KEYS.DOWN:\n          // Transfer physical focus into the dropdown only if the data is present and the dropdown\n          // has rendered the data. Otherwise, keep the focus in the field.\n          if (data != null && dropdownRef.current) {\n            // get the focusable element from the dropdown.\n            // consider element with tabindex=-1 as well.\n            const firstFocusableElem = allTabbableElements(dropdownRef.current, undefined, true)[0];\n            // focus the first element if it exists\n            firstFocusableElem?.focus();\n\n            // set the first row as current row if there is no current row at the moment\n            if (currentRowOverride.rowKey === undefined) {\n              setCurrentRowOverride({ rowKey: data.data[0]?.metadata?.key });\n            }\n          }\n          // prevent the default action, since we are handling it\n          event.preventDefault();\n          break;\n      }\n    },\n    [currentRowOverride, data, dropdownRef, setCurrentRowOverride]\n  );\n\n  /**\n   * Handler for DropdownList.onKeyDown\n   * This is used for handling:\n   * - Pressing Tab when highlighted on a list item should select & commit that item as value\n   */\n  const handleListKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      switch (event.code) {\n        case KEYS.TAB:\n          // if there is a currentRow in the dropdown, select it and commit it\n          if (currentRowKeyRef.current !== undefined && data != null && data.data.length > 0) {\n            setSelectedKeys(new Set<K>([currentRowKeyRef.current]));\n            onCommit(currentRowKeyRef.current, { reason: 'tabKey' });\n          }\n          break;\n      }\n    },\n    [currentRowKeyRef, data, onCommit]\n  );\n\n  /**\n   * Handler for ClearButton.onClick\n   * This is for handling:\n   * - on clicking the clear icon, the value & selection should be cleared.\n   */\n  const handleClearButtonClick = useCallback(() => {\n    // reset the user filter and the value of the component\n    stopFiltering();\n    // clear the value\n    clearValue({ reason: 'itemAction' });\n    // set focus to the input\n    inputRef.current?.focus();\n    // call onFilter with undefined\n    onFilter?.({ searchText: undefined });\n  }, [clearValue, onFilter, stopFiltering]);\n\n  /**\n   * Create collection Renderer context. This will be used by the default\n   * collectionRenderer.\n   */\n  const collectionRendererContext = useCollectionRenderer<K, D>({\n    currentKey: currentRowOverride.rowKey,\n    searchText,\n    selectedKeys,\n    onCurrentKeyChange,\n    onItemAction: handleItemAction\n  });\n\n  // TODO: JET-73973 - ListView is not respecting TabbableMode\n  // Currently List does not respect TabbableMode, so for now explicitly set tabindex=\"-1\".\n  // When this bug is fixed, this useEffect can be removed.\n  useEffect(() => {\n    const list = dropdownRef.current?.querySelector('div[role=\"listbox\"][tabindex=\"0\"]');\n    list?.setAttribute('tabindex', '-1');\n  });\n\n  return {\n    collectionRendererContext,\n    formFieldContext,\n    hasUserAssistance: Boolean(assistiveText || helpSourceLink),\n    isEmptyResults,\n    isUserFiltering,\n    labelProps: {\n      ...labelProps,\n      children: label\n    } satisfies ComponentProps<typeof Label>,\n    listContainerProps: {\n      id: listId,\n      dropdownListRef: dropdownRef,\n      onKeyDown: handleListKeyDown\n    } satisfies ComponentProps<typeof DropdownList>,\n    selectSingleFieldProps: {\n      contentVariant: 'input',\n      // InlineSelectSingle currently only supports inside label.\n      hasInsideLabel: true,\n      isBackButtonShown: hasBackIcon === 'always',\n      isClearButtonShown: hasClearIcon === 'conditionally' && valueItem !== undefined,\n      onBackButtonClick: onBackIconAction,\n      onClearButtonClick: handleClearButtonClick,\n      styleVariant: 'embedded' as const\n    } satisfies Omit<ComponentProps<typeof SelectSingleField>, 'children'>,\n    selectFieldInputProps: {\n      ...inputProps,\n      'aria-controls': listId,\n      // InlineSelectSingle always have the list open, so it will always be in an expanded state.\n      'aria-expanded': true,\n      displayValue,\n      // InlineSelectSingle currently only supports inside label,\n      // so it is expected to always have a label.\n      hasEmptyLabel: false,\n      // InlineSelectSingle currently only supports inside label.\n      hasInsideLabel: true,\n      inputRef,\n      // InlineSelectSingle currently does not support Add to List.\n      isAddToListShown: false,\n      // InlineSelectSingle currently does not support Advanced Search.\n      isAdvancedSearchShown: false,\n      // InlineSelectSingle currently does not support Required.\n      isRequired: false,\n      isUserFiltering,\n      liveRegionText,\n      onInput: handleFieldInput,\n      onKeyDown: handleFieldKeyDown,\n      onKeyUp: handleFieldKeyUp,\n      placeholder,\n      textAlign,\n      userInput,\n      variant: 'embedded',\n      virtualKeyboard\n    } satisfies ComponentProps<typeof SelectSingleFieldInput>,\n    userAssistanceProps: {\n      ...userAssistanceProps,\n      assistiveText,\n      fieldLabel: label,\n      helpSourceLink,\n      helpSourceText\n    } satisfies ComponentProps<typeof InlineUserAssistance>\n  };\n}\n"],"names":["PREVENT_TABBING","isTabbable","InlineSelectSingle","forwardRef","props","ref","data","itemRenderer","itemText","label","onLoadRange","testId","userAssistancePosition","collectionRendererContext","formFieldContext","hasUserAssistance","isEmptyResults","isUserFiltering","labelProps","listContainerProps","selectSingleFieldProps","selectFieldInputProps","userAssistanceProps","ariaDescribedBy","assistiveText","hasBackIcon","hasClearIcon","helpSourceLink","helpSourceText","isLoading","propIsLoading","onBackIconAction","onCommit","propOnCommit","onFilter","placeholder","textAlign","propTextAlign","valueItem","virtualKeyboard","inputRef","useRef","formTextAlign","useFormContext","isDataFetched","isBeforeDataFetch","totalSize","prevDataRef","prevValueItemRef","isInitialRender","selectedKeys","setSelectedKeys","useState","undefined","Set","key","useLoadingIndicatorTimer","displayValue","useDisplayValue","useImperativeHandle","focus","current","blur","UNSAFE_DOM_ACCESS","currentRowKeyRef","currentRowOverride","dropdownRef","isFocused","onCurrentKeyChange","searchText","setCurrentRowOverride","stopFiltering","updateFiltering","userInput","useSelectCommon","baseId","inputProps","useTextField","value","listId","hasValue","translations","useTranslationBundle","liveRegionText","select_noMatchesFound","select_oneMatchFound","sizePrecision","select_sizeMatchesFound","TOTAL_SIZE","select_sizeOrMoreMatchesFound","offset","length","rowKey","isSearchTextEmptyOrUndefined","metadata","useCallback","previousValue","reason","clearValue","isClearValueNeeded","handleItemAction","detail","newKey","context","handleFieldInput","handleFieldKeyDown","event","isControlOrFunctionKey","code","KEYS","UP","DOWN","preventDefault","ENTER","TAB","isPhone","commitMetadata","handleFieldKeyUp","firstFocusableElem","allTabbableElements","handleListKeyDown","handleClearButtonClick","useCollectionRenderer","currentKey","onItemAction","useEffect","list","querySelector","setAttribute","Boolean","children","id","dropdownListRef","onKeyDown","contentVariant","hasInsideLabel","isBackButtonShown","isClearButtonShown","onBackButtonClick","onClearButtonClick","styleVariant","hasEmptyLabel","isAddToListShown","isAdvancedSearchShown","isRequired","onInput","onKeyUp","variant","fieldLabel","useInlineSelectSingle","defaultCollectionRenderer","onPersistCurrentRowKey","onRowAction","selected","currentRowKeyOverride","_jsx","DefaultList","currentItemVariant","selectionMode","userAssistance","View","minWidth","padding","jsx","InlineUserAssistance","Flex","direction","gap","maxHeight","width","_jsxs","FormFieldContext","Provider","flex","SelectSingleField","Label","SelectSingleFieldInput","Separator","DropdownList","hasBottomGap","hasTopGap","TabbableModeContext","EmptyResults","jsxs"],"mappings":"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"}