{"version":3,"file":"usePieChartNav-339488db.js","sources":["../../src/hooks/PRIVATE_usePieChartNav/usePieChartNav.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useCallback, useRef, useState } from 'preact/hooks';\nimport { getRandomId } from '#utils/PRIVATE_visLayoutUtils';\nimport { cancelEvent } from '#utils/UNSAFE_visUtils';\nimport { useVisHover } from '#hooks/PRIVATE_useVisHover';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport { gestureTypes } from '#hooks/PRIVATE_useVisContextMenu';\nimport {\n  ItemDrillDetail,\n  ItemFocusDetail,\n  ItemHoverDetail,\n  PieChartItemData\n} from '#UNSAFE_PieChart/pieChart.types';\nimport { useVisDrill } from '#hooks/PRIVATE_useVisDrill';\n\nexport type ItemInfo = {\n  isFocusVisible?: boolean;\n  itemIndex: number;\n};\n\nexport const getItemInfo = (event: Event) => {\n  const itemIndex = (event.target as HTMLElement).dataset['ojPrivateItemIndex'];\n  if (itemIndex) {\n    return {\n      itemIndex: parseInt(itemIndex, 10)\n    };\n  }\n  return;\n};\n\n/**\n * Hook to handle chart navigation. This can be shared between the pie, funnel and pyramid chart\n * as they follow similar navigation pattern.\n * TODO: rename\n */\nexport function usePieChartNav<K, D extends PieChartItemData<K>>(\n  touchResponse: 'touchStart' | 'touchHold',\n  getDetailFromInfo: (info?: ItemInfo) => ItemHoverDetail<K, D> | ItemFocusDetail<K, D>,\n  getNextChartItem: (\n    info: ItemInfo,\n    arrow: 'ArrowLeft' | 'ArrowRight' | 'ArrowDown' | 'ArrowUp'\n  ) => ItemInfo,\n  drilling?: 'on' | 'off',\n  onItemDrill?: (detail: ItemDrillDetail<K, D>) => void\n) {\n  const [focusedItemInfo, setfocusedItemInfo] = useState<ItemInfo>({ itemIndex: 0 });\n  const [hoveredItemInfo, setHoveredItemInfo] = useState<ItemInfo>();\n  const activeId = useRef<string>();\n\n  const onContextMenuDismissed = (gesture: gestureTypes) => {\n    if (gesture === 'keyboard') {\n      updateFocusedItemInfo({\n        ...focusedItemInfo,\n        isFocusVisible: true\n      });\n    }\n  };\n\n  const updateFocusedItemInfo = (itemInfo: ItemInfo) => {\n    if (\n      itemInfo.itemIndex !== focusedItemInfo.itemIndex ||\n      itemInfo.isFocusVisible !== focusedItemInfo.isFocusVisible\n    ) {\n      setfocusedItemInfo(itemInfo);\n      setHoveredItemInfo(undefined);\n    }\n  };\n\n  const onPointerUp = (event: PointerEvent) => {\n    const info = getItemInfo(event);\n    if (info) {\n      updateFocusedItemInfo({ ...info, isFocusVisible: false });\n    }\n  };\n\n  const onHover = (event: PointerEvent) => {\n    const info = getItemInfo(event);\n    if (info?.itemIndex != hoveredItemInfo?.itemIndex) {\n      setHoveredItemInfo(info);\n      activeId.current = getRandomId();\n    } else if (!info) {\n      activeId.current = undefined;\n    }\n  };\n\n  const onHoverLeave = () => {\n    setHoveredItemInfo(undefined);\n    activeId.current = undefined;\n  };\n\n  const hoverHandlers = useVisHover(onHover, undefined, onHoverLeave, touchResponse);\n  const processDrill = useCallback(\n    (info?: ItemInfo) => {\n      const { id, data } = getDetailFromInfo(info);\n      if (id != null && data) {\n        onItemDrill?.({ id, data });\n        activeId.current = getRandomId();\n      }\n    },\n    [getDetailFromInfo, onItemDrill]\n  );\n\n  const onDrill = useCallback(\n    (event: Event) => {\n      if (drilling == 'on') {\n        updateFocusedItemInfo({\n          ...focusedItemInfo,\n          isFocusVisible: true\n        });\n        if (event.type === 'keydown') {\n          processDrill(focusedItemInfo);\n        } else {\n          processDrill(getItemInfo(event));\n        }\n      }\n    },\n    [drilling, focusedItemInfo, processDrill, updateFocusedItemInfo]\n  );\n\n  const drillProps = useVisDrill('none', onDrill);\n\n  const onKeyDown = (event: KeyboardEvent) => {\n    const key = event.key;\n    switch (key) {\n      case 'Tab':\n        return;\n      case 'ArrowDown': {\n        const info = getNextChartItem(focusedItemInfo, 'ArrowDown');\n        updateFocusedItemInfo({ ...info, isFocusVisible: true });\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowUp': {\n        const info = getNextChartItem(focusedItemInfo, 'ArrowUp');\n        updateFocusedItemInfo({ ...info, isFocusVisible: true });\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowLeft': {\n        const info = getNextChartItem(focusedItemInfo, 'ArrowLeft');\n        updateFocusedItemInfo({ ...info, isFocusVisible: true });\n        cancelEvent(event);\n        break;\n      }\n      case 'ArrowRight': {\n        const info = getNextChartItem(focusedItemInfo, 'ArrowRight');\n        updateFocusedItemInfo({ ...info, isFocusVisible: true });\n        cancelEvent(event);\n        break;\n      }\n    }\n    activeId.current = getRandomId();\n  };\n\n  const onKeyUp = (event: KeyboardEvent) => {\n    const key = event.key;\n    if (key === 'Tab') {\n      updateFocusedItemInfo({ ...focusedItemInfo, isFocusVisible: true });\n    }\n  };\n\n  const onBlur = () => {\n    updateFocusedItemInfo({\n      ...focusedItemInfo,\n      isFocusVisible: false\n    });\n  };\n\n  return {\n    focusedItemInfo,\n    hoveredItemInfo,\n    activeId: activeId.current,\n    eventsProps: mergeProps(drillProps, hoverHandlers, {\n      onKeyDown,\n      onKeyUp,\n      onPointerUp,\n      onBlur\n    }),\n    onContextMenuDismissed\n  };\n}\n"],"names":["getItemInfo","event","itemIndex","target","dataset","parseInt","touchResponse","getDetailFromInfo","getNextChartItem","drilling","onItemDrill","focusedItemInfo","setfocusedItemInfo","useState","hoveredItemInfo","setHoveredItemInfo","activeId","useRef","updateFocusedItemInfo","itemInfo","isFocusVisible","undefined","hoverHandlers","useVisHover","info","current","getRandomId","processDrill","useCallback","id","data","onDrill","type","drillProps","useVisDrill","eventsProps","mergeProps","onKeyDown","key","cancelEvent","onKeyUp","onPointerUp","onBlur","onContextMenuDismissed","gesture"],"mappings":"4NA2BO,MAAMA,EAAeC,IAC1B,MAAMC,EAAaD,EAAME,OAAuBC,QAA4B,mBAC5E,GAAIF,EACF,MAAO,CACLA,UAAWG,SAASH,EAAW,IAG5B,mBAQH,SACJI,EACAC,EACAC,EAIAC,EACAC,GAEA,MAAOC,EAAiBC,GAAsBC,EAAQA,SAAW,CAAEX,UAAW,KACvEY,EAAiBC,GAAsBF,EAAQA,WAChDG,EAAWC,EAAAA,SAWXC,EAAyBC,IAE3BA,EAASjB,YAAcS,EAAgBT,WACvCiB,EAASC,iBAAmBT,EAAgBS,iBAE5CR,EAAmBO,GACnBJ,OAAmBM,GACpB,EAyBGC,EAAgBC,EAAAA,aAfLtB,IACf,MAAMuB,EAAOxB,EAAYC,GACrBuB,GAAMtB,WAAaY,GAAiBZ,WACtCa,EAAmBS,GACnBR,EAASS,QAAUC,EAAAA,eACTF,IACVR,EAASS,aAAUJ,EACpB,QAQwCA,GALtB,KACnBN,OAAmBM,GACnBL,EAASS,aAAUJ,CAAS,GAGsCf,GAC9DqB,EAAeC,eAClBJ,IACC,MAAMK,GAAEA,EAAEC,KAAEA,GAASvB,EAAkBiB,GAC7B,MAANK,GAAcC,IAChBpB,IAAc,CAAEmB,KAAIC,SACpBd,EAASS,QAAUC,EAAAA,cACpB,GAEH,CAACnB,EAAmBG,IAGhBqB,EAAUH,eACb3B,IACiB,MAAZQ,IACFS,EAAsB,IACjBP,EACHS,gBAAgB,IAEC,YAAfnB,EAAM+B,KACRL,EAAahB,GAEbgB,EAAa3B,EAAYC,IAE5B,GAEH,CAACQ,EAAUE,EAAiBgB,EAAcT,IAGtCe,EAAaC,EAAAA,YAAY,OAAQH,GAiDvC,MAAO,CACLpB,kBACAG,kBACAE,SAAUA,EAASS,QACnBU,YAAaC,EAAAA,WAAWH,EAAYX,EAAe,CACjDe,UApDepC,IAEjB,OADYA,EAAMqC,KAEhB,IAAK,MACH,OACF,IAAK,YAAa,CAChB,MAAMd,EAAOhB,EAAiBG,EAAiB,aAC/CO,EAAsB,IAAKM,EAAMJ,gBAAgB,IACjDmB,EAAWA,YAACtC,GACZ,KACD,CACD,IAAK,UAAW,CACd,MAAMuB,EAAOhB,EAAiBG,EAAiB,WAC/CO,EAAsB,IAAKM,EAAMJ,gBAAgB,IACjDmB,EAAWA,YAACtC,GACZ,KACD,CACD,IAAK,YAAa,CAChB,MAAMuB,EAAOhB,EAAiBG,EAAiB,aAC/CO,EAAsB,IAAKM,EAAMJ,gBAAgB,IACjDmB,EAAWA,YAACtC,GACZ,KACD,CACD,IAAK,aAAc,CACjB,MAAMuB,EAAOhB,EAAiBG,EAAiB,cAC/CO,EAAsB,IAAKM,EAAMJ,gBAAgB,IACjDmB,EAAWA,YAACtC,GACZ,KACD,EAEHe,EAASS,QAAUC,EAAAA,aAAa,EAuB9Bc,QApBavC,IAEH,QADAA,EAAMqC,KAEhBpB,EAAsB,IAAKP,EAAiBS,gBAAgB,GAC7D,EAiBCqB,YA3GiBxC,IACnB,MAAMuB,EAAOxB,EAAYC,GACrBuB,GACFN,EAAsB,IAAKM,EAAMJ,gBAAgB,GAClD,EAwGCsB,OAfW,KACbxB,EAAsB,IACjBP,EACHS,gBAAgB,GAChB,IAaFuB,uBAjI8BC,IACd,aAAZA,GACF1B,EAAsB,IACjBP,EACHS,gBAAgB,GAEnB,EA6HL"}