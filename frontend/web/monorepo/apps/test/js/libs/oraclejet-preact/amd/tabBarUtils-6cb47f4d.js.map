{"version":3,"file":"tabBarUtils-6cb47f4d.js","sources":["../../src/utils/PRIVATE_tabBarUtils/tabBarUtils.ts"],"sourcesContent":["import { MutableRef } from 'preact/hooks';\nimport { getKey } from '../PRIVATE_collectionUtils';\n\nexport type TrailingContentInfo = {\n  badge?: string | null;\n  metadata?: string | null;\n  contentWidth: number;\n};\n\nconst ITEM_SELECTOR = '[role=\"tab\"]';\nconst LABEL_MIN_WIDTH = 96;\nconst TAB_BORDER = 6;\n//This is the minWidth a tab will have if it has only a label.\nconst TAB_MIN_WIDTH = LABEL_MIN_WIDTH + TAB_BORDER;\n\nconst getTrailingContentInfo = (elem: HTMLElement, cache: TrailingContentInfo) => {\n  let trailingContentWidth = 0;\n  const hasSeverity = elem.querySelector('[data-oj-tab-severity]') !== null;\n  //A tab can have only one type of trailing content i.e either badge or metadata or severity so we would calculate only for one of them\n  let badge, metadata;\n  if (hasSeverity) {\n    trailingContentWidth = 20;\n  } else {\n    const badgeElem = elem.querySelector('[data-oj-tab-badge]');\n    if (badgeElem) {\n      badge = badgeElem.getAttribute('data-oj-tab-badge');\n      trailingContentWidth = badge === cache.badge ? cache.contentWidth : badgeElem.clientWidth;\n    } else {\n      const metadataElem = elem.querySelector('[data-oj-tab-metadata]');\n      if (metadataElem) {\n        metadata = metadataElem.getAttribute('data-oj-tab-metadata');\n        trailingContentWidth =\n          metadata === cache.metadata ? cache.contentWidth : metadataElem.clientWidth;\n      }\n    }\n  }\n  return { badge, metadata, contentWidth: trailingContentWidth };\n};\nconst getNonTextWidth = (elem: HTMLElement, trailingContentWidth: number, isLastKey: boolean) => {\n  const tabBarItemBorder = 6;\n  //Gap between one item and it's adjacent neighbor also account's for an item's non text width with the exception of last item.\n  const gapBetweenItems = isLastKey ? 0 : 32;\n  //Gap between each content within the item, example gap between metadata and label.\n  const gapBetweenItemContent = 8;\n  const hasIcon = elem.querySelector('[data-oj-tab-icon]') !== null;\n  const iconWidth = hasIcon ? 20 + gapBetweenItemContent : 0;\n  const isRemovable = elem.querySelector('[data-oj-tabbar-item-remove-icon]') !== null;\n  const removeIconWidth = isRemovable ? 24 + gapBetweenItemContent : 0;\n  const nonTextWidth =\n    tabBarItemBorder +\n    iconWidth +\n    removeIconWidth +\n    (trailingContentWidth > 0 ? trailingContentWidth + gapBetweenItemContent + gapBetweenItems : 0);\n  return nonTextWidth;\n};\n\nexport const getTabWidths = <K extends string | number>(\n  container: HTMLDivElement,\n  trailingContentWidths: MutableRef<Map<K, TrailingContentInfo>>,\n  isTruncationDisabled: boolean,\n  tabBarWidth: number,\n  isAllItemsTruncatedMax?: boolean,\n  keysArray?: K[]\n) => {\n  let sumofItemsWidth = 0;\n  const tabWidths: {\n    key: K;\n    maxWidth: number;\n    cumulativeWidth: number;\n    nonTextWidth?: number;\n    needsTruncation?: boolean;\n    hasReachedLimit?: boolean;\n  }[] = Array.from(container.querySelectorAll(ITEM_SELECTOR)).map((elem) => {\n    const maxWidth = (elem as HTMLElement).offsetWidth;\n    const hasReachedLimit = maxWidth <= LABEL_MIN_WIDTH ? true : false;\n    const itemKey = getKey(elem as HTMLElement) as K;\n    const cacheInfo = trailingContentWidths?.current?.get(itemKey);\n    const trailingContentInfo = getTrailingContentInfo(\n      elem as HTMLElement,\n      cacheInfo ? cacheInfo : { contentWidth: 0 }\n    );\n    trailingContentWidths.current.set(itemKey, trailingContentInfo);\n    const isLastKey =\n      keysArray && itemKey === (keysArray[keysArray.length - 1] as string | number) ? true : false;\n    const nonTextWidth = getNonTextWidth(\n      elem as HTMLElement,\n      trailingContentInfo.contentWidth,\n      isLastKey\n    );\n    sumofItemsWidth += Math.max(96, maxWidth) + nonTextWidth;\n    return {\n      key: itemKey,\n      maxWidth: maxWidth,\n      nonTextWidth: nonTextWidth,\n      cumulativeWidth: sumofItemsWidth,\n      hasReachedLimit: hasReachedLimit\n    };\n  });\n  //If all items have reached max treshold of truncation then we do not have to re-calculate or re-distribute any width\n  if (tabWidths.length > 0 && !isTruncationDisabled && !isAllItemsTruncatedMax) {\n    const gap = (tabWidths.length - 1) * 32;\n    const avgWidth = (tabBarWidth - gap) / tabWidths.length;\n    let extraWidth = 0;\n    const wideTabIndex: number[] = [];\n    tabWidths.forEach((record, index) => {\n      //If an item has reached max treshold of truncation then we do not have to re-calculate or re-distribute any width\n      if (!record.hasReachedLimit) {\n        if (record.maxWidth <= avgWidth) {\n          extraWidth = extraWidth + (avgWidth - record.maxWidth);\n        } else {\n          wideTabIndex.push(index);\n        }\n        record.maxWidth = avgWidth;\n      }\n    });\n    if (wideTabIndex.length > 0 && extraWidth > 0) {\n      const distributeWidth = extraWidth / wideTabIndex.length;\n      wideTabIndex.forEach((index) => {\n        //If an item has reached max treshold of truncation then we do not have to re-calculate or re-distribute any width\n        if (!tabWidths[index].hasReachedLimit) {\n          tabWidths[index].maxWidth += distributeWidth;\n          //The hook should add distributed width to the wide tab item's cumulativeWidth\n          tabWidths[index].cumulativeWidth += distributeWidth!;\n          //The hook should return the maximumWidth label can have accounting for non text content as well\n          tabWidths[index].maxWidth -= tabWidths[index].nonTextWidth!;\n        }\n        //If the maximum width is lesser than threshold of truncation i.e 96px + tab's border then reset maxWidth to that and none of the tabs need truncation\n        if (tabWidths[index].maxWidth <= TAB_MIN_WIDTH) {\n          tabWidths[index].needsTruncation = false;\n          tabWidths[index].maxWidth = TAB_MIN_WIDTH;\n        }\n      });\n    }\n  }\n  return tabWidths;\n};\n\n/**\n * Provides the reordered keys and reference item position after performing the move operation\n */\nexport const handleMove = <K extends string | number>(\n  moveDirection: 'forward' | 'backward',\n  tabKeys: K[],\n  itemKey: K\n) => {\n  const newArray = [...tabKeys];\n  const currentItemIndex = newArray.indexOf(itemKey);\n  let referenceItemIndex;\n  if (moveDirection === 'forward') {\n    referenceItemIndex = currentItemIndex + 1;\n    newArray.splice(currentItemIndex, 1);\n    newArray.splice(referenceItemIndex as number, 0, itemKey);\n  } else {\n    referenceItemIndex = currentItemIndex - 1;\n    newArray.splice(currentItemIndex, 1);\n    newArray.splice(referenceItemIndex as number, 0, itemKey);\n  }\n  return {\n    newArray,\n    referenceItemIndex\n  };\n};\n"],"names":["container","trailingContentWidths","isTruncationDisabled","tabBarWidth","isAllItemsTruncatedMax","keysArray","sumofItemsWidth","tabWidths","Array","from","querySelectorAll","map","elem","maxWidth","offsetWidth","hasReachedLimit","itemKey","getKey","cacheInfo","current","get","trailingContentInfo","cache","badge","metadata","trailingContentWidth","querySelector","badgeElem","getAttribute","contentWidth","clientWidth","metadataElem","getTrailingContentInfo","set","isLastKey","length","nonTextWidth","gapBetweenItems","getNonTextWidth","Math","max","key","cumulativeWidth","avgWidth","extraWidth","wideTabIndex","forEach","record","index","push","distributeWidth","LABEL_MIN_WIDTH","needsTruncation","moveDirection","tabKeys","newArray","currentItemIndex","indexOf","referenceItemIndex","splice"],"mappings":"2FAwD4B,CAC1BA,EACAC,EACAC,EACAC,EACAC,EACAC,KAEA,IAAIC,EAAkB,EACtB,MAAMC,EAOAC,MAAMC,KAAKT,EAAUU,iBA/DP,iBA+DwCC,KAAKC,IAC/D,MAAMC,EAAYD,EAAqBE,YACjCC,EAAkBF,GAhEJ,GAiEdG,EAAUC,SAAOL,GACjBM,EAAYjB,GAAuBkB,SAASC,IAAIJ,GAChDK,EA9DqB,EAACT,EAAmBU,KACjD,IAGIC,EAAOC,EAHPC,EAAuB,EAI3B,GAHqE,OAAjDb,EAAKc,cAAc,0BAIrCD,EAAuB,OAClB,CACL,MAAME,EAAYf,EAAKc,cAAc,uBACrC,GAAIC,EACFJ,EAAQI,EAAUC,aAAa,qBAC/BH,EAAuBF,IAAUD,EAAMC,MAAQD,EAAMO,aAAeF,EAAUG,gBACzE,CACL,MAAMC,EAAenB,EAAKc,cAAc,0BACpCK,IACFP,EAAWO,EAAaH,aAAa,wBACrCH,EACED,IAAaF,EAAME,SAAWF,EAAMO,aAAeE,EAAaD,YAErE,CACF,CACD,MAAO,CAAEP,QAAOC,WAAUK,aAAcJ,EAAsB,EAyChCO,CAC1BpB,EACAM,GAAwB,CAAEW,aAAc,IAE1C5B,EAAsBkB,QAAQc,IAAIjB,EAASK,GAC3C,MAAMa,KACJ7B,GAAaW,IAAaX,EAAUA,EAAU8B,OAAS,IACnDC,EA9Cc,EAACxB,EAAmBa,EAA8BS,KACxE,MAEMG,EAAkBH,EAAY,EAAI,GAYxC,OAdyB,GAKoC,OAA7CtB,EAAKc,cAAc,sBACP,GAA6B,IACuB,OAA5Dd,EAAKc,cAAc,qCACD,GAA6B,IAKhED,EAAuB,EAAIA,EATA,EAS+CY,EAAkB,EAC5E,EA+BIC,CACnB1B,EACAS,EAAoBQ,aACpBK,GAGF,OADA5B,GAAmBiC,KAAKC,IAAI,GAAI3B,GAAYuB,EACrC,CACLK,IAAKzB,EACLH,SAAUA,EACVuB,aAAcA,EACdM,gBAAiBpC,EACjBS,gBAAiBA,EAClB,IAGH,GAAIR,EAAU4B,OAAS,IAAMjC,IAAyBE,EAAwB,CAC5E,MACMuC,GAAYxC,EADmB,IAAxBI,EAAU4B,OAAS,IACO5B,EAAU4B,OACjD,IAAIS,EAAa,EACjB,MAAMC,EAAyB,GAY/B,GAXAtC,EAAUuC,SAAQ,CAACC,EAAQC,KAEpBD,EAAOhC,kBACNgC,EAAOlC,UAAY8B,EACrBC,GAA2BD,EAAWI,EAAOlC,SAE7CgC,EAAaI,KAAKD,GAEpBD,EAAOlC,SAAW8B,EACnB,IAECE,EAAaV,OAAS,GAAKS,EAAa,EAAG,CAC7C,MAAMM,EAAkBN,EAAaC,EAAaV,OAClDU,EAAaC,SAASE,IAEfzC,EAAUyC,GAAOjC,kBACpBR,EAAUyC,GAAOnC,UAAYqC,EAE7B3C,EAAUyC,GAAON,iBAAmBQ,EAEpC3C,EAAUyC,GAAOnC,UAAYN,EAAUyC,GAAOZ,cAG5C7B,EAAUyC,GAAOnC,UAlHPsC,MAmHZ5C,EAAUyC,GAAOI,iBAAkB,EACnC7C,EAAUyC,GAAOnC,SApHLsC,IAqHb,GAEJ,CACF,CACD,OAAO5C,CAAS,eAMQ,CACxB8C,EACAC,EACAtC,KAEA,MAAMuC,EAAW,IAAID,GACfE,EAAmBD,EAASE,QAAQzC,GAC1C,IAAI0C,EAUJ,MATsB,YAAlBL,GACFK,EAAqBF,EAAmB,EACxCD,EAASI,OAAOH,EAAkB,GAClCD,EAASI,OAAOD,EAA8B,EAAG1C,KAEjD0C,EAAqBF,EAAmB,EACxCD,EAASI,OAAOH,EAAkB,GAClCD,EAASI,OAAOD,EAA8B,EAAG1C,IAE5C,CACLuC,WACAG,qBACD"}