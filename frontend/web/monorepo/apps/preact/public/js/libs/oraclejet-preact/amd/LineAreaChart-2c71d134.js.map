{"version":3,"file":"LineAreaChart-2c71d134.js","sources":["../../src/UNSAFE_LineAreaChart/LineAreaChart.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { LineAreaChartProps, LineAreaItem } from './lineAreaChart.types';\nimport {\n  findNearestDataPoint,\n  getStartAndEndAxesOffset\n} from '#utils/PRIVATE_chartUtils/layoutUtils';\nimport { AreaSeries } from '#PRIVATE_LineAreaComponents/AreaSeries';\nimport { getCumulativeSeries, getMarkers, getSeriesData } from '#utils/PRIVATE_chartUtils/utils';\nimport { MarkersWithLabel } from '#PRIVATE_Chart/MarkersWithLabel';\nimport { getLineAreaChartNavUtil } from '#utils/PRIVATE_chartUtils/navUtils';\nimport { Chart } from '#PRIVATE_Chart';\nimport { Scale, TimeAxisProps } from '#utils/UNSAFE_visTypes/chart';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport { getColorRamp } from '#utils/UNSAFE_visUtils';\nimport { LineSeries } from '#PRIVATE_LineAreaComponents/LineSeries';\nimport { Point } from '#utils/PRIVATE_visSVGUtils';\nimport { getLineAreaSegments } from '#utils/PRIVATE_chartUtils/utils';\nimport { colorSchemeVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\nimport { getItemColor, getMarkerType } from '#utils/PRIVATE_chartUtils/dataStyleUtils';\nimport { getLineAreaChartItemPosition } from '#PRIVATE_LineAreaComponents/utils/chartUtils';\n\nconst LINE_WITH_AREA_OPACITY = 0.2;\n\n/**\n * The LineAreaChart displays information graphically using lines and filled areas, making relationships among the data easier to understand.\n */\nexport function LineAreaChart<K extends string | number, D extends LineAreaItem<K>>({\n  width,\n  height,\n  selectedIds = [],\n  hiddenIds = [],\n  highlightedIds,\n  hideAndShowBehavior = 'none',\n  orientation = 'vertical',\n  yAxis,\n  y2Axis,\n  series,\n  groups,\n  isStacked = false,\n  getDataItem,\n  selectionMode = 'none',\n  drilling = 'off',\n  type = 'line',\n  overview = 'off',\n  dataLabelEffect = 'outline',\n  ...props\n}: LineAreaChartProps<K, D>) {\n  const { direction, forcedColors } = useUser();\n  const isHighContrast = forcedColors === 'active';\n  const isTestEnv = props.testId !== undefined;\n  const isRtl = direction === 'rtl';\n  const isLog = yAxis?.scale === 'log';\n  const timeAxisType = (props.xAxis as TimeAxisProps)?.timeAxisType;\n  const hiddenSet = new Set(hiddenIds);\n  const selectedSet = new Set(selectedIds);\n  const highlightedSet = new Set(highlightedIds);\n  const isHoriz = orientation === 'horizontal';\n  const colors = getColorRamp();\n  let renderedSeries = isStacked\n    ? getCumulativeSeries(series.length, groups.length, getDataItem, hiddenSet, isLog)\n    : getSeriesData(series?.length, groups?.length, getDataItem, hiddenSet, isLog);\n\n  const renderedGetDataItem = (seriesIndex: number, groupIndex: number): D | undefined => {\n    if (!isStacked) return getDataItem(seriesIndex, groupIndex);\n    return {\n      ...getDataItem(seriesIndex, groupIndex),\n      value: renderedSeries[seriesIndex][groupIndex]\n    } as D;\n  };\n\n  const getGapRatio = () => {\n    return 1;\n  };\n\n  const getNextChartItemFunc = (startIndex: number, endIndex: number) => {\n    // TODO: JET-71332\n    //@ts-ignore\n    return getLineAreaChartNavUtil<D>(\n      getDataItem,\n      series.length,\n      startIndex,\n      endIndex,\n      isStacked,\n      isRtl,\n      isHoriz\n    );\n  };\n\n  const getDataItemPos = (xScale: Scale, yScale: Scale, y2Scale: Scale) => {\n    return (seriesIndex: number, groupIndex: number) => {\n      const isAssociatedToY2 = series[seriesIndex].associatedYAxis === 'y2';\n      return getLineAreaChartItemPosition(\n        seriesIndex,\n        groupIndex,\n        renderedSeries,\n        getDataItem,\n        groups,\n        isHoriz,\n        xScale,\n        isAssociatedToY2 ? y2Scale : yScale,\n        timeAxisType\n      );\n    };\n  };\n\n  const getMarkerColorAndType = (seriesIndex: number, groupIndex: number) => {\n    return {\n      color: getItemColor(seriesIndex, groupIndex, series, getDataItem),\n      type: getMarkerType(seriesIndex, groupIndex, getDataItem)\n    };\n  };\n\n  const findNearest = (xScale: Scale, yScale: Scale, y2Scale: Scale) => {\n    const getSeriesDataInfo = () => {\n      return {\n        offset: 0,\n        dataWidth: 0\n      };\n    };\n\n    const getYCoord = (value: number, yScale: Scale) => {\n      return yScale.transform(value);\n    };\n\n    return findNearestDataPoint<K, D>(\n      series,\n      groups,\n      xScale,\n      yScale,\n      renderedGetDataItem,\n      isStacked,\n      getSeriesDataInfo,\n      getYCoord,\n      isLog,\n      0,\n      hiddenSet,\n      timeAxisType,\n      y2Scale\n    );\n  };\n  const { hasCenteredSeries, hasUncenteredSeries } = series.reduce(\n    (acc, s) => {\n      return {\n        hasCenteredSeries:\n          acc.hasCenteredSeries ||\n          s.lineType === 'centeredSegmented' ||\n          s.lineType === 'centeredStepped',\n        hasUncenteredSeries:\n          acc.hasUncenteredSeries || s.lineType === 'segmented' || s.lineType === 'stepped'\n      };\n    },\n    { hasCenteredSeries: false, hasUncenteredSeries: false }\n  );\n\n  const getOffset = (groupCount: number) => {\n    return getStartAndEndAxesOffset(hasCenteredSeries, hasUncenteredSeries, isHoriz, groupCount);\n  };\n\n  const markers = getMarkers();\n  const areaOpacity = type === 'lineWithArea' ? LINE_WITH_AREA_OPACITY : 1;\n  const isAreaRendered = type === 'area' || type === 'lineWithArea';\n  const isContrastLineNeeded = type === 'area';\n  const allLineSegmentCoords: Point[][] = [];\n  return (\n    <Chart\n      width={width}\n      height={height}\n      selectedIds={selectedSet}\n      hiddenIds={hiddenIds}\n      hideAndShowBehavior={hideAndShowBehavior}\n      orientation={orientation}\n      yAxis={yAxis}\n      y2Axis={y2Axis}\n      series={series}\n      groups={groups}\n      selectionMode={selectionMode}\n      drilling={drilling}\n      isStacked={isStacked}\n      getDataItem={getDataItem}\n      findNearest={findNearest}\n      getDataItemPos={getDataItemPos}\n      getMarkerInfo={getMarkerColorAndType}\n      renderGridLinesInFront={isAreaRendered}\n      getNavUtil={getNextChartItemFunc}\n      getGapRatio={getGapRatio}\n      getStartAndEndAxesOffset={getOffset}\n      isRtl={isRtl}\n      overview={overview}\n      defaultOverviewContentRenderer={() => {\n        return (\n          <OverviewLineAreaChart\n            series={series}\n            groups={groups}\n            getDataItem={getDataItem}\n            type={type}\n          />\n        );\n      }}\n      {...props}>\n      {({\n        getItemAriaLabel,\n        groupsInfo,\n        xStartIndex,\n        xEndIndex,\n        xScale,\n        yScale,\n        y2Scale,\n        activeId,\n        focusedItemInfo,\n        hoveredItemInfo,\n        isPointInsideMarquee,\n        defaultFontSize,\n        getTextDimensions,\n        plotAreaClipPathId,\n        axisStepWidth\n      }) => {\n        const leafGroups = groupsInfo.map(({ item }) => item);\n        renderedSeries = isStacked\n          ? getCumulativeSeries(series.length, leafGroups.length, getDataItem, hiddenSet, isLog)\n          : getSeriesData(series?.length, leafGroups?.length, getDataItem, hiddenSet, isLog);\n        return (\n          <>\n            {renderedSeries.map((lineAreaSeries, index) => {\n              if (lineAreaSeries.length === 0) {\n                /* TODO: need a better way to handle when a series is hidden. */\n                return;\n              }\n              const seriesItem = series[index];\n              const isAssociatedToY2 = seriesItem.associatedYAxis === 'y2';\n              const lineSegmentCoords: Point[][] = getLineAreaSegments<K, D>(\n                isAssociatedToY2 ? y2Scale : yScale,\n                xScale,\n                lineAreaSeries,\n                xStartIndex,\n                xEndIndex,\n                isLog,\n                leafGroups,\n                index,\n                renderedGetDataItem,\n                timeAxisType\n              );\n              allLineSegmentCoords[index] = lineSegmentCoords[0];\n              const isBottomSegmentCurved =\n                seriesItem.lineType === 'curved' &&\n                isStacked &&\n                renderedSeries.length > 1 &&\n                index > 0;\n\n              const isHighlighted =\n                highlightedIds === undefined ||\n                highlightedIds.length === 0 ||\n                highlightedSet.has(seriesItem.id);\n\n              const prevCoords =\n                isStacked && index != 0\n                  ? allLineSegmentCoords.reduce((prevValue, newValue, j) => {\n                      // find the index i such that i < index, and series i  has at least\n                      // one or more data item unhidden. Only such series will can be\n                      // used as bottomCoord for current series. Otherwise we have to use\n                      // baseline coord\n                      if (j >= index) {\n                        return prevValue;\n                      }\n                      if (newValue.length > 0) {\n                        return j;\n                      }\n                      return prevValue;\n                    }, 0)\n                  : undefined;\n\n              return (\n                <>\n                  {isAreaRendered && (\n                    <AreaSeries\n                      yScale={isAssociatedToY2 ? y2Scale : yScale}\n                      lineType={seriesItem.lineType}\n                      color={seriesItem.areaColor || colors[index % colors.length]}\n                      isHorizontal={isHoriz}\n                      areaColorOpacity={areaOpacity}\n                      isBottomSegmentCurved={isBottomSegmentCurved}\n                      bottomCoords={\n                        prevCoords !== undefined &&\n                        allLineSegmentCoords[prevCoords].some((value) => value != null)\n                          ? allLineSegmentCoords[prevCoords]\n                          : undefined\n                      }\n                      lineSegments={lineSegmentCoords}\n                      isLog={isLog}\n                      isHighlighted={isHighlighted}\n                      seriesIndex={index}\n                      groupWidth={axisStepWidth}\n                      isRtl={isRtl}\n                      timeAxisType={timeAxisType}\n                      plotAreaClipPathId={plotAreaClipPathId}\n                    />\n                  )}\n                  <LineSeries\n                    lineType={seriesItem.lineType}\n                    /* TODO: confirm with UX if this is contrastLine (changes depending on dark/light mode) or always white. \n                        It's always white in legacy.*/\n                    lineColor={\n                      isContrastLineNeeded ? colorSchemeVars.dvt.contrastLine : seriesItem.lineColor\n                    }\n                    /* The area generated in legacy are bit apart and not touching when stacked. Preact areas are a bit closer than legacy when curved. \n                      Increased the contrast linewidth (to 2.5 from legacy 1.25) to give legacy visual treatment.\n                      TODO: investivage why legacy areas are not touching. maybe we want to do the same in preact svg utils that\n                      generates this curve.\n                     */\n                    lineWidth={\n                      isContrastLineNeeded ? (isStacked ? 2.5 : 1.25) : seriesItem.lineWidth\n                    }\n                    lineStyle={seriesItem.lineStyle}\n                    color={seriesItem.lineColor || colors[index % colors.length]}\n                    lineSegmentCoords={lineSegmentCoords}\n                    isHorizontal={isHoriz}\n                    isHighlighted={isHighlighted}\n                    seriesIndex={index}\n                    groupWidth={axisStepWidth}\n                    isRtl={isRtl}\n                    timeAxisType={timeAxisType}\n                    plotAreaClipPathId={plotAreaClipPathId}\n                  />\n                  {\n                    /*for non stacked charts, markers should render in the order of series.\n                     some markers might get hidden behind area but this preserves the legacy behavior. */\n                    !isStacked && (\n                      <MarkersWithLabel\n                        yScale={isAssociatedToY2 ? y2Scale : yScale}\n                        xScale={xScale}\n                        groups={leafGroups}\n                        series={seriesItem}\n                        timeAxisType={timeAxisType}\n                        color={\n                          seriesItem.lineColor ||\n                          seriesItem.areaColor ||\n                          colors[\n                            index % colors.length\n                          ] /* TODO : make this use getItemColor function from dataStyleUtils. */\n                        }\n                        seriesIndex={index}\n                        startIndex={xStartIndex}\n                        endIndex={xEndIndex}\n                        markerType={markers[index % markers.length]}\n                        orientation={orientation}\n                        isLog={isLog}\n                        activeId={activeId}\n                        getDataItem={getDataItem}\n                        isPointInsideMarquee={isPointInsideMarquee}\n                        selectedIds={selectedSet}\n                        highlightedIds={highlightedIds !== undefined ? highlightedSet : undefined}\n                        focusedItemIndex={\n                          focusedItemInfo.seriesIndex === index &&\n                          focusedItemInfo.isFocusVisible &&\n                          !(props.isDataCursorEnabled && props.dataCursorStyle?.isMarkerDisplayed)\n                            ? focusedItemInfo.groupIndex\n                            : undefined\n                        }\n                        hoveredItemIndex={\n                          hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                            ? hoveredItemInfo.groupIndex\n                            : undefined\n                        }\n                        isSelectionEnabled={\n                          selectionMode === 'single' || selectionMode === 'multiple'\n                        }\n                        isDrillEnabled={drilling === 'on'}\n                        defaultFontSize={defaultFontSize}\n                        dataLabelEffect={dataLabelEffect}\n                        isHighContrast={isHighContrast}\n                        isTestEnv={isTestEnv}\n                        getTextDimensions={getTextDimensions}\n                        getItemAriaLabel={getItemAriaLabel}\n                      />\n                    )\n                  }\n                </>\n              );\n            })}\n            {isStacked &&\n              renderedSeries.map((lineAreaSeries, index) => {\n                if (lineAreaSeries.length === 0) {\n                  /* TODO: need a better way to handle when a series is hidden.*/\n                  return;\n                }\n                const seriesItem = series[index];\n                const isAssociatedToY2 = seriesItem.associatedYAxis === 'y2';\n                return (\n                  <MarkersWithLabel\n                    yScale={isAssociatedToY2 ? y2Scale : yScale}\n                    series={series[index]}\n                    xScale={xScale}\n                    groups={leafGroups}\n                    timeAxisType={timeAxisType}\n                    color={\n                      seriesItem.lineColor || seriesItem.areaColor || colors[index % colors.length]\n                    }\n                    seriesIndex={index}\n                    isPointInsideMarquee={isPointInsideMarquee}\n                    startIndex={xStartIndex}\n                    endIndex={xEndIndex}\n                    markerType={markers[index % markers.length]}\n                    orientation={orientation}\n                    isLog={isLog}\n                    activeId={activeId}\n                    getDataItem={renderedGetDataItem}\n                    selectedIds={selectedSet}\n                    focusedItemIndex={\n                      focusedItemInfo.seriesIndex === index && focusedItemInfo.isFocusVisible\n                        ? focusedItemInfo.groupIndex\n                        : undefined\n                    }\n                    hoveredItemIndex={\n                      hoveredItemInfo?.isCurrent && hoveredItemInfo.seriesIndex === index\n                        ? hoveredItemInfo.groupIndex\n                        : undefined\n                    }\n                    isSelectionEnabled={selectionMode === 'single' || selectionMode === 'multiple'}\n                    isDrillEnabled={drilling === 'on'}\n                    defaultFontSize={defaultFontSize}\n                    dataLabelEffect={dataLabelEffect}\n                    isHighContrast={isHighContrast}\n                    isTestEnv={isTestEnv}\n                    getTextDimensions={getTextDimensions}\n                    getItemAriaLabel={getItemAriaLabel}\n                  />\n                );\n              })}\n          </>\n        );\n      }}\n    </Chart>\n  );\n}\n\nfunction OverviewLineAreaChart<K extends string | number, D extends LineAreaItem<K>>(\n  props: LineAreaChartProps<K, D>\n) {\n  return (\n    <LineAreaChart\n      datatip={() => ({ content: '' })}\n      zoomAndScroll=\"off\"\n      overview=\"off\"\n      plotArea={{\n        yMajorTick: {\n          isRendered: false\n        }\n      }}\n      xAxis={{\n        tickLabel: {\n          autoRotate: false,\n          // @ts-ignore\n          isRendered: props.xAxis?.timeAxisType ? true : false\n        }\n      }}\n      series={props.series}\n      groups={props.groups}\n      getDataItem={props.getDataItem}\n      yAxis={{\n        tickLabel: {\n          isRendered: false\n        }\n      }}\n      type={props.type}\n    />\n  );\n}\n"],"names":["LineAreaChart","width","height","selectedIds","hiddenIds","highlightedIds","hideAndShowBehavior","orientation","yAxis","y2Axis","series","groups","isStacked","getDataItem","selectionMode","drilling","type","overview","dataLabelEffect","props","direction","forcedColors","useUser","isHighContrast","isTestEnv","undefined","testId","isRtl","isLog","scale","timeAxisType","xAxis","hiddenSet","Set","selectedSet","highlightedSet","isHoriz","colors","getColorRamp","renderedSeries","getCumulativeSeries","length","getSeriesData","renderedGetDataItem","seriesIndex","groupIndex","value","hasCenteredSeries","hasUncenteredSeries","reduce","acc","s","lineType","markers","getMarkers","areaOpacity","isAreaRendered","isContrastLineNeeded","allLineSegmentCoords","_jsx","Chart","findNearest","xScale","yScale","y2Scale","findNearestDataPoint","offset","dataWidth","transform","getDataItemPos","isAssociatedToY2","associatedYAxis","getLineAreaChartItemPosition","getMarkerInfo","color","getItemColor","getMarkerType","renderGridLinesInFront","getNavUtil","startIndex","endIndex","getLineAreaChartNavUtil","getGapRatio","getStartAndEndAxesOffset","groupCount","defaultOverviewContentRenderer","OverviewLineAreaChart","children","getItemAriaLabel","groupsInfo","xStartIndex","xEndIndex","activeId","focusedItemInfo","hoveredItemInfo","isPointInsideMarquee","defaultFontSize","getTextDimensions","plotAreaClipPathId","axisStepWidth","leafGroups","map","item","_jsxs","jsxs","_Fragment","Fragment","lineAreaSeries","index","seriesItem","lineSegmentCoords","getLineAreaSegments","isBottomSegmentCurved","isHighlighted","has","id","prevCoords","prevValue","newValue","j","AreaSeries","areaColor","isHorizontal","areaColorOpacity","bottomCoords","some","lineSegments","groupWidth","LineSeries","lineColor","colorSchemeVars","dvt","contrastLine","lineWidth","lineStyle","jsx","MarkersWithLabel","markerType","focusedItemIndex","isFocusVisible","isDataCursorEnabled","dataCursorStyle","isMarkerDisplayed","hoveredItemIndex","isCurrent","isSelectionEnabled","isDrillEnabled","datatip","content","zoomAndScroll","plotArea","yMajorTick","isRendered","tickLabel","autoRotate"],"mappings":"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"}