{"version":3,"file":"useUnsafeDomElementRef-75afb461.js","sources":["../../src/hooks/PRIVATE_useUnsafeDomElementRef/useUnsafeDomElementRef.ts"],"sourcesContent":["import { useRef } from 'preact/hooks';\nimport { RefObject } from 'preact';\n\nimport { UNSAFE_DOM_ACCESS } from '#utils/UNSAFE_unsafeDomAccess';\nimport type { UnsafeDomHandle } from '#utils/UNSAFE_unsafeDomAccess';\n\n/**\n * This hook converts a ref of type UnsafeDomHandle to a ref that directly exposes\n * the unsafe DOM element.\n *\n * The intention is that this can be used internally in JET Preact to simplify\n * cases where we receive and UnsafeDomHandle but need to pass this to code\n * that operates an an element-based ref.\n *\n * An alternative approach would be to rewrite any code that currently operates\n * on element-based refs to also support UnsafeDomHandle.  While we can do that\n * at any point, the advantage of this hook is that it limits the scope of code\n * that needs to be aware of unsafe DOM handles.\n *\n * For typing purposes, this function exposes two type parameters:\n *\n * - ElementType: this is the type of the unsafe DOM element that will be\n *   extracted and placed in the returned ref.\n * - ExtraType: in some cases refs may support additional types beyond\n *   just UnsafeDomHandle.  For example, Floating's anchorRef has the\n *   type  RefObject<Element | Coords | UnsafeDomHandle<Element>>.  The\n *   ExtraType type parameter would be used to convey that <Element | Coords> are\n *   also valid types for the ref handle.\n */\nexport function useUnsafeDomElementRef<\n  ElementType extends Element = HTMLElement,\n  ExtraType = never\n>(unsafeRootElementRef: RefObject<UnsafeDomHandle<ElementType> | ElementType | ExtraType>) {\n  const extractedRef = useRef<ElementType | ExtraType>(null);\n\n  // Note that in theory we should be able to populate the extractedRef's value via\n  // useImperativeHandle.  In practice, this does not work due to Popup + Floating's\n  // handling of anchorRef.  In particular, the Popup component writes the anchorRef.current\n  // value during rendering.  The Floating component reads the anchorRef.current value\n  // during rendering.  However, useImperativeHandle does its work in a layout effect.\n  // If we attempt to true up the extractedRef with the provided unsafeRootElementRef via\n  // an imperative handle, extractedRef will only be updated after Floating has already read\n  // the stale value.\n  //\n  // Note that React discourages reading/writing refs during rendering.  See the \"Pitfall\"\n  // section under:\n  //\n  // https://react.dev/reference/react/useRef#referencing-a-value-with-a-ref\n  //\n  // While we should probably revisit our ref handling in Popup/Floating, for the moment I\n  // am working around this by avoiding useImperativeHandle and instead directly modifying\n  // ref.current (which, ironically, also violates React's recommendations).\n  let current = unsafeRootElementRef.current;\n  const unsafeDomHandle = current as UnsafeDomHandle<ElementType>;\n\n  if (unsafeDomHandle?.[UNSAFE_DOM_ACCESS]) {\n    current = unsafeDomHandle[UNSAFE_DOM_ACCESS];\n  }\n\n  if (extractedRef.current !== current) {\n    extractedRef.current = current as ElementType | ExtraType;\n  }\n\n  return extractedRef;\n}\n"],"names":["unsafeRootElementRef","extractedRef","useRef","current","unsafeDomHandle","UNSAFE_DOM_ACCESS"],"mappings":"sHA6BM,SAGJA,GACA,MAAMC,EAAeC,SAAgC,MAmBrD,IAAIC,EAAUH,EAAqBG,QACnC,MAAMC,EAAkBD,EAUxB,OARIC,IAAkBC,EAAAA,qBACpBF,EAAUC,EAAgBC,EAAAA,oBAGxBJ,EAAaE,UAAYA,IAC3BF,EAAaE,QAAUA,GAGlBF,CACT"}