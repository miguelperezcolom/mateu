{"version":3,"file":"UNSAFE_useUncontrolledState.js","sources":["../../../src/hooks/UNSAFE_useUncontrolledState/useUncontrolledState.ts"],"sourcesContent":["import { useCallback, useRef, useState } from 'preact/hooks';\n\n/**\n * A custom hook for handling uncontrolled properties. These are the properties for which\n * we need to maintain an internal state and also trigger certain callbacks whenever we\n * update the internal state.\n *\n * Examples:\n * 1. The `value` property in an uncontrolled InputText\n *\n * Here, we will have `value` property and a corresponding `onValueChanged` callback. When\n * one interacts with the component and updates the value on the UI, we need to update the\n * `value` prop accordingly. Being uncontrolled, we do not have to rely on the parent to push\n * back the value, so we maintain an internal state for it and update the internal state.\n * Even though we are maintaining an internal state, we still need to invoke the callback\n * so we do that when the new value is different from the current value.\n *\n * We use useUncontrolledState hook for getting this behavior like follows:\n * ```\n * const [uncontrolledValue, setUncontrolledValue] = useUncontrolledState(value, onValueChanged);\n * ```\n *\n * Whenever you want to change this value, you would simply do:\n * ```\n * // set the new value\n * setUncontrolledValue(newValue);\n * ```\n * This call automatically calls the `onValueChanged` callback for you when the new value is different.\n * Essentially, you might want to consider using this method if your property supports writeback. This\n * way, whenever we update the internal state, the onPropertyChanged will be invoked automatically with\n * the new value which would in turn writes back the new value on the prop.\n *\n * @param initialState The initial value for the internal state. Calling this hook again with a different\n *                     value for this argument will not update the internal state.\n * @param onStateChange The callback function that needs to be called whenever the state value is updated.\n * @returns A stateful value and a setter function to update it. Here the setter function identity\n *          is stable and won't change on re-renders (similar to useState's setter function)\n */\nexport function useUncontrolledState<V>(\n  initialState?: V,\n  onStateChange?: (value: V, ...args: any[]) => void\n): [V | undefined, (value: V, ...args: any[]) => void] {\n  // Internal state for storing the value\n  const [stateValue, setStateValue] = useState(initialState);\n  // Internal ref to store value. This is to know what the previous value was.\n  const stateRef = useRef(stateValue);\n\n  // In order to make the setter function returned by this hook stable, we need to remove\n  // any external dependency from it. So, we use a ref that gets updated every render\n  // to store the onStateChange callback function. This way we can refer to this function\n  // without making it a dependency.\n  const onStateChangeRef = useRef(onStateChange);\n  onStateChangeRef.current = onStateChange;\n\n  // A setter function for updating the state\n  const setUncontrolledValue = useCallback((state: V, ...args: any[]) => {\n    // update the internal state\n    setStateValue(state);\n    // Call the onChange callback only if the value is changed\n    if (stateRef.current !== state) {\n      onStateChangeRef.current?.(state, ...args);\n      stateRef.current = state;\n    }\n  }, []);\n\n  // The setUncontrolledValue function returned here is guaranteed to\n  // be the same.\n  return [stateValue, setUncontrolledValue];\n}\n"],"names":["initialState","onStateChange","stateValue","setStateValue","useState","stateRef","useRef","onStateChangeRef","current","useCallback","state","args"],"mappings":"qFAsCgB,SACdA,EACAC,GAGA,MAAOC,EAAYC,GAAiBC,EAAQA,SAACJ,GAEvCK,EAAWC,SAAOJ,GAMlBK,EAAmBD,SAAOL,GAgBhC,OAfAM,EAAiBC,QAAUP,EAepB,CAACC,EAZqBO,EAAWA,aAAC,CAACC,KAAaC,KAErDR,EAAcO,GAEVL,EAASG,UAAYE,IACvBH,EAAiBC,UAAUE,KAAUC,GACrCN,EAASG,QAAUE,EACpB,GACA,IAKL"}