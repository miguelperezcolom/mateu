{"version":3,"file":"TabBarContextMenu-cad0a362.js","sources":["../../src/UNSAFE_TabBar/TabBarContextMenu.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentProps } from 'preact';\nimport { Menu, MenuItem } from '../UNSAFE_Menu';\nimport { TabBarContextMenuConfig, TabBarItemContext } from '../UNSAFE_TabBarCommon';\nimport { TabBar } from './TabBar';\nimport { Separator } from '../UNSAFE_Separator';\nimport { TabBarItemContextMenuContext } from '../UNSAFE_TabBarCommon/TabBar.types';\nimport { ReorderableTabBar } from '../UNSAFE_ReorderableTabBar';\nimport { handleMove } from '../utils/PRIVATE_tabBarUtils';\n\nexport type Props<K extends string | number> = Omit<ComponentProps<typeof Menu>, 'children'> & {\n  contextMenuConfig: TabBarContextMenuConfig<K>;\n} & { contextMenuContext: TabBarItemContext<K> };\n\n/**\n * The internal component used to render a custom or default context menu\n */\nexport function TabBarContextMenu<K extends string | number>({\n  contextMenuConfig,\n  contextMenuContext,\n  ...menuProps\n}: Props<K>) {\n  const accessibleLabel = contextMenuConfig.accessibleLabel;\n\n  // We want to call itemsRenderer only when menu is open otherwise it would be called during render phase when no context is available\n  const menuItems = menuProps.isOpen ? contextMenuConfig.itemsRenderer(contextMenuContext) : null;\n  // If there are menu items then we construct the menu otherwise menu will be mounted unnecessarily, if menu items are null we return an empty fragment as return type needs to be a JSX\n  if (menuItems != null) {\n    return (\n      <>\n        <Menu\n          {...menuProps}\n          {...(accessibleLabel && {\n            'aria-label': accessibleLabel\n          })}>\n          {menuItems}\n        </Menu>\n      </>\n    );\n  }\n  return <></>;\n}\n\n/**\n * Optional props because we could have only remove feature or reorder feature.\n */\ntype StatusProps<K extends string | number> = {\n  position?: 'before' | 'after';\n  destinationKey?: K;\n  removedKey?: K;\n};\ntype AccInfo = {\n  /*\n   * Callback to obtain the key for remove/ key and position for moving a tab and build acc status text.\n   */\n  handleAccStatus: (statusDetail: StatusProps<string | number>) => void;\n};\n\n/**\n * Optional because we could have only remove feature or reorder feature.\n */\ntype RemoveItemProps = {\n  handleRemove?: ComponentProps<typeof TabBar>['onRemove'];\n  isRemovable?: boolean;\n};\n\n/**\n * Optional because we could have only remove feature or reorder feature.\n */\ntype ReorderItemProps<K> = {\n  handleReorder?: ComponentProps<typeof ReorderableTabBar>['onReorder'];\n  tabKeys?: K[];\n  direction?: 'ltr' | 'rtl';\n};\n\ntype TranslationLabels = {\n  /*\n   * The translation labels for remove item and move items. Optional because we could have only remove feature or reorder feature.\n   */\n  itemLabels: { labelRemove?: string; labelMoveLeft?: string; labelMoveRight?: string };\n};\n\n/**\n * Creates the default context menu items\n */\nexport function getDefaultContextMenu<K extends string | number>({\n  isRemovable,\n  handleReorder,\n  handleRemove,\n  itemKey,\n  tabKeys,\n  direction,\n  itemLabels,\n  handleAccStatus\n}: RemoveItemProps & ReorderItemProps<K> & TabBarItemContext<K> & TranslationLabels & AccInfo) {\n  const handleRemoveAction = () => {\n    handleRemove?.({ value: itemKey as string | number });\n    handleAccStatus?.({\n      removedKey: itemKey\n    });\n  };\n\n  const isReorderable = handleReorder != null;\n\n  const isRtl = direction === 'rtl';\n  const handleMoveAction = (moveDirection: 'forward' | 'backward') => {\n    if (isReorderable && tabKeys) {\n      const { newArray, referenceItemIndex } = handleMove(moveDirection, tabKeys, itemKey);\n      const destinationKey = tabKeys[referenceItemIndex];\n      handleReorder?.({\n        reorderedKeys: newArray,\n        itemKeys: [itemKey],\n        referenceKey: destinationKey\n      });\n      handleAccStatus?.({\n        position: moveDirection === 'forward' ? 'after' : 'before',\n        destinationKey: destinationKey\n      });\n    }\n  };\n\n  const allMenuItems = isReorderable\n    ? {\n        moveForwardItem: (\n          <MenuItem\n            label={isRtl ? itemLabels?.labelMoveLeft! : itemLabels?.labelMoveRight!}\n            onAction={() => handleMoveAction('forward')}\n          />\n        ),\n        moveBackwardItem: (\n          <MenuItem\n            label={isRtl ? itemLabels?.labelMoveRight! : itemLabels?.labelMoveLeft!}\n            onAction={() => handleMoveAction('backward')}\n          />\n        ),\n        removeItem: <MenuItem label={'Remove'} onAction={handleRemoveAction} />,\n        remove: <MenuItem label={'Remove'} onAction={handleRemoveAction} />,\n        reorder: (\n          <>\n            <MenuItem\n              label={isRtl ? itemLabels?.labelMoveLeft! : itemLabels?.labelMoveRight!}\n              onAction={() => handleMoveAction('forward')}\n            />\n            <MenuItem\n              label={isRtl ? itemLabels?.labelMoveRight! : itemLabels?.labelMoveLeft!}\n              onAction={() => handleMoveAction('backward')}\n            />\n          </>\n        )\n      }\n    : {\n        remove: <MenuItem label={'Remove'} onAction={handleRemoveAction} />,\n        removeItem: <MenuItem label={'Remove'} onAction={handleRemoveAction} />\n      };\n\n  const createMoveMenuItems = (itemKey: K) => {\n    let moveItem;\n    switch (isReorderable) {\n      case itemKey === tabKeys?.[0]:\n        moveItem = allMenuItems['moveForwardItem'];\n        break;\n      case itemKey === tabKeys?.[tabKeys.length - 1]:\n        moveItem = allMenuItems['moveBackwardItem'];\n        break;\n      default:\n        moveItem = (\n          <>\n            {allMenuItems['moveForwardItem']}\n            {allMenuItems['moveBackwardItem']}\n          </>\n        );\n    }\n    return moveItem;\n  };\n\n  const defaultMenuItems =\n    isRemovable || isReorderable ? (\n      <>\n        {isReorderable && tabKeys ? (\n          <>\n            {createMoveMenuItems(itemKey)}\n            {isRemovable ? <Separator /> : undefined}\n          </>\n        ) : undefined}\n        {isRemovable ? allMenuItems['remove'] : undefined}\n      </>\n    ) : undefined;\n\n  return {\n    itemKey,\n    defaultMenuItems,\n    allMenuItems\n  } as TabBarItemContextMenuContext<K>;\n}\n"],"names":["contextMenuConfig","contextMenuContext","menuProps","accessibleLabel","menuItems","isOpen","itemsRenderer","_jsx","Menu","children","isRemovable","handleReorder","handleRemove","itemKey","tabKeys","direction","itemLabels","handleAccStatus","handleRemoveAction","value","removedKey","isReorderable","isRtl","handleMoveAction","moveDirection","newArray","referenceItemIndex","handleMove","destinationKey","reorderedKeys","itemKeys","referenceKey","position","allMenuItems","moveForwardItem","jsx","MenuItem","label","labelMoveLeft","labelMoveRight","onAction","moveBackwardItem","removeItem","remove","reorder","_jsxs","jsxs","_Fragment","Fragment","defaultMenuItems","moveItem","length","createMoveMenuItems","Separator","undefined"],"mappings":"2xBAuBM,UAAuDA,kBAC3DA,EAAiBC,mBACjBA,KACGC,IAEH,MAAMC,EAAkBH,EAAkBG,gBAGpCC,EAAYF,EAAUG,OAASL,EAAkBM,cAAcL,GAAsB,KAE3F,OAAiB,MAAbG,EAEAG,2BACEA,EAAAA,IAACC,EAAAA,SACKN,KACCC,GAAmB,CACtB,aAAcA,GAEfM,SAAAL,MAKFG,oBACT,oCA4CiEG,YAC/DA,EAAWC,cACXA,EAAaC,aACbA,EAAYC,QACZA,EAAOC,QACPA,EAAOC,UACPA,EAASC,WACTA,EAAUC,gBACVA,IAEA,MAAMC,EAAqB,KACzBN,IAAe,CAAEO,MAAON,IACxBI,IAAkB,CAChBG,WAAYP,GACZ,EAGEQ,EAAiC,MAAjBV,EAEhBW,EAAsB,QAAdP,EACRQ,EAAoBC,IACxB,GAAIH,GAAiBP,EAAS,CAC5B,MAAMW,SAAEA,EAAQC,mBAAEA,GAAuBC,EAAUA,WAACH,EAAeV,EAASD,GACtEe,EAAiBd,EAAQY,GAC/Bf,IAAgB,CACdkB,cAAeJ,EACfK,SAAU,CAACjB,GACXkB,aAAcH,IAEhBX,IAAkB,CAChBe,SAA4B,YAAlBR,EAA8B,QAAU,SAClDI,eAAgBA,GAEnB,GAGGK,EAAeZ,EACjB,CACEa,gBACE3B,EAAC4B,IAAAC,EAAQA,SACP,CAAAC,MAAOf,EAAQN,GAAYsB,cAAiBtB,GAAYuB,eACxDC,SAAU,IAAMjB,EAAiB,aAGrCkB,iBACElC,EAAC4B,IAAAC,EAAQA,SACP,CAAAC,MAAOf,EAAQN,GAAYuB,eAAkBvB,GAAYsB,cACzDE,SAAU,IAAMjB,EAAiB,cAGrCmB,WAAYnC,EAAC4B,IAAAC,WAAS,CAAAC,MAAO,SAAUG,SAAUtB,IACjDyB,OAAQpC,EAAC4B,IAAAC,WAAS,CAAAC,MAAO,SAAUG,SAAUtB,IAC7C0B,QACEC,EACEC,KAAAC,EAAAC,SAAA,CAAAvC,SAAA,CAAAF,EAAA4B,IAACC,WAAQ,CACPC,MAAOf,EAAQN,GAAYsB,cAAiBtB,GAAYuB,eACxDC,SAAU,IAAMjB,EAAiB,aAEnChB,EAAC4B,IAAAC,EAAQA,SACP,CAAAC,MAAOf,EAAQN,GAAYuB,eAAkBvB,GAAYsB,cACzDE,SAAU,IAAMjB,EAAiB,kBAKzC,CACEoB,OAAQpC,EAAC4B,IAAAC,WAAS,CAAAC,MAAO,SAAUG,SAAUtB,IAC7CwB,WAAYnC,EAAC4B,IAAAC,WAAS,CAAAC,MAAO,SAAUG,SAAUtB,KAuBjD+B,EACJvC,GAAeW,EACbwB,EAAAA,KACGE,EAAAA,SAAA,CAAAtC,SAAA,CAAAY,GAAiBP,EAChB+B,EAAAA,KACGE,EAAAA,SAAA,CAAAtC,SAAA,CAzBiB,CAACI,IAC3B,IAAIqC,EACJ,OAAQ7B,GACN,KAAKR,IAAYC,IAAU,GACzBoC,EAAWjB,EAA8B,gBACzC,MACF,KAAKpB,IAAYC,IAAUA,EAAQqC,OAAS,GAC1CD,EAAWjB,EAA+B,iBAC1C,MACF,QACEiB,EACEL,EACGC,KAAAC,WAAA,CAAAtC,SAAA,CAAAwB,EAA8B,gBAC9BA,EAA+B,oBAIxC,OAAOiB,CAAQ,EAQNE,CAAoBvC,GACpBH,EAAcH,EAAC4B,IAAAkB,EAASA,UAAG,CAAA,QAAGC,UAE/BA,EACH5C,EAAcuB,EAAqB,YAAIqB,UAExCA,EAEN,MAAO,CACLzC,UACAoC,mBACAhB,eAEJ"}