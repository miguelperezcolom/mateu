{"version":3,"file":"useSwipe-d22a98f1.js","sources":["../../src/hooks/UNSAFE_useSwipe/useSwipe.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useRef, useCallback } from 'preact/hooks';\n\n/*\n  threshold: Minimal threshold required before recognizing\n  tolerance: A tolerance value which allows the user to move their finger about a length measured in pixels.\n  This allows the swipe gesture to be triggered more easily since a User might not move their finger\n  in a straight line.\n*/\ntype SwipeOptions = {\n  threshold?: number;\n  maximumTime?: number;\n  tolerance?: number;\n  isDisabled?: boolean;\n};\n\ntype SwipeInfo = {\n  direction: 'left' | 'right' | 'up' | 'down';\n};\n\ntype SwipeState = {\n  pointerDownId: number | null;\n  startTime: number | null;\n  prevClientX: number;\n  prevClientY: number;\n};\n\nexport function useSwipe(\n  onSwipe: (e: SwipeInfo) => void,\n  { threshold = 10, maximumTime = 300, tolerance = 50, isDisabled = false }: SwipeOptions = {\n    threshold: 10,\n    maximumTime: 300,\n    tolerance: 50,\n    isDisabled: false\n  }\n): { swipeProps: Record<string, any> } {\n  const ref = useRef<SwipeState>({\n    pointerDownId: 0,\n    startTime: null,\n    prevClientX: 0,\n    prevClientY: 0\n  });\n\n  const clearSwipe = useCallback(() => {\n    ref.current = {\n      pointerDownId: null,\n      startTime: 0,\n      prevClientX: 0,\n      prevClientY: 0\n    };\n  }, []);\n\n  const onPointerDown = useCallback(\n    (e: PointerEvent) => {\n      if (!ref.current.pointerDownId) {\n        ref.current = {\n          pointerDownId: e.pointerId,\n          startTime: e.timeStamp,\n          prevClientX: e.clientX,\n          prevClientY: e.clientY\n        };\n      } else {\n        clearSwipe();\n      }\n    },\n    [clearSwipe]\n  );\n\n  const onPointerUp = useCallback(\n    (ev: PointerEvent) => {\n      if (ev.pointerId === ref.current.pointerDownId) {\n        if (ref.current.startTime && ev.timeStamp - ref.current.startTime < maximumTime) {\n          if (\n            ref.current.prevClientX - ev.clientX > threshold &&\n            Math.abs(ev.clientY - ref.current.prevClientY) <= tolerance\n          ) {\n            onSwipe?.({ direction: 'left' });\n          } else if (\n            ev.clientX - ref.current.prevClientX > threshold &&\n            Math.abs(ev.clientY - ref.current.prevClientY) <= tolerance\n          ) {\n            onSwipe?.({ direction: 'right' });\n          } else if (\n            ref.current.prevClientY - ev.clientY > threshold &&\n            Math.abs(ev.clientX - ref.current.prevClientX) <= tolerance\n          ) {\n            onSwipe?.({ direction: 'up' });\n          } else if (\n            ev.clientY - ref.current.prevClientY > threshold &&\n            Math.abs(ev.clientX - ref.current.prevClientX) <= tolerance\n          ) {\n            onSwipe?.({ direction: 'down' });\n          }\n        }\n      }\n      // state would be reset to its original state whether swipe is completed or cancelled\n      clearSwipe();\n    },\n    [threshold, onSwipe, clearSwipe, maximumTime, tolerance]\n  );\n\n  const swipeProps = isDisabled\n    ? {}\n    : {\n        /** event handlers to spread on the target element. */\n        onPointerDown,\n        onPointerUp,\n        onPointerCancel: clearSwipe\n      };\n\n  return {\n    swipeProps\n  };\n}\n"],"names":["onSwipe","threshold","maximumTime","tolerance","isDisabled","ref","useRef","pointerDownId","startTime","prevClientX","prevClientY","clearSwipe","useCallback","current","onPointerDown","e","pointerId","timeStamp","clientX","clientY","onPointerUp","ev","Math","abs","direction","swipeProps","onPointerCancel"],"mappings":"yEAkCM,SACJA,GACAC,UAAEA,EAAY,GAAEC,YAAEA,EAAc,IAAGC,UAAEA,EAAY,GAAEC,WAAEA,GAAa,GAAwB,CACxFH,UAAW,GACXC,YAAa,IACbC,UAAW,GACXC,YAAY,IAGd,MAAMC,EAAMC,EAAAA,OAAmB,CAC7BC,cAAe,EACfC,UAAW,KACXC,YAAa,EACbC,YAAa,IAGTC,EAAaC,EAAAA,aAAY,KAC7BP,EAAIQ,QAAU,CACZN,cAAe,KACfC,UAAW,EACXC,YAAa,EACbC,YAAa,EACd,GACA,IAEGI,EAAgBF,eACnBG,IACMV,EAAIQ,QAAQN,cAQfI,IAPAN,EAAIQ,QAAU,CACZN,cAAeQ,EAAEC,UACjBR,UAAWO,EAAEE,UACbR,YAAaM,EAAEG,QACfR,YAAaK,EAAEI,QAIlB,GAEH,CAACR,IAGGS,EAAcR,eACjBS,IACKA,EAAGL,YAAcX,EAAIQ,QAAQN,eAC3BF,EAAIQ,QAAQL,WAAaa,EAAGJ,UAAYZ,EAAIQ,QAAQL,UAAYN,IAEhEG,EAAIQ,QAAQJ,YAAcY,EAAGH,QAAUjB,GACvCqB,KAAKC,IAAIF,EAAGF,QAAUd,EAAIQ,QAAQH,cAAgBP,EAElDH,IAAU,CAAEwB,UAAW,SAEvBH,EAAGH,QAAUb,EAAIQ,QAAQJ,YAAcR,GACvCqB,KAAKC,IAAIF,EAAGF,QAAUd,EAAIQ,QAAQH,cAAgBP,EAElDH,IAAU,CAAEwB,UAAW,UAEvBnB,EAAIQ,QAAQH,YAAcW,EAAGF,QAAUlB,GACvCqB,KAAKC,IAAIF,EAAGH,QAAUb,EAAIQ,QAAQJ,cAAgBN,EAElDH,IAAU,CAAEwB,UAAW,OAEvBH,EAAGF,QAAUd,EAAIQ,QAAQH,YAAcT,GACvCqB,KAAKC,IAAIF,EAAGH,QAAUb,EAAIQ,QAAQJ,cAAgBN,GAElDH,IAAU,CAAEwB,UAAW,UAK7Bb,GAAY,GAEd,CAACV,EAAWD,EAASW,EAAYT,EAAaC,IAYhD,MAAO,CACLsB,WAViBrB,EACf,CAAE,EACF,CAEEU,gBACAM,cACAM,gBAAiBf,GAMzB"}