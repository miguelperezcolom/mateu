{"version":3,"file":"DataGrid-299f750b.js","sources":["../../src/PRIVATE_DataGrid/DataGridCell.tsx","../../src/PRIVATE_DataGrid/utils/DataGridRenderUtils.ts","../../src/PRIVATE_DataGrid/DataGrid.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Skeleton } from '#UNSAFE_Skeleton';\nimport { classNames } from '#utils/UNSAFE_classNames/classNames';\nimport { dataGridCellStyles } from './themes/DataGridCell.css';\n\nexport type DataGridCellProps<D> = {\n  cell: {\n    cellType: string;\n    rowStart: number;\n    rowExtent: number;\n    columnStart: number;\n    columnExtent: number;\n    data: D;\n    lastColIndex: boolean;\n    lastRowIndex: boolean;\n    borderLeft: boolean;\n    borderRight: boolean;\n    level?: number;\n  };\n  height: number;\n  width: number;\n};\n\nconst getCellStyle = (cell: any, width: number, height: number) => {\n  let styleString = `\n    grid-row-start: ${cell.rowStart + 1};\n    grid-row-end: ${cell.rowStart + cell.rowExtent + 1};\n    grid-column-start: ${cell.columnStart + 1};\n    grid-column-end: ${cell.columnStart + cell.columnExtent + 1};\n  `;\n\n  switch (cell.cellType) {\n    case 'rowHeader':\n    case 'rowHeaderSkeleton':\n      styleString += `left: ${width * cell.level}px;`;\n      break;\n    case 'rowEndHeader':\n    case 'rowEndHeaderSkeleton':\n      styleString += `right: ${width * cell.level}px;`;\n      break;\n    case 'columnEndHeader':\n    case 'columnEndHeaderSkeleton':\n      styleString += `bottom: ${height * cell.level}px;`;\n      break;\n    case 'columnHeader':\n    case 'columnHeaderSkeleton':\n      styleString += `top: ${height * cell.level}px;`;\n      break;\n    case 'rowHeaderLabel':\n    case 'columnHeaderLabel':\n      styleString += `\n        top: ${height * cell.rowStart}px;\n        left: ${width * cell.columnStart}px;\n      `;\n      break;\n    case 'rowEndHeaderLabel':\n      styleString += `right: ${width * cell.level}px;`;\n      break;\n    case 'columnEndHeaderLabel':\n      styleString += `bottom: ${height * cell.level}px;`;\n      break;\n  }\n\n  return styleString.trim();\n};\n\nconst getCellClasses = (cell: any) => {\n  const baseClass = dataGridCellStyles.base;\n  const headerTypes = [\n    'rowHeader',\n    'rowEndHeader',\n    'columnEndHeader',\n    'columnHeader',\n    'rowHeaderSkeleton',\n    'rowEndHeaderSkeleton',\n    'columnEndHeaderSkeleton',\n    'columnHeaderSkeleton'\n  ];\n  const topLeftTypes = ['rowHeaderLabel', 'columnHeaderLabel', 'topLeftSpacer'];\n  const topRightTypes = ['rowEndHeaderLabel', 'topRightSpacer'];\n  const bottomLeftTypes = ['columnEndHeaderLabel', 'bottomLeftSpacer'];\n  const bottomRightTypes = ['bottomRightSpacer'];\n\n  const classes = [baseClass];\n\n  if (headerTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.header);\n  } else if (topLeftTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.topLeft);\n  } else if (topRightTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.topRight);\n  } else if (bottomLeftTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.bottomLeft);\n  } else if (bottomRightTypes.includes(cell.cellType)) {\n    classes.push(dataGridCellStyles.bottomRight);\n  } else if (cell.cellType === 'rowHeaderSpacer') {\n    classes.push(dataGridCellStyles.rhSpacer);\n  } else if (cell.cellType === 'columnHeaderSpacer') {\n    classes.push(dataGridCellStyles.chSpacer);\n  }\n\n  if (cell.lastRow) {\n    classes.push(dataGridCellStyles.lastRow);\n  }\n  if (cell.lastColumn) {\n    classes.push(dataGridCellStyles.lastColumn);\n  }\n  if (cell.borderLeft) {\n    classes.push(dataGridCellStyles.borderLeft);\n  }\n  if (cell.borderTop) {\n    classes.push(dataGridCellStyles.borderTop);\n  }\n\n  return classNames(classes);\n};\n\nexport function DataGridCell<D>({ cell, height, width }: DataGridCellProps<D>) {\n  if (cell.cellType.includes('Skeleton')) {\n    return (\n      <div style={getCellStyle(cell, width, height)} class={getCellClasses(cell)}>\n        <Skeleton height=\"6x\" width=\"16x\" />\n      </div>\n    );\n  }\n  return (\n    <div style={getCellStyle(cell, width, height)} class={getCellClasses(cell)}>\n      {(cell as any).data}\n    </div>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { DataGridRange, Props } from '../../PRIVATE_GridView';\nimport { dataGridStyles } from '../themes/DataGrid.css';\nimport { classNames } from '../../utils/UNSAFE_classNames';\nimport {\n  DataGridColumnRange,\n  DataGridRowRange,\n  GridProps\n} from '#PRIVATE_GridView/DataGrid.types.js';\n\nconst _CELL_HEIGHT = 50;\nconst _CELL_WIDTH = 85;\n\nconst _ROW_CONST = 'row';\nconst _ROW_END_CONST = 'rowEnd';\nconst _COLUMN_CONST = 'column';\nconst _COLUMN_END_CONST = 'columnEnd';\n\ntype D = any;\ntype _ROW_TYPE = typeof _ROW_CONST;\ntype _ROW_END_TYPE = typeof _ROW_END_CONST;\ntype _COLUMN_TYPE = typeof _COLUMN_CONST;\ntype _COLUMN_END_TYPE = typeof _COLUMN_END_CONST;\ntype _ROW_TYPES = _ROW_TYPE | _ROW_END_TYPE;\ntype _COLUMN_TYPES = _COLUMN_TYPE | _COLUMN_END_TYPE;\ntype _HEADER_TYPES = _ROW_TYPES | _COLUMN_TYPES;\n\nexport const renderGrid = (\n  { ranges, totalColumnCount, totalRowCount, onLoadRange, height, width, cell, header }: Props<D>,\n  skeletonList: (\n    | { type: string; rowIndex: number }\n    | { type: string; columnIndex: number }\n    | { type: string; columnIndex: number; rowIndex: number }\n  )[]\n) => {\n  // TODO: handle custom heights widths\n  const getHeaderLevels = (header: GridProps<D>['header'], type: _HEADER_TYPES) => {\n    const headerLevels = header?.[type]?.levels;\n    let range;\n    if (type === 'row') {\n      range = ranges.rowHeaders;\n    } else if (type === 'rowEnd') {\n      range = ranges.rowEndHeaders;\n    } else if (type === 'column') {\n      range = ranges.columnHeaders;\n    } else if (type === 'columnEnd') {\n      range = ranges.columnEndHeaders;\n    }\n    return range && headerLevels && headerLevels > 0 ? headerLevels : 0;\n  };\n\n  const getHeaderLabels = (header: GridProps<D>['header'], type: _HEADER_TYPES) => {\n    const headerLabels = header?.[type]?.label;\n    return headerLabels && getHeaderLevels(header, type) > 0;\n  };\n\n  // Helper to check if both headers exist for a given pair\n  const getHasBothHeaders = (\n    header: GridProps<D>['header'],\n    _ROW_TYPES: _ROW_TYPES,\n    colType: _COLUMN_TYPES\n  ) => getHeaderLevels(header, _ROW_TYPES) > 0 && getHeaderLevels(header, colType) > 0;\n\n  // Helper to check if both labels exist for a given pair\n  const getHasBothLabels = (\n    header: GridProps<D>['header'],\n    _ROW_TYPES: _ROW_TYPES,\n    colType: _COLUMN_TYPES\n  ) => getHeaderLabels(header, _ROW_TYPES) && getHeaderLabels(header, colType);\n\n  // Determine if a top-left spacer is needed\n  const hasBothHeaders = getHasBothHeaders(header, _ROW_CONST, _COLUMN_CONST);\n  const hasBothLabels = getHasBothLabels(header, _ROW_CONST, _COLUMN_CONST);\n  const isEmptyRowLabels = !getHeaderLabels(header, _ROW_CONST);\n  const isEmptyColumnLabels = !getHeaderLabels(header, _COLUMN_CONST);\n  const rowLevels = getHeaderLevels(header, _ROW_CONST);\n  const columnLevels = getHeaderLevels(header, _COLUMN_CONST);\n\n  const hasTopLeftSpacer =\n    hasBothHeaders &&\n    ((!hasBothLabels && isEmptyRowLabels && isEmptyColumnLabels) ||\n      (hasBothLabels && rowLevels > columnLevels) ||\n      (hasBothLabels && rowLevels > 1 && columnLevels > 1));\n\n  // Determine if spacers are needed for other corners\n  const hasTopRightSpacer =\n    getHasBothHeaders(header, _ROW_END_CONST, _COLUMN_CONST) &&\n    !getHeaderLabels(header, _ROW_END_CONST);\n  const hasBottomLeftSpacer =\n    getHasBothHeaders(header, _ROW_CONST, _COLUMN_END_CONST) &&\n    !getHeaderLabels(header, _COLUMN_END_CONST);\n\n  const hasBottomRightSpacer = getHasBothHeaders(header, _ROW_END_CONST, _COLUMN_END_CONST);\n\n  // Check for header collision in the top-left corner\n  const collision =\n    getHasBothHeaders(header, _ROW_CONST, _COLUMN_CONST) &&\n    getHasBothLabels(header, _ROW_CONST, _COLUMN_CONST) &&\n    Math.min(getHeaderLevels(header, _ROW_CONST), getHeaderLevels(header, _COLUMN_CONST)) >= 1;\n\n  // Check if row or column header spacers are needed\n  const hasRowHeaderSpacer =\n    (getHeaderLabels(header, _COLUMN_CONST) || getHeaderLabels(header, _COLUMN_END_CONST)) &&\n    getHeaderLevels(header, _ROW_CONST) <= 0;\n\n  const hasColumnHeaderSpacer =\n    (getHeaderLabels(header, _ROW_CONST) || getHeaderLabels(header, _ROW_END_CONST)) &&\n    getHeaderLevels(header, _COLUMN_CONST) <= 0;\n\n  // TODO: handle unknown\n  // Helper function to add header levels if they exist\n  const addHeaderLevels = (header: GridProps<D>['header'], type: _HEADER_TYPES) =>\n    getHeaderLevels(header, type) > 0 ? getHeaderLevels(header, type) : 0;\n\n  // Calculate total columns in the grid\n  let gridTotalColumns = totalColumnCount === 'unknown' ? 0 : totalColumnCount;\n  const dataRegionColumnCount = gridTotalColumns;\n\n  // Adjust for row headers and row header spacer\n  gridTotalColumns += addHeaderLevels(header, _ROW_CONST) + addHeaderLevels(header, _ROW_END_CONST);\n  gridTotalColumns += hasRowHeaderSpacer ? 1 : 0;\n\n  // Calculate total rows in the grid\n  let gridTotalRows = totalRowCount === 'unknown' ? 0 : totalRowCount;\n  const dataRegionRowCount = gridTotalRows;\n\n  // Adjust for column headers, collisions, and column header spacer\n  gridTotalRows +=\n    addHeaderLevels(header, _COLUMN_CONST) + addHeaderLevels(header, _COLUMN_END_CONST);\n  gridTotalRows += collision ? 1 : 0;\n  gridTotalRows += hasColumnHeaderSpacer ? 1 : 0;\n\n  // Calculate row starts\n  const rowHeaderRowStart =\n    getHeaderLevels(header, _COLUMN_CONST) + (collision || hasColumnHeaderSpacer ? 1 : 0);\n  const rowEndHeaderRowStart = rowHeaderRowStart;\n\n  const columnHeaderRowStart = 0;\n  const columnEndHeaderRowStart = gridTotalRows - getHeaderLevels(header, _COLUMN_END_CONST);\n\n  // Calculate column starts\n  const columnHeaderColumnStart =\n    getHeaderLevels(header, _ROW_CONST) + (hasRowHeaderSpacer ? 1 : 0);\n  const columnEndHeaderColumnStart = columnHeaderColumnStart;\n\n  const rowHeaderColumnStart = 0;\n  const rowEndHeaderColumnStart = gridTotalColumns - getHeaderLevels(header, _ROW_END_CONST);\n\n  // Merges overlapping or adjacent cell ranges in a grid in 2 dimensions.\n  const mergeCellRanges = (ranges: DataGridRange[] | undefined): DataGridRange[] | false => {\n    if (!ranges || ranges.length === 0) return false;\n\n    const mergedRanges: DataGridRange[] = [];\n\n    // Sort ranges by rowStart and then by columnStart\n    ranges.sort((a, b) =>\n      a.rowStart === b.rowStart ? a.columnStart - b.columnStart : a.rowStart - b.rowStart\n    );\n\n    // Merge ranges\n    for (const range of ranges) {\n      const lastMerged = mergedRanges[mergedRanges.length - 1];\n      if (\n        !lastMerged ||\n        lastMerged.rowStart + lastMerged.rowCount < range.rowStart ||\n        lastMerged.columnStart + lastMerged.columnCount < range.columnStart\n      ) {\n        mergedRanges.push(range);\n      } else {\n        // Extend the current merged range\n        lastMerged.rowCount =\n          Math.max(lastMerged.rowStart + lastMerged.rowCount, range.rowStart + range.rowCount) -\n          lastMerged.rowStart;\n\n        lastMerged.columnCount =\n          Math.max(\n            lastMerged.columnStart + lastMerged.columnCount,\n            range.columnStart + range.columnCount\n          ) - lastMerged.columnStart;\n      }\n    }\n\n    return mergedRanges;\n  };\n\n  const mergedDataBody = mergeCellRanges(ranges.dataBody);\n  let actualDataRows = 0;\n  let actualDataCols = 0;\n  if (mergedDataBody) {\n    mergedDataBody.forEach((range) => {\n      actualDataCols += range.columnCount;\n      actualDataRows += range.rowCount;\n    });\n  }\n\n  // 1D array of actual cells we need to render\n  const grid = [];\n\n  // Map of indices that we getHas seen\n  const seenIndexMap = new Map();\n\n  // Handle skipping cells for row extent\n  const handleRowSkip = (rowIndex: number, columnIndex: number, rowExtent: number) => {\n    for (let r = rowIndex; r < rowIndex + rowExtent; r++) {\n      seenIndexMap.set(`${r},${columnIndex}`, { cellType: 'skip' });\n    }\n  };\n\n  // Handle skipping cells for column extent\n  const handleColumnSkip = (rowIndex: number, columnIndex: number, columnExtent: number) => {\n    for (let c = columnIndex; c < columnIndex + columnExtent; c++) {\n      seenIndexMap.set(`${rowIndex},${c}`, { cellType: 'skip' });\n    }\n  };\n\n  // Calculates label extents and offsets\n  const calculateLabelExtentsAndOffsets = (\n    type: string,\n    itemLevels: number,\n    currentLevel: number\n  ) => {\n    let rowExtent = 1,\n      columnExtent = 1,\n      rowOffset = 0,\n      columnOffset = 0;\n    const columnHeaderLevels = getHeaderLevels(header, _COLUMN_CONST);\n    const rowHeaderLevels = getHeaderLevels(header, _ROW_CONST);\n\n    switch (type) {\n      case 'rowEndHeaderLabel':\n        columnOffset = itemLevels - currentLevel - 1;\n        rowExtent = collision ? columnHeaderLevels + 1 : columnHeaderLevels;\n        break;\n      case 'columnEndHeaderLabel':\n        rowOffset = itemLevels - currentLevel - 1;\n        columnExtent = rowHeaderLevels > 0 ? rowHeaderLevels : 1;\n        break;\n      case 'rowHeaderLabel':\n        columnOffset = currentLevel;\n        rowExtent = collision ? 1 : columnHeaderLevels;\n        break;\n      case 'columnHeaderLabel':\n        rowOffset = currentLevel;\n        columnExtent = collision ? 1 : rowHeaderLevels;\n        break;\n    }\n\n    return { rowExtent, columnExtent, rowOffset, columnOffset };\n  };\n\n  // Walks ranges and adds appropriate cells to grid.\n  const processLabelData = (\n    item: {\n      data: (rowIndex: number, level: number) => { data: D; depth: number; extent: number };\n      levels: number;\n      label?: {\n        data: (level: number) => { data: D };\n      };\n    },\n    rowAxisStart: number,\n    columnAxisStart: number,\n    type: string,\n    isRow: boolean,\n    isEnd: boolean\n  ) => {\n    if (!item.label) {\n      return;\n    }\n    for (let i = 0; i < item.levels; i++) {\n      const labelData = item.label.data(i);\n      const { rowExtent, columnExtent, rowOffset, columnOffset } = calculateLabelExtentsAndOffsets(\n        type,\n        item.levels,\n        i\n      );\n      const rowIndex = rowAxisStart + rowOffset;\n      const columnIndex = columnAxisStart + columnOffset;\n      grid.push({\n        cellType: type,\n        rowStart: rowIndex,\n        rowExtent: rowExtent,\n        columnStart: columnIndex,\n        columnExtent: columnExtent,\n        data: labelData.data,\n        borderTop: !isRow && isEnd ? i === item.levels - 1 : false,\n        borderLeft: isRow && isEnd ? i === item.levels - 1 : false,\n        level: i\n      });\n    }\n  };\n\n  // Renders row header labels\n  if (ranges.rowHeaders && header?.row && header.row.label) {\n    processLabelData(\n      header.row,\n      collision ? rowHeaderRowStart - 1 : columnHeaderRowStart,\n      rowHeaderColumnStart,\n      'rowHeaderLabel',\n      true,\n      false\n    );\n  }\n\n  // Renders column header labels\n  if (ranges.columnHeaders && header?.column && header.column.label) {\n    processLabelData(\n      header.column,\n      columnHeaderRowStart,\n      collision ? columnHeaderColumnStart - 1 : rowHeaderColumnStart,\n      'columnHeaderLabel',\n      false,\n      false\n    );\n  }\n\n  // Renders row end header labels\n  if (ranges.rowEndHeaders && header?.rowEnd && header.rowEnd.label) {\n    processLabelData(\n      header.rowEnd,\n      columnHeaderRowStart,\n      rowEndHeaderColumnStart,\n      'rowEndHeaderLabel',\n      true,\n      true\n    );\n  }\n\n  // Renders column end header labels\n  if (ranges.columnEndHeaders && header?.columnEnd && header.columnEnd.label) {\n    processLabelData(\n      header.columnEnd,\n      columnEndHeaderRowStart,\n      rowHeaderColumnStart,\n      'columnEndHeaderLabel',\n      false,\n      true\n    );\n  }\n\n  // Renders bottom left spacer\n  if (hasBottomLeftSpacer) {\n    const columnExtent =\n      getHeaderLevels(header, _ROW_CONST) > 0 ? getHeaderLevels(header, _ROW_CONST) : 0;\n    const rowExtent = getHeaderLevels(header, _COLUMN_END_CONST);\n    const rowStart = columnEndHeaderRowStart;\n    grid.push({\n      cellType: 'bottomLeftSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: rowHeaderColumnStart,\n      columnExtent: columnExtent,\n      borderRight: true,\n      borderTop: true\n    });\n  }\n\n  // Renders bottom right spacer\n  if (hasBottomRightSpacer) {\n    const columnExtent = getHeaderLevels(header, _ROW_END_CONST);\n    const rowExtent = getHeaderLevels(header, _COLUMN_END_CONST);\n    const rowStart = columnEndHeaderRowStart;\n    const columnStart = gridTotalColumns - getHeaderLevels(header, _ROW_END_CONST);\n    grid.push({\n      cellType: 'bottomRightSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: columnStart,\n      columnExtent: columnExtent,\n      borderTop: true,\n      borderLeft: true\n    });\n  }\n\n  // Renders top right spacer\n  if (hasTopRightSpacer) {\n    const columnExtent = getHeaderLevels(header, _ROW_END_CONST);\n    let rowExtent =\n      getHeaderLevels(header, _COLUMN_CONST) > 0 ? getHeaderLevels(header, _COLUMN_CONST) : 1;\n    if (collision) {\n      rowExtent += 1;\n    }\n    const rowStart = columnHeaderRowStart;\n    const columnStart = rowEndHeaderColumnStart;\n    grid.push({\n      cellType: 'topRightSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: columnStart,\n      columnExtent: columnExtent,\n      borderLeft: true\n    });\n  }\n\n  // Renders top left spacer\n  if (hasTopLeftSpacer) {\n    const columnExtent = collision\n      ? getHeaderLevels(header, _ROW_CONST) - 1\n      : getHeaderLevels(header, _ROW_CONST);\n    const rowExtent = getHeaderLevels(header, _COLUMN_CONST);\n    const rowStart = 0;\n    const columnStart = 0;\n    grid.push({\n      cellType: 'topLeftSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: columnStart,\n      columnExtent: columnExtent\n    });\n  }\n\n  // Renders row heder spacer\n  if (hasRowHeaderSpacer) {\n    let rowStart = getHeaderLabels(header, _COLUMN_CONST)\n      ? getHeaderLevels(header, _COLUMN_CONST)\n      : 0;\n    let rowExtent = gridTotalRows;\n    if (getHeaderLabels(header, _COLUMN_CONST)) {\n      rowExtent -= getHeaderLevels(header, _COLUMN_CONST);\n    }\n    if (getHeaderLabels(header, _COLUMN_END_CONST)) {\n      rowExtent -= getHeaderLevels(header, _COLUMN_END_CONST);\n    }\n    if (hasColumnHeaderSpacer) {\n      rowExtent -= 1;\n      rowStart += 1;\n    }\n    grid.push({\n      cellType: 'rowHeaderSpacer',\n      rowStart: rowStart,\n      rowExtent: rowExtent,\n      columnStart: 0,\n      columnExtent: 1,\n      lastRow: getHeaderLabels(header, _COLUMN_END_CONST) ? true : false\n    });\n  }\n\n  // Renders column heder spacer\n  if (hasColumnHeaderSpacer) {\n    const columnStart = getHeaderLabels(header, _ROW_CONST)\n      ? getHeaderLevels(header, _ROW_CONST)\n      : 0;\n    let columnExtent = gridTotalColumns;\n    if (getHeaderLabels(header, _ROW_CONST)) {\n      columnExtent -= getHeaderLevels(header, _ROW_CONST);\n    }\n    if (getHeaderLabels(header, _ROW_END_CONST)) {\n      columnExtent -= getHeaderLevels(header, _ROW_END_CONST);\n    }\n    grid.push({\n      cellType: 'columnHeaderSpacer',\n      rowStart: 0,\n      rowExtent: 1,\n      columnStart: columnStart,\n      columnExtent: columnExtent,\n      lastColumn: getHeaderLabels(header, _ROW_END_CONST) ? true : false\n    });\n  }\n\n  // Calculates Header range bounds\n  const getHeaderRangeBounds = (\n    range: DataGridRowRange | DataGridColumnRange,\n    isRow: boolean,\n    levels: number\n  ) => {\n    if (isRow) {\n      return {\n        rowStart: (range as DataGridRowRange).rowStart,\n        rowEnd: (range as DataGridRowRange).rowCount + (range as DataGridRowRange).rowStart,\n        columnStart: 0,\n        columnEnd: levels\n      };\n    } else {\n      return {\n        rowStart: 0,\n        rowEnd: levels,\n        columnStart: (range as DataGridColumnRange).columnStart,\n        columnEnd:\n          (range as DataGridColumnRange).columnCount + (range as DataGridColumnRange).columnStart\n      };\n    }\n  };\n\n  // Calculates header offsets\n  const getHeaderOffsets = (i: number, j: number, type: string, levels: number) => {\n    let rowOffset = i;\n    let columnOffset = j;\n    if (type === 'rowEndHeader') {\n      columnOffset = levels - j - 1;\n    } else if (type === 'columnEndHeader') {\n      rowOffset = levels - i - 1;\n    }\n    return { rowOffset, columnOffset };\n  };\n\n  // Walks ranges and adds appropriate header cells to grid\n  const processHeaderData = (\n    item: {\n      data: (rowIndex: number, level: number) => { data: D; depth: number; extent: number };\n      levels: number;\n      label?: {\n        data: (level: number) => { data: D };\n      };\n    },\n    rangeArray: (DataGridRowRange | DataGridColumnRange)[],\n    rowAxisStart: number,\n    columnAxisStart: number,\n    type: string,\n    isRow: boolean,\n    isEnd: boolean\n  ) => {\n    rangeArray.forEach((range: DataGridRowRange | DataGridColumnRange) => {\n      const { rowStart, rowEnd, columnStart, columnEnd } = getHeaderRangeBounds(\n        range,\n        isRow,\n        item.levels\n      );\n      for (let i = rowStart; i < rowEnd; i++) {\n        for (let j = columnStart; j < columnEnd; j++) {\n          const { rowOffset, columnOffset } = getHeaderOffsets(i, j, type, item.levels);\n          const rowIndex = rowAxisStart + rowOffset;\n          const columnIndex = columnAxisStart + columnOffset;\n          const cellObject = seenIndexMap.get(`${rowIndex},${columnIndex}`);\n          if (cellObject?.cellType === 'skip') {\n            continue;\n          }\n          const headerData = item.data(isRow ? i : j, isRow ? j : i);\n          let extent = headerData.extent;\n          let depth = headerData.depth;\n          if (type === 'columnHeader' && i === item.levels - 1 && collision) {\n            depth += 1;\n          }\n          const maxExtent = isRow\n            ? (range as DataGridRowRange).rowStart + (range as DataGridRowRange).rowCount\n            : (range as DataGridColumnRange).columnStart +\n              (range as DataGridColumnRange).columnCount;\n\n          if ((isRow && i + extent > maxExtent) || (!isRow && j + extent > maxExtent)) {\n            extent = isRow ? maxExtent - i : maxExtent - j;\n          }\n\n          grid.push({\n            cellType: type,\n            rowStart: rowIndex,\n            rowExtent: isRow ? extent : depth,\n            columnStart: columnIndex,\n            columnExtent: isRow ? depth : extent,\n            data: headerData.data,\n            level: isRow ? j : i,\n            borderTop: !isRow && isEnd ? i === item.levels - 1 : false,\n            borderLeft: isRow && isEnd ? j === item.levels - 1 : false,\n            lastColumn: !isRow && j + extent === dataRegionColumnCount,\n            lastRow: isRow && i + extent === dataRegionRowCount\n          });\n          if (extent > 1) {\n            if (isRow) {\n              handleRowSkip(rowIndex, columnIndex, extent);\n            } else {\n              handleColumnSkip(rowIndex, columnIndex, extent);\n            }\n          }\n          if (depth > 1) {\n            if (isRow) {\n              handleColumnSkip(rowIndex, columnIndex, depth);\n            } else {\n              handleRowSkip(rowIndex, columnIndex, depth);\n            }\n          }\n        }\n      }\n    });\n  };\n\n  // Merges overlapping ranges if it exists\n  const mergeHeaderRanges = <T extends DataGridColumnRange | DataGridRowRange>(\n    ranges: T[],\n    getStart: (range: T) => number,\n    getEnd: (range: T) => number\n  ): T[] => {\n    const mergedRanges: T[] = [];\n\n    ranges.sort((a, b) => getStart(a) - getStart(b));\n\n    for (let i = 0; i < ranges.length; i++) {\n      if (\n        !mergedRanges.length ||\n        getEnd(mergedRanges[mergedRanges.length - 1]) < getStart(ranges[i])\n      ) {\n        mergedRanges.push(ranges[i]);\n      } else {\n        // Merge ranges by extending the last range in mergedRanges\n        const lastRange = mergedRanges[mergedRanges.length - 1];\n        mergedRanges[mergedRanges.length - 1] = {\n          ...lastRange,\n          // Update the end of the merged range with the maximum value of the end\n          end: Math.max(getEnd(lastRange), getEnd(ranges[i]))\n        };\n      }\n    }\n\n    return mergedRanges;\n  };\n\n  // Renders row headers\n  if (ranges.rowHeaders && header?.row) {\n    const mergedRowRanges = mergeHeaderRanges(\n      ranges.rowHeaders,\n      (range) => range.rowStart,\n      (range) => range.rowCount\n    );\n    processHeaderData(\n      header.row,\n      mergedRowRanges,\n      rowHeaderRowStart,\n      rowHeaderColumnStart,\n      'rowHeader',\n      true,\n      false\n    );\n  }\n\n  // Renders rowEnd headers\n  if (ranges.rowEndHeaders && header?.rowEnd) {\n    const mergedRowEndRanges = mergeHeaderRanges(\n      ranges.rowEndHeaders,\n      (range) => range.rowStart,\n      (range) => range.rowCount\n    );\n    processHeaderData(\n      header.rowEnd,\n      mergedRowEndRanges,\n      rowEndHeaderRowStart,\n      rowEndHeaderColumnStart,\n      'rowEndHeader',\n      true,\n      true\n    );\n  }\n\n  // Renders column headers\n  if (ranges.columnHeaders && header?.column) {\n    const mergedColumnRanges = mergeHeaderRanges(\n      ranges.columnHeaders,\n      (range) => range.columnStart,\n      (range) => range.columnCount\n    );\n    processHeaderData(\n      header.column,\n      mergedColumnRanges,\n      columnHeaderRowStart,\n      columnHeaderColumnStart,\n      'columnHeader',\n      false,\n      false\n    );\n  }\n\n  // Renders column end headers\n  if (ranges.columnEndHeaders && header?.columnEnd) {\n    const mergedColumnEndRanges = mergeHeaderRanges(\n      ranges.columnEndHeaders,\n      (range) => range.columnStart,\n      (range) => range.columnCount\n    );\n    processHeaderData(\n      header.columnEnd,\n      mergedColumnEndRanges,\n      columnEndHeaderRowStart,\n      columnEndHeaderColumnStart,\n      'columnEndHeader',\n      false,\n      true\n    );\n  }\n\n  // makes sure we are in bounds of given range\n  const getCellRangeBounds = (range: DataGridRange) => ({\n    rowStart: range.rowStart,\n    rowEnd: range.rowCount + range.rowStart,\n    columnStart: range.columnStart,\n    columnEnd: range.columnCount + range.columnStart\n  });\n\n  // Makes sure cell range is valid\n  const isValidCellRange = (range: DataGridRange): boolean =>\n    range?.rowCount != null &&\n    range?.rowStart != null &&\n    range?.columnCount != null &&\n    range?.columnStart != null;\n\n  // Makes sure we account for merged cells by adding to seenIndex\n  const handleCellSkips = (\n    rowStart: number,\n    rowExtent: number,\n    columnStart: number,\n    columnExtent: number\n  ) => {\n    for (let i = rowStart; i < rowStart + rowExtent; i++) {\n      for (let j = columnStart; j < columnStart + columnExtent; j++) {\n        seenIndexMap.set(`${i},${j}`, { cellType: 'skip' });\n      }\n    }\n  };\n\n  // Walks ranges and adds appropriate cells to grid\n  const processCellData = (\n    item: {\n      data: (\n        rowIndex: number,\n        columnIndex: number\n      ) => { data: D; rowExtent: number; columnExtent: number };\n    },\n    rangeArray: DataGridRange[]\n  ) => {\n    rangeArray.forEach((range: DataGridRange) => {\n      if (isValidCellRange(range)) {\n        const { rowStart, rowEnd, columnStart, columnEnd } = getCellRangeBounds(range);\n        for (let i = rowStart; i < rowEnd; i++) {\n          for (let j = columnStart; j < columnEnd; j++) {\n            const rowIndex = rowHeaderRowStart + i;\n            const columnIndex = columnHeaderColumnStart + j;\n            const cellObject = seenIndexMap.get(`${rowIndex},${columnIndex}`);\n            if (cellObject?.cellType === 'skip') {\n              continue;\n            }\n            const cellData = item.data(i, j);\n            const rowExtent = cellData.rowExtent;\n            const columnExtent = cellData.columnExtent;\n            grid.push({\n              cellType: 'cell',\n              rowStart: rowIndex,\n              rowExtent: rowExtent,\n              columnStart: columnIndex,\n              columnExtent: columnExtent,\n              data: cellData.data,\n              lastColumn: j + columnExtent === dataRegionColumnCount,\n              lastRow: i + rowExtent === dataRegionRowCount\n            });\n            if (rowExtent > 1 || columnExtent > 1) {\n              handleCellSkips(rowIndex, rowExtent, columnIndex, columnExtent);\n            }\n          }\n        }\n      }\n    });\n  };\n\n  // Renders cells\n  if (cell && mergedDataBody) {\n    processCellData(cell, mergedDataBody);\n  }\n\n  skeletonList.forEach((skeletonCell: any) => {\n    let rowIndex = skeletonCell.rowIndex ? skeletonCell.rowIndex : 0;\n    let rowExtent = 1;\n    const columnExtent = 1;\n    let columnIndex = skeletonCell.columnIndex ? skeletonCell.columnIndex : 0;\n    if (skeletonCell.type === 'columnHeaderSkeleton') {\n      rowIndex = columnHeaderRowStart + skeletonCell.level;\n      if (collision && skeletonCell.level + 1 === header?.column?.levels) {\n        rowExtent = 2;\n      }\n      columnIndex = columnHeaderColumnStart + columnIndex;\n    } else if (skeletonCell.type === 'columnEndHeaderSkeleton') {\n      rowIndex =\n        columnEndHeaderRowStart + getHeaderLevels(header, _COLUMN_END_CONST) - rowIndex - 1;\n      columnIndex = columnEndHeaderColumnStart + columnIndex;\n    } else if (skeletonCell.type === 'rowHeaderSkeleton') {\n      columnIndex = rowHeaderColumnStart + skeletonCell.level;\n      rowIndex = rowHeaderRowStart + rowIndex;\n    } else if (skeletonCell.type === 'rowEndHeaderSkeleton') {\n      columnIndex =\n        rowEndHeaderColumnStart + getHeaderLevels(header, _ROW_END_CONST) - columnIndex - 1;\n      rowIndex = rowEndHeaderRowStart + rowIndex;\n    } else {\n      rowIndex = rowHeaderRowStart + rowIndex;\n      columnIndex = columnHeaderColumnStart + columnIndex;\n    }\n\n    grid.push({\n      cellType: skeletonCell.type,\n      rowStart: rowIndex,\n      rowExtent: rowExtent,\n      columnStart: columnIndex,\n      columnExtent: columnExtent,\n      level: skeletonCell.level,\n      borderTop:\n        skeletonCell.type === 'columnEndHeaderSkeleton' &&\n        skeletonCell.level + 1 === header?.columnEnd?.levels\n          ? true\n          : false,\n      borderLeft:\n        skeletonCell.type === 'rowEndHeaderSkeleton' &&\n        skeletonCell.level + 1 === header?.rowEnd?.levels\n          ? true\n          : false\n    });\n  });\n\n  // need this in order to build\n  onLoadRange({} as any);\n\n  // renders the style template strings for grid.\n  const getGridStyle = () => {\n    const rows = `grid-template-rows: ${Array(gridTotalRows).fill(`${_CELL_HEIGHT}px`).join(' ')};`;\n    const columns = `grid-template-columns: ${Array(gridTotalColumns)\n      .fill(`${_CELL_WIDTH}px`)\n      .join(' ')};`;\n    const dimensions = `width: ${width}px; height: ${height}px;`;\n\n    return `${rows} ${columns} ${dimensions}`;\n  };\n\n  const classes = classNames([dataGridStyles.base]);\n  return { grid, classes, style: getGridStyle(), cellHeight: _CELL_HEIGHT, cellWidth: _CELL_WIDTH };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { StateUpdater, useEffect, useState } from 'preact/hooks';\nimport { Props } from '../PRIVATE_GridView';\nimport { DataGridCell } from './DataGridCell';\nimport { renderGrid } from './utils/DataGridRenderUtils';\n/**\n * Component that renders a basic grid.\n */\nexport const DataGrid = function DataGrid<D>(props: Props<D>) {\n  const [skeletonList, setSkeletonList] = useState<\n    (\n      | {\n          type: string;\n          rowIndex: number;\n        }\n      | {\n          type: string;\n          columnIndex: number;\n        }\n      | {\n          type: string;\n          columnIndex: number;\n          rowIndex: number;\n        }\n    )[]\n  >([]);\n  const { grid, classes, style, cellHeight, cellWidth } = renderGrid(props, skeletonList);\n\n  const calculateViewportRange = (\n    element: HTMLElement,\n    cellSize: number,\n    totalCount: number,\n    isVertical: boolean\n  ) => {\n    const totalInViewPort = Math.round(\n      (isVertical ? element.offsetHeight : element.offsetWidth) / cellSize\n    );\n    const firstPosition = Math.round(\n      (isVertical ? element.scrollTop : element.scrollLeft) / cellSize\n    );\n    const buffer = Math.round(totalInViewPort / 2);\n\n    const tempTopPosition = firstPosition - buffer;\n    const topPosition = tempTopPosition > 0 ? tempTopPosition : 0;\n\n    const tempBottomPosition = topPosition + totalInViewPort + buffer * 2;\n    const bottomPosition = tempBottomPosition < totalCount ? tempBottomPosition : totalCount;\n\n    return { topPosition, bottomPosition };\n  };\n\n  const generateSkeletonsForHeaders = (\n    levels: number | undefined,\n    ranges: any[] | undefined,\n    topViewport: number,\n    bottomViewport: number,\n    type: string,\n    tempSkeletonList: any[],\n    isRow = true\n  ) => {\n    if (ranges && levels) {\n      for (let level = 0; level < levels; level++) {\n        const skeletonArray = new Array(bottomViewport).fill(null);\n        ranges.forEach((range) => {\n          const start = isRow ? range.rowStart : range.columnStart;\n          const count = isRow ? range.rowCount : range.columnCount;\n\n          for (let i = start; i < start + count; i++) {\n            if (i < skeletonArray.length) {\n              skeletonArray[i] = true;\n            }\n          }\n        });\n\n        for (let i = topViewport; i < skeletonArray.length; i++) {\n          if (!skeletonArray[i]) {\n            tempSkeletonList.push({\n              type: `${type}Skeleton`,\n              [isRow ? 'rowIndex' : 'columnIndex']: i,\n              level: level\n            });\n          }\n        }\n      }\n    }\n  };\n\n  useEffect(() => {\n    const element = document.getElementById('dataGrid') as HTMLDivElement;\n\n    const { topPosition: topRowOfViewPort, bottomPosition: bottomRowOfViewPort } =\n      calculateViewportRange(element, cellHeight, props.totalRowCount as number, true);\n\n    const { topPosition: topColumnOfViewPort, bottomPosition: bottomColumnOfViewPort } =\n      calculateViewportRange(element, cellWidth, props.totalColumnCount as number, false);\n    const tempSkeletonList: StateUpdater<\n      (\n        | { type: string; rowIndex: number; level: number }\n        | { type: string; columnIndex: number; level: number }\n        | { type: string; columnIndex: number; rowIndex: number }\n      )[]\n    > = [];\n\n    generateSkeletonsForHeaders(\n      props.header?.row?.levels,\n      props.ranges.rowHeaders,\n      topRowOfViewPort,\n      bottomRowOfViewPort,\n      'rowHeader',\n      tempSkeletonList,\n      true\n    );\n\n    generateSkeletonsForHeaders(\n      props.header?.rowEnd?.levels,\n      props.ranges.rowEndHeaders,\n      topRowOfViewPort,\n      bottomRowOfViewPort,\n      'rowEndHeader',\n      tempSkeletonList,\n      true\n    );\n\n    generateSkeletonsForHeaders(\n      props.header?.column?.levels,\n      props.ranges.columnHeaders,\n      topColumnOfViewPort,\n      bottomColumnOfViewPort,\n      'columnHeader',\n      tempSkeletonList,\n      false\n    );\n\n    generateSkeletonsForHeaders(\n      props.header?.columnEnd?.levels,\n      props.ranges.columnEndHeaders,\n      topColumnOfViewPort,\n      bottomColumnOfViewPort,\n      'columnEndHeader',\n      tempSkeletonList,\n      false\n    );\n\n    if (props.ranges.dataBody) {\n      const skeletonArray = new Array(bottomColumnOfViewPort)\n        .fill(null)\n        .map(() => new Array(bottomRowOfViewPort).fill(null));\n\n      props.ranges.dataBody.forEach((range) => {\n        for (let i = range.columnStart; i < range.columnStart + range.columnCount; i++) {\n          if (i < skeletonArray.length) {\n            for (let j = range.rowStart; j < range.rowStart + range.rowCount; j++) {\n              if (j < skeletonArray[i].length) {\n                skeletonArray[i][j] = true;\n              }\n            }\n          }\n        }\n      });\n\n      for (let i = topColumnOfViewPort; i < skeletonArray.length; i++) {\n        for (let j = topRowOfViewPort; j < skeletonArray[i].length; j++) {\n          if (!skeletonArray[i][j]) {\n            tempSkeletonList.push({ type: 'cellSkeleton', columnIndex: i, rowIndex: j });\n          }\n        }\n      }\n    }\n    setSkeletonList(tempSkeletonList);\n  }, [cellHeight, cellWidth, props]);\n\n  return (\n    <div id=\"dataGrid\" role={'application'} class={classes} style={style}>\n      {grid.map((gridCell: any) => (\n        <DataGridCell<D> cell={gridCell} height={cellHeight} width={cellWidth} />\n      ))}\n    </div>\n  );\n};\n"],"names":["getCellStyle","cell","width","height","styleString","rowStart","rowExtent","columnStart","columnExtent","cellType","level","trim","getCellClasses","classes","dataGridCellStyles","base","includes","push","header","topLeft","topRight","bottomLeft","bottomRight","rhSpacer","chSpacer","lastRow","lastColumn","borderLeft","borderTop","classNames","DataGridCell","_jsx","jsx","style","class","children","Skeleton","data","_ROW_CONST","_ROW_END_CONST","_COLUMN_CONST","_COLUMN_END_CONST","renderGrid","ranges","totalColumnCount","totalRowCount","onLoadRange","skeletonList","getHeaderLevels","type","headerLevels","levels","range","rowHeaders","rowEndHeaders","columnHeaders","columnEndHeaders","getHeaderLabels","headerLabels","label","getHasBothHeaders","_ROW_TYPES","colType","getHasBothLabels","hasBothHeaders","hasBothLabels","isEmptyRowLabels","isEmptyColumnLabels","rowLevels","columnLevels","hasTopLeftSpacer","hasTopRightSpacer","hasBottomLeftSpacer","hasBottomRightSpacer","collision","Math","min","hasRowHeaderSpacer","hasColumnHeaderSpacer","addHeaderLevels","gridTotalColumns","dataRegionColumnCount","gridTotalRows","dataRegionRowCount","rowHeaderRowStart","rowEndHeaderRowStart","columnEndHeaderRowStart","columnHeaderColumnStart","columnEndHeaderColumnStart","rowEndHeaderColumnStart","mergedDataBody","length","mergedRanges","sort","a","b","lastMerged","rowCount","columnCount","max","mergeCellRanges","dataBody","actualDataRows","actualDataCols","forEach","grid","seenIndexMap","Map","handleRowSkip","rowIndex","columnIndex","r","set","handleColumnSkip","c","calculateLabelExtentsAndOffsets","itemLevels","currentLevel","rowOffset","columnOffset","columnHeaderLevels","rowHeaderLevels","processLabelData","item","rowAxisStart","columnAxisStart","isRow","isEnd","i","labelData","row","column","rowEnd","columnEnd","borderRight","getHeaderOffsets","j","processHeaderData","rangeArray","getHeaderRangeBounds","cellObject","get","headerData","extent","depth","maxExtent","mergeHeaderRanges","getStart","getEnd","lastRange","end","mergedRowRanges","mergedRowEndRanges","mergedColumnRanges","mergedColumnEndRanges","handleCellSkips","isValidCellRange","getCellRangeBounds","cellData","skeletonCell","dataGridStyles","Array","fill","join","cellHeight","cellWidth","props","setSkeletonList","useState","calculateViewportRange","element","cellSize","totalCount","isVertical","totalInViewPort","round","offsetHeight","offsetWidth","firstPosition","scrollTop","scrollLeft","buffer","tempTopPosition","topPosition","tempBottomPosition","bottomPosition","generateSkeletonsForHeaders","topViewport","bottomViewport","tempSkeletonList","skeletonArray","start","count","useEffect","document","getElementById","topRowOfViewPort","bottomRowOfViewPort","topColumnOfViewPort","bottomColumnOfViewPort","map","id","role","gridCell"],"mappings":"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"}