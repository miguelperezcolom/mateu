{"version":3,"file":"useResizeObserver-25032462.js","sources":["../../src/hooks/UNSAFE_useResizeObserver/useResizeObserver.tsx"],"sourcesContent":["import { useAddBusyState } from '#hooks/PRIVATE_useAddBusyState';\nimport { UnsafeDomHandle, UNSAFE_DOM_ACCESS } from '#utils/UNSAFE_unsafeDomAccess';\nimport type { RefObject } from 'preact';\nimport { useLayoutEffect } from 'preact/hooks';\n\ntype Options = {\n  /**\n   * When set to true, the callback will not be invoked even if the target element's size changes.\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Sets which box model the observer will observe changes to.\n   */\n  box?: ResizeObserverBoxOptions;\n};\n\n/**\n * A hook for observing and responding to changes to the size of a DOM element.\n * It utilizes a ResizeObserver to observe changes to the size of the specified element\n * and accepts a callback function to respond to these changes.\n *\n * @param ref The ref to the target DOM element to observe.\n *     Note that if the element is dynamically added or remounted (e.g., due to conditional rendering or changes in dynamic lists),\n *     a simple useRef object will not automatically trigger the hook to re-observe the new element.\n *     To handle such cases, ensure that the hook receives a new ref whenever the DOM element changes.\n *     One way to achieve this is by storing the ref in state and updating it using a callback ref.\n * @param callback A callback function to be called when the size of the observed element changes.\n *     If the provided callback triggers the consuming component to re-render, then\n *     it's important to pass the same instance of the callback function during each render\n *     to prevent infinite re-render loops. One way to achieve this is by using useCallback.\n * @param options Configuration options.\n */\nconst useResizeObserver = (\n  ref: RefObject<Element> | RefObject<UnsafeDomHandle<Element>>,\n  callback: (entry: ResizeObserverEntry) => void,\n  options?: Options\n) => {\n  const { box, isDisabled = false } = options || {};\n  const { onBusyStart, onBusyEnd } = useAddBusyState('useResizeObserver: resizing');\n\n  useLayoutEffect(() => {\n    // Note ref may be undefined in the hooks storybook demo\n    if (!ref?.current || isDisabled) return;\n\n    const target = ref.current instanceof Element ? ref.current : ref.current[UNSAFE_DOM_ACCESS];\n    if (!target) return;\n\n    onBusyStart();\n    const resizeObserver = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        callback(entry);\n      }\n      onBusyEnd();\n    });\n    resizeObserver.observe(target, { box });\n\n    return () => {\n      resizeObserver.disconnect();\n      onBusyEnd();\n    };\n  }, [ref, callback, box, isDisabled, onBusyStart, onBusyEnd]);\n};\n\nexport { useResizeObserver };\n"],"names":["ref","callback","options","box","isDisabled","onBusyStart","onBusyEnd","useAddBusyState","useLayoutEffect","current","target","Element","UNSAFE_DOM_ACCESS","resizeObserver","ResizeObserver","entries","entry","observe","disconnect"],"mappings":"gJAiC0B,CACxBA,EACAC,EACAC,KAEA,MAAMC,IAAEA,EAAGC,WAAEA,GAAa,GAAUF,GAAW,CAAA,GACzCG,YAAEA,EAAWC,UAAEA,GAAcC,EAAeA,gBAAC,+BAEnDC,EAAAA,iBAAgB,KAEd,IAAKR,GAAKS,SAAWL,EAAY,OAEjC,MAAMM,EAASV,EAAIS,mBAAmBE,QAAUX,EAAIS,QAAUT,EAAIS,QAAQG,EAAAA,mBAC1E,IAAKF,EAAQ,OAEbL,IACA,MAAMQ,EAAiB,IAAIC,gBAAgBC,IACzC,IAAK,MAAMC,KAASD,EAClBd,EAASe,GAEXV,GAAW,IAIb,OAFAO,EAAeI,QAAQP,EAAQ,CAAEP,QAE1B,KACLU,EAAeK,aACfZ,GAAW,CACZ,GACA,CAACN,EAAKC,EAAUE,EAAKC,EAAYC,EAAaC,GAAW"}