{"version":3,"file":"ObfuscatedTextFieldInput-c0e463cf.js","sources":["../../src/UNSAFE_TextField/HistoryManager.ts","../../src/UNSAFE_TextField/ObfuscatedTextFieldInput.tsx","../../src/UNSAFE_TextField/useHistoryManager.ts"],"sourcesContent":["const DEFAULT_MAX_HISTORY = 100;\n\n/**\n * Options for instantiating the HistoryManager class\n */\ntype HistoryManagerOptions = {\n  /**\n   * Maximum allowed states in the history. If a new state is pushed\n   * when the manager is at the limit, the oldest state is removed from\n   * the history.\n   */\n  maxHistory?: number;\n};\n\n/**\n * This class creates an instance that can be used to manage history.\n * One can use the push method to store any history state and can call\n * undo/redo method to get a previous/next state in the history.\n * @template State The type of the state stored in the history\n */\nexport class HistoryManager<State = any> {\n  private currentIndex: number;\n  private maxHistory: number;\n  private states: State[];\n\n  constructor({ maxHistory = DEFAULT_MAX_HISTORY }: HistoryManagerOptions) {\n    this.currentIndex = 0;\n    this.maxHistory = maxHistory;\n    this.states = [];\n  }\n\n  get currentState() {\n    return this.states[this.currentIndex];\n  }\n\n  get isEmpty() {\n    return this.states.length === 0;\n  }\n\n  get hasUndo() {\n    return !this.isEmpty && this.currentIndex > 0;\n  }\n\n  get hasRedo() {\n    return !this.isEmpty && this.currentIndex < this.states.length - 1;\n  }\n\n  /**\n   * Pushes a state to the history\n   * @param state the state to be pushed into the history\n   */\n  push(state: State) {\n    // if the current position is not the end of the array, clear all the\n    // items after the current position\n    if (this.currentIndex < this.states.length - 1) this.states.length = this.currentIndex + 1;\n    // add the new state\n    this.states.push(state);\n    // if the states' size exceeded the allowed limit, remove the oldest state\n    if (this.states.length > this.maxHistory) this.states.shift();\n    this.currentIndex = this.states.length - 1;\n  }\n\n  /**\n   * Retrieves the state from the history after walking the provided steps.\n   * @param steps number of steps to travel in the history\n   * @returns the state after walking the steps in the history\n   */\n  go(steps: number) {\n    this.currentIndex = Math.min(Math.max(this.currentIndex + steps, 0), this.states.length - 1);\n    return this.currentState;\n  }\n\n  /**\n   * Go back in history by 1 step\n   * @returns The previous state\n   */\n  undo() {\n    return this.go(-1);\n  }\n\n  /**\n   * Go forward in history by 1 step\n   * @returns The previous state\n   */\n  redo() {\n    return this.go(1);\n  }\n\n  /**\n   * Clears the history\n   */\n  clear() {\n    this.states.length = 0;\n    this.currentIndex = 0;\n  }\n}\n","import { useEffectEvent } from '#hooks/PRIVATE_useEffectEvent';\nimport { isUndoEvent, isRedoEvent } from '#utils/PRIVATE_keyboardUtils';\nimport { mergeRefs } from '#utils/PRIVATE_refUtils';\nimport { ComponentProps, Ref, useCallback, useLayoutEffect, useMemo, useRef } from 'preact/compat';\nimport { TextFieldInput } from './TextFieldInput';\nimport { containerStyles } from './themes/ObfuscatedTextFieldInputStyles.css';\nimport { useHistoryManager } from './useHistoryManager';\n\ntype TextFieldInputProps = ComponentProps<typeof TextFieldInput>;\ntype PickedPropsFromTextFieldInput = Pick<\n  TextFieldInputProps,\n  | 'aria-describedby'\n  | 'aria-invalid'\n  | 'aria-label'\n  | 'aria-labelledby'\n  | 'autoFocus'\n  | 'currentCommitValue'\n  | 'hasEmptyLabel'\n  | 'hasEndContent'\n  | 'hasInsideLabel'\n  | 'hasStartContent'\n  | 'id'\n  | 'isRequired'\n  | 'onBlur'\n  | 'onCommit'\n  | 'onFocus'\n  | 'onInput'\n  | 'placeholder'\n  | 'textAlign'\n  | 'type'\n  | 'value'\n  | 'variant'\n>;\ntype Props = PickedPropsFromTextFieldInput & {\n  /**\n   * The character used for obfuscation\n   */\n  character?: string;\n  /**\n   * The ref for the input element\n   */\n  inputRef?: Ref<HTMLInputElement>;\n  /**\n   * Flag to indicate if the text is to be revealed\n   */\n  isRevealed?: boolean;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n// Various delete interactions. While this covers all platforms, the examples //\n// are only provided for MacOS. This will work the same for similar behavior  //\n// from other platforms achieved from platform specific keystrokes.           //\n////////////////////////////////////////////////////////////////////////////////\n\n// Some of the deletion types exist in the spec, but unable to trigger for input:\n// 1. deleteSoftLineForward\n// 2. deleteEntireSoftLine\n// 3. deleteHardLineBackward (triggered only in Safari instead of deleteSoftLineBackward)\n// 4. deleteHardLineForward\n// 5. deleteByDrag\n// 6. deleteContent\n//\n// Some we do not want to support:\n// 1. deleteByCut - we want to disable cutting/copying value when obfuscated\n\n/**\n * Deletes the whole selection.\n * @param content the current content\n * @param selectionStart the selection start index\n * @param selectionEnd the selection end index\n * @returns the content with deletion performed and the new cursor position\n */\nconst deleteSelection = (content: string, selectionStart: number, selectionEnd: number) => ({\n  content: content.slice(0, selectionStart) + content.slice(selectionEnd),\n  // when a selection is deleted, the new cursor position will always be the\n  //  selectionStart\n  selectionStart,\n  selectionEnd: selectionStart\n});\n\n/**\n * Deletes the whole content before the cursor.\n * @param content the current content\n * @param selectionStart the selection start index\n * @param selectionEnd the selection end index\n * @returns the content with deletion performed and the new cursor position\n */\nconst deleteEverythingBackward = (content: string, selectionStart: number, selectionEnd: number) =>\n  // if there is a selection, remove the selection to form the new word\n  selectionEnd > selectionStart\n    ? deleteSelection(content, selectionStart, selectionEnd)\n    : // if the cursor is at the start, then noop\n    selectionStart === 0\n    ? { content, selectionStart, selectionEnd }\n    : // if there is no selection, then delete everything before the cursor\n      // we don't delete word by word when we are showing obfuscated text\n      {\n        content: content.slice(selectionEnd),\n        // the new selection range will be at the beginning of the text\n        selectionStart: 0,\n        selectionEnd: 0\n      };\n\n/**\n * Deletes the whole content after the cursor.\n * @param content the current content\n * @param selectionStart the selection start index\n * @param selectionEnd the selection end index\n * @returns the content with deletion performed and the new cursor position\n */\nconst deleteEverythingForward = (content: string, selectionStart: number, selectionEnd: number) =>\n  // if there is a selection, remove the selection to form the new word\n  selectionEnd > selectionStart\n    ? deleteSelection(content, selectionStart, selectionEnd)\n    : // if the cursor is at the end, then noop\n    selectionStart === content.length\n    ? { content, selectionStart, selectionEnd }\n    : // if there is no selection, then delete everything after the cursor and the selection range\n      // stays the same\n      // we don't delete word by word when we are showing obfuscated text\n      { content: content.slice(0, selectionStart), selectionStart, selectionEnd };\n\nconst deletionOperations = {\n  /**\n   * Deletes the current selection or a character before the cursor if there is no selection.\n   * Key Combinations (MacOS) - delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed and the new cursor position\n   */\n  deleteContentBackward(content: string, selectionStart: number, selectionEnd: number) {\n    // if there is a selection, remove the selection to form the new word\n    if (selectionEnd > selectionStart) {\n      return deleteSelection(content, selectionStart, selectionEnd);\n    }\n    // if the cursor is at the start, then noop\n    if (selectionStart === 0) {\n      return { content, selectionStart, selectionEnd };\n    }\n    // if no selection, then remove one char before the cursor\n    return {\n      content: content.slice(0, selectionStart - 1) + content.slice(selectionEnd),\n      // new selectionStart & selectionEnd will be one position before\n      selectionStart: selectionStart - 1,\n      selectionEnd: selectionStart - 1\n    };\n  },\n\n  /**\n   * Deletes the current selection or a character after the cursor if there is no selection.\n   * Key Combinations (MacOS) - fn + delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteContentForward(content: string, selectionStart: number, selectionEnd: number) {\n    // if there is a selection, remove the selection to form the new word\n    if (selectionEnd > selectionStart) {\n      return deleteSelection(content, selectionStart, selectionEnd);\n    }\n    // if the cursor is at the end, then noop\n    if (selectionStart === content.length) {\n      return { content, selectionStart, selectionEnd };\n    }\n    // if no selection, then remove one char after the cursor\n    return {\n      content: content.slice(0, selectionStart) + content.slice(selectionEnd + 1),\n      // the new selection range will stay the same\n      selectionStart,\n      selectionEnd\n    };\n  },\n\n  /**\n   * Deletes the current selection or a word before the cursor if there is no selection.\n   * Key Combinations (MacOS) - option + delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteWordBackward(content: string, selectionStart: number, selectionEnd: number) {\n    // In input's case, when obfuscated there will not be any spaces\n    // So, we delete everything before the cursor\n    return deleteEverythingBackward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or a word after the cursor if there is no selection.\n   * Key Combinations (MacOS) - option + fn + delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteWordForward(content: string, selectionStart: number, selectionEnd: number) {\n    // In input's case, when obfuscated there will not be any spaces\n    // So, we delete everything after the cursor\n    return deleteEverythingForward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or everything before the cursor if there is no selection.\n   * Key Combinations (MacOS) - command + delete\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteSoftLineBackward(content: string, selectionStart: number, selectionEnd: number) {\n    // delete everything before the cursor\n    return deleteEverythingBackward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or everything after the cursor if there is no selection.\n   * Key Combinations (MacOS) - unable to trigger\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteSoftLineForward(content: string, selectionStart: number, selectionEnd: number) {\n    // delete everything after the cursor\n    return deleteEverythingForward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or everything before the cursor if there is no selection.\n   * Key Combinations (MacOS) - command + delete in Safari only\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteHardLineBackward(content: string, selectionStart: number, selectionEnd: number) {\n    // in input, everything is single line. So, this is similar to soft line\n    // delete everything before the cursor\n    return deleteEverythingBackward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection or everything after the cursor if there is no selection.\n   * Key Combinations (MacOS) - unable to trigger\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   * @returns the content with deletion performed\n   */\n  deleteHardLineForward(content: string, selectionStart: number, selectionEnd: number) {\n    // in input, everything is single line. So, this is similar to soft line\n    // delete everything after the cursor\n    return deleteEverythingForward(content, selectionStart, selectionEnd);\n  },\n\n  /**\n   * Deletes the current selection without any direction. Noop if there is no\n   * selection.\n   * @param content the current content\n   * @param selectionStart the selection start index\n   * @param selectionEnd the selection end index\n   */\n  deleteContent(content: string, selectionStart: number, selectionEnd: number) {\n    // this should always have a selection\n    if (selectionEnd > selectionStart) {\n      return deleteSelection(content, selectionStart, selectionEnd);\n    }\n    // return the original content if there is no selection.\n    return { content, selectionStart, selectionEnd };\n  }\n} as const;\n\n/**\n * Checks if the provided deletion operation is supported\n * @param op The operation name\n * @returns whether the deletion operation is supported\n */\nconst isSupportedDeletionOperation = (op: string): op is keyof typeof deletionOperations =>\n  Object.keys(deletionOperations).includes(op);\n\n//////////////////////////////////////////////////////////////////////////////\n// Various insertions interactions. Insertions are those interactions which //\n// include text to the field one way or another (like pasting and such).    //\n//////////////////////////////////////////////////////////////////////////////\n\n// Since we will be using input element and not contenteditable div or textarea\n// we will only support a few and rest we will simply not handle.\n// 1. insertText - when one normally types\n// 2. insertFromPaste - when one pastes content or autofill\n// The way we handle the event is same for these supported types.\n// See other inputTypes and what they do here -\n// https://w3c.github.io/input-events/#interface-InputEvent-Attributes\nconst supportedInputOperations = ['insertText', 'insertFromPaste'];\n/**\n * Checks if the provided insertion operation is supported\n * @param op The operation name\n * @returns whether the insertion operation is supported\n */\nconst isSupportedInsertionOperation = (op: string) => supportedInputOperations.includes(op);\n\n/////////////////////////////////////////////////////////////////////\n// Since we are obfuscating the text, we need to implement our own //\n// Undo / Redo implementation. This is achieved by using the       //\n// HistoryManager. And this type represents the structure of the   //\n// state in the HistoryManager.                                    //\n/////////////////////////////////////////////////////////////////////\ntype InputHistoryState = {\n  value: string;\n  selection: {\n    start: number;\n    end: number;\n  };\n};\n\n/**\n * Compares two states to see if they are equal.\n * @param a a state to be compared\n * @param b another state to be compared\n * @returns result of equality\n */\nconst compareInputHistoryState = (a?: InputHistoryState, b?: InputHistoryState) => {\n  if (a === b) return true;\n  if (!a || !b) return false;\n\n  return (\n    a.value === b.value &&\n    a.selection.start === b.selection.start &&\n    a.selection.end === b.selection.end\n  );\n};\n\n/**\n * Renders an input field (similar to TextFieldInput) that obfuscates the text\n * entered in it.\n */\nexport const ObfuscatedTextFieldInput = ({\n  character = 'â€¢',\n  currentCommitValue,\n  inputRef,\n  isRevealed = false,\n  onCommit,\n  onInput,\n  type = 'text',\n  value,\n  ...passThroughProps\n}: Props) => {\n  // Even though TextFieldInput handles retaining the cursor position on rerender\n  // it will not work for us here as we preventDefault in the onbeforeinput event\n  // which will prevent the input event from getting called. Since TextFieldInput\n  // component relies on the input event to be called for restoring cursor position\n  // things will not work as expected. So, we have to reimplement this logic here\n  // again.\n  const selectionRangeRef = useRef({\n    selectionStart: value?.length ?? 0,\n    selectionEnd: value?.length ?? 0\n  });\n  const internalInputRef = useRef<HTMLInputElement>(null);\n  const mergedInputRef = useMemo(\n    () => mergeRefs(inputRef, internalInputRef),\n    [inputRef, internalInputRef]\n  );\n\n  // this component manually handles history when it is obfuscated, so we will be\n  // using the history manager\n  const historyManager = useHistoryManager<InputHistoryState>({\n    comparator: compareInputHistoryState,\n    // We do not want to maintain history when we are revealing the text.\n    // Disabling will reset the history.\n    isDisabled: isRevealed,\n    // We push the new value along with the current selectionRange to the history.\n    // Notice that we memoize the state based on the value. This is because a new\n    // state should be created only when the value changes and not when the selection\n    // changes.\n    state: useMemo<InputHistoryState>(\n      () => ({\n        value: value ?? '',\n        selection: {\n          start: selectionRangeRef.current.selectionStart,\n          end: selectionRangeRef.current.selectionEnd\n        }\n      }),\n      [value]\n    )\n  });\n\n  const onInputPayloadRef = useRef<Parameters<NonNullable<typeof onInput>>[0]>();\n\n  /**\n   * Restores selection range using the ref.\n   * @param _ we don't need this param, but this is just for making the\n   *            useLayoutEffect hook and its dependency array to match.\n   */\n  const STABLE_restoreSelectionRange = useEffectEvent((_?: any) => {\n    // only update the selectionRange of the component if it is focused\n    if (internalInputRef.current !== document.activeElement) return;\n\n    const { selectionStart, selectionEnd } = selectionRangeRef.current;\n    internalInputRef.current?.setSelectionRange(selectionStart, selectionEnd);\n  });\n\n  // when the value changes, we need to update the selection range\n  useLayoutEffect(() => {\n    // restore selection on value change\n    STABLE_restoreSelectionRange(value);\n  }, [STABLE_restoreSelectionRange, value]);\n\n  const computeNextInput = useCallback<NonNullable<GlobalEventHandlers['onbeforeinput']>>(\n    (event) => {\n      // if the component is revealing the current value, then let it\n      // go through the onInput event\n      if (isRevealed) return;\n\n      // otherwise handle it here\n      const target = event.target as HTMLInputElement;\n      const { selectionStart, selectionEnd } = target;\n      const previousValue = value ?? '';\n      const operation = event.inputType;\n\n      // stop ignoring history state updates as user initiated an action\n      historyManager.ignore(false);\n      // reset the next input state\n      onInputPayloadRef.current = undefined;\n\n      // There are different insertion inputTypes, but we only care about some\n      // see isSupportedInsertionOperation for what we support and\n      // https://w3c.github.io/input-events/#interface-InputEvent-Attributes\n      // for all the available inputTypes.\n      // And per spec, event.data will exist for insertion events, but we check for\n      // it anyway.\n      if (isSupportedInsertionOperation(operation) && event.data) {\n        // now, we determine what is the current value based on the\n        // current position of the cursor, previous value and the current\n        // entered key\n        const newValue =\n          previousValue.slice(0, selectionStart ?? previousValue.length) +\n          event.data +\n          previousValue.slice(selectionEnd ?? previousValue.length);\n\n        // new cursor position will be number of chars in event.data from\n        // the selectionStart\n        const cursorPosition = (selectionStart ?? previousValue.length) + event.data.length;\n        selectionRangeRef.current = {\n          selectionStart: cursorPosition,\n          selectionEnd: cursorPosition\n        };\n\n        // store the next input state which will be used to trigger onInput\n        // during the input event\n        onInputPayloadRef.current = { previousValue, value: newValue };\n        return;\n      }\n\n      // there are various different types of deletion events (e.g., delete vs backspace)\n      // and we need to handle it accordingly\n      // See https://w3c.github.io/input-events/#interface-InputEvent-Attributes\n      if (isSupportedDeletionOperation(operation)) {\n        const deletionOperation = deletionOperations[operation];\n        const {\n          content: newValue,\n          selectionStart: newSelectionStart,\n          selectionEnd: newSelectionEnd\n        } = deletionOperation(\n          previousValue,\n          selectionStart ?? previousValue.length,\n          selectionEnd ?? previousValue.length\n        );\n\n        // new cursor position will always be the selection start\n        selectionRangeRef.current = {\n          selectionStart: newSelectionStart,\n          selectionEnd: newSelectionEnd\n        };\n\n        // with this, trigger the onInput (only if the data is changed)\n        if (previousValue !== newValue) {\n          // store the next input state which will be used to trigger onInput\n          // during the input event\n          onInputPayloadRef.current = { previousValue, value: newValue };\n        }\n        return;\n      }\n\n      // handling history actions - undo/redo\n      if (['historyUndo', 'historyRedo'].includes(event.inputType)) {\n        const isUndo = event.inputType === 'historyUndo';\n\n        // if we don't have an undo/redo state, do nothing and return\n        if ((isUndo && !historyManager.hasUndo) || (!isUndo && !historyManager.hasRedo)) return;\n\n        // since we are restoring from history, we do not want to push this state back to history\n        // so we ignore the history updates until the next normal input happens\n        historyManager.ignore();\n        const { value: newValue, selection } = isUndo\n          ? historyManager.undo()\n          : historyManager.redo();\n\n        // with this trigger the onInput and the selection range\n        selectionRangeRef.current = {\n          selectionStart: selection.start,\n          selectionEnd: selection.end\n        };\n        // store the next input state which will be used to trigger onInput\n        // during the input event\n        onInputPayloadRef.current = { previousValue, value: newValue };\n        return;\n      }\n\n      // Unsupported action, so we prevent the input event from triggering\n      event.preventDefault();\n    },\n    [historyManager, isRevealed, value]\n  );\n\n  const triggerOnInputCallback = useCallback(() => {\n    // if the component is revealing the current value, then let it\n    // go through the onInput event from the TextFieldInput component.\n    if (isRevealed) return;\n\n    // if there is a stored next input state, then call the\n    // onInput callback\n    if (onInputPayloadRef.current) {\n      onInput?.(onInputPayloadRef.current);\n    }\n  }, [isRevealed, onInput]);\n\n  const selectAllWhenObfuscated = useCallback(() => {\n    // do not do anything when the value is revealed\n    if (isRevealed) return;\n\n    // Since we are using special char, double clicking will not select all the text\n    // and so we do it manually.\n    internalInputRef.current?.select();\n  }, [isRevealed]);\n\n  const killEventWhenObfuscated = useCallback<EventListener>(\n    (event) => {\n      if (isRevealed) return;\n\n      // prevent the default action when we are obfuscating the text.\n      // usually for events like cut and copy as we do not want to allow that.\n      event.preventDefault();\n    },\n    [isRevealed]\n  );\n\n  // the onInputHandler, onCommitHandler, onKeyDown are wired to TextFieldInput component\n  const onInputHandler = useCallback<NonNullable<TextFieldInputProps['onInput']>>(\n    (details) => {\n      // do not handle the onInput events, if the component is not in\n      // revealed state as we are handling things in onBeforeInput\n      if (!isRevealed) return;\n\n      // otherwise simply pass through to the onInput handler from the\n      // props and update the selectionRange\n      selectionRangeRef.current = {\n        selectionStart: internalInputRef.current?.selectionStart ?? details.value?.length ?? 0,\n        selectionEnd: internalInputRef.current?.selectionEnd ?? details.value?.length ?? 0\n      };\n      onInput?.(details);\n    },\n    [isRevealed, onInput]\n  );\n  const onCommitHandler = useCallback<NonNullable<TextFieldInputProps['onCommit']>>(() => {\n    // trigger onCommit only if the current value is different from the previous commit value\n    if (currentCommitValue === value) return;\n    onCommit?.({ previousValue: currentCommitValue, value });\n  }, [currentCommitValue, value, onCommit]);\n  const onKeyDownHandler = useCallback<NonNullable<TextFieldInputProps['onKeyDown']>>(\n    (event) => {\n      // if the component is revealing the current value, then let it naturally\n      // go through the onInput event\n      if (isRevealed) return;\n\n      // We handle undo/redo in both beforeinput and keydown as firefox does not\n      // seem to trigger beforeinput for undo/redo in our implementation. So, we handle it\n      // using keydown event.\n      const _isUndoEvent = isUndoEvent(event);\n      const _isRedoEvent = isRedoEvent(event);\n      if (_isUndoEvent || _isRedoEvent) {\n        // if we don't have an undo/redo state, do nothing and return\n        if ((_isUndoEvent && !historyManager.hasUndo) || (_isRedoEvent && !historyManager.hasRedo))\n          return;\n\n        // prevent the default here\n        event.preventDefault();\n        // since we are restoring from history, we do not want to push this state back to history\n        // so we ignore the history updates until the next normal input happens\n        historyManager.ignore();\n        const { value: newValue, selection } = _isUndoEvent\n          ? historyManager.undo()\n          : historyManager.redo();\n\n        // with this trigger the onInput and the selection range\n        selectionRangeRef.current = {\n          selectionStart: selection.start,\n          selectionEnd: selection.end\n        };\n        onInput?.({ previousValue: value, value: newValue });\n        return;\n      }\n    },\n    [historyManager, isRevealed, onInput, value]\n  );\n\n  return (\n    <div\n      class={containerStyles}\n      // Note: We are capturing events bubbling from the input element in the bubbling phase\n      // We are doing this approach because we do not want to add APIs to the TextFieldInput\n      // component exposing these event callbacks.\n      // This is for obfuscating the characters typed in the input\n      // Note: onBeforeInput is typed as a GenericEventHandler in preact\n      // so the event argument is of generic Event type. But as per the mdn\n      // docs (https://developer.mozilla.org/en-US/docs/Web/API/Element/beforeinput_event#event_type)\n      // it will receive an InputEvent. Hence, the explicit any casting here.\n      onBeforeInput={computeNextInput as any}\n      onInput={triggerOnInputCallback}\n      // This is for preventing cut action when obfuscated\n      onCut={killEventWhenObfuscated}\n      // This is for preventing copy action when obfuscated\n      onCopy={killEventWhenObfuscated}\n      // This is for selecting all the chars when double-clicked\n      onDblClick={selectAllWhenObfuscated}\n      // This is for selecting all the chars when right-clicked\n      onContextMenu={selectAllWhenObfuscated}>\n      <TextFieldInput\n        {...passThroughProps}\n        // override properties\n        as=\"input\"\n        autoComplete=\"off\"\n        // this is not really needed as we don't rely on the information from\n        // onCommit callback\n        currentCommitValue={currentCommitValue}\n        type={type}\n        spellcheck={false}\n        inputRef={mergedInputRef}\n        // We handle our own Input and Commit events and may not\n        // be relying on the data that the TextFieldInput provides us\n        onInput={onInputHandler}\n        onCommit={onCommitHandler}\n        onKeyDown={onKeyDownHandler}\n        value={isRevealed ? value : character.repeat(value?.length ?? 0)}\n      />\n    </div>\n  );\n};\n","import { useEffect, useMemo, useRef } from 'preact/compat';\nimport { HistoryManager } from './HistoryManager';\n\ntype Props<T> = {\n  /**\n   * The state that needs to be pushed to the history.\n   */\n  state: T;\n\n  /**\n   * Compares two states\n   * @param a State A\n   * @param b State B\n   * @returns equality of the two states\n   */\n  comparator: (a?: T, b?: T) => boolean;\n\n  /**\n   * Whether history management is disabled. When it is disabled\n   * the states will not be pushed to the history. Additionally, when it\n   * changes from enabled to disabled, the history will be cleared.\n   */\n  isDisabled: boolean;\n\n  /**\n   * Maximum states that need to be stored in the history. This can only be set\n   * during the initialization. Changing the value after the initialization will\n   * not have any effect.\n   */\n  maxHistory?: number;\n};\n\nexport type HistoryController<T> = Pick<\n  HistoryManager<T>,\n  'hasRedo' | 'hasUndo' | 'redo' | 'undo'\n> & {\n  /**\n   * A method that can be called to toggle the history manager to\n   * save or ignore states.\n   * This is different from `isDisabled`; ignoring will not clear the history\n   * while disabling clears the history.\n   * @param doIgnore flag to indicate if this should ignore state updates\n   */\n  ignore: (doIgnore?: boolean) => void;\n};\n\n/**\n * A custom hook that provides history management. Using this hook, one can push\n * consecutive states to the stack. Then they can go to any point in the history\n * by performing undo/redo operations.\n * @param param0 The hook's props\n * @returns The history manager controller that can be used to manage the history.\n *\n * @template State A Generic representing the shape of the state.\n *\n * @example\n * function MyComponent(props) {\n *   const historyManager = useHistoryManager<MyValue>({\n *     state: props.value,\n *     comparator: (value1, value2) => value1 === value2\n *   });\n *\n *   return (\n *     <SomeComponent\n *       value={props.value}\n *       onValueChange={props.onValueChange}\n *       onUndo={() => {\n *         const undoValue = historyManager.undo();\n *         props.onValueChange(historyManager.undo());\n *       }}\n *       onRedo={() => {\n *         const redoValue = historyManager.redo();\n *         props.onValueChange(redoValue);\n *       }}  />\n *   );\n * }\n */\nexport function useHistoryManager<State>({\n  state,\n  comparator,\n  isDisabled,\n  maxHistory\n}: Props<State>) {\n  // We do not want to recreate history manager and only have a single version.\n  const initialMaxHistoryRef = useRef(maxHistory);\n  const historyManager = useMemo(\n    () => new HistoryManager<State>({ maxHistory: initialMaxHistoryRef.current }),\n    []\n  );\n\n  // We use a ref for determining if we should ignore state updates. This is needed\n  // as we may not want to update the history when we are undoing/redoing.\n  const isIgnoredRef = useRef(false);\n\n  // We want to add the state to the history if it changes. But, we should not cause\n  // a rerender as pushing a state to the history does not cause any UI changes. So we\n  // will use refs instead of states.\n  const previousStateRef = useRef<State>();\n  // we only push the new state if\n  // 1. it is different from the old state\n  // 2. the history management is not disabled\n  // 3. the states are not ignored\n  if (!comparator(previousStateRef.current, state) && !isDisabled && !isIgnoredRef.current) {\n    previousStateRef.current = state;\n    historyManager.push(state);\n  }\n\n  // when the history management becomes disabled, we clear the history created so far\n  if (isDisabled) {\n    historyManager.clear();\n  }\n\n  // clear the history when the component is unmounted\n  // we only want to clear history on unmount.\n  // TODO: Disable eslint exhaustive-deps rule when it is enabled\n  // doing it now results in eslint error, saying the rule is not found.\n  useEffect(() => () => historyManager.clear(), [historyManager]);\n\n  return useMemo<HistoryController<State>>(\n    () => ({\n      get hasRedo() {\n        return historyManager.hasRedo;\n      },\n      get hasUndo() {\n        return historyManager.hasUndo;\n      },\n      redo: () => historyManager.redo(),\n      undo: () => historyManager.undo(),\n      ignore(doIgnore = true) {\n        isIgnoredRef.current = !!doIgnore;\n      }\n    }),\n    [historyManager]\n  );\n}\n"],"names":["HistoryManager","constructor","maxHistory","this","currentIndex","states","currentState","isEmpty","length","hasUndo","hasRedo","push","state","shift","go","steps","Math","min","max","undo","redo","clear","deleteSelection","content","selectionStart","selectionEnd","slice","deleteEverythingBackward","deleteEverythingForward","deletionOperations","deleteContentBackward","deleteContentForward","deleteWordBackward","deleteWordForward","deleteSoftLineBackward","deleteSoftLineForward","deleteHardLineBackward","deleteHardLineForward","deleteContent","supportedInputOperations","compareInputHistoryState","a","b","value","selection","start","end","character","currentCommitValue","inputRef","isRevealed","onCommit","onInput","type","passThroughProps","selectionRangeRef","useRef","internalInputRef","mergedInputRef","useMemo","mergeRefs","historyManager","comparator","isDisabled","initialMaxHistoryRef","current","isIgnoredRef","previousStateRef","useEffect","ignore","doIgnore","useHistoryManager","onInputPayloadRef","STABLE_restoreSelectionRange","useEffectEvent","_","document","activeElement","setSelectionRange","useLayoutEffect","computeNextInput","useCallback","event","target","previousValue","operation","inputType","undefined","op","includes","data","newValue","cursorPosition","Object","keys","isSupportedDeletionOperation","deletionOperation","newSelectionStart","newSelectionEnd","isUndo","preventDefault","triggerOnInputCallback","selectAllWhenObfuscated","select","killEventWhenObfuscated","onInputHandler","details","onCommitHandler","onKeyDownHandler","_isUndoEvent","isUndoEvent","_isRedoEvent","isRedoEvent","_jsx","class","containerStyles","onBeforeInput","onCut","onCopy","onDblClick","onContextMenu","children","jsx","TextFieldInput","as","autoComplete","spellcheck","onKeyDown","repeat"],"mappings":"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"}