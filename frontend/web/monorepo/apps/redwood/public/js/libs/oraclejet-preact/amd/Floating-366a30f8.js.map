{"version":3,"file":"Floating-366a30f8.js","sources":["../../src/UNSAFE_Floating/FloatingTail.tsx","../../src/UNSAFE_Floating/Floating.tsx"],"sourcesContent":["import { forwardRef, ForwardedRef } from 'preact/compat';\nimport { useMemo, useLayoutEffect, useRef, useState } from 'preact/hooks';\nimport type { RefObject } from 'preact';\nimport { PositionData, Coords } from './Floating.types';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { FloatingStyles } from './themes/FloatingStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport type { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { Property } from 'csstype';\nimport { rgba } from '../UNSAFE_Theme/utils';\nimport { colorSchemeVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\nimport { FloatingRedwoodTheme } from './themes/redwood/FloatingTheme';\n\ntype Props = Pick<ColorProps, 'backgroundColor'> & {\n  data?: PositionData;\n  anchorRef: RefObject<Element | Coords>;\n  tail: 'none' | 'simple';\n  isRtl: boolean;\n};\n\nconst ARROW_SIZE = 7;\nconst ARROW_SIZE_CORNER = 6;\nconst ARROW_INNER_SIZE = 5;\nconst ARROW_INNER_SIZE_CORNER = 5;\n\nconst FloatingTail = forwardRef(\n  (\n    { data, anchorRef, tail, isRtl, backgroundColor }: Props,\n    ref: ForwardedRef<HTMLDivElement | null>\n  ) => {\n    const { styles, baseTheme } = useComponentTheme<never, FloatingStyles>(FloatingRedwoodTheme);\n    const arrowRef = useRef<HTMLDivElement | null>(null);\n    const [arrowStyles, setArrowStyles] = useState({\n      arrowStyle: { visibility: 'hidden' },\n      arrowInnerStyle: { visibility: 'hidden' }\n    });\n\n    useLayoutEffect(() => {\n      if (arrowRef.current == null) return;\n      const { isCornerVerticalPlacement, isCornerHorizontalPlacement } = isCorner(\n        anchorRef,\n        tail,\n        data\n      );\n      setArrowStyles(\n        setStyles(\n          tail,\n          isRtl,\n          isCornerVerticalPlacement,\n          isCornerHorizontalPlacement,\n          data,\n          backgroundColor\n        )\n      );\n    }, [\n      data,\n      backgroundColor,\n      data?.placement,\n      data?.x,\n      data?.y,\n      data?.offset,\n      data?.arrow,\n      tail,\n      isRtl,\n      anchorRef\n    ]);\n\n    const stableRef = useMemo(() => mergeRefs(ref, arrowRef), [ref, arrowRef]);\n    return (\n      tail === 'simple' && (\n        <div\n          ref={stableRef}\n          class={classNames([baseTheme, styles.floatingTailBaseStyle])}\n          style={arrowStyles.arrowStyle}>\n          {' '}\n          {/*Outer arrow - shadow*/}\n          <div\n            class={classNames([styles.floatingTailBaseStyle])}\n            style={arrowStyles.arrowInnerStyle}></div>{' '}\n          {/*Inner arrow - body*/}\n        </div>\n      )\n    );\n  }\n);\n\nfunction isCorner(\n  anchorRef: RefObject<Element | Coords>,\n  tail: 'none' | 'simple',\n  data?: PositionData\n) {\n  if (tail === 'simple' && data && data.arrow) {\n    const { centerOffset } = data.arrow;\n    const arrowSize = ARROW_SIZE;\n    let anchorRefHeight = 0;\n    let anchorRefWidth = 0;\n    const current = anchorRef.current;\n    // @ts-ignore. Type 'Element | Coords' issues\n    // Property 'x' does not exist on type 'Element'.\n    // Property 'y' does not exist on type 'Element'.\n    const isAnchorRefElement = current?.x === undefined && current?.y === undefined;\n    if (isAnchorRefElement) {\n      // @ts-ignore. Property 'getBoundingClientRect' does not exist on type 'Coords'.\n      anchorRefHeight = Math.round(current.getBoundingClientRect().height);\n      // @ts-ignore. Property 'getBoundingClientRect' does not exist on type 'Coords'.\n      anchorRefWidth = Math.round(anchorRef.current?.getBoundingClientRect().width);\n    }\n    const isCornerVerticalPlacement = isAnchorRefElement\n      ? Math.abs(centerOffset) >= anchorRefHeight / 2 - arrowSize / 2\n      : ['start-top-corner', 'start-bottom-corner', 'end-top-corner', 'end-bottom-corner'].includes(\n          data.origPlacement\n        );\n    const isCornerHorizontalPlacement = isAnchorRefElement\n      ? Math.abs(centerOffset) >= anchorRefWidth / 2 - arrowSize / 2\n      : ['top-start-corner', 'top-end-corner', 'bottom-start-corner', 'bottom-end-corner'].includes(\n          data.origPlacement\n        );\n\n    return { isCornerVerticalPlacement, isCornerHorizontalPlacement };\n  } else return { isCornerVerticalPlacement: false, isCornerHorizontalPlacement: false };\n}\n\nfunction setStyles(\n  //arrowEl: HTMLDivElement,\n  tail: 'none' | 'simple',\n  isRtl: boolean,\n  isCornerVerticalPlacement: boolean,\n  isCornerHorizontalPlacement: boolean,\n  data?: PositionData,\n  backgroundColor?: Property.BackgroundColor\n) {\n  const result = { visibility: 'visible' };\n  const innerResult = { visibility: 'visible' };\n  if (tail === 'simple' && data && data.arrow) {\n    const { x, y, centerOffset } = data.arrow;\n    const arrowSize = ARROW_SIZE;\n    const arrowSizeCorner = ARROW_SIZE_CORNER;\n    //const arrowInnerEl = arrowEl.querySelector('div') as Element;\n    const arrowInnerSize = ARROW_INNER_SIZE;\n    const arrowInnerSizeCorner = ARROW_INNER_SIZE_CORNER;\n\n    const isCenter = centerOffset === 0;\n    const isCenterOffsetPositive = centerOffset > 0;\n\n    // Set sizes of the arrow\n    setArrowSizes(isCornerVerticalPlacement || isCornerHorizontalPlacement);\n\n    // Corner vs. normal arrow\n    function setArrowSizes(isCornerPlacement?: boolean) {\n      // Outer arrow (shadow)\n      const arrowFinalSize = isCornerPlacement ? arrowSizeCorner : arrowSize;\n      setArrowStyle(\n        {\n          // Tracked: \n          borderTop: `${getSize(arrowFinalSize)} solid ${rgba(\n            colorSchemeVars.palette.neutral[90],\n            0.1\n          )}`,\n          borderRight: getTransparentBorder(arrowFinalSize),\n          borderLeft: getTransparentBorder(arrowFinalSize)\n        },\n        result\n      );\n      // Inner arrow\n      const arrowInnerFinalSize = isCornerPlacement ? arrowInnerSizeCorner : arrowInnerSize;\n      setArrowInnerStyle(\n        {\n          // Tracked: \n          borderTop: `${getSize(arrowInnerFinalSize)} solid ${backgroundColor}`,\n          borderRight: `${getTransparentBorder(arrowInnerFinalSize)}`,\n          borderLeft: `${getTransparentBorder(arrowInnerFinalSize)}`\n        },\n        innerResult\n      );\n    }\n\n    function setArrowStyle(style: object, result: object) {\n      Object.assign(result, style);\n    }\n\n    function setArrowInnerStyle(style: object, result: object) {\n      Object.assign(result, style);\n    }\n\n    function getTurn(eighth: number) {\n      return `rotate(${eighth * 45}deg)`;\n    }\n\n    function getSize(size: number) {\n      return `${size}px`;\n    }\n\n    function getTransparentBorder(size: number) {\n      return `${getSize(size)} solid transparent`;\n    }\n\n    const placementArr = data.placement.split('-');\n    const side = placementArr[0];\n\n    switch (side) {\n      case 'top':\n        setArrowTop();\n        break;\n      case 'end':\n        isRtl ? setArrowStart() : setArrowEnd();\n        break;\n      case 'bottom':\n        setArrowBottom();\n        break;\n      case 'start':\n        isRtl ? setArrowEnd() : setArrowStart();\n        break;\n    }\n\n    function setArrowTop() {\n      if (x != undefined) {\n        if (isCornerHorizontalPlacement) {\n          // Top corners\n          setArrowStyle(\n            {\n              top: '', // flip 'reset'\n              bottom: getSize(-arrowSize + 2),\n              left: getSize(x + (isCenterOffsetPositive ? 5 : -5)),\n              transform: getTurn(isCenterOffsetPositive ? 5 : 3)\n            },\n            result\n          );\n          setCornerArrowInner();\n        } else {\n          setArrowStyle(\n            {\n              top: '', // flip 'reset'\n              bottom: getSize(-arrowSize),\n              left: isCenter ? getSize(x) : getSize(x + (isCenterOffsetPositive ? 1 : -1)),\n              transform: getTurn(0)\n            },\n            result\n          );\n          setNonCornerArrowInner();\n        }\n      }\n    }\n\n    function setArrowEnd() {\n      if (y != undefined) {\n        if (isCornerVerticalPlacement) {\n          // End corners\n          setArrowStyle(\n            {\n              top: getSize(y + (isCenterOffsetPositive ? 2 : -2)),\n              right: '', // flip 'reset'\n              left: getSize(-arrowSize - 1),\n              transform: getTurn(isCenterOffsetPositive ? 7 : 5)\n            },\n            result\n          );\n          setCornerArrowInner();\n        } else {\n          // End\n          setArrowStyle(\n            {\n              top: isCenter ? getSize(y) : getSize(y + (isCenterOffsetPositive ? -2 : +2)),\n              right: '', // flip 'reset'\n              left: getSize(-arrowSize * 1.5),\n              transform: getTurn(2)\n            },\n            result\n          );\n          setNonCornerArrowInner();\n        }\n      }\n    }\n\n    function setArrowBottom() {\n      if (x != undefined) {\n        if (isCornerHorizontalPlacement) {\n          // Bottom corners\n          setArrowStyle(\n            {\n              top: getSize(-arrowSize + 3),\n              bottom: '', // flip 'reset'\n              left: getSize(x + (isCenterOffsetPositive ? 4 : -4)),\n              transform: getTurn(isCenterOffsetPositive ? 2 : 6)\n            },\n            result\n          );\n          setArrowInnerStyle(\n            {\n              top: getSize(-arrowInnerSize),\n              left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? 1 : -1))\n            },\n            innerResult\n          );\n        } else {\n          setArrowStyle(\n            {\n              top: getSize(-arrowSize),\n              bottom: '', // flip 'reset'\n              left: isCenter ? getSize(x) : getSize(x + (isCenterOffsetPositive ? 1 : -1)),\n              transform: getTurn(4)\n            },\n            result\n          );\n          setNonCornerArrowInner();\n        }\n      }\n    }\n\n    function setArrowStart() {\n      if (y != undefined) {\n        if (isCornerVerticalPlacement) {\n          // Start corners\n          setArrowStyle(\n            {\n              top: getSize(y + (isCenterOffsetPositive ? 2 : -2)),\n              right: getSize(-arrowSize - 1),\n              left: '', // flip 'reset'\n              transform: getTurn(isCenterOffsetPositive ? 1 : 3)\n            },\n            result\n          );\n          setArrowInnerStyle(\n            {\n              top: getSize(-arrowInnerSize),\n              left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? -2 : 2))\n            },\n            innerResult\n          );\n        } else {\n          // Start\n          setArrowStyle(\n            {\n              top: isCenter ? getSize(y) : getSize(y + (isCenterOffsetPositive ? -2 : +2)),\n              right: getSize(-arrowSize * 1.5),\n              left: '', // flip 'reset'\n              transform: getTurn(6)\n            },\n            result\n          );\n          setNonCornerArrowInner();\n        }\n      }\n    }\n\n    function setCornerArrowInner() {\n      setArrowInnerStyle(\n        {\n          top: getSize(-arrowInnerSize),\n          left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? 2 : -2))\n        },\n        innerResult\n      );\n    }\n\n    function setNonCornerArrowInner() {\n      setArrowInnerStyle(\n        {\n          top: getSize(-arrowInnerSize - 2),\n          left: getSize(-arrowInnerSize)\n        },\n        innerResult\n      );\n    }\n  }\n  return { arrowStyle: result, arrowInnerStyle: innerResult };\n}\n\nexport { FloatingTail };\n","import type { RefObject, JSX } from 'preact';\nimport { useLayoutEffect, useEffect, useMemo, useState, useRef, useCallback } from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { autoUpdate, arrow } from '@floating-ui/dom';\nimport {\n  useFloating,\n  shift,\n  flip,\n  size,\n  offset,\n  limitShift,\n  VirtualElement,\n  logicalSide\n} from '../hooks/PRIVATE_useFloating';\nimport { Offset, Placement, Coords, PositionData } from './Floating.types';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { FloatingTail } from './FloatingTail';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { FloatingStyles, floatingVisibilityStyles } from './themes/FloatingStyles.css';\nimport { FloatingRedwoodTheme } from './themes/redwood/FloatingTheme';\nimport { assignInlineVars } from '@vanilla-extract/dynamic';\nimport { floatingVars } from './themes/FloatingContract.css';\nimport type { ColorProps } from '../utils/UNSAFE_interpolations/colors';\n\nimport type { UnsafeDomHandle } from '#utils/UNSAFE_unsafeDomAccess';\nimport { useUnsafeDomElementRef } from '#hooks/PRIVATE_useUnsafeDomElementRef';\n\ntype IntrinsicProps = Pick<UnpackSignals<JSX.IntrinsicElements['div']>, 'children' | 'class'>;\n/**\n * Specifies the flipping behavior along the respective axis.\n */\nexport type FlipOptions = {\n  /**\n   * If set to true, enables collision detection on the main axis,\n   * which runs along the floating placement side.\n   */\n  mainAxis?: boolean;\n  /**\n   * If set to true, enables collision detection on the cross axis,\n   * which runs along the floating placement side.\n   */\n  crossAxis?: boolean;\n  /**\n   * Specifies an array of placements to try\n   * if the preferred initial placement doesn’t fit on the axes\n   * in which collision is detected.\n   */\n  fallbackPlacements?: Array<Placement>;\n};\n\n/**\n * Specifies the shift behavior along the respective axis.\n * When true, the floating element will shift to prevent overflow.\n */\nexport type ShiftOptions = {\n  /**\n   * main axis in which shifting is applied. Default <code>true</code>.\n   */\n  mainAxis?: boolean;\n  /**\n   * cross axis in which shifting is applied. Default <code>false</code>.\n   */\n  crossAxis?: boolean;\n};\n\n/**\n * This describes the virtual padding around the collision boundary (currently the view port).\n * This could be extended in the future,\n * i.e. property to define what is a boundary ( a view port, a document, some other html element)\n */\nexport type BoundaryOptions = {\n  padding?:\n    | number\n    | {\n        top: number;\n        right: number;\n        bottom: number;\n        left: number;\n      };\n};\n/**\n * Specifies the resizing behaviour for max-height and max-width of the floating component.\n * The floating element will change the size depending on the available space.\n * isMaxHeightAdjusted/isMaxWidthAdjusted - sets the max-height/max-width of the floating to the available space till the collision.\n * maxHeightCeiling/maxWidthCeiling - this is the limit for max-height/max-width that should not be exceeded, even if there is more available space till the collision.\n */\nexport type SizeOptions = {\n  isMaxWidthAdjusted?: boolean;\n  isMaxHeightAdjusted?: boolean;\n  maxHeightCeiling?: number;\n  maxWidthCeiling?: number;\n};\n\ntype Props = IntrinsicProps &\n  Pick<ColorProps, 'backgroundColor'> & {\n    /**\n     * <p>Placement of the floating element relative to its reference element.</p>\n     * <p>Placement consists of two parts, the first part is the side, the second is the alignment.</p>\n     * <p>Possible values are:</p>\n     * <p> <code>'top' </code> <code>'top-start' </code> <code> 'top-end' </code> <code> 'top-start-corner' </code> <code> 'top-end-corner' </code>\n     * <code> 'end' </code> <code> 'end-top'  </code> <code> 'end-bottom' </code> <code> 'end-top-corner' </code> <code> 'end-bottom-corner' </code>\n     * <code> 'bottom'  </code> <code> 'bottom-start'  </code> <code> 'bottom-end' </code> <code> 'bottom-start-corner' </code> <code> 'bottom-end-corner' </code>\n     * <code> 'start' </code> <code> 'start-top'  </code> <code> 'start-bottom' </code> <code> 'start-top-corner' </code> <code> 'start-bottom-corner' </code>\n     * </p>\n     */\n    placement?: Placement;\n\n    /**\n     * Trigger element reference.\n     */\n    anchorRef: RefObject<Element | Coords | UnsafeDomHandle<Element>>;\n\n    /**\n     * Placement offset.\n     * Offset displaces the floating element from its core placement along the specified axes.\n     * Offset could be a number or an object\n     * A number represents the distance (gutter or margin) between the floating element and the reference element.\n     * This is shorthand for mainAxis.\n     * <pre>\n     *   {\n     *     mainAxis?: number;\n     *     crossAxis?: number;\n     *   }\n     * </pre>\n     * <p><code>mainAxis</code> - represents the distance (gutter or margin) between the floating element and the reference element.</p>\n     * <p><code>crossAxis</code> - represents the shifting between the floating element and the reference element.<p>\n     */\n    offsetValue?: Offset;\n\n    /**\n     * Click outside callback.\n     */\n    onClickOutside?: (event: MouseEvent) => void;\n\n    /**\n     * FlipOptions object\n     * <pre>\n     * type FlipOptions = {\n     *     mainAxis?: boolean;\n     *     crossAxis?: boolean;\n     *     fallbackPlacements?: Array<Placement>;\n     *   }\n     * </pre>\n     * <p>Specifies the flipping behavior along the respective axis.<p>\n     * <p><code>mainAxis</code> - If set to true, enables collision detection on the main axis, which runs along the floating placement side.\n     * Default is <code>true</code>.\n     * </p>\n     * <p><code>crossAxis</code> - If set to true, enables collision detection on the cross axis, which runs along the floating placement alignment.\n     * Default is <code>false</code>.\n     * </p>\n     * <p><code>fallbackPlacements</code> - specifies an array of placements to try if the preferred initial placement doesn’t fit on the axes in which collision is detected.\n     * The fallback placements will be tried in the order they are specified in the array.\n     * The following placements are allowed as values of the array:\n     * <code>'top'</code>, <code>'top-start'</code>, <code>'top-end'</code>, <code>'start'</code>, <code>'start-top'</code>, <code>'start-bottom'</code>, <code>'bottom'</code>,\n     * <code>'bottom-start'</code>, <code>'bottom-end'</code>, <code>'end'</code>, <code>'end-top'</code>, <code>'end-bottom'</code>.\n     * <p>\n     * If not specified, the default behaviour is to flip to the side <code>opposite</code> to the one in which collision is detected\n     * </p>\n     * </p>\n     */\n    flipOptions?: FlipOptions;\n\n    /**\n     * Specifies the shift behavior along the respective axis. When true, the floating element will shift to prevent overflow.\n     * <pre>\n     * type ShiftOptions = {\n     *  mainAxis?: boolean;\n     *  crossAxis?: boolean;\n     * };\n     * </pre>\n     * <p><code>mainAxis</code> - main axis in which shifting is applied. Default <code>true</code>.</p>\n     * <p><code>crossAxis</code> - cross axis in which shifting is applied. Default <code>false</code>.</p>\n     */\n    shiftOptions?: ShiftOptions;\n\n    /**\n     *  Triggered when placement or coordinates are changed after collision is detected\n     */\n    onPosition?: (data: PositionData) => void;\n\n    /**\n     * Tail\n     */\n    tail?: 'none' | 'simple';\n\n    /**\n     * Specifies the resizing behaviour for max-height and max-width of the floating component.\n     * <pre>\n     * type SizeOptions = {\n     *    isMaxWidthAdjusted?: boolean;\n     *    isMaxHeightAdjusted?: boolean;\n     *    maxHeightCeiling?: number;\n     *    maxWidthCeiling?: number;\n     *  }\n     * </pre>\n     * <p><code>isMaxHeightAdjusted</code> and <code>isMaxWidthAdjusted</code> - sets the max-height/max-width of the floating to the available space till the collision.\n     * When either of the options isMaxHeightAdjusted, isMaxWidthAdjusted is true, the floating element will change the size depending on the available space.\n     * Default values are <code>'false'</code>.</p>\n     * <p><code>maxHeightCeiling</code> and <code>maxWidthCeiling</code> - are maximal values that could not be exceeded.\n     * Defaults are undefined and it means to use full available width/height.</p>\n     */\n    sizeOptions?: SizeOptions;\n\n    /**\n     * <p>This describes the virtual padding around the collision boundary (currently the view port).</p>\n     * <p>This could be extended in the future,\n     * i.e. property to define what is a boundary\n     * ( a view port, a document, some other html element)</p>\n     * <pre>\n     * type BoundaryOptions = {\n     *  padding?: number | {\n     *    top: number;\n     *    right: number;\n     *    bottom: number;\n     *    left: number;\n     *  };\n     * }\n     * </pre>\n     * Default value for padding is 0.\n     */\n    boundaryOptions?: BoundaryOptions;\n    /**\n     * Specifies the type of CSS position property to use.\n     * <pre>\n     * type Strategy = 'absolute' | 'fixed';\n     * </pre>\n     * Default value is 'absolute'.\n     */\n    strategy?: 'absolute' | 'fixed';\n  };\n\nfunction isElement(value: any): value is Element {\n  return value instanceof Element;\n}\n\n/**\n * A floating component allows the user to create a floating element that is displayed relative to an anchor element or pointer coordinates\n * and at the same time on the \"top layer\" of all other elements.\n * The Floating component is a base component and is often used by such components as Popup, Tooltip, SelectMultiple, Menu and other components.\n */\nexport const Floating = forwardRef(\n  (\n    {\n      children,\n      backgroundColor,\n      onClickOutside,\n      placement = 'bottom',\n      anchorRef,\n      offsetValue,\n      class: className,\n      tail = 'none',\n      flipOptions = { mainAxis: true, crossAxis: false },\n      shiftOptions = { mainAxis: true, crossAxis: false },\n      sizeOptions = { isMaxHeightAdjusted: false, isMaxWidthAdjusted: false },\n      boundaryOptions = { padding: 0 },\n      onPosition,\n      strategy\n    }: Props,\n    ref: ForwardedRef<HTMLElement | null>\n  ) => {\n    const arrowRef = useRef<HTMLDivElement>(null);\n    const [positionData, setPositionData] = useState<PositionData>();\n\n    const unsafeAnchorRef = useUnsafeDomElementRef<Element, Element | Coords>(anchorRef);\n\n    const [previousAnchor, setPreviousAnchor] = useState<Element | Coords | null>(null);\n\n    const { styles, baseTheme } = useComponentTheme<never, FloatingStyles>(FloatingRedwoodTheme);\n\n    // we need to be sure anchorRef.current exists in first call\n    // to be able to set the previousAnchor state\n    useLayoutEffect(() => {\n      setPreviousAnchor(unsafeAnchorRef.current);\n    }, [unsafeAnchorRef]);\n\n    // In case anchorRef.current changes and we need to update floating position\n    // when it changes, we need to have copy in the state.\n    // For example when anchorRef is Coords( virtual element)\n    if (unsafeAnchorRef.current !== previousAnchor) {\n      setPreviousAnchor(unsafeAnchorRef.current);\n    }\n\n    const { direction } = useUser();\n    const isRtl = direction === 'rtl';\n\n    const _onPosition = useCallback(\n      (data: PositionData) => {\n        setPositionData(data);\n        onPosition?.(data);\n      },\n      [onPosition]\n    );\n\n    const middleware = [\n      offset(offsetValue),\n      flip({\n        mainAxis: flipOptions.mainAxis,\n        crossAxis: flipOptions.crossAxis,\n        fallbackPlacements: flipOptions.fallbackPlacements?.map((placement) =>\n          logicalSide(placement, direction)\n        ),\n        padding: boundaryOptions.padding\n      }),\n      shift({\n        mainAxis: shiftOptions.mainAxis,\n        crossAxis: shiftOptions.crossAxis,\n        limiter: limitShift({\n          mainAxis: shiftOptions.mainAxis,\n          crossAxis: shiftOptions.crossAxis\n        })\n      }),\n      ...(arrowRef.current\n        ? [\n            arrow({\n              element: arrowRef.current\n            })\n          ]\n        : [])\n    ];\n    if (sizeOptions.isMaxHeightAdjusted || sizeOptions.isMaxWidthAdjusted) {\n      middleware.push(\n        size({\n          apply({ availableWidth, availableHeight, elements }) {\n            if (sizeOptions.isMaxHeightAdjusted) {\n              if (parseInt(elements.floating.style.maxHeight) !== availableHeight) {\n                Object.assign(elements.floating.style, {\n                  maxHeight: `${Math.min(\n                    availableHeight,\n                    sizeOptions.maxHeightCeiling || availableHeight\n                  )}px`\n                });\n              }\n            }\n\n            if (sizeOptions.isMaxWidthAdjusted) {\n              if (parseInt(elements.floating.style.maxWidth) !== availableWidth) {\n                Object.assign(elements.floating.style, {\n                  maxWidth: `${Math.min(\n                    availableWidth,\n                    sizeOptions.maxWidthCeiling || availableWidth\n                  )}px`\n                });\n              }\n            }\n          },\n\n          padding: boundaryOptions.padding\n        })\n      );\n    }\n\n    const { x, y, reference, floating, refs, update } = useFloating({\n      placement: placement,\n      middleware: middleware,\n      onPosition: _onPosition,\n      strategy: strategy\n    });\n\n    // To solve \"loop limit exceeds\" problem from the ResizeObserver in autoUpdate\n    // we need to make sure that we utilize autoUpdate function\n    // after the Floating component is positioned and has x, y coordinates.\n    const [isPositioned, setIsPositioned] = useState(false);\n\n    // here autoUpdate should be called only once during the Component lifecycle,\n    // if the floating, reference, placement and middleware do not change\n    useEffect(() => {\n      if (!refs.reference.current || !refs.floating.current || isPositioned !== true) {\n        return;\n      }\n\n      return autoUpdate(refs.reference.current, refs.floating.current, update);\n    }, [refs.floating, refs.reference, update, isPositioned]);\n\n    // here we should know when the Floating is positioned\n    useEffect(() => {\n      if (x != null && y != null) {\n        setIsPositioned(true);\n      }\n    }, [x, y]);\n\n    useOutsideClick({ isDisabled: false, ref: refs.floating, handler: onClickOutside });\n\n    function createVirtualElement(\n      domRef: Element | null,\n      data: {\n        axis: 'x' | 'y' | 'both';\n        x: number | null;\n        y: number | null;\n      }\n    ) {\n      let offsetX: number | null = null;\n      let offsetY: number | null = null;\n      let isAutoUpdateEvent = false;\n\n      return {\n        contextElement: domRef || undefined,\n        getBoundingClientRect() {\n          const domRect = domRef?.getBoundingClientRect() || {\n            width: 0,\n            height: 0,\n            x: 0,\n            y: 0\n          };\n\n          const isXAxis = data.axis === 'x' || data.axis === 'both';\n          const isYAxis = data.axis === 'y' || data.axis === 'both';\n\n          let width = domRect.width;\n          let height = domRect.height;\n          let x = domRect.x;\n          let y = domRect.y;\n\n          if (offsetX == null && data.x && isXAxis) {\n            offsetX = domRect.x - data.x;\n          }\n\n          if (offsetY == null && data.y && isYAxis) {\n            offsetY = domRect.y - data.y;\n          }\n\n          x -= offsetX || 0;\n          y -= offsetY || 0;\n          width = 0;\n          height = 0;\n\n          if (!isAutoUpdateEvent) {\n            width = data.axis === 'y' ? domRect.width : 0;\n            height = data.axis === 'x' ? domRect.height : 0;\n            x = isXAxis && data.x != null ? data.x : x;\n            y = isYAxis && data.y != null ? data.y : y;\n          } else if (isAutoUpdateEvent) {\n            height = data.axis === 'x' ? domRect.height : height;\n            width = data.axis === 'y' ? domRect.width : width;\n          }\n\n          isAutoUpdateEvent = true;\n          const virtEl = {\n            width,\n            height,\n            x,\n            y,\n            top: y,\n            right: x + width,\n            bottom: y + height,\n            left: x\n          };\n\n          return virtEl;\n        }\n      };\n    }\n\n    useLayoutEffect(() => {\n      if (isElement(previousAnchor)) {\n        const element = previousAnchor as Element;\n        reference(element);\n        return;\n      }\n      const coords = previousAnchor as Coords;\n      if (coords != null && coords.contextElement != null) {\n        const virtualEl = createVirtualElement(coords.contextElement, {\n          axis: 'both',\n          x: coords.x,\n          y: coords.y\n        });\n        reference(virtualEl);\n        return;\n      }\n      const virtualEl: VirtualElement = {\n        getBoundingClientRect() {\n          return {\n            width: 0,\n            height: 0,\n            x: coords!.x,\n            y: coords!.y,\n            top: coords!.y,\n            left: coords!.x,\n            right: coords!.x,\n            bottom: coords!.y\n          };\n        }\n      };\n      if (coords && coords.x != null) {\n        reference(virtualEl);\n      }\n    }, [previousAnchor, reference]);\n\n    const stableRef = useMemo(() => mergeRefs(ref, floating), [ref, floating]);\n    const positionStyle = { top: y, left: x };\n\n    let assignedVars = {}; // empty var override unless background is specified\n    if (backgroundColor) {\n      assignedVars = assignInlineVars({\n        [floatingVars.backgroundColor]: backgroundColor\n      });\n    }\n\n    const visibilityStyles =\n      x == null && y == null ? floatingVisibilityStyles.hidden : floatingVisibilityStyles.visible;\n    const floatingClasses = classNames([className, baseTheme, styles.baseStyle, visibilityStyles]);\n    const isAnchorMounted = anchorRef && anchorRef.current;\n    const content = (\n      <div class={floatingClasses} ref={stableRef} style={{ ...positionStyle, ...assignedVars }}>\n        {children}\n        {isAnchorMounted && (\n          <FloatingTail\n            ref={arrowRef}\n            backgroundColor={backgroundColor}\n            data={positionData}\n            anchorRef={unsafeAnchorRef}\n            tail={tail}\n            isRtl={isRtl}\n          />\n        )}\n      </div>\n    );\n    return content;\n  }\n);\n"],"names":["FloatingTail","forwardRef","data","anchorRef","tail","isRtl","backgroundColor","ref","styles","baseTheme","useComponentTheme","FloatingRedwoodTheme","arrowRef","useRef","arrowStyles","setArrowStyles","useState","arrowStyle","visibility","arrowInnerStyle","useLayoutEffect","current","isCornerVerticalPlacement","isCornerHorizontalPlacement","arrow","centerOffset","arrowSize","anchorRefHeight","anchorRefWidth","isAnchorRefElement","undefined","x","y","Math","round","getBoundingClientRect","height","width","abs","includes","origPlacement","isCorner","result","innerResult","arrowSizeCorner","arrowInnerSize","arrowInnerSizeCorner","isCenter","isCenterOffsetPositive","setArrowSizes","isCornerPlacement","arrowFinalSize","setArrowStyle","borderTop","getSize","rgba","colorSchemeVars","palette","neutral","borderRight","getTransparentBorder","borderLeft","arrowInnerFinalSize","setArrowInnerStyle","style","Object","assign","getTurn","eighth","size","placement","split","setArrowTop","setArrowStart","setArrowEnd","setArrowBottom","top","bottom","left","transform","setCornerArrowInner","setNonCornerArrowInner","right","setStyles","offset","stableRef","useMemo","mergeRefs","_jsxs","class","classNames","floatingTailBaseStyle","children","_jsx","Floating","onClickOutside","offsetValue","className","flipOptions","mainAxis","crossAxis","shiftOptions","sizeOptions","isMaxHeightAdjusted","isMaxWidthAdjusted","boundaryOptions","padding","onPosition","strategy","positionData","setPositionData","unsafeAnchorRef","useUnsafeDomElementRef","previousAnchor","setPreviousAnchor","direction","useUser","_onPosition","useCallback","middleware","flip","fallbackPlacements","map","logicalSide","shift","limiter","limitShift","element","push","apply","availableWidth","availableHeight","elements","parseInt","floating","maxHeight","min","maxHeightCeiling","maxWidth","maxWidthCeiling","reference","refs","update","useFloating","isPositioned","setIsPositioned","useEffect","autoUpdate","useOutsideClick","isDisabled","handler","Element","coords","contextElement","virtualEl","domRef","offsetX","offsetY","isAutoUpdateEvent","domRect","isXAxis","axis","isYAxis","createVirtualElement","positionStyle","assignedVars","assignInlineVars","floatingVars","visibilityStyles","floatingVisibilityStyles","hidden","visible","floatingClasses","baseStyle","isAnchorMounted"],"mappings":"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"}