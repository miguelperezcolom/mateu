{"version":3,"file":"toggleButtonUtils-0ebe4c56.js","sources":["../../src/utils/UNSAFE_buttonUtils/toggleButtonUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { StylingOptions } from '../../UNSAFE_BaseButton';\nimport { ButtonSetPosition, LayoutWidths, InputTypes } from './toggle.types';\nimport type { ToggleButtonTypes } from './toggle.types';\n\n/**\n * Maps a position to the required button styling classes.\n * @param position the toggle location in the buttonSetItem\n * @return an array of styling classes\n */\nfunction positionStyling(position?: ButtonSetPosition): StylingOptions[] {\n  let positionStyling = [] as StylingOptions[];\n  switch (position) {\n    case 'start':\n      positionStyling = ['noBorderRadiusEnd', 'noBorderEnd'];\n      break;\n    case 'end':\n      positionStyling = ['noBorderRadiusStart', 'noBorderStart'];\n      break;\n    case 'middle':\n      positionStyling = [\n        'noBorderRadiusEnd',\n        'noBorderEnd',\n        'noBorderRadiusStart',\n        'noBorderStart'\n      ];\n      break;\n  }\n  return positionStyling;\n}\n\n/**\n * Convert a child index to a position\n * ie, [start, middle, middle, end]\n */\nexport function indexToPosition(index: number, length: number): ButtonSetPosition {\n  if (length === 1) {\n    return 'single';\n  }\n  if (!index) {\n    return 'start';\n  }\n  if (index === length - 1) {\n    return 'end';\n  }\n  return 'middle';\n}\n\n/**\n * Convert width styling to styling classes\n * @param layoutWidth\n * @returns an array of styling classes\n */\n\nfunction layoutWidthStyling(layoutWidth: LayoutWidths): StylingOptions[] {\n  return layoutWidth === 'equal' ? ['widthEqual'] : ['widthAuto'];\n}\n\n/**\n * Returns the styling classes for a toggle button based on state\n * @param layoutWidth\n * @param isSelected\n * @param isSwitch\n * @param isInput\n * @param position\n * @param hasLabel\n * @param isIconOnly\n * @returns\n */\nexport function toggleStyling(\n  layoutWidth: LayoutWidths = 'auto',\n  isSelected: boolean,\n  isSwitch: boolean,\n  isInput: boolean,\n  isAdjacent?: boolean,\n  position?: ButtonSetPosition,\n  hasLabel?: boolean,\n  isIconOnly?: boolean,\n  isNewStackingContext = false\n): StylingOptions[] {\n  const selectedStyling = isSelected && !isSwitch ? ['selected'] : [];\n  const iconStyling = isIconOnly ? ['min'] : [];\n  const inputStyling = isInput ? ['embedded', 'min'] : [];\n  const labelOnlyStyling = !isIconOnly ? (hasLabel ? ['default'] : ['min']) : ['min'];\n  const positionStyles = isAdjacent ? positionStyling(position) : [];\n  const layoutWidthStyles = isIconOnly ? [] : layoutWidthStyling(layoutWidth);\n  const newStackingContextStyling = isNewStackingContext ? ['newStackingContext'] : [];\n  const buttonSetItemStyles =\n    position === 'single'\n      ? []\n      : position === 'middle' || position === 'end'\n      ? ['buttonSetItem', 'trailingItem']\n      : ['buttonSetItem'];\n  const styling: StylingOptions[] = [\n    ...inputStyling,\n    ...selectedStyling,\n    ...iconStyling,\n    ...positionStyles,\n    ...buttonSetItemStyles,\n    ...layoutWidthStyles,\n    ...labelOnlyStyling,\n    ...newStackingContextStyling\n  ] as StylingOptions[];\n  return styling;\n}\n\n/**\n * Merge buttonset input type choices with prop toggle type\n * @param inputType\n * @param buttonSetInputType\n * @returns\n */\n\nexport function isMergedInputs(\n  inputType: ToggleButtonTypes,\n  buttonSetInputType?: InputTypes\n): boolean {\n  return (\n    (buttonSetInputType && buttonSetInputType.length > 0) ||\n    inputType === 'radio' ||\n    inputType === 'checkbox'\n  );\n}\n/**\n * Used to toggle the value in a ButtonSetItem.\n * A checkbox can have 0 or many selected.\n * @param value\n * @param buttonSetValue\n * @returns\n */\nexport function toggleButtonSetItem(value: string, buttonSetValue?: Array<string>): Array<string> {\n  // create a new set from the previous and add or remove the changed value\n  if (!buttonSetValue) {\n    return [value];\n  }\n  return buttonSetValue.includes(value)\n    ? buttonSetValue.filter((i) => i !== value)\n    : [...buttonSetValue, value];\n}\n"],"names":["index","length","value","buttonSetValue","includes","filter","i","layoutWidth","isSelected","isSwitch","isInput","isAdjacent","position","hasLabel","isIconOnly","isNewStackingContext","selectedStyling","iconStyling","inputStyling","labelOnlyStyling","positionStyles","positionStyling","layoutWidthStyles","layoutWidthStyling"],"mappings":"+DA0CgB,SAAgBA,EAAeC,GAC7C,OAAe,IAAXA,EACK,SAEJD,EAGDA,IAAUC,EAAS,EACd,MAEF,SALE,OAMX,wBAoFgB,SAAoBC,EAAeC,GAEjD,OAAKA,EAGEA,EAAeC,SAASF,GAC3BC,EAAeE,QAAQC,GAAMA,IAAMJ,IACnC,IAAIC,EAAgBD,GAJf,CAACA,EAKZ,kBArEM,SACJK,EAA4B,OAC5BC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAAuB,GAEvB,MAAMC,EAAkBR,IAAeC,EAAW,CAAC,YAAc,GAC3DQ,EAAcH,EAAa,CAAC,OAAS,GACrCI,EAAeR,EAAU,CAAC,WAAY,OAAS,GAC/CS,EAAoBL,EAAkD,CAAC,OAArCD,EAAW,CAAC,WAAa,CAAC,OAC5DO,EAAiBT,EA1EzB,SAAyBC,GACvB,IAAIS,EAAkB,GACtB,OAAQT,GACN,IAAK,QACHS,EAAkB,CAAC,oBAAqB,eACxC,MACF,IAAK,MACHA,EAAkB,CAAC,sBAAuB,iBAC1C,MACF,IAAK,SACHA,EAAkB,CAChB,oBACA,cACA,sBACA,iBAIN,OAAOA,CACT,CAuDsCA,CAAgBT,GAAY,GAC1DU,EAAoBR,EAAa,GA/BzC,SAA4BP,GAC1B,MAAuB,UAAhBA,EAA0B,CAAC,cAAgB,CAAC,YACrD,CA6B8CgB,CAAmBhB,GAkB/D,MAVkC,IAC7BW,KACAF,KACAC,KACAG,KATU,WAAbR,EACI,GACa,WAAbA,GAAsC,QAAbA,EACzB,CAAC,gBAAiB,gBAClB,CAAC,oBAOFU,KACAH,KAd6BJ,EAAuB,CAAC,sBAAwB,GAkBpF"}