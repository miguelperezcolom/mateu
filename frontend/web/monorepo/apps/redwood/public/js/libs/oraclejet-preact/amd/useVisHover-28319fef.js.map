{"version":3,"file":"useVisHover-28319fef.js","sources":["../../src/hooks/PRIVATE_useVisHover/useVisHover.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useState, useRef, useCallback } from 'preact/hooks';\n\nconst TOUCH_HOLD_THRESHOLD_MS = 200;\n\n/**\n * Returns the event handlers for visualization hover gestures.\n */\nexport function useVisHover(\n  onHover: (event: PointerEvent) => void,\n  onHoverEnter?: (event: PointerEvent, currentTarget: HTMLElement) => void,\n  onHoverLeave?: () => void,\n  touchResponse: 'touchStart' | 'touchHold' = 'touchStart',\n  isDisabled = false\n) {\n  const [isTouchHovering, setIsTouchHovering] = useState(false);\n  const touchTimeoutId = useRef<ReturnType<typeof setTimeout>>();\n\n  const onTouchMove = useCallback(\n    (event: TouchEvent) => {\n      // Disable browser handling of touch gestures such as panning.\n      if (isTouchHovering) event.preventDefault();\n    },\n    [isTouchHovering]\n  );\n\n  const onPointerDown = useCallback(\n    (event: PointerEvent) => {\n      if (event.pointerType === 'touch') {\n        // useDatatip currently depends on event.currentTarget during onHoverEnter\n        // On 'touchHold', the event.currentTarget would be accessed in a setTimeout,\n        // at which point it becomes null.\n        // Solution for now is to store the currentTarget upfront and pass it as an\n        // argument to onHoverEnter.\n        // TODO: JET-68292 to improve this.\n        const currentTarget = event.currentTarget as HTMLElement;\n        const initiateTouchHover = () => {\n          setIsTouchHovering(true);\n          onHoverEnter?.(event, currentTarget);\n          onHover(event);\n          if ((event.target as Element).hasPointerCapture(event.pointerId)) {\n            (event.target as Element).releasePointerCapture(event.pointerId);\n          }\n        };\n        if (touchResponse === 'touchHold') {\n          touchTimeoutId.current = setTimeout(initiateTouchHover, TOUCH_HOLD_THRESHOLD_MS);\n        } else {\n          initiateTouchHover();\n        }\n      }\n    },\n    [onHoverEnter, onHover, touchResponse]\n  );\n\n  const onPointerMove = useCallback(\n    (event: PointerEvent) => {\n      if (event.pointerType === 'touch' && !isTouchHovering) return;\n      onHover(event);\n    },\n    [onHover, isTouchHovering]\n  );\n\n  const onPointerUp = useCallback(\n    (event: PointerEvent) => {\n      if (event.pointerType === 'touch') {\n        clearTimeout(touchTimeoutId.current);\n        touchTimeoutId.current = undefined;\n        if (isTouchHovering) onHoverLeave?.();\n        setIsTouchHovering(false);\n      }\n    },\n    [onHoverLeave, isTouchHovering]\n  );\n\n  const onPointerEnter = useCallback(\n    (event: PointerEvent) => {\n      if (event.pointerType === 'touch' && !isTouchHovering) return;\n      onHoverEnter?.(event, event.currentTarget as HTMLElement);\n    },\n    [onHoverEnter, isTouchHovering]\n  );\n\n  const onPointerLeave = useCallback(\n    (event: PointerEvent) => {\n      if (event.pointerType === 'touch' && !isTouchHovering) return;\n      onHoverLeave?.();\n    },\n    [onHoverLeave, isTouchHovering]\n  );\n\n  const onPointerCancel = useCallback(\n    (event: PointerEvent) => {\n      if (event.pointerType === 'touch' && !isTouchHovering) {\n        clearTimeout(touchTimeoutId.current);\n        touchTimeoutId.current = undefined;\n      }\n    },\n    [isTouchHovering]\n  );\n\n  return isDisabled\n    ? {}\n    : {\n        onTouchMove,\n        onPointerDown,\n        onPointerUp,\n        onPointerMove,\n        onPointerEnter,\n        onPointerLeave,\n        onPointerCancel\n      };\n}\n"],"names":["onHover","onHoverEnter","onHoverLeave","touchResponse","isDisabled","isTouchHovering","setIsTouchHovering","useState","touchTimeoutId","useRef","onTouchMove","useCallback","event","preventDefault","onPointerDown","pointerType","currentTarget","initiateTouchHover","target","hasPointerCapture","pointerId","releasePointerCapture","current","setTimeout","onPointerMove","onPointerUp","clearTimeout","undefined","onPointerEnter","onPointerLeave","onPointerCancel"],"mappings":"4EAegB,SACdA,EACAC,EACAC,EACAC,EAA4C,aAC5CC,GAAa,GAEb,MAAOC,EAAiBC,GAAsBC,EAAQA,UAAC,GACjDC,EAAiBC,EAAAA,SAEjBC,EAAcC,eACjBC,IAEKP,GAAiBO,EAAMC,gBAAgB,GAE7C,CAACR,IAGGS,EAAgBH,eACnBC,IACC,GAA0B,UAAtBA,EAAMG,YAAyB,CAOjC,MAAMC,EAAgBJ,EAAMI,cACtBC,EAAqB,KACzBX,GAAmB,GACnBL,IAAeW,EAAOI,GACtBhB,EAAQY,GACHA,EAAMM,OAAmBC,kBAAkBP,EAAMQ,YACnDR,EAAMM,OAAmBG,sBAAsBT,EAAMQ,UACvD,EAEmB,cAAlBjB,EACFK,EAAec,QAAUC,WAAWN,EA1Cd,KA4CtBA,GAEH,IAEH,CAAChB,EAAcD,EAASG,IAGpBqB,EAAgBb,eACnBC,KAC2B,UAAtBA,EAAMG,aAA4BV,IACtCL,EAAQY,EAAM,GAEhB,CAACZ,EAASK,IAGNoB,EAAcd,eACjBC,IAC2B,UAAtBA,EAAMG,cACRW,aAAalB,EAAec,SAC5Bd,EAAec,aAAUK,EACrBtB,GAAiBH,MACrBI,GAAmB,GACpB,GAEH,CAACJ,EAAcG,IAGXuB,EAAiBjB,eACpBC,KAC2B,UAAtBA,EAAMG,aAA4BV,IACtCJ,IAAeW,EAAOA,EAAMI,cAA6B,GAE3D,CAACf,EAAcI,IAGXwB,EAAiBlB,eACpBC,KAC2B,UAAtBA,EAAMG,aAA4BV,IACtCH,KAAgB,GAElB,CAACA,EAAcG,IAGXyB,EAAkBnB,eACrBC,IAC2B,UAAtBA,EAAMG,aAA4BV,IACpCqB,aAAalB,EAAec,SAC5Bd,EAAec,aAAUK,EAC1B,GAEH,CAACtB,IAGH,OAAOD,EACH,CAAE,EACF,CACEM,cACAI,gBACAW,cACAD,gBACAI,iBACAC,iBACAC,kBAER"}