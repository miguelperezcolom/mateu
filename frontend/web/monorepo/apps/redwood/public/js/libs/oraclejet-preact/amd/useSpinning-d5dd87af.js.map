{"version":3,"file":"useSpinning-d5dd87af.js","sources":["../../src/hooks/UNSAFE_useSpinning/useSpinning.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useCallback, useEffect, useRef } from 'preact/hooks';\nimport { useToggle } from '../UNSAFE_useToggle';\n\nconst SPIN_DELAY = 500;\nconst SPIN_INTERVAL = 40;\n\nexport type StepDirection = 'increase' | 'decrease';\n\nexport type StepEvent = {\n  /**\n   * The direction of the requested step.\n   */\n  direction: StepDirection;\n};\n\nexport type StepProps = {\n  /**\n   * Controls whether step down is disabled.\n   */\n  isStepDownDisabled?: boolean;\n\n  /**\n   * Controls whether step up is disabled.\n   */\n  isStepUpDisabled?: boolean;\n\n  /**\n   * Called when a continuous step is requested (aka \"spin\")\n   * by holding down the arrow up or arrow down keys, or\n   * by pressing and holding down a step button.\n   */\n  onSpin?: (event: StepEvent) => void;\n\n  /**\n   * Called when spinning is complete and the user has\n   * released the arrow key or step button.\n   */\n  onSpinComplete?: () => void;\n\n  /**\n   * Called when a single step is requested by clicking a step button\n   * or by pressing the arrow up or arrow down keys.\n   */\n  onStep?: (event: StepEvent) => void;\n};\n\n/**\n * A hook that provides keyboard and pointer event handlers that can be spread\n * onto any component that wants to support stepping and spinning through the\n * Arrow Up or Down Keys, or by clicking a StepButton. Holding down the key\n * or button first emits a step, then waits for SPIN_DELAY before producing\n * continuous step events (aka spinning) for every SPIN_INTERVAL.\n *\n * @param isStepDownDisabled Controls whether stepping down is disabled\n * @param isStepUpDisabled Controls whether stepping up is disabled\n * @param onSpin Called when a continuous step (aka spin) is requested\n * @param onSpinComplete Called when spinning is complete\n * @param onStep Called when a single step is requested\n * @returns Keyboard and pointer event handlers\n */\nexport const useSpinning = ({\n  isStepDownDisabled,\n  isStepUpDisabled,\n  onSpin,\n  onSpinComplete,\n  onStep\n}: StepProps) => {\n  const { bool: isStarted, setTrue: setStartedTrue, setFalse: setStartedFalse } = useToggle(false);\n  const {\n    bool: isSpinning,\n    setTrue: setSpinningTrue,\n    setFalse: setSpinningFalse\n  } = useToggle(false);\n  const startTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const spinTimerRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const directionRef = useRef<StepDirection>('increase');\n  const spinCompleteRef = useRef(false);\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (!(event.key === 'ArrowDown' || event.key === 'ArrowUp')) {\n        return;\n      }\n      // By default, pressing the arrow keys moves the cursor to the\n      // beginning or end which we don't want, so call preventDefault.\n      // We also want to stop propagation of handled events.\n      event.preventDefault();\n      event.stopPropagation();\n\n      if (isStarted) {\n        // If already started, ignore repeated key down events.\n        return;\n      }\n      if (\n        (event.key === 'ArrowDown' && isStepDownDisabled) ||\n        (event.key === 'ArrowUp' && isStepUpDisabled)\n      ) {\n        // If requested step is disabled, return.\n        return;\n      }\n      directionRef.current = event.key === 'ArrowDown' ? 'decrease' : 'increase';\n      setStartedTrue();\n      // Do an initial step, which is what oj-input-number did as well.\n      onStep?.({ direction: directionRef.current });\n    },\n    [isStarted, onStep, isStepDownDisabled, isStepUpDisabled, setStartedTrue]\n  );\n\n  const onKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {\n        if (isSpinning) {\n          // Only want to call onSpinComplete if we were actually spinning.\n          spinCompleteRef.current = true;\n        }\n        setStartedFalse();\n        setSpinningFalse();\n        event.stopPropagation();\n      }\n    },\n    [isSpinning, setStartedFalse, setSpinningFalse]\n  );\n\n  const onIncreasePointerDown = useCallback(\n    (event: PointerEvent) => {\n      // Similar to Arrow Up, stop propagation of the event, start the timer, and\n      // do an initial 'increase' step.\n      event.stopPropagation();\n      // We don't want the step buttons getting focus, so call preventDefault.\n      event.preventDefault();\n\n      if (isStepUpDisabled) {\n        return;\n      }\n      directionRef.current = 'increase';\n      setStartedTrue();\n      onStep?.({ direction: directionRef.current });\n    },\n    [onStep, isStepUpDisabled, setStartedTrue]\n  );\n\n  const onDecreasePointerDown = useCallback(\n    (event: PointerEvent) => {\n      // Similar to Arrow Down, stop propagation of the event, start the timer, and\n      // do an initial 'decrease' step.\n      event.stopPropagation();\n      // We don't want the step buttons getting focus, so call preventDefault.\n      event.preventDefault();\n\n      if (isStepDownDisabled) {\n        return;\n      }\n      directionRef.current = 'decrease';\n      setStartedTrue();\n      onStep?.({ direction: directionRef.current });\n    },\n    [onStep, isStepDownDisabled, setStartedTrue]\n  );\n\n  const onPointerUpOutOrCancel = useCallback(\n    // Handle spin cancellation on pointer up, out, or cancel.\n    // This is for both the increase and decrease cases.\n    (event: PointerEvent) => {\n      if (isSpinning) {\n        spinCompleteRef.current = true;\n      }\n      setStartedFalse();\n      setSpinningFalse();\n      event.stopPropagation();\n    },\n    [isSpinning, setStartedFalse, setSpinningFalse]\n  );\n\n  useEffect(() => {\n    if (isStarted && !startTimerRef.current) {\n      startTimerRef.current = setTimeout(() => {\n        setSpinningTrue();\n      }, SPIN_DELAY);\n    }\n    return () => {\n      // Clean up between renders.\n      if (startTimerRef.current) {\n        clearTimeout(startTimerRef.current);\n        startTimerRef.current = null;\n      }\n    };\n  }, [isStarted, setSpinningTrue]);\n\n  useEffect(() => {\n    if (!isSpinning) {\n      if (spinTimerRef.current) {\n        clearInterval(spinTimerRef.current);\n        spinTimerRef.current = null;\n      }\n    } else {\n      if (!spinTimerRef.current) {\n        spinTimerRef.current = setInterval(() => {\n          // If further spinning is disabled, call setSpinningFalse to\n          // clean up the timer otherwise repeat the step.\n          if (\n            (directionRef.current === 'increase' && isStepUpDisabled) ||\n            (directionRef.current === 'decrease' && isStepDownDisabled)\n          ) {\n            setSpinningFalse();\n            spinCompleteRef.current = true;\n          } else {\n            onSpin?.({ direction: directionRef.current });\n          }\n        }, SPIN_INTERVAL);\n      }\n    }\n    return () => {\n      // Clean up between renders.\n      if (spinTimerRef.current) {\n        clearInterval(spinTimerRef.current);\n        spinTimerRef.current = null;\n      }\n    };\n  }, [isSpinning, isStepDownDisabled, isStepUpDisabled, onSpin, setSpinningFalse]);\n\n  // Only want to run this effect when isSpinning is false and our ref is true.\n  // This helps guarantee onSpinComplete is only called once after spinning stops,\n  // even if onSpinComplete's identity is changing.\n  useEffect(() => {\n    if (!isSpinning && spinCompleteRef.current) {\n      spinCompleteRef.current = false;\n      onSpinComplete?.();\n    }\n  }, [isSpinning, onSpinComplete]);\n\n  // Handlers for arrow key up and down events.\n  const keyboardHandlerProps = { onKeyDown, onKeyUp };\n\n  // Handlers for pointer events on a step button that increases the value.\n  const pointerIncreaseHandlerProps = {\n    onPointerDown: onIncreasePointerDown,\n    onPointerUp: onPointerUpOutOrCancel,\n    onPointerOut: onPointerUpOutOrCancel,\n    onPointerCancel: onPointerUpOutOrCancel\n  };\n\n  // Handlers for pointer events on a step button that decreases the value.\n  const pointerDecreaseHandlerProps = {\n    onPointerDown: onDecreasePointerDown,\n    onPointerUp: onPointerUpOutOrCancel,\n    onPointerOut: onPointerUpOutOrCancel,\n    onPointerCancel: onPointerUpOutOrCancel\n  };\n\n  return { keyboardHandlerProps, pointerIncreaseHandlerProps, pointerDecreaseHandlerProps };\n};\n"],"names":["isStepDownDisabled","isStepUpDisabled","onSpin","onSpinComplete","onStep","bool","isStarted","setTrue","setStartedTrue","setFalse","setStartedFalse","useToggle","isSpinning","setSpinningTrue","setSpinningFalse","startTimerRef","useRef","spinTimerRef","directionRef","spinCompleteRef","onKeyDown","useCallback","event","key","preventDefault","stopPropagation","current","direction","onKeyUp","onIncreasePointerDown","onDecreasePointerDown","onPointerUpOutOrCancel","useEffect","setTimeout","clearTimeout","setInterval","clearInterval","keyboardHandlerProps","pointerIncreaseHandlerProps","onPointerDown","onPointerUp","onPointerOut","onPointerCancel","pointerDecreaseHandlerProps"],"mappings":"qGAoE2B,EACzBA,qBACAC,mBACAC,SACAC,iBACAC,aAEA,MAAQC,KAAMC,EAAWC,QAASC,EAAgBC,SAAUC,GAAoBC,aAAU,IAExFN,KAAMO,EACNL,QAASM,EACTJ,SAAUK,GACRH,aAAU,GACRI,EAAgBC,SAA6C,MAC7DC,EAAeD,SAA8C,MAC7DE,EAAeF,SAAsB,YACrCG,EAAkBH,UAAO,GAEzBI,EAAYC,eACfC,IACqB,cAAdA,EAAMC,KAAqC,YAAdD,EAAMC,MAMzCD,EAAME,iBACNF,EAAMG,kBAEFnB,GAKa,cAAdgB,EAAMC,KAAuBvB,GACf,YAAdsB,EAAMC,KAAqBtB,IAK9BiB,EAAaQ,QAAwB,cAAdJ,EAAMC,IAAsB,WAAa,WAChEf,IAEAJ,IAAS,CAAEuB,UAAWT,EAAaQ,WAAU,GAE/C,CAACpB,EAAWF,EAAQJ,EAAoBC,EAAkBO,IAGtDoB,EAAUP,eACbC,IACmB,cAAdA,EAAMC,KAAqC,YAAdD,EAAMC,MACjCX,IAEFO,EAAgBO,SAAU,GAE5BhB,IACAI,IACAQ,EAAMG,kBACP,GAEH,CAACb,EAAYF,EAAiBI,IAG1Be,EAAwBR,eAC3BC,IAGCA,EAAMG,kBAENH,EAAME,iBAEFvB,IAGJiB,EAAaQ,QAAU,WACvBlB,IACAJ,IAAS,CAAEuB,UAAWT,EAAaQ,UAAU,GAE/C,CAACtB,EAAQH,EAAkBO,IAGvBsB,EAAwBT,eAC3BC,IAGCA,EAAMG,kBAENH,EAAME,iBAEFxB,IAGJkB,EAAaQ,QAAU,WACvBlB,IACAJ,IAAS,CAAEuB,UAAWT,EAAaQ,UAAU,GAE/C,CAACtB,EAAQJ,EAAoBQ,IAGzBuB,EAAyBV,EAAWA,aAGvCC,IACKV,IACFO,EAAgBO,SAAU,GAE5BhB,IACAI,IACAQ,EAAMG,iBAAiB,GAEzB,CAACb,EAAYF,EAAiBI,IAGhCkB,EAAAA,WAAU,KACJ1B,IAAcS,EAAcW,UAC9BX,EAAcW,QAAUO,YAAW,KACjCpB,GAAiB,GA7KN,MAgLR,KAEDE,EAAcW,UAChBQ,aAAanB,EAAcW,SAC3BX,EAAcW,QAAU,KACzB,IAEF,CAACpB,EAAWO,IAEfmB,EAAAA,WAAU,KACHpB,EAMEK,EAAaS,UAChBT,EAAaS,QAAUS,aAAY,KAIL,aAAzBjB,EAAaQ,SAA0BzB,GACd,aAAzBiB,EAAaQ,SAA0B1B,GAExCc,IACAK,EAAgBO,SAAU,GAE1BxB,IAAS,CAAEyB,UAAWT,EAAaQ,SACpC,GA3MW,KA0LZT,EAAaS,UACfU,cAAcnB,EAAaS,SAC3BT,EAAaS,QAAU,MAmBpB,KAEDT,EAAaS,UACfU,cAAcnB,EAAaS,SAC3BT,EAAaS,QAAU,KACxB,IAEF,CAACd,EAAYZ,EAAoBC,EAAkBC,EAAQY,IAK9DkB,EAAAA,WAAU,MACHpB,GAAcO,EAAgBO,UACjCP,EAAgBO,SAAU,EAC1BvB,MACD,GACA,CAACS,EAAYT,IAqBhB,MAAO,CAAEkC,qBAlBoB,CAAEjB,YAAWQ,WAkBXU,4BAfK,CAClCC,cAAeV,EACfW,YAAaT,EACbU,aAAcV,EACdW,gBAAiBX,GAWyCY,4BAPxB,CAClCJ,cAAeT,EACfU,YAAaT,EACbU,aAAcV,EACdW,gBAAiBX,GAGsE"}