{"version":3,"file":"Dialog-b6be33fd.js","sources":["../../src/UNSAFE_Dialog/Dialog.tsx"],"sourcesContent":["import type { ComponentChild, RefObject, JSX } from 'preact';\nimport { ForwardedRef, forwardRef } from 'preact/compat';\nimport { Offset, WindowOverlay, WindowOverlayPlacement } from '../UNSAFE_WindowOverlay';\nimport { TestIdProps, useTestId } from '../hooks/UNSAFE_useTestId';\nimport { useAnimation } from '../hooks/UNSAFE_useAnimation';\nimport { useEffect, useRef, useCallback, useMemo, useState } from 'preact/hooks';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\n\nimport { DialogRedwoodTheme } from './themes/redwood/DialogTheme';\nimport { DialogStyles } from './themes/DialogStyles.css';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\nimport { Layer } from '../UNSAFE_Layer';\nimport { Modal } from '../UNSAFE_Modal';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { globalImages } from '#/ImageVars.css';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { dimensionInterpolations, DimensionProps } from '../utils/UNSAFE_interpolations/dimensions';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { useResizeObserver } from '../hooks/UNSAFE_useResizeObserver';\n\nimport { DraggableProps, useDraggable } from '../hooks/PRIVATE_useDraggable';\nimport { Floating, Coords } from '../UNSAFE_Floating';\nimport { IconButton } from '../UNSAFE_IconButton';\nimport { CloseIcon } from '../PRIVATE_ThemedIcons/CloseIcon';\nimport { Resizable, ResizableConstraints } from '../PRIVATE_Resizable/Resizable';\nimport { Position, Rect } from '../utils/UNSAFE_flexibleComponentUtils';\nimport { useBreakpoints } from '../hooks/UNSAFE_useBreakpoints';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { BundleType } from '../resources/nls/bundle';\nimport {\n  SLIDE_DOWN_XLARGE,\n  SLIDE_UP_XLARGE,\n  DURATION_LARGE\n} from '../utils/PRIVATE_animationUtils';\nimport {\n  allTabbableElements,\n  focusOn,\n  focusWithin,\n  getActiveElement\n} from '../utils/PRIVATE_tabbableUtils';\n\nimport type { UnsafeDomHandle } from '#utils/UNSAFE_unsafeDomAccess';\nimport { UNSAFE_DOM_ACCESS } from '#utils/UNSAFE_unsafeDomAccess';\n\n// dialog states\ntype Status = 'initial' | 'opening' | 'closing' | 'unmounted';\ntype VisibilityStatus = 'hidden' | 'visible';\ntype Animations = 'zoomIn' | 'zoomOut' | 'slideUp' | 'slideDown';\n\ntype IntrinsicProps = Pick<UnpackSignals<JSX.IntrinsicElements['div']>, 'children' | 'role'>;\n\ntype OnCloseDetail = {\n  /**\n   * reason for closing the dialog\n   */\n  reason: 'escapeKey' | 'icon';\n};\n\nexport type CancelBehavior = 'none' | 'escape' | 'icon';\n\ntype DialogProps = IntrinsicProps &\n  DimensionProps & {\n    /**\n     * Optional ref for an element to focus on when component mounts\n     */\n    autoFocusRef?: RefObject<{ focus: () => void }>;\n\n    /**\n     * On Close callback.\n     */\n    onClose?: (detail: OnCloseDetail) => void;\n\n    /**\n     * On opening or closing transition end callback.\n     */\n    onTransitionEnd?: (value: boolean) => void;\n\n    /**\n     * Determines whether the Dialog is open.\n     */\n    isOpen: boolean;\n\n    /**\n     * Dialog header content. Can be a string or VNode (Component Child).\n     * <p>\n     * When a plain string is passed, it will be used as the dialog title. Otherwise, the prop value\n     * will be used as the header content.\n     * </p>\n     * <p>\n     * Dialog will automatically refer to the header content as the accessible label.\n     * The user can override this behavior by specifying the <code>aria-labelledby</code> property\n     * and setting its value as needed.\n     * </p>\n     */\n    header?: ComponentChild;\n\n    /**\n     * Dialog footer content.\n     */\n    footer?: ComponentChild;\n\n    /**\n     * Determines dialog modality. Default is 'modal'.\n     */\n    modality?: 'modal' | 'modeless';\n\n    /**\n     * Specifies dialog's cancel behavior. Default is 'none'.\n     */\n    cancelBehavior?: CancelBehavior;\n\n    /**\n     * Specifies dialog's launcher. After dialog closes, it returns focus to the launcher.\n     * If not specified, focus goes back to the last active element before dialog opened.\n     */\n    launcherRef?: RefObject<HTMLElement | UnsafeDomHandle<HTMLElement>>;\n\n    /**\n     * Specifies dialog's anchor. Dialog is placed relative to its anchor. If not specified,\n     * it is placed relatively to window.\n     */\n    anchorRef?: RefObject<Element | Coords>;\n\n    /**\n     * Determines placement of the dialog relative to the viewport.\n     * Supported values are:\n     * <p> <code>center</code>, <code>top</code>, <code>top-start</code>, <code>top-end</code>,\n     * <code>end</code>, <code>end-top</code>, <code>end-bottom</code>,\n     * <code>bottom</code>, <code>bottom-start</code>, <code>bottom-end</code>,\n     * <code>start</code>, <code>start-top</code>, <code>start-bottom</code>\n     * </p>\n     * Default is <code>center</code>.\n     */\n    placement?: WindowOverlayPlacement;\n\n    /**\n     * Determines the offset of the Dialog from its core placement along the specified axes.\n     *\n     * Offset could be a number or an object\n     *\n     * An object has the following type:\n     * <pre>\n     *   {\n     *     mainAxis?: number;\n     *     crossAxis?: number;\n     *   }\n     * </pre>\n     * For the <code>center</code> placement the convention for the offset type is that mainAxis defines\n     * offset from the top, crossAxis defines offset from the left side of the view port.\n     *\n     * A number is a shortcut for setting the mainAxis.\n     */\n    offset?: Offset;\n\n    /**\n     * Determines if the Dialog should be sensitive to drag gestures. To create a draggable dialog,\n     * set <code>dragAffordance='header'</code> and specify the <code>onDragMove</code> handler.\n     */\n    dragAffordance?: 'none' | 'header';\n\n    /**\n     * Determines if the Dialog should support resizing. To create a resizable dialog,\n     * set <code>resizeBehavior='resizable'</code> and specify the <code>onResize</code> handler.\n     */\n    resizeBehavior?: 'none' | 'resizable';\n\n    /**\n     * Callback to be invoked if <code>dragAffordance</code> is set to <code>header</code> and a drag gesture is initiated.\n     * The current position is reported in the <code>pos</code> parameter.\n     *\n     * @param pos\n     */\n    onDragStart?: (pos: Position) => void;\n\n    /**\n     * Callback to be invoked if <code>dragAffordance</code> is set to <code>header</code> and a drag gesture is detected.\n     * The current position is reported in the <code>pos</code> parameter.\n     *\n     * @param pos\n     */\n    onDragMove?: (pos: Position) => void;\n\n    /**\n     * Callback to be invoked if <code>dragAffordance</code> is set to <code>header</code> and a drag gesture is completed.\n     * The current position is reported in the <code>pos</code> parameter.\n     *\n     * @param pos\n     */\n    onDragEnd?: (pos: Position) => void;\n\n    /**\n     * Callback to be invoked if <code>resizeBehavior</code> is set to <code>resizable</code> and\n     * a resize gesture is initiated. The current position and dimensions are reported in the\n     * <code>rect</code> parameter.\n     *\n     * @param rect\n     */\n    onResizeStart?: (rect: Rect) => void;\n\n    /**\n     * Callback to be invoked if <code>resizeBehavior</code> is set to <code>resizable</code> and\n     * a resize gesture is detected. The current position and dimensions are reported in the\n     * <code>rect</code> parameter.\n     *\n     * @param rect\n     */\n    onResize?: (rect: Rect) => void;\n\n    /**\n     * Callback to be invoked if <code>resizeBehavior</code> is set to <code>resizable</code> and\n     * a resize gesture is completed. The current position and dimensions are reported in the\n     * <code>rect</code> parameter.\n     *\n     * @param rect\n     */\n    onResizeEnd?: (rect: Rect) => void;\n\n    /**\n     * Specifies callback triggered when initial focus is set or when a modeless dialog receives focus\n     * via the F6 key.\n     */\n    onFocusSet?: () => void;\n\n    /**\n     * Determines if the header decoration should be displayed. The default is <code>on</code>\n     * which renders a textured strip at the top of the dialog header in the Redwood theme.\n     * If set to <code>off</code>, no decoration is rendered.\n     */\n    headerDecoration?: 'off' | 'on';\n\n    /**\n     * Specifies the ARIA role type. Depending on how the dialog is used in the page, the developer\n     * should choose from the following:\n     * <ul>\n     *   <li><code>dialog</code> defines an application window that is designed to interrupt the current\n     *      processing of an application in order to prompt the user to enter information or require\n     *      a response.</li>\n     *   <li><code>alertdialog</code> defines type of dialog that contains an alert message, where initial\n     *      focus goes to an element within the dialog.</li>\n     * </ul>\n     */\n    role?: string;\n\n    /**\n     * Optional <code>aria-labelledby</code> property referring to the content to be used as Dialog's\n     * accessible <label htmlFor=\"\" className=\"\"></label>\n     * If not specified, the Dialog will automatically refer to the entire header content as the accessible label.\n     */\n    'aria-labelledby'?: string;\n\n    /**\n     * Optional accessible description for the dialog.\n     */\n    'aria-describedby'?: string;\n  } & TestIdProps;\n\n// dialog header\ntype DialogHeaderProps = Pick<DialogProps, 'children'> & {\n  id?: string;\n  cancelBehavior?: CancelBehavior;\n  onClose?: (detail: OnCloseDetail) => void;\n  draggableProps?: DraggableProps;\n  headerDecoration?: 'off' | 'on';\n};\n\nconst StyledDialogHeader = ({\n  children,\n  id,\n  cancelBehavior,\n  onClose,\n  draggableProps,\n  headerDecoration = 'on'\n}: DialogHeaderProps) => {\n  const { styles } = useComponentTheme<never, DialogStyles>(DialogRedwoodTheme);\n\n  const classes = classNames([\n    styles.dialogHeaderStyle,\n    ...(headerDecoration === 'on' ? [styles.dialogHeaderDecorationStyle] : [])\n  ]);\n\n  const content: ComponentChild =\n    typeof children === 'string' ? (\n      <h1 id={id} className={styles.dialogTitleStyle}>\n        {children}\n      </h1>\n    ) : (\n      <>{children}</>\n    );\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const handleIconClose = () => {\n    onClose?.({ reason: 'icon' });\n  };\n\n  const closeIcon: ComponentChild =\n    cancelBehavior === 'icon' ? (\n      <div>\n        <div className={styles.dialogHeaderCloseIconStyle}>\n          <IconButton\n            aria-label={translations.message_close()}\n            size=\"sm\"\n            variant=\"ghost\"\n            onAction={handleIconClose}>\n            <CloseIcon />\n          </IconButton>\n        </div>\n      </div>\n    ) : null;\n\n  return (\n    <div className={classes} {...draggableProps}>\n      {content}\n      {closeIcon}\n    </div>\n  );\n};\n\n// dialog footer\n\ntype DialogFooterProps = Pick<DialogProps, 'children'> & {\n  style?: string;\n};\n\nconst StyledDialogFooter = forwardRef(\n  ({ children, style }: DialogFooterProps, ref: ForwardedRef<HTMLDivElement | null>) => {\n    return (\n      <div ref={ref} className={style}>\n        {children}\n      </div>\n    );\n  }\n);\n\n// styled dialog\n\ntype MainProps = Pick<DialogProps, 'children' | 'header' | 'footer' | 'role'> &\n  Pick<UnpackSignals<JSX.IntrinsicElements['div']>, 'style' | 'onKeyDown'> & {\n    visibility: VisibilityStatus;\n    labelId?: string;\n    ariaLabelledBy?: string;\n    ariaDescribedBy?: string;\n    cancelBehavior?: CancelBehavior;\n    draggableProps?: DraggableProps;\n    isResizable?: boolean;\n    headerDecoration?: 'off' | 'on';\n    containerRef?: RefObject<HTMLElement>;\n    onClose?: (detail: OnCloseDetail) => void;\n    onResizeStart?: (rect: Rect) => void;\n    onResize?: (rect: Rect) => void;\n    onResizeEnd?: (rect: Rect) => void;\n    footerRef?: RefObject<HTMLDivElement | null>;\n  } & TestIdProps;\n\nconst StyledDialog = forwardRef(\n  (\n    {\n      children,\n      header,\n      footer,\n      visibility,\n      labelId,\n      role,\n      ariaLabelledBy,\n      ariaDescribedBy,\n      cancelBehavior,\n      draggableProps,\n      isResizable,\n      headerDecoration,\n      containerRef,\n      onClose,\n      onResizeStart,\n      onResize,\n      onResizeEnd,\n      onKeyDown,\n      testId,\n      style,\n      footerRef\n    }: MainProps,\n    ref: ForwardedRef<HTMLDivElement | null>\n  ) => {\n    const elementRef = useRef<HTMLDivElement>(null);\n    const mergedRef = mergeRefs(ref, elementRef);\n\n    // computed dialog dimension limits\n    const sizeConstraints = useRef<ResizableConstraints>();\n\n    const [isSmallHeight, setSmallHeight] = useState<boolean>(false);\n    const isSmallWidth = !useBreakpoints()['md'];\n\n    const { classes: styleClasses, styles } = useComponentTheme<never, DialogStyles>(\n      DialogRedwoodTheme\n    );\n\n    const resizeHandler = useCallback(() => {\n      if (elementRef.current) {\n        if (elementRef.current.clientHeight < 400) {\n          setSmallHeight(true);\n        } else {\n          setSmallHeight(false);\n        }\n        if (elementRef.current) {\n          const cs = window.getComputedStyle(elementRef.current);\n          sizeConstraints.current = {\n            minHeight: parseFloat(cs.minHeight),\n            maxHeight: parseFloat(cs.maxHeight),\n            minWidth: parseFloat(cs.minWidth),\n            maxWidth: parseFloat(cs.maxWidth)\n          };\n        }\n      }\n    }, []);\n\n    // set initial Height\n    useEffect(() => {\n      resizeHandler();\n    }, [resizeHandler]);\n\n    useResizeObserver(elementRef, resizeHandler);\n\n    // for small widths (mobile), use the 'smallWidth' dialog style\n    // otherwise, check for small height to apply 'smallWidth' or 'desktop' styles accordingly\n    const baseStyle = isSmallWidth ? styles.baseStyleSmallWidth : styles.baseStyleDesktop;\n\n    // content should scroll depending on the viewport height\n    // on large screens, the header and footer should be \"sticky\",\n    // at small viewport heights, the entire content should be scrollable\n    const contentStyle = isSmallHeight\n      ? styles.dialogContentStyleNoShrink\n      : styles.dialogContentStyle;\n\n    const visibilityStyle =\n      visibility === 'visible' ? styles.visibilityVisible : styles.visibilityHidden;\n\n    const testIdProps = useTestId(testId);\n\n    return (\n      <FocusTrap restoreFocusRef={false}>\n        <div\n          ref={mergedRef}\n          tabIndex={-1}\n          className={classNames([styleClasses, baseStyle, visibilityStyle, globalImages])}\n          style={style}\n          onKeyDown={onKeyDown}\n          role={role}\n          aria-labelledby={ariaLabelledBy}\n          aria-describedby={ariaDescribedBy}\n          {...testIdProps}>\n          <div className={styles.dialogContainerStyle}>\n            <StyledDialogHeader\n              id={labelId}\n              onClose={onClose}\n              headerDecoration={headerDecoration}\n              cancelBehavior={cancelBehavior}\n              draggableProps={draggableProps}>\n              {header}\n            </StyledDialogHeader>\n            <div className={contentStyle}>\n              <div className={styles.dialogBodyStyle}>{children}</div>\n            </div>\n            <StyledDialogFooter ref={footerRef} style={styles.dialogFooterStyle}>\n              {footer}\n            </StyledDialogFooter>\n          </div>\n          {isResizable && (\n            <Resizable\n              onResizeStart={onResizeStart}\n              onResize={onResize}\n              onResizeEnd={onResizeEnd}\n              containerRef={containerRef}\n              constraints={sizeConstraints.current}></Resizable>\n          )}\n        </div>\n      </FocusTrap>\n    );\n  }\n);\n\n// main Dialog component\n\n/**\n * WAI-ARIA-compliant dialog component. A dialog is a floating window that typically contains\n * a title bar and a content area.\n * The dialog is generally placed on top of the rest of the page content. It can be either modal\n * (only the content in the dialog can be interacted with) or non-modal (it's still possible\n * to interact with content outside of the dialog).\n */\nexport const Dialog = forwardRef(\n  (\n    {\n      children,\n      isOpen,\n      header = '',\n      footer,\n      modality = 'modal',\n      launcherRef,\n      anchorRef,\n      autoFocusRef,\n      placement,\n      offset = 0,\n      cancelBehavior = 'none',\n      dragAffordance = 'none',\n      resizeBehavior = 'none',\n      headerDecoration = 'on',\n      onDragStart,\n      onDragMove,\n      onDragEnd,\n      onResizeStart,\n      onResize,\n      onResizeEnd,\n      onFocusSet,\n      onClose,\n      onTransitionEnd,\n      role = 'dialog',\n      'aria-labelledby': ariaLabelledBy,\n      'aria-describedby': ariaDescribedBy,\n      testId,\n      ...props\n    }: DialogProps,\n    ref: ForwardedRef<HTMLDivElement | null>\n  ) => {\n    const [status, _setStatus] = useState<Status>(isOpen ? 'initial' : 'unmounted');\n    const _status = useRef<Status>(isOpen ? 'initial' : 'unmounted');\n    const setStatus = (s: Status) => {\n      _status.current = s;\n      _setStatus(s);\n    };\n\n    const [visibility, setVisibility] = useState<VisibilityStatus>('hidden');\n\n    const prevStatusRef = useRef<Status>('unmounted');\n\n    const floatingRef = useRef<HTMLDivElement>(null);\n    const contentWrapperRef = useRef<HTMLDivElement | null>(null);\n    const localLauncherRef = useRef<HTMLElement | null>(null);\n    const footerRef = useRef<HTMLDivElement | null>(null);\n\n    const isSmallWidth = !useBreakpoints()['md'];\n    const derivedPlacement = isSmallWidth ? 'bottom' : placement ? placement : 'center';\n    const animationType = isSmallWidth\n      ? status === 'opening'\n        ? 'slideUp'\n        : 'slideDown'\n      : status === 'opening'\n      ? 'zoomIn'\n      : 'zoomOut';\n\n    const uniqueId = useId();\n    const labelId = ariaLabelledBy ? ariaLabelledBy : uniqueId;\n\n    const interpolations = [...Object.values(dimensionInterpolations)];\n    const styleInterpolations = mergeInterpolations<DimensionProps>(interpolations);\n    const { ...styles } = styleInterpolations(props);\n    const shouldReturnFocus = useRef<boolean>(false);\n\n    const setInitialFocus = useCallback(() => {\n      // Focus autoFocusRef if specifed, otherwise focus on first tabbable element\n      // in the Dialog or the Dialog container itself if there is none\n      if (autoFocusRef && autoFocusRef.current) {\n        focusOn(autoFocusRef.current);\n      } else if (footerRef.current && allTabbableElements(footerRef.current).length > 0) {\n        focusWithin(footerRef.current);\n      } else {\n        focusWithin(contentWrapperRef.current as HTMLElement);\n      }\n      onFocusSet?.();\n    }, [autoFocusRef, onFocusSet]);\n\n    const returnFocus = useCallback((): void => {\n      const launcherEl = localLauncherRef.current;\n\n      if (shouldReturnFocus.current && launcherEl) {\n        focusOn(launcherEl);\n        shouldReturnFocus.current = false;\n      }\n    }, []);\n\n    // Animation\n    const { nodeRef } = useAnimation<Animations, HTMLDivElement>(animationType, {\n      animationStates,\n      isAnimatedOnMount: true,\n      onAnimationEnd: () => {\n        if (isOpen) {\n          onTransitionEnd?.(true);\n        } else if (!isOpen) {\n          // Should return focus?\n          // Modeless: check whether Dialog contains focus before it unmounts\n          // Modal: always return focus\n          shouldReturnFocus.current =\n            contentWrapperRef.current?.contains(getActiveElement() as HTMLElement) || false;\n          nodeRef(null);\n          setVisibility('hidden');\n          setStatus('unmounted');\n          onTransitionEnd?.(false);\n        }\n      }\n    });\n\n    const mergedRef = useMemo(() => mergeRefs(contentWrapperRef, ref), [contentWrapperRef, ref]);\n\n    const launcherKeyDownCallback = useCallback(\n      (event: KeyboardEvent): void => {\n        if (localLauncherRef.current === getActiveElement() && event.code === 'F6') {\n          // Prevent default F6 handlers.\n          // F6 is a standard Chrome address bar shortcut on Windows.\n          event.preventDefault();\n          event.stopPropagation();\n\n          focusWithin(contentWrapperRef.current as HTMLElement);\n          onFocusSet?.();\n        }\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [modality]\n    );\n\n    const { draggableProps } = useDraggable({\n      isDisabled: dragAffordance === 'none',\n      containerRef: floatingRef,\n      onDragStart,\n      onDragMove,\n      onDragEnd\n    });\n\n    useEffect(() => {\n      // 1. Ignore status update on initial render or return focus on component unmount\n      if (status === 'unmounted' && !isOpen) {\n        if (status !== prevStatusRef.current) {\n          returnFocus();\n        }\n      }\n\n      // 2. Mount visually hidden component\n      // Component gets mounted, but will be visually hidden to avoid flickering\n      // Flickering happens because it gets rendered before animation hook repositions\n      // it in next render cycle\n      else if (status === 'unmounted' && isOpen) {\n        setStatus('initial');\n      }\n\n      // 3. Setup animation\n      // Component has been mounted.\n      // We will kick out animation as node is already present in DOM.\n      // To avoid flickering, we still keep it visually hidden until the next render cycle.\n      else if (status === 'initial' && isOpen) {\n        nodeRef(contentWrapperRef.current);\n        setStatus('opening');\n      }\n\n      // 3. Unhide component. It becomes visible.\n      else if (status === 'opening' && isOpen) {\n        setVisibility('visible');\n      }\n\n      // 4. Closing\n      else if (!isOpen && _status.current !== 'unmounted') {\n        setStatus('closing');\n      }\n\n      return () => {\n        // remember the previous status\n        prevStatusRef.current = status;\n      };\n    }, [isOpen, status, nodeRef, returnFocus]);\n\n    // Destroy case handler\n    useEffect(() => {\n      return () => {\n        const launcherEl = localLauncherRef.current;\n        if (\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          (contentWrapperRef.current?.contains(getActiveElement() as HTMLElement) || false) &&\n          launcherEl\n        ) {\n          // In destroy case ModalManager is blocking returning of the focus.\n          // We need to reschedule it to workaround that\n          setTimeout(() => {\n            focusOn(launcherEl);\n          }, 0);\n        }\n      };\n    }, []);\n\n    // Initialize launcher\n    useEffect(() => {\n      if (isOpen) {\n        localLauncherRef.current = _getLauncherElement(launcherRef);\n\n        // Register F6 key handler to enter a modeless dialog\n        if (modality === 'modeless') {\n          localLauncherRef.current?.addEventListener('keydown', launcherKeyDownCallback);\n        }\n      }\n      return () => {\n        // Deregister F6 key handler\n        if (modality === 'modeless') {\n          localLauncherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);\n        }\n      };\n    }, [isOpen, launcherRef, launcherKeyDownCallback, modality]);\n\n    // setInitialFocus when the dialog becomes visible\n    useEffect(() => {\n      if (visibility === 'visible') {\n        setInitialFocus();\n      }\n    }, [visibility, setInitialFocus]);\n\n    const handleKeyDown = (event: KeyboardEvent) => {\n      switch (event.code) {\n        case 'Escape':\n          onClose?.({ reason: 'escapeKey' });\n          break;\n        case 'F6':\n          // Focus launcher\n          if (localLauncherRef.current && modality === 'modeless') {\n            focusOn(localLauncherRef.current);\n          }\n          // Prevent default F6 handlers. F6 is a standard Chrome address bar shortcut on Windows.\n          event.preventDefault();\n          event.stopPropagation();\n          break;\n      }\n    };\n\n    const handleBackdropClick = () => {\n      // in case of a backdrop click, move focus to dialog's root element\n      contentWrapperRef.current?.focus();\n    };\n\n    const renderDialogContent = () => {\n      return (\n        <StyledDialog\n          ref={mergedRef}\n          labelId={labelId}\n          header={header}\n          footer={footer}\n          role={role}\n          ariaLabelledBy={labelId}\n          ariaDescribedBy={ariaDescribedBy}\n          onKeyDown={handleKeyDown}\n          testId={testId}\n          style={styles}\n          visibility={visibility}\n          cancelBehavior={cancelBehavior}\n          draggableProps={draggableProps}\n          isResizable={resizeBehavior === 'resizable'}\n          headerDecoration={headerDecoration}\n          containerRef={floatingRef}\n          onClose={onClose}\n          onResizeStart={onResizeStart}\n          onResize={onResize}\n          onResizeEnd={onResizeEnd}\n          footerRef={footerRef}>\n          {children}\n        </StyledDialog>\n      );\n    };\n\n    const renderDialog = () => {\n      if (anchorRef && anchorRef.current) {\n        return (\n          <Floating\n            ref={floatingRef}\n            anchorRef={anchorRef}\n            placement={'bottom-start'}\n            flipOptions={{ mainAxis: false, crossAxis: false }}\n            shiftOptions={{ mainAxis: false, crossAxis: false }}>\n            {renderDialogContent()}\n          </Floating>\n        );\n      } else {\n        return (\n          <WindowOverlay placement={derivedPlacement} offset={offset}>\n            {renderDialogContent()}\n          </WindowOverlay>\n        );\n      }\n    };\n\n    if (modality === 'modal') {\n      return (\n        <Modal isOpen={status !== 'unmounted'} onBackdropClick={handleBackdropClick}>\n          {renderDialog()}\n        </Modal>\n      );\n    } else {\n      return status !== 'unmounted' ? <Layer>{renderDialog()}</Layer> : null;\n    }\n  }\n);\n\nfunction _getLauncherElement(launcherRef: DialogProps['launcherRef']) {\n  const launcher = launcherRef?.current;\n\n  if (launcher) {\n    const launcherElement = launcher instanceof Element ? launcher : launcher[UNSAFE_DOM_ACCESS];\n\n    if (document.body.contains(launcherElement)) {\n      return launcherElement;\n    }\n  }\n\n  return getActiveElement() as HTMLElement;\n}\n\nconst animationStates = {\n  zoomIn: {\n    from: {\n      scaleX: 0.9,\n      scaleY: 0.9,\n      transformOrigin: 'center',\n      opacity: 0\n    },\n    to: {\n      scaleX: 1,\n      scaleY: 1,\n      opacity: 1\n    },\n    options: {\n      duration: 200\n    }\n  },\n  zoomOut: {\n    from: {\n      scaleX: 1,\n      scaleY: 1,\n      transformOrigin: 'center',\n      opacity: 1\n    },\n    to: {\n      scaleX: 0.9,\n      scaleY: 0.9,\n      opacity: 0\n    },\n    options: {\n      duration: 200\n    }\n  },\n  slideUp: {\n    ...SLIDE_UP_XLARGE,\n    options: {\n      duration: DURATION_LARGE\n    }\n  },\n  slideDown: {\n    ...SLIDE_DOWN_XLARGE,\n    options: {\n      duration: DURATION_LARGE\n    }\n  }\n};\n"],"names":["StyledDialogHeader","children","id","cancelBehavior","onClose","draggableProps","headerDecoration","styles","useComponentTheme","DialogRedwoodTheme","classes","classNames","dialogHeaderStyle","dialogHeaderDecorationStyle","content","_jsx","className","dialogTitleStyle","jsx","_Fragment","Fragment","translations","useTranslationBundle","closeIcon","dialogHeaderCloseIconStyle","IconButton","message_close","size","variant","onAction","reason","CloseIcon","SvgClose","_jsxs","StyledDialogFooter","forwardRef","style","ref","StyledDialog","header","footer","visibility","labelId","role","ariaLabelledBy","ariaDescribedBy","isResizable","containerRef","onResizeStart","onResize","onResizeEnd","onKeyDown","testId","footerRef","elementRef","useRef","mergedRef","mergeRefs","sizeConstraints","isSmallHeight","setSmallHeight","useState","isSmallWidth","useBreakpoints","styleClasses","resizeHandler","useCallback","current","clientHeight","cs","window","getComputedStyle","minHeight","parseFloat","maxHeight","minWidth","maxWidth","useEffect","useResizeObserver","baseStyle","baseStyleSmallWidth","baseStyleDesktop","contentStyle","dialogContentStyleNoShrink","dialogContentStyle","visibilityStyle","visibilityVisible","visibilityHidden","testIdProps","useTestId","FocusTrap","restoreFocusRef","tabIndex","globalImages","dialogContainerStyle","dialogBodyStyle","dialogFooterStyle","Resizable","constraints","Dialog","isOpen","modality","launcherRef","anchorRef","autoFocusRef","placement","offset","dragAffordance","resizeBehavior","onDragStart","onDragMove","onDragEnd","onFocusSet","onTransitionEnd","props","status","_setStatus","_status","setStatus","s","setVisibility","prevStatusRef","floatingRef","contentWrapperRef","localLauncherRef","derivedPlacement","animationType","uniqueId","useId","interpolations","Object","values","dimensionInterpolations","styleInterpolations","mergeInterpolations","shouldReturnFocus","setInitialFocus","focusOn","allTabbableElements","length","focusWithin","returnFocus","launcherEl","nodeRef","useAnimation","animationStates","isAnimatedOnMount","onAnimationEnd","contains","getActiveElement","useMemo","launcherKeyDownCallback","event","code","preventDefault","stopPropagation","useDraggable","isDisabled","setTimeout","launcher","launcherElement","Element","UNSAFE_DOM_ACCESS","document","body","_getLauncherElement","addEventListener","removeEventListener","handleKeyDown","handleBackdropClick","focus","renderDialogContent","renderDialog","Floating","flipOptions","mainAxis","crossAxis","shiftOptions","WindowOverlay","Modal","onBackdropClick","Layer","zoomIn","from","scaleX","scaleY","transformOrigin","opacity","to","options","duration","zoomOut","slideUp","SLIDE_UP_XLARGE","DURATION_LARGE","slideDown","SLIDE_DOWN_XLARGE"],"mappings":"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"}