{"version":3,"file":"ListView-02b5ba6d.js","sources":["../../src/UNSAFE_ListView/ScrollPositionUtils.ts","../../src/UNSAFE_ListView/ListViewReorderableItem.tsx","../../src/UNSAFE_ListView/ListViewContextMenu.tsx","../../src/UNSAFE_ListView/useListViewContextMenu.ts","../../src/UNSAFE_ListView/ListView.tsx","../../src/UNSAFE_ListView/useListViewCurrentItemOverride.tsx","../../src/UNSAFE_ListView/useListViewReorder.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { getKey } from '../utils/PRIVATE_collectionUtils';\n\n/**\n * Type for scroll position in ListView\n */\nexport type ListViewScrollPosition<K> = {\n  offsetY?: number;\n  key?: K;\n  y?: number;\n};\n\n/**\n * Returns the key for the row at the given index\n */\nconst getKeyForIndex = (root: HTMLElement, index: number) => {\n  if (root != null) {\n    const rowElements = root.querySelectorAll(`[role='row']`);\n    if (rowElements.length > index) {\n      return getKey(rowElements[index] as HTMLElement);\n    }\n  }\n  return null;\n};\n\nexport function getScrollPosition<K>(root: HTMLDivElement, newScrollTop?: number) {\n  // ensure scroll position y value is initialized\n  const scrollTop = Math.abs(newScrollTop == null ? root.scrollTop : newScrollTop);\n\n  const scrollPosition: ListViewScrollPosition<K> = {\n    y: scrollTop,\n    key: undefined,\n    offsetY: undefined\n  };\n\n  let rowBottom = 0;\n  const rowElements = root.querySelectorAll(`[role='row']`);\n  if (rowElements.length > 0) {\n    if (scrollTop === 0) {\n      scrollPosition.key = getKeyForIndex(root, 0) as K;\n      scrollPosition.offsetY = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < rowElements.length; i++) {\n    const rowHeight = rowElements[i].getBoundingClientRect().height;\n    rowBottom += rowHeight;\n    if (scrollTop < rowBottom) {\n      scrollPosition.key = getKeyForIndex(root, i) as K;\n      scrollPosition.offsetY = rowHeight + scrollTop - rowBottom;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\n/**\n * Helper to set the scroll position on the ListView.\n */\nexport function setScrollPosition<K>(\n  root: HTMLDivElement,\n  scrollPosition?: ListViewScrollPosition<K>\n) {\n  const y = _getScrollTopFromScrollPosition(root, scrollPosition);\n  root.scrollTop = y != null ? y : 0;\n}\n\n/**\n * Helper to determine the 'y' value of a given scroll position.\n */\nfunction _getScrollTopFromScrollPosition<K>(\n  root: HTMLDivElement,\n  scrollPosition?: ListViewScrollPosition<K>\n) {\n  if (scrollPosition != null) {\n    let key;\n    let useRow = false;\n    if (scrollPosition.key != null) {\n      // key takes precedence over everything else\n      useRow = true;\n      key = scrollPosition.key;\n    } else if (scrollPosition.offsetY != null && scrollPosition.y == null) {\n      // offsetY can be used on its own if it is the only vertical aspect provided\n      useRow = true;\n      key = getScrollPosition(root).key;\n    }\n    if (useRow) {\n      if (key != null) {\n        let y = 0;\n        const rowElements = root.querySelectorAll(`[role ='row']`);\n        for (let i = 0; i < rowElements.length; i++) {\n          if (key === getKey(rowElements[i] as HTMLElement)) {\n            return y + (scrollPosition.offsetY != null ? scrollPosition.offsetY : 0);\n          }\n          y += rowElements[i].getBoundingClientRect().height;\n        }\n      }\n    } else if (scrollPosition.y != null) {\n      return scrollPosition.y;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n","import { memo } from 'preact/compat';\nimport { useRef, useCallback } from 'preact/hooks';\nimport { useReorderableItem } from '../hooks/PRIVATE_useReorderable';\nimport { ReorderableItemProps } from '../UNSAFE_Collection/Reorderable.types';\nimport { ITEM_SELECTOR } from '../utils/PRIVATE_collectionUtils';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { styles } from './themes/ListViewStyles.css';\nimport { isKeyDefined } from '../utils/UNSAFE_keys';\n\nexport type ListReorderableItemProps<K> = ReorderableItemProps<K>;\n\n/**\n * A private item that will be used by ReorderableCardFlexView, location TBD (could be moved to PRIVATE_CardFlexView)\n */\nexport function ListViewReorderableItem<K extends string | number>({\n  children,\n  dragKey,\n  setDragKey,\n  onReorder,\n  rootRef,\n  itemKey\n}: ListReorderableItemProps<K> & { itemKey: K }) {\n  const itemRef = useRef<HTMLDivElement | null>(null);\n  const itemStyles = {\n    itemOverlayFront: styles.reorderableItemOverlayFront,\n    itemOverlayRear: styles.reorderableItemOverlayRear,\n    itemDragger: styles.reorderableItemDragger\n  };\n  const getItem = () => itemRef?.current?.closest(ITEM_SELECTOR);\n  const setTransferData = useCallback(\n    (event: DragEvent) => {\n      event.dataTransfer?.setData('text/listview-items-key', JSON.stringify(itemKey));\n    },\n    [itemKey]\n  );\n  const { rootProps, isDragged, overlayZoneBeforeProps, overlayZoneAfterProps } =\n    useReorderableItem({\n      isDisabled: onReorder ? false : true,\n      dragKey,\n      setDragKey,\n      onReorder,\n      rootRef,\n      ref: itemRef,\n      getItem,\n      setTransferData,\n      itemStyles,\n      itemSelector: ITEM_SELECTOR,\n      isVertical: true\n    });\n  const classes = classNames([rootProps?.class, styles.reorderableItemDnd]);\n\n  return (\n    <div {...rootProps} class={classes}>\n      {children}\n      {!isDragged && isKeyDefined(dragKey) && (\n        <>\n          <div {...overlayZoneBeforeProps}></div>\n          <div {...overlayZoneAfterProps}></div>\n        </>\n      )}\n    </div>\n  );\n}\n\nexport const MemoizeListViewReorderableItem = memo(\n  ListViewReorderableItem,\n  <K,>(prev: ListReorderableItemProps<K>, next: ListReorderableItemProps<K>) => {\n    if (prev && next) {\n      return prev?.children === next?.children && prev?.dragKey === next?.dragKey;\n    }\n    return false;\n  }\n);\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentProps } from 'preact';\n\nimport { ListItemContext } from '#UNSAFE_Collection';\nimport { Menu } from '#UNSAFE_Menu';\nimport { ListViewContextMenuConfig } from './List.types';\n\nexport type Props<K extends string | number, D> = Omit<ComponentProps<typeof Menu>, 'children'> & {\n  contextMenuConfig: ListViewContextMenuConfig<K, D>;\n} & { contextMenuContext: ListItemContext<K, D> } & {\n  testId: ComponentProps<typeof Menu>['testId'];\n};\n\n/**\n * The internal component used to render a custom context menu\n */\nexport function ListViewContextMenu<K extends string | number, D>({\n  contextMenuConfig,\n  testId,\n  contextMenuContext,\n  ...menuProps\n}: Props<K, D>) {\n  const accessibleLabel = contextMenuConfig.accessibleLabel;\n\n  return (\n    <>\n      <Menu\n        {...menuProps}\n        {...(accessibleLabel && {\n          'aria-label': accessibleLabel\n        })}\n        testId={testId}>\n        {menuProps.isOpen && contextMenuConfig.itemsRenderer(contextMenuContext)}\n      </Menu>\n    </>\n  );\n}\n","import type { ComponentProps, RefObject } from 'preact';\nimport { useCallback, useState, useRef } from 'preact/hooks';\n\nimport { DataState, ListItemContext, CurrentKeyDetail } from '#UNSAFE_Collection';\nimport { Menu } from '#UNSAFE_Menu';\nimport { findItemContext } from '#hooks/PRIVATE_useItemAction';\nimport { useContextMenuGesture } from '#hooks/UNSAFE_useContextMenuGesture';\nimport { ITEM_SELECTOR, findElementByKey, keyExtractor } from '#utils/PRIVATE_collectionUtils';\nimport { ListView } from './ListView';\n\ntype MenuProps = Pick<\n  ComponentProps<typeof Menu>,\n  'anchorRef' | 'initialFocus' | 'placement' | 'offsetValue' | 'isOpen'\n>;\n\nconst TOUCH_OFFSET_VALUE = 40;\n\nconst menuPropGestureStates: Record<\n  'mouse' | 'keyboard' | 'touch',\n  Omit<Required<MenuProps>, 'anchorRef' | 'isOpen'>\n> = {\n  mouse: {\n    initialFocus: 'menu',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  keyboard: {\n    initialFocus: 'firstItem',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  touch: {\n    initialFocus: 'menu',\n    placement: 'end',\n    offsetValue: TOUCH_OFFSET_VALUE\n  }\n};\n\nconst initialMenuProps: MenuProps = {\n  isOpen: false,\n  initialFocus: 'menu',\n  placement: 'bottom-start',\n  offsetValue: 0,\n  anchorRef: { current: null }\n};\n\ntype ListViewProps<K extends string | number, D> = ComponentProps<typeof ListView<K, D>>;\n\nexport const useListViewContextMenu = <K extends string | number, D>(\n  dataState: DataState<K, D> | null,\n  contextMenuConfig: ListViewProps<K, D>['contextMenuConfig'],\n  scrollListRef: RefObject<HTMLElement | null>,\n  updateCurrentKey: (key: K) => void\n) => {\n  /*Context Menu section\n   TODO: A version of context Menu listview will be merged using useContextMenuGesture instead. Once it's merged we\n   can go back to this to create a hook or utility that could be share among all collection comps. JET-60320\n  */\n\n  /*\n  Steps to open a menu:\n    1.- useContextMenu handler is called when menu is supposed to be opened.\n    2.- We set contextMenuContext when contextMenuRenderer is called.\n    3.- We dispatch opening the menu with the correct anchor.\n    5.- Menu receives updated props and updated contextMenuContext.\n    6.- Menu is opened.\n\n    */\n\n  //Supposed to be updated when menu is about to be opened\n  //We set an initial key value for the context menu context, to allow user use object destructuring inside the\n  //contextMenuRenderer. It doesn't matter if the key is not correct at the initial rendering since menu starts\n  //being closed always\n  const [contextMenuContext, setContextMenuContext] = useState<ListItemContext<K, D>>();\n\n  const [menuProps, setMenuProps] = useState<MenuProps>(initialMenuProps);\n\n  const currentKeyRef = useRef<K>();\n  const notifyCurrentKeyChanged = (detail: CurrentKeyDetail<K>) => {\n    currentKeyRef.current = detail.value;\n  };\n\n  const { triggerProps } = useContextMenuGesture(\n    ({ gesture, anchor, target }) => {\n      let anchorBasedOnGesture = anchor;\n      if (gesture === 'keyboard') {\n        //We find the element where the position of the menu is going to be based of\n        const elem = findElementByKey(\n          scrollListRef.current as HTMLElement,\n          currentKeyRef.current as K,\n          ITEM_SELECTOR\n        );\n\n        //We set the correct anchor\n        anchorBasedOnGesture = elem ? elem : anchor;\n\n        const context = findItemContext(\n          currentKeyRef.current as K,\n          dataState as DataState<string | number | null, D>\n        );\n\n        setContextMenuContext(context as ListItemContext<K, D>);\n      } else {\n        //We search for the key using the target of the event\n        const key = keyExtractor(target as HTMLElement, ITEM_SELECTOR);\n\n        const context = findItemContext(key, dataState as DataState<string | number | null, D>);\n\n        setContextMenuContext(context as ListItemContext<K, D>);\n\n        //We update the key so when we close logical focus is on the correct item\n        updateCurrentKey(key as K);\n      }\n      setMenuProps({\n        ...menuPropGestureStates[gesture],\n        anchorRef: { current: anchorBasedOnGesture },\n        isOpen: true\n      });\n    },\n    {\n      isDisabled: !contextMenuConfig //If there is no a context menu renderer we disable the hook\n    }\n  );\n\n  const handleCloseContextMenu = useCallback<Required<ComponentProps<typeof Menu>>['onClose']>(\n    (detail) => {\n      /*\n      TODO: Focus ring should be visible when context menu was closed because of selecting an item using keyboard,\n      but should not be visible when the selection was done using mouse or touch. This would probably means menu\n      onClose API is going to be changed a little bit so we can satisfy this requirement. JET-62372\n      */\n      //Focus has to be set on the current target that was obtained\n      //during context menu gesture when menu is dismissed or item is \"selected\"\n      if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {\n        scrollListRef.current?.focus({ preventScroll: true });\n      }\n      // We close the menu.The only prop that matters here is isOpen\n      setMenuProps({ ...initialMenuProps });\n    },\n    [scrollListRef]\n  );\n\n  return {\n    menuProps: { ...menuProps, onClose: handleCloseContextMenu },\n    onClose: handleCloseContextMenu,\n    contextMenuContext: contextMenuContext as ListItemContext<K, D>,\n    triggerProps,\n    notifyCurrentKeyChanged\n  } as const;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren, JSX } from 'preact';\nimport { ForwardedRef, forwardRef } from 'preact/compat';\nimport { useImperativeHandle, useRef, useLayoutEffect } from 'preact/hooks';\nimport { ReorderableContext } from '../hooks/PRIVATE_useReorderable';\nimport { DataState, CurrentKeyDetail } from '../UNSAFE_Collection';\nimport { HiddenAccessible } from '../UNSAFE_HiddenAccessible';\nimport { List, SkeletonContainer } from '../PRIVATE_List';\nimport {\n  ListProps,\n  ListViewContextMenuConfig,\n  ListViewHandle,\n  SkeletonRendererContext\n} from './List.types';\nimport {\n  getScrollPosition,\n  setScrollPosition,\n  ListViewScrollPosition\n} from './ScrollPositionUtils';\nimport { MemoizeListViewReorderableItem } from './ListViewReorderableItem';\nimport { useListViewReorder } from './useListViewReorder';\nimport { ListViewContextMenu } from './ListViewContextMenu';\nimport { useListViewContextMenu } from './useListViewContextMenu';\nimport { useListViewCurrentItemOverride } from './useListViewCurrentItemOverride';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\n\n/**\n * Props specific to non-virtualized ListView\n */\ntype NonVirtualizedListProps<K, D> = {\n  /**\n   * The data that is used to render each item in ListView.  If the value is null, then ListView will show nothing\n   * if hasMore is false, or loading indicator if hasMore is true.\n   */\n  data: D[] | null;\n  /**\n   * A callback function to extract the key which is used to identify the item.\n   */\n  getRowKey: (data: D) => K;\n  /**\n   * Whether there are more data available to load.  By default this returns false.\n   */\n  hasMore?: boolean;\n  /**\n   * An optional callback function which is invoked when user scrolls to the end of the list.\n   */\n  onLoadMore?: () => void;\n\n  /**\n   * Configuration used to specify a context menu.\n   */\n  contextMenuConfig?: ListViewContextMenuConfig<K, D>;\n};\n\n/**\n * Props for the ListView Component\n */\nexport type Props<K, D> = Pick<\n  ListProps<K, D>,\n  | 'aria-label'\n  | 'aria-labelledby'\n  | 'aria-describedby'\n  | 'children'\n  | 'gridlines'\n  | 'currentItemOverride'\n  | 'onPersistCurrentItem'\n  | 'onItemAction'\n  | 'onSelectionChange'\n  | 'promotedSection'\n  | 'selectedKeys'\n  | 'selectionMode'\n  | 'viewportConfig'\n  | 'testId'\n  | 'scrollPositionOverride'\n  | 'onReorder'\n  | 'itemPadding'\n  | 'itemEnterKeyFocusBehavior'\n  | 'skeletonRenderer'\n> &\n  NonVirtualizedListProps<K, D>;\n/**\n * A list view displays data items as a list or a grid with highly interactive features.\n */\nexport const ListView = forwardRef(\n  <K extends string | number, D>(props: Props<K, D>, ref?: ForwardedRef<ListViewHandle<K>>) => {\n    const { contextMenuConfig } = props;\n    const scrollPositionRef = useRef<ListViewScrollPosition<K>>();\n    const listRef = useRef<HTMLDivElement | null>(null);\n\n    const { currentItemOverride, updateCurrentItemOverride } = useListViewCurrentItemOverride(\n      props.currentItemOverride\n    );\n\n    const dataMetadata = props.data\n      ? props.data.map((aData: D) => {\n          const key = props.getRowKey(aData);\n          return { data: aData, metadata: { key } };\n        })\n      : null;\n\n    const loadRange = props.onLoadMore ? props.onLoadMore : () => {};\n    const dataState = dataMetadata\n      ? ({\n          offset: 0,\n          data: dataMetadata,\n          sizePrecision: props.hasMore ? 'atLeast' : 'exact',\n          totalSize: dataMetadata.length\n        } as DataState<K, D>)\n      : null;\n\n    useImperativeHandle(ref!, () => ({\n      getScrollPosition: () => {\n        if (listRef.current) {\n          return getScrollPosition(listRef.current);\n        }\n        return { y: 0 };\n      },\n      focus: () => {\n        if (listRef.current) {\n          listRef.current.focus();\n        }\n      }\n    }));\n\n    // update scroll position if a new value is provided\n    useLayoutEffect(() => {\n      if (listRef.current && scrollPositionRef.current !== props.scrollPositionOverride) {\n        setScrollPosition(listRef.current, props.scrollPositionOverride);\n        scrollPositionRef.current = props.scrollPositionOverride;\n      }\n    }, [props.scrollPositionOverride]);\n\n    /**\n     * Reorder Section\n     */\n    const isReorderEnabled = props.onReorder != undefined;\n    const {\n      reorderProps,\n      reorderItemProps,\n      reorderContext,\n      reorderInstructionsId,\n      reorderInstructions\n    } = useListViewReorder({\n      onReorder: props.onReorder,\n      rootRef: listRef,\n      viewportConfig: props.viewportConfig\n    });\n\n    const { triggerProps, menuProps, contextMenuContext, notifyCurrentKeyChanged } =\n      useListViewContextMenu(dataState, contextMenuConfig, listRef, updateCurrentItemOverride);\n\n    const onPersistCurrentItem = (detail: CurrentKeyDetail<K>) => {\n      props.onPersistCurrentItem?.(detail);\n      notifyCurrentKeyChanged(detail);\n    };\n\n    if (isReorderEnabled && reorderItemProps) {\n      return (\n        <>\n          <ReorderableContext.Provider value={reorderContext}>\n            <List\n              {...props}\n              aria-describedby={reorderInstructionsId}\n              contextMenuTriggerProps={triggerProps}\n              reorderProps={reorderProps}\n              onLoadRange={loadRange}\n              scrollerRef={listRef}\n              data={dataState}\n              currentItemOverride={currentItemOverride}\n              onPersistCurrentItem={onPersistCurrentItem}>\n              {(context) => (\n                <MemoizeListViewReorderableItem\n                  {...reorderItemProps}\n                  itemKey={context.metadata.key}>\n                  {props.children(context)}\n                </MemoizeListViewReorderableItem>\n              )}\n            </List>\n            <span id={reorderInstructionsId}>\n              <HiddenAccessible>{reorderInstructions}</HiddenAccessible>\n            </span>\n          </ReorderableContext.Provider>\n          {contextMenuConfig && (\n            <ListViewContextMenu\n              {...menuProps}\n              testId={props.testId ? props.testId + '-menu' : undefined}\n              contextMenuConfig={contextMenuConfig}\n              contextMenuContext={contextMenuContext}\n            />\n          )}\n        </>\n      );\n    }\n\n    const customInitialSkeleton = (\n      skeletonRenderer: (context: SkeletonRendererContext) => ComponentChildren\n    ) => {\n      return (\n        <SkeletonContainer minimumCount={25}>\n          {(index) => {\n            const context: SkeletonRendererContext = {\n              loadingStatus: 'initial',\n              index: index\n            };\n            return skeletonRenderer(context);\n          }}\n        </SkeletonContainer>\n      );\n    };\n\n    const customLoadMoreSkeleton = (\n      skeletonRenderer: (context: SkeletonRendererContext) => ComponentChildren\n    ) => {\n      return (\n        <div class={LOADMORE_STYLE_CLASS}>\n          <SkeletonContainer minimumCount={3}>\n            {(index) => {\n              const context: SkeletonRendererContext = {\n                loadingStatus: 'loadMore',\n                index: index\n              };\n              return skeletonRenderer(context);\n            }}\n          </SkeletonContainer>\n        </div>\n      );\n    };\n\n    return (\n      <>\n        <List\n          {...props}\n          loadingIndicator={\n            props.skeletonRenderer ? customInitialSkeleton(props.skeletonRenderer) : undefined\n          }\n          loadMoreIndicator={\n            props.skeletonRenderer ? customLoadMoreSkeleton(props.skeletonRenderer) : undefined\n          }\n          onLoadRange={loadRange}\n          scrollerRef={listRef}\n          data={dataState}\n          contextMenuTriggerProps={triggerProps}\n          currentItemOverride={currentItemOverride}\n          onPersistCurrentItem={onPersistCurrentItem}>\n          {props.children}\n        </List>\n        {contextMenuConfig && (\n          <ListViewContextMenu\n            {...menuProps}\n            contextMenuConfig={contextMenuConfig}\n            contextMenuContext={contextMenuContext}\n            testId={props.testId ? props.testId + '-menu' : undefined}\n          />\n        )}\n      </>\n    );\n  }\n) as <K extends string | number, D>(\n  props: Props<K, D> & { ref?: ForwardedRef<ListViewHandle<K>> }\n) => JSX.Element;\n","import { useCallback, useRef } from 'preact/hooks';\nimport { Item as CurrentItem } from '#UNSAFE_Collection';\nimport { ListProps } from './List.types';\n\n/**\n * This hook handles the currentItemOverride passing to PRIVATE_List layer.\n *\n * If the app provided new value for 'currentItemOverride', we pass that down to PRIVATE_List layer;\n * otherwise, we will pass down the value of internal override, which would be the value\n * updated by useListViewContextMenu hook\n *\n * @param currentItemOverride\n */\nexport const useListViewCurrentItemOverride = <K extends string | number, D>(\n  currentItemOverride: ListProps<K, D>['currentItemOverride']\n) => {\n  // the override that will be passed down to PRIVATE_List layer\n  const listOverrideRef = useRef<CurrentItem<K>>();\n\n  // track the currentItemOverride attribute set by app\n  const appOverrideRef = useRef<CurrentItem<K>>();\n  if (appOverrideRef.current !== currentItemOverride) {\n    appOverrideRef.current = currentItemOverride;\n    listOverrideRef.current = currentItemOverride;\n  }\n\n  // track the internal override updated by useListViewContextMenu hook\n  // we can just update ref here since the hook will trigger a state update for its context, which will trigger a rerender\n  const updateCurrentItemOverride = useCallback((key: K) => {\n    listOverrideRef.current = { rowKey: key };\n  }, []);\n\n  return {\n    currentItemOverride: listOverrideRef.current,\n    updateCurrentItemOverride\n  };\n};\n","import type { RefObject } from 'preact';\nimport { useState, useEffect, useRef } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { ITEM_SELECTOR, dragToScroll, findElementByKey } from '../utils/PRIVATE_collectionUtils';\nimport { ViewportConfig } from '../hooks/UNSAFE_useViewportIntersect';\nimport { useReorderable } from '../hooks/PRIVATE_useReorderable';\nimport { scrollToVisible } from '../PRIVATE_List';\nimport { ListProps } from './List.types';\n\ntype useListViewReorderProps<K, D> = Pick<ListProps<K, D>, 'onReorder'> & {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportConfig?: ViewportConfig;\n};\n\nexport const useListViewReorder = <K extends string | number, D>({\n  onReorder,\n  rootRef,\n  viewportConfig\n}: useListViewReorderProps<K, D>) => {\n  const isReorderEnabled = onReorder != undefined;\n\n  const [dragKey, setDragKey] = useState<K | undefined>(undefined);\n  const { reorderProps, reorderContext, reorderInstructionsId, reorderInstructions } =\n    useReorderable({\n      onReorder,\n      rootRef,\n      itemSelector: ITEM_SELECTOR,\n      isDisabled: !isReorderEnabled,\n      columns: 1\n    });\n\n  // ensure the current item is scrolled into view during keyboard reordering,\n  // disable that during mouse reordering\n  const reorderScrollIntoView = useRef(false);\n  useEffect(() => {\n    if (isReorderEnabled && reorderScrollIntoView.current) {\n      const rootElement = rootRef.current as HTMLElement;\n      const elem = findElementByKey(\n        rootElement,\n        reorderContext.currentItemKey.current as K,\n        ITEM_SELECTOR\n      );\n      if (elem) {\n        const scroller = viewportConfig?.scroller() || rootElement;\n        // make sure item is visible\n        scrollToVisible(elem, scroller, 0);\n        reorderScrollIntoView.current = false;\n      }\n    }\n  });\n\n  if (!isReorderEnabled) {\n    return {\n      reorderProps,\n      reorderContext,\n      reorderInstructionsId,\n      reorderInstructions\n    } as const;\n  }\n\n  const handleKeyDown = (event: KeyboardEvent) => {\n    // listview only do keyboard reordering with arrow up/down keys\n    if (\n      isReorderEnabled &&\n      (event.key === 'ArrowUp' || event.key === 'ArrowDown') &&\n      (event.metaKey || event.ctrlKey) &&\n      event.shiftKey\n    ) {\n      reorderScrollIntoView.current = true;\n      reorderProps.onKeyDown?.(event);\n    }\n  };\n\n  const handleDragOver = (event: DragEvent) => {\n    if (dragKey !== undefined) {\n      reorderScrollIntoView.current = false;\n      dragToScroll(event, dragKey !== undefined, rootRef.current);\n    }\n  };\n\n  const reorderEventProps = mergeProps({ onKeyDown: handleKeyDown, onDragOver: handleDragOver });\n\n  const reorderItemProps = {\n    dragKey,\n    setDragKey,\n    onReorder,\n    rootRef\n  };\n\n  return {\n    reorderProps: reorderEventProps,\n    reorderItemProps,\n    reorderContext,\n    reorderInstructionsId,\n    reorderInstructions\n  } as const;\n};\n"],"names":["getKeyForIndex","root","index","rowElements","querySelectorAll","length","getKey","getScrollPosition","newScrollTop","scrollTop","Math","abs","scrollPosition","y","key","undefined","offsetY","rowBottom","i","rowHeight","getBoundingClientRect","height","setScrollPosition","useRow","_getScrollTopFromScrollPosition","MemoizeListViewReorderableItem","memo","children","dragKey","setDragKey","onReorder","rootRef","itemKey","itemRef","useRef","itemStyles","itemOverlayFront","styles","reorderableItemOverlayFront","itemOverlayRear","reorderableItemOverlayRear","itemDragger","reorderableItemDragger","setTransferData","useCallback","event","dataTransfer","setData","JSON","stringify","rootProps","isDragged","overlayZoneBeforeProps","overlayZoneAfterProps","useReorderableItem","isDisabled","ref","getItem","current","closest","ITEM_SELECTOR","itemSelector","isVertical","classes","classNames","class","reorderableItemDnd","_jsxs","isKeyDefined","jsxs","_Fragment","Fragment","_jsx","jsx","prev","next","ListViewContextMenu","contextMenuConfig","testId","contextMenuContext","menuProps","accessibleLabel","Menu","isOpen","itemsRenderer","menuPropGestureStates","mouse","initialFocus","placement","offsetValue","keyboard","touch","initialMenuProps","anchorRef","ListView","forwardRef","props","scrollPositionRef","listRef","currentItemOverride","updateCurrentItemOverride","listOverrideRef","appOverrideRef","rowKey","useListViewCurrentItemOverride","dataMetadata","data","map","aData","metadata","getRowKey","loadRange","onLoadMore","dataState","offset","sizePrecision","hasMore","totalSize","useImperativeHandle","focus","useLayoutEffect","scrollPositionOverride","isReorderEnabled","reorderProps","reorderItemProps","reorderContext","reorderInstructionsId","reorderInstructions","viewportConfig","useState","useReorderable","columns","reorderScrollIntoView","useEffect","rootElement","elem","findElementByKey","currentItemKey","scroller","scrollToVisible","mergeProps","onKeyDown","metaKey","ctrlKey","shiftKey","onDragOver","dragToScroll","useListViewReorder","triggerProps","notifyCurrentKeyChanged","scrollListRef","updateCurrentKey","setContextMenuContext","setMenuProps","currentKeyRef","useContextMenuGesture","gesture","anchor","target","anchorBasedOnGesture","context","findItemContext","keyExtractor","handleCloseContextMenu","detail","reason","preventScroll","onClose","value","useListViewContextMenu","onPersistCurrentItem","ReorderableContext","Provider","List","contextMenuTriggerProps","onLoadRange","scrollerRef","id","HiddenAccessible","loadingIndicator","skeletonRenderer","SkeletonContainer","minimumCount","loadingStatus","loadMoreIndicator","LOADMORE_STYLE_CLASS","customLoadMoreSkeleton"],"mappings":"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"}