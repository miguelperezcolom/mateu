{"version":3,"file":"TextFieldInput-eb40adaa.js","sources":["../../src/UNSAFE_TextField/TextFieldInput.tsx"],"sourcesContent":["import type { ContextType, Ref, JSX } from 'preact';\nimport { useLayoutEffect, useRef } from 'preact/hooks';\n\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\n\nimport { useAccessibleContext } from '#hooks/UNSAFE_useAccessibleContext';\nimport { useComponentTheme } from '#hooks/UNSAFE_useComponentTheme';\nimport { useFormFieldContext } from '#hooks/UNSAFE_useFormFieldContext';\nimport type { FormVariantContext } from '#hooks/UNSAFE_useFormVariantContext';\nimport { useTabbableMode } from '#hooks/UNSAFE_useTabbableMode';\nimport { useTextFieldInputHandlers } from '#hooks/UNSAFE_useTextFieldInputHandlers';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport type { BundleType } from '#resources/nls/bundle';\nimport { isEmbeddedVariant } from '#utils/PRIVATE_formControlUtils';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { type TextProps, textInterpolations } from '#utils/UNSAFE_interpolations/text';\nimport { mergeInterpolations } from '#utils/UNSAFE_mergeInterpolations';\nimport { mergeProps } from '#utils/UNSAFE_mergeProps';\nimport type { ValueUpdateDetail } from '#utils/UNSAFE_valueUpdateDetail';\nimport { isInputPlaceholderShown } from './TextFieldUtils';\nimport { formControlInheritTextAlign } from './themes/FormControlUtilsStyles.css';\nimport { TextFieldInputRedwoodTheme } from './themes/redwood/TextFieldInputTheme';\nimport { type TextFieldInputVariantOptions } from './themes/TextFieldInputStyles.css';\n\nconst interpolations = [...Object.values(textInterpolations)];\n\nconst styleInterpolations = mergeInterpolations<Props>(interpolations);\n\n// The WHATWG forms spec specifies the following input types that support setSelectedRange\nconst supportsSetSelection = ['text', 'search', 'url', 'tel', 'password', 'textarea'];\n\ntype Autocomplete = 'off' | 'on' | string;\n\ntype OrigPickedPropsFromInput = Pick<\n  UnpackSignals<JSX.IntrinsicElements['input']>,\n  'autofocus' | 'id' | 'placeholder' | 'required' | 'role' | 'spellcheck' | 'type'\n>;\ntype RenamedPropsFromInput = Omit<\n  OrigPickedPropsFromInput,\n  'autofocus' | 'readonly' | 'required'\n> & {\n  autoFocus?: OrigPickedPropsFromInput['autofocus'];\n  isRequired?: OrigPickedPropsFromInput['required'];\n};\ntype InputProps = {\n  as?: 'input';\n  type?: Pick<UnpackSignals<JSX.IntrinsicElements['input']>, 'type'>['type'];\n  rows?: never;\n  inputRef?: Ref<HTMLInputElement>;\n  hasPrefix?: boolean;\n  hasSuffix?: boolean;\n};\n\ntype TextAreaProps = {\n  as: 'textarea';\n  type?: never;\n  rows?: number;\n  inputRef?: Ref<HTMLTextAreaElement>;\n  hasPrefix?: never;\n  hasSuffix?: never;\n};\n\ntype FocusProps = Pick<UnpackSignals<JSX.HTMLAttributes<HTMLElement>>, 'onBlur' | 'onFocus'>;\n\ntype UniqueProps = InputProps | TextAreaProps;\n\ntype AriaProps = Pick<\n  UnpackSignals<JSX.AriaAttributes>,\n  | 'aria-autocomplete'\n  | 'aria-controls'\n  | 'aria-describedby'\n  | 'aria-expanded'\n  | 'aria-invalid'\n  | 'aria-label'\n  | 'aria-labelledby'\n  | 'aria-valuemax'\n  | 'aria-valuemin'\n  | 'aria-valuenow'\n  | 'aria-valuetext'\n>;\n\ntype Props = UniqueProps &\n  TextProps &\n  RenamedPropsFromInput &\n  AriaProps &\n  FocusProps & {\n    autoComplete?: Autocomplete;\n    // TODO: Should we expose has* props like these or should we pass this info\n    // via FormFieldContext?  (from review on 3/8/22)\n    currentCommitValue?: string;\n    hasEmptyLabel?: boolean;\n    hasEndContent?: boolean;\n    hasInsideLabel?: boolean;\n    hasStartContent?: boolean;\n    value?: string;\n    variant?: ContextType<typeof FormVariantContext>;\n    onInput?: (detail: ValueUpdateDetail<string>) => void;\n    onCommit?: (detail: ValueUpdateDetail<string>) => void;\n    onKeyDown?: (event: KeyboardEvent) => void;\n    onKeyUp?: (event: KeyboardEvent) => void;\n  };\n\n/**\n * Merge multiple ids into a space-separated list\n * @param ids The ids to be merged\n * @returns The space separated string of ids\n */\nfunction mergeIDs(...ids: (string | undefined)[]) {\n  return ids.filter(Boolean).join(' ') || undefined;\n}\n\nexport const TextFieldInput = ({\n  as = 'input',\n  'aria-autocomplete': ariaAutoComplete,\n  'aria-controls': ariaControls,\n  'aria-describedby': ariaDescribedBy,\n  'aria-expanded': ariaExpanded,\n  'aria-invalid': ariaInvalid,\n  'aria-label': ariaLabel,\n  'aria-labelledby': inputLabelledBy,\n  'aria-valuemax': ariaValueMax,\n  'aria-valuemin': ariaValueMin,\n  'aria-valuenow': ariaValueNow,\n  'aria-valuetext': ariaValueText,\n  autoComplete,\n  autoFocus,\n  currentCommitValue,\n  hasEmptyLabel,\n  hasEndContent = false,\n  hasInsideLabel = false,\n  hasPrefix = false,\n  hasStartContent = false,\n  hasSuffix = false,\n  id,\n  inputRef,\n  placeholder,\n  isRequired,\n  role,\n  rows,\n  spellcheck,\n  type,\n  value = '',\n  variant = 'default',\n  onInput,\n  onCommit,\n  onKeyDown,\n  onKeyUp,\n  onBlur,\n  onFocus,\n  ...props\n}: Props) => {\n  const { isDisabled, isFocused, isLoading, isReadonly } = useFormFieldContext();\n  const { class: styleInterpolationClasses } = styleInterpolations(props);\n  const hasValue = value !== '';\n  const isTextArea = as === 'textarea';\n  const isInput = as === 'input';\n  const isPassword = type === 'password';\n  const renderPrefix = !isDisabled && hasPrefix;\n  const renderSuffix = !isDisabled && hasSuffix;\n  const myPlaceholder = isInputPlaceholderShown(hasInsideLabel, hasValue, isFocused)\n    ? placeholder\n    : undefined;\n\n  const { classes } = useComponentTheme<TextFieldInputVariantOptions>(TextFieldInputRedwoodTheme, {\n    type: isPassword ? 'isPassword' : 'notPassword',\n    styleVariant: isEmbeddedVariant(variant) ? 'embedded' : 'default',\n    textarea: isTextArea ? 'isTextArea' : 'notTextArea',\n    input: isInput ? 'isInput' : 'notInput',\n    div: 'notDiv',\n    prefix: renderPrefix ? 'hasPrefix' : 'noPrefix',\n    suffix: renderSuffix ? 'hasSuffix' : 'noSuffix',\n    startContent: hasStartContent ? 'hasStartContent' : 'noStartContent',\n    endContent: hasEndContent ? 'hasEndContent' : 'noEndContent',\n    insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',\n    value: hasValue ? 'hasValue' : 'noValue',\n    focused: isFocused ? 'isFocused' : 'notFocused',\n    disabled: isDisabled ? 'isDisabled' : 'notDisabled'\n  });\n\n  const inputClasses = classNames([\n    classes,\n    styleInterpolationClasses,\n    // JET-72775 - Form control alignment in tables\n    // When we are in legacy collection components, we want to inherit the text align\n    // when it is not set explicitly.\n    variant === 'legacyEmbedded' && props.textAlign === undefined && formControlInheritTextAlign\n  ]);\n  const Comp = as || 'input';\n\n  // ref to hold the text selection to restore.\n  const selectionRef = useRef({\n    start: 0,\n    end: 0\n  });\n\n  const textFieldInputHandlers = useTextFieldInputHandlers({\n    currentCommitValue,\n    // Enter should not commit for textarea.\n    isCommitOnEnter: as === 'input',\n    value,\n    onInput,\n    onCommit,\n    onKeyDown,\n    selectionRef\n  });\n  const handlers = mergeProps(textFieldInputHandlers, { onBlur, onFocus });\n  // the implicit default for tabindex on an input is 0, so do not explicitly set it.\n  // JET-52914 - Implement Tabbable mode API contract in InputText\n  // if not tabbable, spread tabbableModeProps on component\n  const { isTabbable, tabbableModeProps } = useTabbableMode();\n  // TODO: for autoComplete='off', need to configure attrs appropriately to make sure it\n  // works across browsers and versions  (from review on 3/11/22)\n\n  // JET-52089: add unsafe API for specifying an external label which is added to ariaLabelledBy on the input,\n  // only when labelEdge is 'none' and label is ''. Since ariaLabelledBy takes precedence over all other\n  // kinds of labels, this helps to ensure we don't override a meaningful label.\n  const { UNSAFE_ariaLabelledBy } = useAccessibleContext();\n  const ariaLabelledBy = hasEmptyLabel\n    ? mergeIDs(inputLabelledBy, UNSAFE_ariaLabelledBy)\n    : inputLabelledBy;\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const loadingAriaLabel = translations.formControl_loading();\n\n  // Restore the saved selection when the value changes.  See JET-62763 for info on why this is needed.\n  useLayoutEffect(() => {\n    // This should never be a function in this case, This is here because of the Ref type.\n    if (typeof inputRef !== 'function') {\n      const inpElem = inputRef?.current;\n      // only set the selection range if the element has focus\n      // only set the selection range on supported types.\n      if (\n        document.activeElement === inpElem &&\n        inpElem &&\n        supportsSetSelection.includes(inpElem.type)\n      ) {\n        inpElem.setSelectionRange(selectionRef.current.start, selectionRef.current.end);\n      }\n    }\n  }, [value, inputRef]);\n\n  return (\n    <Comp\n      aria-autocomplete={ariaAutoComplete}\n      aria-controls={ariaControls}\n      aria-describedby={ariaDescribedBy}\n      aria-expanded={ariaExpanded}\n      aria-invalid={ariaInvalid}\n      aria-label={isLoading ? loadingAriaLabel : ariaLabel ? ariaLabel : undefined}\n      aria-labelledby={ariaLabelledBy}\n      aria-required={isRequired ? true : undefined}\n      aria-valuemax={ariaValueMax}\n      aria-valuemin={ariaValueMin}\n      aria-valuenow={ariaValueNow}\n      aria-valuetext={ariaValueText}\n      autocomplete={autoComplete}\n      autofocus={autoFocus}\n      class={inputClasses}\n      disabled={isDisabled}\n      id={id}\n      onKeyUp={onKeyUp}\n      placeholder={myPlaceholder}\n      readonly={isReadonly}\n      // @ts-expect-error TS cannot infer the type correctly for the polymorphed ref\n      ref={inputRef}\n      role={role}\n      rows={rows}\n      spellcheck={spellcheck}\n      type={type}\n      value={value}\n      {...handlers}\n      {...(!isTabbable && tabbableModeProps)}\n    />\n  );\n};\n"],"names":["interpolations","Object","values","textInterpolations","styleInterpolations","mergeInterpolations","supportsSetSelection","as","ariaAutoComplete","ariaControls","ariaDescribedBy","ariaExpanded","ariaInvalid","ariaLabel","inputLabelledBy","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","autoComplete","autoFocus","currentCommitValue","hasEmptyLabel","hasEndContent","hasInsideLabel","hasPrefix","hasStartContent","hasSuffix","id","inputRef","placeholder","isRequired","role","rows","spellcheck","type","value","variant","onInput","onCommit","onKeyDown","onKeyUp","onBlur","onFocus","props","isDisabled","isFocused","isLoading","isReadonly","useFormFieldContext","class","styleInterpolationClasses","hasValue","isTextArea","isInput","isPassword","renderPrefix","renderSuffix","myPlaceholder","isInputPlaceholderShown","undefined","classes","useComponentTheme","TextFieldInputRedwoodTheme","styleVariant","isEmbeddedVariant","textarea","input","div","prefix","suffix","startContent","endContent","insideLabel","focused","disabled","inputClasses","classNames","textAlign","formControlInheritTextAlign","Comp","selectionRef","useRef","start","end","textFieldInputHandlers","useTextFieldInputHandlers","isCommitOnEnter","handlers","mergeProps","isTabbable","tabbableModeProps","useTabbableMode","UNSAFE_ariaLabelledBy","useAccessibleContext","ariaLabelledBy","ids","filter","Boolean","join","mergeIDs","loadingAriaLabel","useTranslationBundle","formControl_loading","useLayoutEffect","inpElem","current","document","activeElement","includes","setSelectionRange","_jsx","autocomplete","autofocus","readonly","ref"],"mappings":"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"}