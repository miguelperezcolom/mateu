{"version":3,"file":"useFocusableTextField-8b755b15.js","sources":["../../src/hooks/UNSAFE_useFocusableTextField/useFocusableTextField.ts"],"sourcesContent":["import type { RefObject } from 'preact';\nimport { useEffect, useMemo, useRef } from 'preact/hooks';\nimport { useFocusWithin } from '../UNSAFE_useFocusWithin';\n\nexport type FocusableHandle = {\n  focus: () => void;\n  blur: () => void;\n};\ntype UseFocusWithinProps = Parameters<typeof useFocusWithin>[0];\ntype UseFocusableTextFieldProps<E, R> = UseFocusWithinProps & {\n  /**\n   * flag indicating whether the field is readonly\n   */\n  isReadonly?: boolean;\n\n  /**\n   * ref to enabled element\n   */\n  enabledElementRef: RefObject<E>;\n\n  /**\n   * ref to readonly element\n   */\n  readonlyElementRef: RefObject<R>;\n};\n\n/**\n * A custom hook that handles the focus when the text field\n * is toggled between readonly and enabled\n * @typedef E represents the type of the enabled element\n * @typedef R represents the type of the readonly element\n */\nexport function useFocusableTextField<E extends HTMLElement, R extends HTMLElement>({\n  isReadonly,\n  enabledElementRef,\n  readonlyElementRef,\n  ...useFocusWithinProps\n}: UseFocusableTextFieldProps<E, R>) {\n  const { focusProps, isFocused } = useFocusWithin(useFocusWithinProps);\n  const previousIsFocusedRef = useRef(isFocused);\n\n  // Retain focus when toggling between readonly and enabled\n  useEffect(() => {\n    // if the readonly state is changed and previously we\n    // were holding focus, set the focus to newly rendered element\n    if (previousIsFocusedRef.current) {\n      if (isReadonly) {\n        setTimeout(() => readonlyElementRef.current?.focus());\n      } else {\n        setTimeout(() => enabledElementRef.current?.focus());\n      }\n    }\n  }, [enabledElementRef, isReadonly, readonlyElementRef]);\n\n  // Keep the previousFocusRef in sync, but be sure to run this hook\n  // after handling focus for the readonly toggling.\n  useEffect(() => {\n    previousIsFocusedRef.current = isFocused;\n  }, [isFocused]);\n\n  const methods = useMemo(\n    () => ({\n      focus: () => {\n        if (isReadonly) {\n          readonlyElementRef.current?.focus();\n        } else {\n          enabledElementRef.current?.focus();\n        }\n      },\n      blur: () => {\n        if (isReadonly) {\n          readonlyElementRef.current?.blur();\n        } else {\n          enabledElementRef.current?.blur();\n        }\n      }\n    }),\n    [enabledElementRef, isReadonly, readonlyElementRef]\n  );\n\n  return {\n    isFocused,\n    focusProps,\n    methods\n  };\n}\n"],"names":["isReadonly","enabledElementRef","readonlyElementRef","useFocusWithinProps","focusProps","isFocused","useFocusWithin","previousIsFocusedRef","useRef","useEffect","current","setTimeout","focus","methods","useMemo","blur"],"mappings":"oHAgCgB,UAAoEA,WAClFA,EAAUC,kBACVA,EAAiBC,mBACjBA,KACGC,IAEH,MAAMC,WAAEA,EAAUC,UAAEA,GAAcC,EAAcA,eAACH,GAC3CI,EAAuBC,SAAOH,GAGpCI,EAAAA,WAAU,KAGJF,EAAqBG,UACnBV,EACFW,YAAW,IAAMT,EAAmBQ,SAASE,UAE7CD,YAAW,IAAMV,EAAkBS,SAASE,UAE/C,GACA,CAACX,EAAmBD,EAAYE,IAInCO,EAAAA,WAAU,KACRF,EAAqBG,QAAUL,CAAS,GACvC,CAACA,IAEJ,MAAMQ,EAAUC,EAAAA,SACd,KAAO,CACLF,MAAO,KACDZ,EACFE,EAAmBQ,SAASE,QAE5BX,EAAkBS,SAASE,OAC5B,EAEHG,KAAM,KACAf,EACFE,EAAmBQ,SAASK,OAE5Bd,EAAkBS,SAASK,MAC5B,KAGL,CAACd,EAAmBD,EAAYE,IAGlC,MAAO,CACLG,YACAD,aACAS,UAEJ"}