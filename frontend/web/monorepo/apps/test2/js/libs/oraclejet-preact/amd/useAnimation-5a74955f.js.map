{"version":3,"file":"useAnimation-5a74955f.js","sources":["../../src/hooks/UNSAFE_useAnimation/animationUtils.ts","../../src/hooks/UNSAFE_useAnimation/useAnimation.ts"],"sourcesContent":["import { StandardProperties } from 'csstype';\n\nexport type UseAnimationCssProperties = StandardProperties & TransformProperties;\n\n// This represents shorthand UseAnimationCssProperties props.\ntype TransformProperties = Partial<\n  Record<\n    | 'translateX'\n    | 'translateY'\n    | 'translateZ'\n    | 'rotateX'\n    | 'rotateY'\n    | 'rotateZ'\n    | 'skewX'\n    | 'skewY',\n    string\n  > &\n    Record<'scaleX' | 'scaleY' | 'scaleZ', string | number>\n>;\n\n/**\n * Converts shorthand translate props into transform string representation.\n *\n * @param translateX\n * @param translateY\n * @param translateZ\n * @returns Longhand transform string representation.\n */\nfunction convertTranslateShortcuts(\n  translateX: TransformProperties['translateX'],\n  translateY: TransformProperties['translateY'],\n  translateZ: TransformProperties['translateZ']\n) {\n  return `${translateX ? ` translateX(${translateX})` : ''}${\n    translateY ? ` translateY(${translateY})` : ''\n  }${translateZ ? ` translateZ(${translateZ})` : ''}`;\n}\n\n/**\n * Converts shorthand rotate props into transform string representation.\n *\n * @param rotateX\n * @param rotateY\n * @param rotateZ\n * @returns Longhand transform string representation.\n */\nfunction convertRotateShortcuts(\n  rotateX?: TransformProperties['rotateX'],\n  rotateY?: TransformProperties['rotateY'],\n  rotateZ?: TransformProperties['rotateZ']\n) {\n  return `${rotateX ? ` rotateX(${rotateX})` : ''}${rotateY ? ` rotateY(${rotateY})` : ''}${\n    rotateZ ? ` rotateZ(${rotateZ})` : ''\n  }`;\n}\n\n/**\n * Converts shorthand scale props into transform string representation.\n *\n * @param scaleX\n * @param scaleY\n * @param scaleZ\n * @returns Longhand transform string representation.\n */\nfunction convertScaleShortcuts(\n  scaleX: TransformProperties['scaleX'],\n  scaleY: TransformProperties['scaleY'],\n  scaleZ: TransformProperties['scaleZ']\n) {\n  return `${scaleX || scaleX === 0 ? ` scaleX(${scaleX})` : ''}${\n    scaleY || scaleY === 0 ? ` scaleY(${scaleY})` : ''\n  }${scaleZ || scaleZ === 0 ? ` scaleZ(${scaleZ})` : ''}`;\n}\n\n/**\n * Converts shorthand skew props into transform string representation.\n *\n * @param skewX\n * @param skewY\n * @returns Longhand transform string representation.\n */\nfunction convertSkewShortcuts(\n  skewX: TransformProperties['skewX'],\n  skewY: TransformProperties['skewY']\n) {\n  return `${skewX ? ` skewX(${skewX})` : ''}${skewY ? ` skewY(${skewY})` : ''}`;\n}\n\n/**\n * Converts animation CSS properties into Regular camel cased CSS properties.\n *\n * @param useAnimationCssProperties This include transform shorthand props.\n * @returns Regular camel cased CSS properties.\n */\nexport function convertUseAnimationCssPropertiesToRegularCSS(\n  useAnimationCssProperties?: UseAnimationCssProperties\n) {\n  if (!useAnimationCssProperties) {\n    return {};\n  }\n  const {\n    translateX,\n    translateY,\n    translateZ,\n    rotateX,\n    rotateY,\n    rotateZ,\n    scaleX,\n    scaleY,\n    scaleZ,\n    skewX,\n    skewY,\n    ...otherCssProperties\n  } = useAnimationCssProperties;\n  const initialTransformValue = useAnimationCssProperties['transform'] || '';\n  // Now we just add values pased in shortcuts to transform property, do we want to replace it instead?\n  const finalTransformValue = `${initialTransformValue}${convertTranslateShortcuts(\n    translateX,\n    translateY,\n    translateZ\n  )}${convertRotateShortcuts(rotateX, rotateY, rotateZ)}${convertScaleShortcuts(\n    scaleX,\n    scaleY,\n    scaleZ\n  )}${convertSkewShortcuts(skewX, skewY)}`;\n  return {\n    ...otherCssProperties,\n    ...(finalTransformValue && { transform: finalTransformValue })\n  };\n}\n\n/**\n * Converts animation CSS properties into WAAPI keyframe properties.\n * Since keyframes have a difference between offset and cssOffset this collision is avoided here.\n *\n * @param useAnimationCssProperties This include transform shorthand props.\n * @returns WAAPI keyframe\n */\nexport function convertUseAnimationCssPropertiesToWAAPIKeyframe(\n  useAnimationCssProperties?: UseAnimationCssProperties\n) {\n  if (!useAnimationCssProperties) {\n    return {};\n  }\n  const { offset, ...otherCssProperties } =\n    convertUseAnimationCssPropertiesToRegularCSS(useAnimationCssProperties);\n  return {\n    ...otherCssProperties,\n    ...(offset && { cssOffset: offset })\n  };\n}\n\n/**\n * Stops an animation.\n *\n * @param animation Animation that is going to be stopped.\n * @returns\n */\nexport function stopAnimation<E extends HTMLElement>(animation: Animation, node: E | null) {\n  // TO DO: rollup-plugin-typescript seems to have an outdated Animation typing. That produces warnings while bulding.\n  // Update picked type to get rid of this casting.\n  // We have to check if the element is visible to commit styles\n  isVisible(node) && (animation as any).commitStyles();\n  animation.cancel();\n}\n\n/**\n * Check if an element is visible. Similar to jQuery :visible selector.\n *\n * @param element HTML element that is going to be checked for its visibility.\n * @returns\n */\nfunction isVisible<E extends HTMLElement>(element: E | null): boolean {\n  return !!(element?.offsetWidth || element?.offsetHeight || element?.getClientRects().length);\n}\n","import { useRef, useEffect, useCallback } from 'preact/hooks';\nimport {\n  convertUseAnimationCssPropertiesToRegularCSS,\n  convertUseAnimationCssPropertiesToWAAPIKeyframe,\n  UseAnimationCssProperties,\n  stopAnimation\n} from './animationUtils';\n\nexport type UseAnimationConfig<V extends string, E extends HTMLElement> = {\n  animationStates: Partial<\n    Record<AnimationStateKey<V>, ((node: E) => AnimationConfig) | AnimationConfig>\n  >;\n  isAnimatedOnMount?: boolean;\n  onAnimationEnd?: ({ animationState }: { animationState: V }) => void;\n};\n\n// Used to filter simple states and ones that include previous state\ntype AnimationStateKey<PA extends string> = ExtractAnimationStates<PA | `${PA} => ${PA}`>;\n\n// Used to get previous and current states and do deeper typing\ntype ExtractAnimationStates<StateString extends string> =\n  StateString extends `${infer From} => ${infer To}`\n    ? KeyWithPreviousAndCurrentState<From, To>\n    : StateString;\n\n// Used to just allow keys with different previous and current states\ntype KeyWithPreviousAndCurrentState<PreviousState extends string, CurrentState extends string> = {\n  b: PreviousState;\n} extends { b: CurrentState }\n  ? never\n  : `${PreviousState} => ${CurrentState}`;\n\ntype AnimationConfig = {\n  from?: UseAnimationCssProperties;\n  to: UseAnimationCssProperties;\n  end?: UseAnimationCssProperties;\n  options?: AnimationOptions;\n};\n\ntype AnimationOptions = {\n  delay?: number;\n  duration?: number;\n  easing?:\n    | 'linear'\n    | 'ease'\n    | 'ease-in'\n    | 'ease-out'\n    | 'ease-in-out'\n    | [number, number, number, number];\n};\n\n// Used to exclude states that include => since this string is used to represent a transition from state to another.\ntype PermittedAnimationState<V extends string> = Exclude<V, `${string}=>${string}`>;\n\n/**\n * Hook to animate single components.\n * It allows n number of animation states.\n * @param animationState\n * @param animationConfig\n * @returns\n */\nexport function useAnimation<V extends string, E extends HTMLElement = HTMLElement>(\n  animationState: PermittedAnimationState<V>,\n  {\n    animationStates,\n    isAnimatedOnMount = false,\n    onAnimationEnd = () => {}\n  }: UseAnimationConfig<PermittedAnimationState<V>, E>\n) {\n  const didMountRef = useRef(false);\n  const nodeRef = useRef<E | null>(null);\n  const currentAnimationState = useRef<PermittedAnimationState<V>>();\n  const currentAnimation = useRef<Animation>();\n\n  // We don't allow changing animationStates. Ref to keep \"first run\" animation states.\n  const animationStatesRef =\n    useRef<UseAnimationConfig<PermittedAnimationState<V>, E>['animationStates']>(animationStates);\n\n  useEffect(() => {\n    // UseEffect just have to be ran when there is a change on animationState\n    if (currentAnimationState.current === animationState) return;\n\n    // It makes sense to keep track of animation states even if there's no animated element to animate.\n    const previousAnimationState = currentAnimationState.current;\n    currentAnimationState.current = animationState;\n\n    //Stop an animation here only makes sense if the previous one is running\n    if (currentAnimation.current?.playState === 'running') {\n      stopAnimation(currentAnimation.current, nodeRef.current);\n    }\n\n    const animatedElement = nodeRef.current;\n    if (!animatedElement) {\n      return;\n    }\n\n    if (!didMountRef.current) {\n      didMountRef.current = true;\n      if (!isAnimatedOnMount) {\n        return;\n      }\n    }\n\n    const animationConfig = getConfig(\n      animationStatesRef.current,\n      animatedElement,\n      animationState,\n      previousAnimationState\n    );\n\n    if (!animationConfig) {\n      return;\n    }\n\n    currentAnimation.current = startAnimation(\n      animationConfig,\n      animatedElement,\n      animationState,\n      onAnimationEnd\n    );\n  }, [animationState, isAnimatedOnMount, onAnimationEnd]);\n\n  /**\n   * Used to cancel current animation. When animation is canceled node style goes back to beginning style of canceled animation.\n   * @returns\n   */\n  const cancelCurrentAnimation = useCallback(() => {\n    const animation = currentAnimation.current;\n    if (animation?.playState === 'running') {\n      animation.cancel();\n    }\n  }, []);\n\n  /**\n   * Callback ref use to set nodeRef.\n   *\n   * @param node Actual element user set.\n   * @returns\n   */\n  const callbackRef = useCallback((node: E | null) => {\n    if (node != nodeRef.current) {\n      //If for any reason element is unmounted we have to cancel animation(if there is one) and\n      //set currentAnimation as undefined so we don't keep running this animation\n      if (nodeRef.current) {\n        currentAnimation.current?.cancel();\n        currentAnimation.current = undefined;\n      }\n      nodeRef.current = node;\n    }\n  }, []);\n\n  return { nodeRef: callbackRef, controller: { cancel: cancelCurrentAnimation } };\n}\n\n/**\n * Gets animation configuration.\n *\n * @param animationStates Set of animation configurations provided by the user.\n * @param animatedElement Element that is going to be styled.\n * @param animationState Current animation state.\n * @param previousAnimationState Previous animation state.\n * @returns AnimationConfig.\n */\nfunction getConfig<V extends string, E extends HTMLElement>(\n  animationStates: UseAnimationConfig<PermittedAnimationState<V>, E>['animationStates'],\n  animatedElement: E,\n  animationState: PermittedAnimationState<V>,\n  previousAnimationState?: PermittedAnimationState<V>\n) {\n  const currentAnimationStateConfig =\n    animationStates[\n      `${previousAnimationState} => ${animationState}` as keyof UseAnimationConfig<\n        PermittedAnimationState<V>,\n        E\n      >['animationStates']\n    ] ||\n    animationStates[\n      animationState as keyof UseAnimationConfig<PermittedAnimationState<V>, E>['animationStates']\n    ];\n\n  const animationConfig =\n    typeof currentAnimationStateConfig === 'function'\n      ? currentAnimationStateConfig(animatedElement)\n      : (currentAnimationStateConfig as AnimationConfig);\n\n  return animationConfig && Object.keys(animationConfig).length > 0 ? animationConfig : null;\n}\n\n/**\n * Starts an animation.\n *\n * @param animationConfig Animation configuration used by the animation.\n * @param animatedElement Element that is going to be styled.\n * @param animationState Current animation state.\n * @param onAnimationEnd Callback called once the animation is completed.\n * @returns Animation.\n */\nfunction startAnimation<V extends string, E extends HTMLElement>(\n  animationConfig: AnimationConfig,\n  animatedElement: E,\n  animationState: PermittedAnimationState<V>,\n  onAnimationEnd: UseAnimationConfig<PermittedAnimationState<V>, E>['onAnimationEnd']\n) {\n  const { delay, duration, easing } = animationConfig.options || {};\n\n  // Setting attributte to find if there is any pending animation\n  animatedElement.setAttribute('oj-animation-pending', 'true');\n\n  //Now, if user does not pass a value we override it by hand. We will use theming tools in future.\n  const animationOptions = {\n    delay: delay || 0,\n    duration: duration || 400,\n    easing: easing\n      ? typeof easing === 'string'\n        ? easing\n        : `cubic-bezier(${easing[0]}, ${easing[1]}, ${easing[2]}, ${easing[3]})`\n      : 'ease'\n  };\n\n  // WAAPI animation method. https://developer.mozilla.org/en-US/docs/Web/API/Element/animate\n  // TO DO: Check for required browser compatibility in case we need pollyfill.\n  // https://github.com/web-animations/web-animations-js/blob/dev/docs/support.md#browser-support\n  const startedAnimation = animatedElement.animate(\n    [\n      convertUseAnimationCssPropertiesToWAAPIKeyframe(animationConfig.from),\n      convertUseAnimationCssPropertiesToWAAPIKeyframe(animationConfig.to)\n    ],\n    { ...animationOptions }\n  );\n\n  startedAnimation.onfinish = () => {\n    animatedElement.removeAttribute('oj-animation-pending');\n    //We commit styles to have an only source of truth.\n    setEndStyle(animatedElement, true, animationConfig);\n    // On animationEnd is only called when animation actually finished. If an animation is interruped by other one\n    // or animated element is not longer rendered onAnimationEnd will not be called. Do we want to have a callback for those cases?\n    onAnimationEnd?.({ animationState });\n  };\n\n  return startedAnimation;\n}\n\n/**\n * Sets element style.\n *\n * @param animatedElement Element that is going to be styled.\n * @param toAndEndStyle Represents which data will be used to set style. If set to true it uses \"to\" and \"endStyle\".\n * If set to false it uses just \"endStyle\".\n * @param animationConfig Style that is going to be set.\n */\nfunction setEndStyle<E extends HTMLElement>(\n  animatedElement: E,\n  toAndEndStyle: boolean,\n  animationConfig: AnimationConfig\n) {\n  const endStyle = toAndEndStyle\n    ? {\n        ...convertUseAnimationCssPropertiesToRegularCSS(animationConfig.to),\n        ...convertUseAnimationCssPropertiesToRegularCSS(animationConfig.end)\n      }\n    : convertUseAnimationCssPropertiesToRegularCSS(animationConfig.end);\n  for (const key in endStyle) {\n    //TO DO: Look for a better way to handle types.\n    (<any>animatedElement.style)[key] = endStyle[key as keyof typeof endStyle];\n  }\n}\n"],"names":["convertUseAnimationCssPropertiesToRegularCSS","useAnimationCssProperties","translateX","translateY","translateZ","rotateX","rotateY","rotateZ","scaleX","scaleY","scaleZ","skewX","skewY","otherCssProperties","finalTransformValue","convertTranslateShortcuts","convertRotateShortcuts","convertScaleShortcuts","convertSkewShortcuts","transform","convertUseAnimationCssPropertiesToWAAPIKeyframe","offset","cssOffset","animationState","animationStates","isAnimatedOnMount","onAnimationEnd","didMountRef","useRef","nodeRef","currentAnimationState","currentAnimation","animationStatesRef","useEffect","current","previousAnimationState","animation","node","element","playState","offsetWidth","offsetHeight","getClientRects","length","commitStyles","cancel","animatedElement","animationConfig","currentAnimationStateConfig","Object","keys","getConfig","delay","duration","easing","options","setAttribute","animationOptions","startedAnimation","animate","from","to","onfinish","removeAttribute","toAndEndStyle","endStyle","end","key","style","setEndStyle","startAnimation","cancelCurrentAnimation","useCallback","undefined","controller"],"mappings":"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"}