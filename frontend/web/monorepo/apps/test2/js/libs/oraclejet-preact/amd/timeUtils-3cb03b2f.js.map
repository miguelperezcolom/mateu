{"version":3,"file":"timeUtils-3cb03b2f.js","sources":["../../src/utils/UNSAFE_timeUtils/timeUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { EditableTimeSegmentType, OrderedTimeSegmentsArray } from '#UNSAFE_InputTimeMask/types';\nimport { BCP47Locale, DateTimeUtils } from '#UNSAFE_IntlDateTime';\nimport { TimeISOStr } from '#UNSAFE_IntlDateTime/types';\nimport { checkNoCalendarExtension } from '#utils/UNSAFE_calendarDateUtils';\nimport {\n  AmPmLocalizedValues,\n  FilteredDateTimeFormatPart,\n  Hour,\n  Millisecond,\n  MillisecondPlaceholder,\n  Minute,\n  Second,\n  Time,\n  TimeGranularity,\n  TimePlaceholders,\n  TimeWithValidIsoStrParts\n} from './types';\n\n// For locales that start with 'en', we use these placeholders.\nconst EN_LOCALE_PLACEHOLDER_HOUR = 'hh';\nconst EN_LOCALE_PLACEHOLDER_MINUTE = 'mm';\nconst EN_LOCALE_PLACEHOLDER_SECOND = 'ss';\nconst EN_LOCALE_PLACEHOLDER_MILLISECOND = 'sss';\n// For locales that do not start with 'en', we use these placeholders.\nconst NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER = '--';\nconst NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER = '---';\n\nconst AM_VALUE = 0;\nconst PM_VALUE = 12;\n\n/**\n * Given an ISO 8601 time-only string without zulu or offset e.g., 'T01:00:00.000' or 'T01:00', this method returns a Time object\n * containing 'hour' and 'minute', with optional 'second' and 'millisecond'.\n *\n * If the input is invalid (empty, null, undefined, or incorrectly formatted), this function returns undefined.\n * @param {TimeISOStr} isoTime - The ISO 8601 time string that starts with 'T'. (e.g., \"T12:30:45.123\")\n * @returns  (TimeWithValidIsoStrParts | undefined)\n * Returns a Time object with hour and minute, and optionally second and millisecond if they are in the input ISO string.\n * If the input is invalid, return undefined.\n */\nconst getTimeObjFromTimeOnlyISOStr = (isoTime: TimeISOStr | undefined | null) => {\n  // Ensure the input is defined and properly formatted.\n  if (isoTime === undefined || isoTime === null || !DateTimeUtils.isTimeOnlyIsoString(isoTime)) {\n    return undefined;\n  }\n\n  // Remove 'T' prefix and split into time and optional millisecond parts.\n  // A valid time-only ISO string must have hour and minute, and may optionally have second and millisecond.\n  const timePart = isoTime.substring(1);\n  const [fullTime, milliPart] = timePart.split('.');\n  const [hour, minute, second] = fullTime.split(':').map((num) => parseInt(num, 10));\n\n  let result: TimeWithValidIsoStrParts;\n\n  if (milliPart !== undefined) {\n    const millisecond = parseInt(milliPart, 10);\n    if (second === undefined) {\n      throw new Error('millisecond is set, but second is missing. This is an invalid iso string');\n    }\n    result = {\n      hour: hour as Hour,\n      minute: minute as Minute,\n      second: second as Second,\n      millisecond: millisecond as Millisecond\n    };\n  } else if (second !== undefined) {\n    result = {\n      hour: hour as Hour,\n      minute: minute as Minute,\n      second: second as Second\n    };\n  } else {\n    result = {\n      hour: hour as Hour,\n      minute: minute as Minute\n    };\n  }\n  return result;\n};\n\n/**\n * Given a Time object with hour, minute, and optionally second and millisecond, return a time-only ISO string that starts with 'T'.\n * @param {Time | undefined} Time object or undefined. The hour and minute must be defined, otherwise this function returns undefined.\n * @returns {TimeISOStr | undefined} Time-only ISO string that starts with 'T'. If the time is undefined, or the hour or minute are undefined, returns undefined.\n * @throws {Error} throws an error if milliseconds is defined but its value is out of the valid range of 0-999. The allowed range is too large to express in Typescript.\n */\nconst getTimeOnlyISOStrFromTimeObj = (time: Time | undefined) => {\n  if (time === undefined) {\n    return undefined;\n  }\n\n  const { hour, minute, second, millisecond } = time;\n\n  if (hour === undefined || minute === undefined) {\n    return undefined;\n  }\n\n  if (millisecond !== undefined && !checkIsValidIsoMillisecond(millisecond)) {\n    throw new Error(\n      'milliseconds is defined but it is out of range to be a valid iso string value. Must be 0-999.'\n    );\n  }\n\n  // Hour and minute must be 2 digits to be a valid ISO 8601 string.\n  const parts = [hour.toString().padStart(2, '0'), minute.toString().padStart(2, '0')];\n  let isoTime = parts.join(':');\n\n  if (second !== undefined) {\n    const secondPart = second.toString().padStart(2, '0');\n    isoTime += ':' + secondPart;\n\n    if (millisecond !== undefined) {\n      const msPart = millisecond.toString().padStart(3, '0');\n      if (msPart) {\n        isoTime += '.' + msPart;\n      }\n    }\n  }\n  return `T${isoTime}`;\n};\n\n/**\n * Returns a new array where the value in the masks array of type/value objects is replaced\n * with the string placeholders based on the locale.\n * For example, [{type='hour', value='hh'}, {type='minute', value='mm'} for 'en' locales,\n * or value='--' for non-'en' locales.\n * @param {BCP47Locale} locale - The locale.\n * @param {TimePlaceholders} masks - The TimePlaceholder masks\n * @returns A new array where the value in the masks array of type/value objects is replaced with\n * the string placeholders based on the locale.\n */\nconst replaceCustomMasksValuesWithPlaceholders = (\n  locale: BCP47Locale,\n  masks: TimePlaceholders\n): TimePlaceholders => {\n  const {\n    hourPlaceholder,\n    minutePlaceholder,\n    secondPlaceholder,\n    millisecondPlaceholder,\n    dayPeriodPlaceholder\n  } = getTimePlaceholderValuesFromLocale(locale);\n\n  return masks.map((p) => {\n    switch (p.type) {\n      case 'hour':\n        return { ...p, value: hourPlaceholder };\n      case 'minute':\n        return { ...p, value: minutePlaceholder };\n      case 'second':\n        return { ...p, value: secondPlaceholder };\n      case 'millisecond':\n        return { ...p, value: millisecondPlaceholder };\n      case 'dayPeriod':\n        return { ...p, value: dayPeriodPlaceholder };\n      default:\n        return { ...p };\n    }\n  }) as TimePlaceholders;\n};\n\n/**\n * Retrieves the TimePlaceholders masks where value has the placeholder (e.g., 'hh' or '--')\n * by using a new instance of Intl.DateTimeFormat with the locale, granularity, and hour12.\n *\n * @param {BCP47Locale} locale - The locale\n * @param {TimeGranularity} granularity - The granularity of the desired time mask.\n * @param hour12 - passes through to Intl.DateTimeFormat's hour12, which indicates\n * if the hour is a 12-hour (as opposed to 24-hour) clock.\n * E.g., new Intl.DateTimeFormat('en-GB', {timeStyle: 'short', hour12: true}).format(date)\n * @returns Returns the TimePlaceholder masks where value has the placeholders (e.g., 'hh' or '--').\n */\nconst getTimeMasksFromLocaleAndOptions = (\n  locale: BCP47Locale = 'en-US',\n  granularity: TimeGranularity,\n  hour12?: boolean\n) => {\n  checkNoCalendarExtension(locale);\n\n  // Filter out anything not related to a time mask.\n  // This does not filter out spaces, e.g., the literal space between the time and the dayPeriod.\n  const filterByTimeType = (parts: Intl.DateTimeFormatPart[]) => {\n    return parts.filter(\n      (p): p is FilteredDateTimeFormatPart =>\n        p.type === 'minute' ||\n        p.type === 'hour' ||\n        p.type === 'second' ||\n        p.type === 'dayPeriod' ||\n        p.type === 'literal'\n    );\n  };\n\n  const testDateWithTime = new Date('2022-11-30T00:00:00');\n  // If granularity is milliseconds, we use timeStyle: 'medium'. Later we stitch in the literal and millisecond part to medium since\n  // there is not a timeStyle for milliseconds, and you cannot use fractionalSecond: 3 with timeStyle in Intl.DateTimeFormat.\n  const timeStyle = granularity === 'minute' ? 'short' : 'medium';\n  const formatter = getTimeFormatterShortMedium(locale, timeStyle, hour12);\n\n  const parts = formatter.formatToParts(testDateWithTime);\n\n  const timeParts = filterByTimeType(parts);\n\n  // If granularity is millisecond, then add a separator and fractionalSecond to the array after seconds.\n  let allTimeParts;\n  if (granularity === 'millisecond') {\n    allTimeParts = insertFractionalSecond(locale, timeParts);\n  } else {\n    allTimeParts = timeParts;\n  }\n\n  // map it so that it has the same type as InputTimeMask's masks type of TimePlaceholders\n  const masks = allTimeParts.map((part) => {\n    switch (part.type) {\n      case 'fractionalSecond':\n        return { type: 'millisecond', value: part.value } as MillisecondPlaceholder;\n      case 'hour':\n      case 'minute':\n      case 'second':\n      case 'dayPeriod':\n      case 'literal':\n        return { ...part };\n    }\n  });\n\n  // replace part value with placeholder\n  return replaceCustomMasksValuesWithPlaceholders(locale, masks as TimePlaceholders);\n};\n\nconst cachedFractionalSecondsDigitFormatter = new Map<BCP47Locale, Intl.DateTimeFormat>();\n/**\n * Returns a new array with the fractionalSecond part\n * and its preceding separator part merged into the parts array after the seconds part.\n *\n * There is not an Intl.DateTimeFormat timeStyle option that displays milliseconds,\n * and you cannot use fractionalSecond: 3 with a timeStyle option at the same time in Intl.DateTimeFormat.\n * Therefore to get the parts for granularity: 'millisecond',\n * get parts from timeStyle: 'medium' and call this function with those parts. This function will stitch in\n * the separator and fractionalSecond parts after the 'second' part.\n *\n * @param {BCP47Locale} locale\n * @param {FilteredDateTimeFormatPart[]} parts - The parts from calling Intl.DateTimeFormat with timeStyle: 'medium'.\n * @returns a new parts array with the fractionalSecond and its preceding separator stitched into the parts array\n * after the 'second' part.\n */\nconst insertFractionalSecond = (locale: BCP47Locale, parts: FilteredDateTimeFormatPart[]) => {\n  const index = parts.findIndex((part) => part.type === 'second');\n  if (index === -1) {\n    // 'second' not found, return the array as is\n    return parts;\n  }\n\n  const cacheKey = `${locale}`;\n  let formatter = cachedFractionalSecondsDigitFormatter.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.DateTimeFormat(locale, {\n      hour: 'numeric',\n      minute: 'numeric',\n      second: '2-digit',\n      fractionalSecondDigits: 3,\n      numberingSystem: 'latn'\n    });\n    cachedFractionalSecondsDigitFormatter.set(cacheKey, formatter);\n  }\n\n  // get separatorValue that comes before the fractionalSecond part.\n  const partsWithFractionalSeconds = formatter.formatToParts(new Date());\n  const separatorPart = getLiteralBeforeFractionalSecond(partsWithFractionalSeconds);\n  if (separatorPart === null) {\n    return parts;\n  }\n  const newParts: FilteredDateTimeFormatPart[] = [\n    { type: 'literal', value: separatorPart.value },\n    { type: 'fractionalSecond', value: 'sss' }\n  ];\n\n  return [...parts.slice(0, index + 1), ...newParts, ...parts.slice(index + 1)];\n};\n\n/**\n * Finds and returns the 'literal' part immediately before the first 'fractionalSecond' part in an\n * array of Intl.DateTimeFormatPart objects. If not found, returns null.\n * @param {Intl.DateTimeFormatPart[]} parts\n * @returns {Intl.DateTimeFormatPart[]|null} - The literal part before the 'fractionalSecond' part.\n */\nconst getLiteralBeforeFractionalSecond = (parts: Intl.DateTimeFormatPart[]) => {\n  const index = parts.findIndex((part) => part.type === 'fractionalSecond');\n  if (index > 0 && parts[index - 1].type === 'literal') {\n    return parts[index - 1];\n  }\n  return null;\n};\n\n/**\n * Creates an object with the time segment placeholders based on the locale.\n * For locales that start with 'en', we use 'hh', 'mm', 'ss', 'sss', for\n * other locales we use '--' or '---' if millisecond.\n *\n * @param {BCP47Locale} locale\n * @returns An object with the time segment placeholders.\n */\nconst getTimePlaceholderValuesFromLocale = (locale: BCP47Locale) => {\n  const { am } = getAmPmStringsForLocale(locale);\n\n  if (locale.startsWith('en')) {\n    return {\n      hourPlaceholder: EN_LOCALE_PLACEHOLDER_HOUR,\n      minutePlaceholder: EN_LOCALE_PLACEHOLDER_MINUTE,\n      secondPlaceholder: EN_LOCALE_PLACEHOLDER_SECOND,\n      millisecondPlaceholder: EN_LOCALE_PLACEHOLDER_MILLISECOND,\n      dayPeriodPlaceholder: am\n    };\n  }\n\n  return {\n    hourPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    minutePlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    secondPlaceholder: NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER,\n    millisecondPlaceholder: NON_EN_LOCALE_THREE_DIGIT_PLACEHOLDER,\n    dayPeriodPlaceholder: am\n  };\n};\n\n/**\n * Creates a time formatter using new Intl.DateTimeFormat for the locale.\n * @param {BCP47Locale} locale - The locale to format the time.\n * @param {'short'|'medium'} timeStyle - The timeStyle formatting option.\n * @param {boolean} hour12 - Whether to use 12-hour time format.\n * @returns A new formatter instance for the specified locale and options.\n */\nconst getTimeFormatterShortMedium = (\n  locale: BCP47Locale,\n  timeStyle: 'short' | 'medium',\n  hour12?: boolean\n) => {\n  const options =\n    hour12 === undefined\n      ? { timeStyle, numberingSystem: 'latn' }\n      : { timeStyle, hour12, numberingSystem: 'latn' };\n\n  return new Intl.DateTimeFormat(locale, options);\n};\n\n/**\n * Gets the day period value strings for AM and PM.\n *\n * @param {BCP47Locale} locale - The locale to format the time.\n * @returns An object containing the AM and PM strings for the locale.\n */\nconst getAmPmStringsForLocale = (locale: BCP47Locale): AmPmLocalizedValues => {\n  const am = getDayPeriodValueStr(locale, 0); // 0 is 12 AM\n  const pm = getDayPeriodValueStr(locale, 13); // 13 is 1 PM\n  return { am, pm };\n};\n\nconst cachedDayPeriodString = new Map<string, string>();\n\n/**\n * Retrieves the day period string for a specific locale and hour.\n * This uses a cache so a new instance of Intl.DateTimeFormat with hour12: true so even if the locale\n * does not have a 1-12 hour time by default, the hour12: true parameter will force it.\n * For example, for 'en-US' if the hour is 0, this returns 'AM'. If the hour is 13, this returns 'PM'.\n * For 'ms', if the hour is 0, this returns 'PG'.\n *\n * @param {BCP47Locale} locale - The locale to format the time.\n * @param {Hour} hour - The hour for which to get the day period (0-23).\n * @returns {string} The locale's day period value for the hour. All locales have a dayPeriod string, but\n * just in case we default to 'AM' and 'PM'.\n */\nconst getDayPeriodValueStr = (locale: BCP47Locale = 'en-US', hour: Hour) => {\n  const morningIsoHourStr = '00';\n  const eveningIsoHourStr = '23';\n  const isoHourStr = hour < 12 ? morningIsoHourStr : eveningIsoHourStr;\n\n  // is locale + isoHourStr in the cache? If so, return it.\n  const dayPeriod = cachedDayPeriodString.get(`${locale}-${isoHourStr}`);\n  if (!dayPeriod) {\n    // This sets hour12 to true.\n    const formatter = getTimeFormatterShortMedium(locale, 'short', true);\n    // Cache both am and pm values at the same time in order to use the same formatter for performance sake.\n    [morningIsoHourStr, eveningIsoHourStr].forEach((hourToCache) => {\n      const isoStr = `2022-11-30T${hourToCache}:00:00`;\n      const date = new Date(isoStr);\n      const parts = formatter.formatToParts(date);\n      const dayPeriodPart = parts.find((p) => p.type === 'dayPeriod');\n      // All locales I tested have a dayPeriod string when hour12: true,\n      // but just in case there is a locale for Intl.DateTimeFormat with no dayPeriod string, we default to one.\n      const defaultDayPeriodToCache = hourToCache === morningIsoHourStr ? 'AM' : 'PM';\n      const dayPeriodToCache = dayPeriodPart ? dayPeriodPart.value : defaultDayPeriodToCache;\n      cachedDayPeriodString.set(`${locale}-${hourToCache}`, dayPeriodToCache);\n    });\n    // return the dayPeriod for the hour requested that we just cached.\n    return cachedDayPeriodString.get(`${locale}-${isoHourStr}`)!;\n  }\n  return dayPeriod;\n};\n\nconst getDayPeriodValueFromHour = (hour: Hour) => {\n  return hour > 11 ? PM_VALUE : AM_VALUE;\n};\n\n/**\n * Formats a Time object into a string based on the provided masks.\n * Handles hour conversion (12-hour/24-hour) since the Time object is in 24-hour format,\n * and the mask, if it has the dayPeriod, is in 12-hour format. Applies leading\n * zeros to hour if leadingZeroForHour is true. Pads zeros to minute, second, and millisecond so\n * that the digits equal two for minute/second and three for millisecond.\n * The timeMasks must have the correct segments to match the granularity before calling this function.\n * @param locale\n * @param time\n * @param granularity\n * @param timeMasks\n * @param leadingZeroForHour\n * @returns a formatted time string\n */\nconst formatTimeFromMasks = (\n  locale: BCP47Locale,\n  time: Time,\n  granularity: TimeGranularity,\n  timeMasks: TimePlaceholders,\n  leadingZeroForHour: boolean\n) => {\n  checkNoCalendarExtension(locale);\n  // First, the time must be complete.\n  if (\n    time.hour === undefined ||\n    time.minute === undefined ||\n    (granularity === 'second' && time.second === undefined) ||\n    (granularity === 'millisecond' && time.millisecond === undefined)\n  ) {\n    return '';\n  }\n\n  const hasDayPeriod = timeMasks.some((part) => part.type === 'dayPeriod');\n  const dayPeriodToDisplay = hasDayPeriod ? getDayPeriodValueStr(locale, time.hour) : ''; // e.g., 'AM' or 'PM' for 'en-US'\n\n  // Format hour with optional leading zero\n  const timeHour = hasDayPeriod ? to12Hour(time.hour) : time.hour;\n  const hourToDisplay = leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();\n\n  // Format minute, second, and millisecond with necessary padding\n  const minuteToDisplay = padWithZero(time.minute, 2);\n  const secondToDisplay = padWithZero(time.second, 2);\n  const millisecondToDisplay = padWithZero(time.millisecond, 3);\n\n  // Map timeMasks to their corresponding values and join them into a formatted time string.\n  const timeValues = timeMasks.map(({ type, value }) =>\n    type === 'hour'\n      ? hourToDisplay\n      : type === 'minute'\n      ? minuteToDisplay\n      : type === 'second'\n      ? secondToDisplay\n      : type === 'millisecond'\n      ? millisecondToDisplay\n      : type === 'dayPeriod'\n      ? dayPeriodToDisplay\n      : value\n  );\n  return timeValues.join('');\n};\n\n/**\n * Retrieves the hour string. If the display has a day period, then the hour string\n * will be 1-12, otherwise it will be 0-23.\n * @param hour\n * @param hasDayPeriod true if the time to display has a day period segment (e.g., a segment that shows AM or PM).\n * This means the time field has a 1-12 hour time.\n * @param leadingZeroForHour If true, the hour string will have length of 2, with leading zeros if necessary to pad it out.\n * @returns\n */\nconst getHourValueStr = (hour: Hour, hasDayPeriod: boolean, leadingZeroForHour: boolean) => {\n  // If hasDayPeriod, the hour to display is in the range of 1-12. E.g., 1:00 AM.\n  // Since the hour parameter is 0-23, the hour to display needs to be converted to a 1-12 hour string.\n  // If hasDayPeriod is false, the hour to display is in the range of 0-23. E.g., 01:00.\n  const timeHour = hasDayPeriod ? to12Hour(hour) : hour;\n  return leadingZeroForHour ? padWithZero(timeHour, 2) : timeHour.toString();\n};\n\nconst cachedTimeStyleShortHasLeadingZero = new Map<BCP47Locale, boolean>();\n/**\n * Returns true if the locale's hour has a leading zero by default.\n *\n * This method uses a cached new Intl.DateTimeFormat(locale),\n * and uses formatToParts for hour\n * to figure out if the hour has a leading zero.\n *\n * @param {BCP47Locale} locale - the locale\n * @returns true if hour starts with 0 for the specific locale.\n */\nconst getLeadingZeroForHour = (locale: BCP47Locale) => {\n  // check timeStyle short for the locale\n  // and see if the hour starts with 0.\n  // if so, return true;\n  const value = new Date('1995-12-17T09:30:00');\n  const cacheKey = `${locale}`;\n  let isLeadingZero = cachedTimeStyleShortHasLeadingZero.get(cacheKey);\n  if (isLeadingZero === undefined) {\n    const formatter = new Intl.DateTimeFormat(locale, {\n      timeStyle: 'short',\n      numberingSystem: 'latn'\n    });\n    const parts = formatter.formatToParts(value);\n    const hourPart = parts.find((part) => part.type === 'hour');\n    const hourValue = hourPart?.value;\n    isLeadingZero = hourValue!.startsWith('0');\n    cachedTimeStyleShortHasLeadingZero.set(cacheKey, isLeadingZero);\n  }\n\n  return isLeadingZero;\n};\n\n/**\n * Converts the 24-hour hour to a 12-hour hour.\n * @param {Hour} hour24\n * @returns\n */\nconst to12Hour = (hour24: Hour) => {\n  const hour12 = hour24 % 12 === 0 ? 12 : hour24 % 12;\n  return hour12;\n};\n\nconst padWithZero = (num: number | undefined, length: number) => {\n  return num !== undefined ? num.toString().padStart(length, '0') : '';\n};\n\n/**\n * Returns true if the time params represent two different times.\n * This is useful to call before we call onInput or onCommit.\n * @param t1\n * @param t2\n * @returns true if the time params represent two different times.\n */\nconst timesAreDifferent = (t1: Time | undefined, t2: Time | undefined) => {\n  const isEmpty = (time: Time | undefined) => {\n    return (\n      !time || // if time is undefined\n      (time.hour === undefined &&\n        time.minute === undefined &&\n        time.second === undefined &&\n        time.millisecond === undefined)\n    );\n  };\n\n  // Both are empty/undefined, return false (same)\n  if (isEmpty(t1) && isEmpty(t2)) return false;\n\n  // If one is empty/undefined and the other isn't, return true (different)\n  if (isEmpty(t1) !== isEmpty(t2)) return true;\n\n  // Return true if any of the segment values don't match.\n  if (\n    t1?.hour !== t2?.hour ||\n    t1?.minute !== t2?.minute ||\n    t1?.second !== t2?.second ||\n    t1?.millisecond !== t2?.millisecond\n  ) {\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Compares two TimeWithValidIsoStrParts objects and returns a number indicating their relative order.\n * @param {TimeWithValidIsoStrParts} time1 The first time to compare.\n * @param {TimeWithValidIsoStrParts} time2 The second time to compare.\n * @returns {number} A negative number if time1 is before time2, a positive number if time1 is after time2, or 0 if they are the same.\n */\nconst compareTimes = (time1: TimeWithValidIsoStrParts, time2: TimeWithValidIsoStrParts) => {\n  if (time1.hour !== time2.hour) {\n    return time1.hour - time2.hour;\n  }\n  if (time1.minute !== time2.minute) {\n    return time1.minute - time2.minute;\n  }\n  // fill second and millisecond to 0 if it isn't filled in.\n  const time1Second = time1.second ?? 0;\n  const time2Second = time2.second ?? 0;\n  if (time1Second !== time2Second) {\n    return time1Second - time2Second;\n  }\n  const time1Millisecond = time1.millisecond ?? 0;\n  const time2Millisecond = time2.millisecond ?? 0;\n  return time1Millisecond - time2Millisecond;\n};\n\n/**\n * Determines whether the input string matches the start of the 'am' and/or 'pm' strings in the given am/pm object.\n *\n * The match is case-insensitive and ignores leading and trailing whitespace.\n *\n * If the input matches with only the start of the 'am' string, 'am' is returned.\n * If the input matches with only the start of the 'pm' string, 'pm' is returned.\n * If the input matches the start of both the 'am' and 'pm strings (e.g., the 'am'/'pm' strings have the same starting letter(s) and the input is too short to disambiguate),\n * 'both is returned.\n * If the input does not match the start of either string, 'none' is returned.\n * @param {AmPmLocalizedValues} amPmObj - An object containing the am and pm strings for the current locale.\n * @param {string} input - The user provided string to match against the am an pm strings.\n * @returns {('am' | 'pm' | 'none' | 'both')}\n */\nconst getAmPmMatchType = (amPmObj: AmPmLocalizedValues, input: string) => {\n  const trimmedInput = input.trim().toLowerCase();\n\n  // If input is empty after trimming, return 'none'\n  if (trimmedInput === '') {\n    return 'none';\n  }\n\n  // Check if the input matches as a prefix in either property (am or pm)\n  const matchesAM = amPmObj.am.toLowerCase().startsWith(trimmedInput);\n  const matchesPM = amPmObj.pm.toLowerCase().startsWith(trimmedInput);\n\n  // If both match, return 'both'\n  if (matchesAM && matchesPM) {\n    return 'both';\n  }\n\n  // If only one matches, return that\n  if (matchesAM) {\n    return 'am';\n  }\n\n  if (matchesPM) {\n    return 'pm';\n  }\n\n  // If neither matches\n  return 'none';\n};\n\n/**\n * Check if the value has segments in it that are not displayed to the user.\n * E.g., originalValue: {hour: 1, minute: 30, second: 59, millisecond: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {millisecond: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {second: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {second: 599}, and the segments are: ['hour', 'minute'], returns true.\n * originalValue: {hour: 1, minute: 30, second: 599}, and the segments are: ['hour', 'minute', 'second'], returns false.\n * @param orderedSegments {OrderedTimeSegmentsArray} - The segments that are displayed to the user\n * @param originalValue {Time|undefined} - The original Time value.\n * @returns {boolean} returns true if the originalValue has segments that are not displayed to the user.\n */\nconst hasSegmentsNotDisplayed = (\n  orderedSegments: OrderedTimeSegmentsArray,\n  originalValue: Time | undefined\n) => {\n  if (originalValue === undefined) {\n    return false;\n  }\n  // orderedSegments are the segments that are displayed to the user.\n  // filter out the 'dayPeriod' since that is not part of the Time object.\n  const filteredSegments = orderedSegments.filter((item) => item !== 'dayPeriod');\n\n  // loop through each key in the original value and see if it exists in the filteredSegments\n  const hasExtraSegmentsCondition = (key: string) =>\n    (key === 'hour' || key === 'minute' || key === 'second' || key === 'millisecond') &&\n    !filteredSegments.includes(key);\n  return Object.keys(originalValue).some(hasExtraSegmentsCondition);\n};\n\n/**\n * Returns true if any one of the displayed time segments has a different value in initialTime vs updatedTime.\n * @param orderedSegments {OrderedTimeSegmentsArray} the time segments that are displayed to the user\n * @param initialTime {Time} The initial time.\n * @param updatedTime {Time} The updated time.\n * @returns true if the displayed time segments have different values\n */\nconst displayedTimeSegmentsAreDifferent = (\n  orderedSegments: OrderedTimeSegmentsArray,\n  initialTime: Time,\n  updatedTime: Time\n) => {\n  // orderedSegments are the segments that are displayed to the user.\n  // filter out the 'dayPeriod' since that is not part of the Time object.\n  const filteredSegments = orderedSegments.filter((item) => item !== 'dayPeriod') as Array<\n    Exclude<EditableTimeSegmentType, 'dayPeriod'>\n  >;\n  for (const key of filteredSegments) {\n    const value1 = initialTime[key]; // might be undefined. In which case, this will return true if value2 also has undefined for this key.\n    const value2 = updatedTime[key];\n    if (value1 !== value2) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if millisecond is a valid ISO value (0-999).\n * The allowed range is too large to express using Typescript.\n */\nconst checkIsValidIsoMillisecond = (millisecond: number) => {\n  return millisecond >= 0 && millisecond <= 999;\n};\n\n/**\n * Format an example TimeISOStr to show in an error message.\n */\nconst formatIsoTimeStrAsExample = (\n  str: TimeISOStr,\n  locale: BCP47Locale,\n  granularity: TimeGranularity,\n  leadingZeroForHour: boolean,\n  masks: TimePlaceholders\n) => {\n  const timeObj = getTimeObjFromTimeOnlyISOStr(str);\n  return timeObj === undefined\n    ? ''\n    : formatTimeFromMasks(locale, timeObj, granularity, masks, leadingZeroForHour);\n};\n\n// Given a pattern, return a TimePlaceholder array.\nconst getTimePlaceholdersFromPattern = (pattern: string) => {\n  const arr = getTimeMaskArrayFromPattern(pattern);\n  const timePlaceholders = convertMaskArrayToTimePlaceholders(arr);\n  return timePlaceholders;\n};\n\n// Given a pattern, like 'h:ss a', return an array like ['h', ':', 'ss', ' ', 'a'].\n// We only support pattern for FA User Preferences, and none of the FA time patterns have milliseconds.\nconst getTimeMaskArrayFromPattern = (pattern: string) => {\n  const result: Array<string> = [];\n  let currentSegmentStr = '';\n  let currentLiteral = '';\n\n  const addSegment = () => {\n    if (currentSegmentStr !== '') {\n      result.push(currentSegmentStr);\n      currentSegmentStr = '';\n    }\n  };\n\n  const addLiteral = () => {\n    if (currentLiteral !== '') {\n      // InputTimeMask wants spaces in its literals, like the space between the time and dayPeriod.\n      result.push(currentLiteral);\n      currentLiteral = '';\n    }\n  };\n\n  for (let i = 0; i < pattern.length; i++) {\n    const char = pattern[i];\n\n    // if we get a character that is not a literal, then push the literal, if any.\n    // This also handles the case where the pattern does not have a space between the 'a' (dayPeriod)\n    // and the hour, minute, or second, like 'ahh:mm:ss' or 'hh:mma' or 'hh:mm:ssa'; These dayPeriod\n    // and hour, minute, second are different segments even though there is no space.\n    // Currently there are no user preference patterns with 'a' at the end with no space before it,\n    // but we handle it just the same.\n    // None of the FA User Preference patterns have milliseconds, so we do not support that here.\n    if (\n      char.toLowerCase() === 'h' ||\n      char.toLowerCase() === 'm' ||\n      char.toLowerCase() === 's' ||\n      char.toLowerCase() === 'a'\n    ) {\n      addLiteral();\n      if (currentSegmentStr[0] === char) {\n        currentSegmentStr += char;\n      } else {\n        addSegment();\n        currentSegmentStr = char;\n      }\n    } else {\n      addSegment();\n      currentLiteral += char;\n    }\n  }\n\n  // Add the last components\n  addSegment();\n  addLiteral();\n\n  return result;\n};\n\n// converts an array into the object that is needed to set on the InputTimeMask's masks property, TimePlaceholders type;\n// This is used when converting a pattern into a masks property.\n// None of the FA User Preference patterns have milliseconds, so we do not support that here.\nconst convertMaskArrayToTimePlaceholders = (array: Array<string>) => {\n  return array.map((item) => {\n    if (item.toLowerCase()[0] === 'h') {\n      return { type: 'hour', value: EN_LOCALE_PLACEHOLDER_HOUR };\n    } else if (item.toLowerCase()[0] === 'm') {\n      return { type: 'minute', value: EN_LOCALE_PLACEHOLDER_MINUTE };\n    } else if (item.toLowerCase()[0] === 's') {\n      return { type: 'second', value: EN_LOCALE_PLACEHOLDER_SECOND };\n    } else if (item.toLowerCase()[0] === 'a') {\n      return { type: 'dayPeriod', value: 'am/pm' };\n    } else {\n      // Default to literal for anything else\n      return { type: 'literal', value: item };\n    }\n  }) as TimePlaceholders;\n};\n\nexport {\n  AM_VALUE,\n  PM_VALUE,\n  compareTimes,\n  displayedTimeSegmentsAreDifferent,\n  formatIsoTimeStrAsExample,\n  formatTimeFromMasks,\n  getAmPmMatchType,\n  getAmPmStringsForLocale,\n  getDayPeriodValueFromHour,\n  getDayPeriodValueStr,\n  getHourValueStr,\n  getLeadingZeroForHour,\n  getTimeOnlyISOStrFromTimeObj,\n  getTimePlaceholdersFromPattern,\n  getTimeObjFromTimeOnlyISOStr,\n  getTimeMasksFromLocaleAndOptions,\n  hasSegmentsNotDisplayed,\n  padWithZero,\n  replaceCustomMasksValuesWithPlaceholders,\n  timesAreDifferent\n};\n"],"names":["NON_EN_LOCALE_TWO_DIGIT_PLACEHOLDER","getTimeObjFromTimeOnlyISOStr","isoTime","DateTimeUtils.isTimeOnlyIsoString","timePart","substring","fullTime","milliPart","split","hour","minute","second","map","num","parseInt","result","undefined","millisecond","Error","replaceCustomMasksValuesWithPlaceholders","locale","masks","hourPlaceholder","minutePlaceholder","secondPlaceholder","millisecondPlaceholder","dayPeriodPlaceholder","getTimePlaceholderValuesFromLocale","p","type","value","cachedFractionalSecondsDigitFormatter","Map","insertFractionalSecond","parts","index","findIndex","part","cacheKey","formatter","get","Intl","DateTimeFormat","fractionalSecondDigits","numberingSystem","set","partsWithFractionalSeconds","formatToParts","Date","separatorPart","getLiteralBeforeFractionalSecond","newParts","slice","am","getAmPmStringsForLocale","startsWith","getTimeFormatterShortMedium","timeStyle","hour12","options","getDayPeriodValueStr","pm","cachedDayPeriodString","morningIsoHourStr","eveningIsoHourStr","isoHourStr","dayPeriod","forEach","hourToCache","date","dayPeriodPart","find","defaultDayPeriodToCache","dayPeriodToCache","formatTimeFromMasks","time","granularity","timeMasks","leadingZeroForHour","checkNoCalendarExtension","hasDayPeriod","some","dayPeriodToDisplay","timeHour","to12Hour","hourToDisplay","padWithZero","toString","minuteToDisplay","secondToDisplay","millisecondToDisplay","join","cachedTimeStyleShortHasLeadingZero","hour24","length","padStart","checkIsValidIsoMillisecond","getTimeMaskArrayFromPattern","pattern","currentSegmentStr","currentLiteral","addSegment","push","addLiteral","i","char","toLowerCase","convertMaskArrayToTimePlaceholders","array","item","time1","time2","time1Second","time2Second","orderedSegments","initialTime","updatedTime","filteredSegments","filter","key","str","timeObj","amPmObj","input","trimmedInput","trim","matchesAM","matchesPM","isLeadingZero","hourPart","hourValue","testDateWithTime","timeParts","filterByTimeType","allTimeParts","msPart","arr","originalValue","Object","keys","includes","t1","t2","isEmpty"],"mappings":"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"}