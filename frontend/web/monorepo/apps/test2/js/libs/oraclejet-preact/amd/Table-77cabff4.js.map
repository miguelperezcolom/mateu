{"version":3,"file":"Table-77cabff4.js","sources":["../../src/PRIVATE_Table/TableColGroup.tsx","../../src/PRIVATE_Table/TableSkeleton.tsx","../../src/PRIVATE_Table/TableSkeletonRow.tsx","../../src/PRIVATE_Table/utils/TableThemeUtils.ts","../../src/PRIVATE_Table/utils/TableDomUtils.ts","../../src/PRIVATE_Table/utils/TableTooltipUtils.ts","../../src/PRIVATE_Table/TableCell.tsx","../../src/PRIVATE_Table/TableRow.tsx","../../src/PRIVATE_Table/TableNoData.tsx","../../src/PRIVATE_Table/TableBody.tsx","../../src/PRIVATE_Table/TableHeaderCell.tsx","../../src/PRIVATE_Table/TableHeader.tsx","../../src/PRIVATE_Table/TableFooterCell.tsx","../../src/PRIVATE_Table/TableFooter.tsx","../../src/PRIVATE_Table/TableDragIndicator.tsx","../../src/PRIVATE_Table/TableContextMenu.tsx","../../src/PRIVATE_Table/utils/TableScrollUtils.ts","../../src/PRIVATE_Table/utils/TableFocusUtils.tsx","../../src/PRIVATE_Table/hooks/useContextMenu.ts","../../src/PRIVATE_Table/hooks/useTruncationTooltip.tsx","../../src/PRIVATE_Table/hooks/useFocusHandling.ts","../../src/PRIVATE_Table/utils/TableActionUtils.ts","../../src/PRIVATE_Table/utils/TableInteractionUtils.ts","../../src/PRIVATE_Table/utils/TableNavigationUtils.ts","../../src/PRIVATE_Table/utils/TableSelectionUtils.ts","../../src/PRIVATE_Table/utils/TableSizingUtils.ts","../../src/PRIVATE_Table/hooks/usePointerHandling.ts","../../src/PRIVATE_Table/hooks/useScrollHandling.ts","../../src/PRIVATE_Table/hooks/useInteractionManager.ts","../../src/PRIVATE_Table/hooks/useKeyboardHandling.ts","../../src/PRIVATE_Table/utils/TableLayoutUtils.ts","../../src/PRIVATE_Table/hooks/useSizingManager.ts","../../src/PRIVATE_Table/Table.tsx","../../src/PRIVATE_Table/hooks/useDataManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n/**\n * Props for the TableColGroup Component\n */\nexport type TableColGroupProps = {\n  tableId: string;\n  isRendered: boolean;\n  columnWidthsArray: (number | undefined)[];\n};\n\n/**\n * The internal component used to render a single colgroup in Table.\n */\nexport function TableColGroup({ tableId, isRendered, columnWidthsArray }: TableColGroupProps) {\n  const getColStyle = (columnWidth?: number) => {\n    return columnWidth == null ? '' : `width:${columnWidth}px;`;\n  };\n\n  return isRendered ? (\n    <colgroup>\n      {columnWidthsArray.map((columnWidth?: number) => {\n        return <col style={getColStyle(columnWidth)} data-oj-table-col={tableId} />;\n      })}\n    </colgroup>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Size } from '../utils/UNSAFE_size';\nimport { dimensionInterpolations } from '../utils/UNSAFE_interpolations/dimensions';\nimport { mergeInterpolations } from '../utils/UNSAFE_mergeInterpolations';\nimport { tableSkeletonStyles, tableSkeletonStylesHC } from './themes/TableSkeletonStyles.css';\n\nconst dimensions = ['height', 'width'] as const;\n//This type has StyleInterpolationProps with the height prop made required.\ntype TableSkeletonProps = {\n  isHighContrast: boolean;\n  height?: Size;\n  width?: Size;\n};\n\n// Create an array [dimensionInterpolations['height'], dimensionInterpolations['width']]\nconst skeletonDimensionInterpolation = Array.from(dimensions, (x) => dimensionInterpolations[x]);\nconst interpolations = [...Object.values(skeletonDimensionInterpolation)];\nconst SkeletonInterpolations = mergeInterpolations<TableSkeletonProps>(interpolations);\n\n/**\n * TableSkeleton component allows the appropriate skeleton to be rendered based on the\n * property values\n **/\nexport function TableSkeleton({ ...props }: TableSkeletonProps) {\n  const skeletonStyles = props.isHighContrast ? tableSkeletonStylesHC : tableSkeletonStyles;\n  const classes = classNames([skeletonStyles.bar]);\n\n  const skeletonDimensions = SkeletonInterpolations({ width: '100%', ...props });\n  return <div style={skeletonDimensions} class={classes} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { tableSkeletonStyles, tableSkeletonStylesHC } from './themes/TableSkeletonStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { TableSkeleton } from './TableSkeleton';\n\ntype SkeletonRowProps = {\n  tableId: string;\n  colspan: number;\n  hasTabIndex: boolean;\n  isShowFocusRing: boolean;\n  isPendingLayout?: boolean;\n  isLoadMore?: boolean;\n  isHighContrast: boolean;\n};\n\n/**\n * TableSkeletonRow renders a set of 'loading' skeletons.\n **/\nexport function TableSkeletonRow({\n  tableId,\n  colspan,\n  hasTabIndex,\n  isShowFocusRing,\n  isPendingLayout = false,\n  isLoadMore = false,\n  isHighContrast\n}: SkeletonRowProps) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const skeletonStyles = isHighContrast ? tableSkeletonStylesHC : tableSkeletonStyles;\n  const cellClassArray = [skeletonStyles.cell];\n  if (isShowFocusRing) {\n    cellClassArray.push(skeletonStyles.focus);\n  }\n  const cellClasses = classNames(cellClassArray);\n  const innerCellClasses = classNames([skeletonStyles.innerCell]);\n  const rowClasses = classNames([skeletonStyles.row, skeletonStyles.rowHeight]);\n  const firstRowClasses = isPendingLayout\n    ? classNames([skeletonStyles.row, skeletonStyles.headerHeight])\n    : rowClasses;\n\n  const accCellContent = (\n    <div style={'width:1px;height:0px;overflow:hidden;'}>{translations.collection_loading()}</div>\n  );\n\n  return (\n    <tr class={LOADMORE_STYLE_CLASS} role={'row'}>\n      <td\n        class={cellClasses}\n        colSpan={colspan}\n        role={'gridcell'}\n        tabIndex={hasTabIndex ? 0 : -1}\n        data-oj-cell-type={isPendingLayout ? 'pending' : isLoadMore ? 'loadMore' : 'loading'}\n        {...(isPendingLayout\n          ? { 'data-oj-table-pending-cell': tableId }\n          : isLoadMore\n          ? { 'data-oj-table-load-more-cell': tableId }\n          : { 'data-oj-table-loading-cell': tableId })}\n        data-oj-table-focusable={tableId}>\n        <div class={innerCellClasses}>\n          {accCellContent}\n          {[...Array(isLoadMore ? 3 : 25)].map((_element, index) => (\n            <div class={index === 0 ? firstRowClasses : rowClasses}>\n              <TableSkeleton height=\"4x\" isHighContrast={isHighContrast} />\n            </div>\n          ))}\n        </div>\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { textAlignStyles, verticalAlignStyles } from '../themes/Table.css';\nimport { CellStyles, tableCellStyles, tableCellStylesHC } from '../themes/TableCellStyles.css';\nimport {\n  FooterCellStyles,\n  tableFooterCellStyles,\n  tableFooterCellStylesHC\n} from '../themes/TableFooterCellStyles.css';\nimport {\n  HeaderCellStyles,\n  tableHeaderCellStyles,\n  tableHeaderCellStylesHC\n} from '../themes/TableHeaderCellStyles.css';\nimport { CellPadding, CurrentRowVariant } from '../../UNSAFE_TableView';\n\ntype DataCellThemingProps = {\n  isFirstColumnIndex: boolean;\n  isFinalColumnIndex: boolean;\n  isFirstRowIndex: boolean;\n  isFinalRowIndex: boolean;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasLastHorizontalGridline: boolean;\n  isRowSelected: boolean;\n  isPreviousRowSelected: boolean;\n  isColumnSelected: boolean;\n  isNextColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isShowFocusRing: boolean;\n  isSticky: boolean;\n  isRowSelectionEnabled: boolean;\n  isRowSingleSelection: boolean;\n  isActive: boolean;\n  isHover: boolean;\n  isPseudoHover: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  hasStartEdge: boolean;\n  hasEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment: 'top' | 'center' | 'bottom';\n  variant?: CurrentRowVariant;\n  padding?: CellPadding;\n};\n\n/**\n * Helper function to generate the class array for a data cell.\n */\nexport const getDataCellClassArray = ({\n  isFirstColumnIndex,\n  isFinalColumnIndex,\n  isFirstRowIndex,\n  isFinalRowIndex,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasLastHorizontalGridline,\n  isRowSelected,\n  isPreviousRowSelected,\n  isColumnSelected,\n  isNextColumnSelected,\n  isPreviousColumnSelected,\n  isShowFocusRing,\n  isSticky,\n  isRowSelectionEnabled,\n  isRowSingleSelection,\n  isActive,\n  isHover,\n  isPseudoHover,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  hasStartEdge,\n  hasEndEdge,\n  isRtl,\n  isHighContrast,\n  horizontalAlignment,\n  verticalAlignment,\n  variant,\n  padding\n}: DataCellThemingProps) => {\n  const cellStyles = isHighContrast ? tableCellStylesHC : tableCellStyles;\n  const classArray = [cellStyles.base];\n\n  // Padding styling logic\n  const { isTopPadding, isBottomPadding, isStartPadding, isEndPadding } = _getPaddingInfo(padding);\n\n  // Horizontal and vertical alignment styling logic\n  _applyAlignmentStyling(classArray, horizontalAlignment, verticalAlignment);\n\n  // Sticky styling logic\n  _applyStickyStyling(classArray, cellStyles, isSticky, isStickyStartEdge, isStickyEndEdge, isRtl);\n\n  // Interaction styling logic\n  if (isRowSelectionEnabled) {\n    if (isActive) {\n      classArray.push(cellStyles.active);\n    } else if (isHover) {\n      classArray.push(cellStyles.hover);\n    } else if (isPseudoHover) {\n      classArray.push(cellStyles.pseudoHover);\n    }\n  }\n  if (variant === 'highlight') {\n    classArray.push(cellStyles.rowHighlight);\n  }\n  _applyFocusStyling(classArray, cellStyles, isShowFocusRing);\n\n  // Selected Rows and Horizontal Gridline styling logic\n  let hasBackground = false;\n  if (isRowSelected) {\n    hasBackground = true;\n    classArray.push(cellStyles.selectedBackground);\n  }\n  if (isRowSingleSelection && (isRowSelected || isPreviousRowSelected)) {\n    classArray.push(cellStyles.horizontalSelectedGridTop);\n    classArray.push(\n      isTopPadding ? cellStyles.selectedBorderTopPadding : cellStyles.selectedBorderTopNoPadding\n    );\n  } else if (!isFirstRowIndex && hasHorizontalGridlines) {\n    classArray.push(cellStyles.horizontalGridTop);\n    classArray.push(isTopPadding ? cellStyles.borderTopPadding : cellStyles.borderTopNoPadding);\n  } else {\n    classArray.push(isTopPadding ? cellStyles.topSpacerPadding : cellStyles.topSpacerNoPadding);\n  }\n  if (isFinalRowIndex) {\n    classArray.push(cellStyles.lastRow);\n    if (isRowSingleSelection && isRowSelected) {\n      classArray.push(cellStyles.horizontalSelectedGridBottom);\n      classArray.push(\n        isBottomPadding\n          ? cellStyles.selectedBorderBottomPadding\n          : cellStyles.selectedBorderBottomNoPadding\n      );\n    } else if (hasLastHorizontalGridline) {\n      classArray.push(cellStyles.horizontalGridBottom);\n      classArray.push(\n        isBottomPadding ? cellStyles.borderBottomPadding : cellStyles.borderBottomNoPadding\n      );\n    } else {\n      classArray.push(\n        isBottomPadding ? cellStyles.bottomSpacerPadding : cellStyles.bottomSpacerNoPadding\n      );\n    }\n  } else {\n    classArray.push(cellStyles.notLastRow);\n    classArray.push(isBottomPadding ? cellStyles.bottomPadding : cellStyles.bottomNoPadding);\n  }\n\n  // Selected Columns and Vertical Gridline styling logic\n  if (isColumnSelected) {\n    if (!hasBackground) {\n      classArray.push(cellStyles.selectedBackground);\n      hasBackground = true;\n    }\n    _applySelectedColumnStyling(\n      classArray,\n      cellStyles,\n      isStartPadding,\n      isEndPadding,\n      hasStartEdge,\n      hasEndEdge\n    );\n  } else {\n    if (!hasBackground) {\n      classArray.push(cellStyles.background);\n    }\n    _applyColumnStyling(\n      classArray,\n      cellStyles,\n      isStartPadding,\n      isEndPadding,\n      isFirstColumnIndex,\n      isFinalColumnIndex,\n      hasStartEdge,\n      hasEndEdge,\n      isNextColumnSelected,\n      isPreviousColumnSelected,\n      hasVerticalGridlines\n    );\n  }\n  return classArray;\n};\n\ntype HeaderFooterCellThemingProps = {\n  isHeader: boolean;\n  isActiveStyle: boolean;\n  isHoverStyle: boolean;\n  isPreviousCellActiveStyle: boolean;\n  isPreviousCellHoverStyle: boolean;\n  isFirstColumnIndex: boolean;\n  isFinalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isSelected: boolean;\n  isNextColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isSticky: boolean;\n  stickyInteractionIndex?: number;\n  stickyNeighborIndex?: number;\n  isShowFocusRing: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  hasStartEdge: boolean;\n  hasEndEdge: boolean;\n  isRtl: boolean;\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment: 'top' | 'center' | 'bottom';\n  isHighContrast: boolean;\n  padding?: CellPadding;\n};\n\n/**\n * Helper function to generate the class array for a header or footer cell.\n */\nexport const getHeaderFooterCellClassArray = ({\n  isHeader,\n  isActiveStyle,\n  isHoverStyle,\n  isPreviousCellActiveStyle,\n  isPreviousCellHoverStyle,\n  isFirstColumnIndex,\n  isFinalColumnIndex,\n  hasVerticalGridlines,\n  isSelected,\n  isNextColumnSelected,\n  isPreviousColumnSelected,\n  isSticky,\n  isShowFocusRing,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  hasStartEdge,\n  hasEndEdge,\n  isRtl,\n  horizontalAlignment,\n  verticalAlignment,\n  isHighContrast,\n  padding\n}: HeaderFooterCellThemingProps) => {\n  let cellStyles;\n\n  if (isHeader) {\n    cellStyles = isHighContrast ? tableHeaderCellStylesHC : tableHeaderCellStyles;\n  } else {\n    cellStyles = isHighContrast ? tableFooterCellStylesHC : tableFooterCellStyles;\n  }\n  const classArray = [cellStyles.base];\n\n  // Padding styling logic\n  const { isTopPadding, isBottomPadding, isStartPadding, isEndPadding } = _getPaddingInfo(padding);\n  classArray.push(isBottomPadding ? cellStyles.bottomPadding : cellStyles.bottomNoPadding);\n  classArray.push(isTopPadding ? cellStyles.topPadding : cellStyles.topNoPadding);\n\n  // Horizontal and vertical alignment styling logic\n  _applyAlignmentStyling(classArray, horizontalAlignment, verticalAlignment);\n\n  // Sticky styling logic\n  _applyStickyStyling(classArray, cellStyles, isSticky, isStickyStartEdge, isStickyEndEdge, isRtl);\n\n  // Interaction styling logic\n  _applyFocusStyling(classArray, cellStyles, isShowFocusRing);\n\n  // Selected and Vertical Gridline styling logic\n  if (isSelected) {\n    if (isActiveStyle) {\n      classArray.push(cellStyles.activeSelected);\n    } else if (isHoverStyle) {\n      classArray.push(cellStyles.hoverSelected);\n    }\n    classArray.push(cellStyles.selectedBackground);\n\n    _applySelectedColumnStyling(\n      classArray,\n      cellStyles,\n      isStartPadding,\n      isEndPadding,\n      hasStartEdge,\n      hasEndEdge\n    );\n  } else {\n    if (isActiveStyle) {\n      classArray.push(cellStyles.active);\n    } else if (isHoverStyle) {\n      classArray.push(cellStyles.hover);\n    }\n    classArray.push(cellStyles.background);\n\n    _applyColumnStyling(\n      classArray,\n      cellStyles,\n      isStartPadding,\n      isEndPadding,\n      isFirstColumnIndex,\n      isFinalColumnIndex,\n      hasStartEdge,\n      hasEndEdge,\n      isNextColumnSelected,\n      isPreviousColumnSelected,\n      hasVerticalGridlines,\n      isActiveStyle,\n      isHoverStyle,\n      isPreviousCellActiveStyle,\n      isPreviousCellHoverStyle\n    );\n  }\n  return classArray;\n};\n\nconst _getPaddingInfo = (padding?: CellPadding) => {\n  const isPaddingDisabled = padding === 'disabled';\n  const isComplexPadding = padding instanceof Object;\n  const isBottomPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.bottom === 'disabled')\n  );\n  const isEndPadding = !(isPaddingDisabled || (isComplexPadding && padding?.end === 'disabled'));\n  const isStartPadding = !(\n    isPaddingDisabled ||\n    (isComplexPadding && padding?.start === 'disabled')\n  );\n  const isTopPadding = !(isPaddingDisabled || (isComplexPadding && padding?.top === 'disabled'));\n  return { isTopPadding, isBottomPadding, isStartPadding, isEndPadding };\n};\n\nconst _applyAlignmentStyling = (\n  classArray: string[],\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center',\n  verticalAlignment: 'top' | 'center' | 'bottom'\n) => {\n  classArray.push(textAlignStyles[horizontalAlignment]);\n  classArray.push(verticalAlignStyles[verticalAlignment]);\n};\n\nconst _applyFocusStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isShowFocusRing: boolean\n) => {\n  if (isShowFocusRing) {\n    classArray.push(cellStyles.focused);\n  }\n};\n\nconst _applyStickyStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isSticky: boolean,\n  isStickyStartEdge: boolean,\n  isStickyEndEdge: boolean,\n  isRtl: boolean\n) => {\n  if (isSticky) {\n    classArray.push(cellStyles.stickyColumn);\n  }\n  if (isStickyStartEdge) {\n    classArray.push(cellStyles.stickyEdge);\n    classArray.push(isRtl ? cellStyles.stickyEdgeLeft : cellStyles.stickyEdgeRight);\n  } else if (isStickyEndEdge) {\n    classArray.push(cellStyles.stickyEdge);\n    classArray.push(isRtl ? cellStyles.stickyEdgeRight : cellStyles.stickyEdgeLeft);\n  }\n};\n\nconst _applyColumnStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isStartPadding: boolean,\n  isEndPadding: boolean,\n  isFirstColumnIndex: boolean,\n  isFinalColumnIndex: boolean,\n  hasStartEdge: boolean,\n  hasEndEdge: boolean,\n  isNextColumnSelected: boolean,\n  isPreviousColumnSelected: boolean,\n  hasVerticalGridlines: boolean,\n  isActiveStyle?: boolean,\n  isHoverStyle?: boolean,\n  isPreviousCellActiveStyle?: boolean,\n  isPreviousCellHoverStyle?: boolean\n) => {\n  if (hasStartEdge) {\n    if (isPreviousColumnSelected) {\n      classArray.push(cellStyles.verticalSelectedGridStart);\n      classArray.push(\n        isStartPadding\n          ? cellStyles.selectedBorderStartPadding\n          : cellStyles.selectedBorderStartNoPadding\n      );\n    } else if (\n      isActiveStyle ||\n      isHoverStyle ||\n      isPreviousCellActiveStyle ||\n      isPreviousCellHoverStyle ||\n      (!isFirstColumnIndex && hasVerticalGridlines)\n    ) {\n      classArray.push(cellStyles.verticalGridStart);\n      classArray.push(\n        isStartPadding ? cellStyles.borderStartPadding : cellStyles.borderStartNoPadding\n      );\n    } else if (isStartPadding) {\n      classArray.push(cellStyles.startSpacerPadding);\n    } else {\n      classArray.push(cellStyles.startSpacerNoPadding);\n    }\n  } else if (isStartPadding) {\n    classArray.push(cellStyles.startPadding);\n  } else {\n    classArray.push(cellStyles.startNoPadding);\n  }\n\n  if (hasEndEdge) {\n    if (isNextColumnSelected) {\n      classArray.push(cellStyles.verticalSelectedGridEnd);\n      classArray.push(\n        isEndPadding ? cellStyles.selectedBorderEndPadding : cellStyles.selectedBorderEndNoPadding\n      );\n    } else if (isActiveStyle || isHoverStyle || (!isFinalColumnIndex && hasVerticalGridlines)) {\n      classArray.push(cellStyles.verticalGridEnd);\n      classArray.push(isEndPadding ? cellStyles.borderEndPadding : cellStyles.borderEndNoPadding);\n    } else if (isEndPadding) {\n      classArray.push(cellStyles.endSpacerPadding);\n    } else {\n      classArray.push(cellStyles.endSpacerNoPadding);\n    }\n  } else if (isEndPadding) {\n    classArray.push(cellStyles.endPadding);\n  } else {\n    classArray.push(cellStyles.endNoPadding);\n  }\n};\n\nconst _applySelectedColumnStyling = (\n  classArray: string[],\n  cellStyles: CellStyles | HeaderCellStyles | FooterCellStyles,\n  isStartPadding: boolean,\n  isEndPadding: boolean,\n  hasStartEdge: boolean,\n  hasEndEdge: boolean\n) => {\n  if (hasStartEdge) {\n    classArray.push(cellStyles.verticalSelectedGridStart);\n    classArray.push(\n      isStartPadding\n        ? cellStyles.selectedBorderStartPadding\n        : cellStyles.selectedBorderStartNoPadding\n    );\n  } else {\n    classArray.push(isStartPadding ? cellStyles.startPadding : cellStyles.startNoPadding);\n  }\n  if (hasEndEdge) {\n    classArray.push(cellStyles.verticalSelectedGridEnd);\n    classArray.push(\n      isEndPadding ? cellStyles.selectedBorderEndPadding : cellStyles.selectedBorderEndNoPadding\n    );\n  } else {\n    classArray.push(isEndPadding ? cellStyles.endPadding : cellStyles.endNoPadding);\n  }\n};\n\n/**\n * Helper function to convert a column's horizontal alignment value into a form control's value.\n */\nexport const getFormTextAlign = (\n  horizontalAlignment: 'start' | 'end' | 'left' | 'right' | 'center',\n  isRtl: boolean\n) => {\n  switch (horizontalAlignment) {\n    case 'left':\n      return isRtl ? 'end' : 'start';\n    case 'center':\n      return undefined;\n    default:\n      return horizontalAlignment;\n  }\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { FocusableElement } from '../../utils/PRIVATE_tabbableUtils';\nimport { ActiveCell, TableColumn } from '../Table';\n\n/**\n * Returns the cell type for the given cell element\n */\nexport const getCellType = (element: FocusableElement) => {\n  return element.dataset['ojCellType'];\n};\n\n/**\n * Returns the row key for the given row element\n */\nexport const getRowKey = <K>(element: HTMLElement) => {\n  return (\n    element.dataset['ojKeyType'] === 'number'\n      ? Number(element.dataset['ojKey'])\n      : element.dataset['ojKey']\n  ) as K;\n};\n\n/**\n * Returns whether or not auto focus is enabled on the specified cell\n */\nexport const isAutoFocusCell = <K, C>(\n  rootElement: HTMLElement,\n  tableId: string,\n  activeCell: ActiveCell<K, C>\n) => {\n  const cellElement = getElementFromCell(rootElement, tableId, activeCell);\n  return cellElement != null && cellElement.dataset['ojTableAutoFocus'] === 'enabled';\n};\n\n/**\n * Returns the key for the row at the given index\n */\nexport const getRowKeyForRowIndex = <K>(\n  rootElement: HTMLElement,\n  tableId: string,\n  index: number\n) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > index) {\n    return getRowKey<K>(rowElements[index] as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the given row element\n */\nexport const getRowIndexForRowElement = (\n  rootElement: HTMLElement,\n  tableId: string,\n  rowElement: HTMLElement\n) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const index = Array.prototype.indexOf.call(rowElements, rowElement);\n  if (index > -1) {\n    return index;\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the row for the given key.\n */\nexport function getRowIndexForRowKey<K>(rootElement: HTMLElement, tableId: string, rowKey: K) {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let i = 0; i < rowElements.length; i++) {\n    if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n      return i;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Returns the column key for the given cell element\n */\nexport const getColumnKey = <C>(element: HTMLElement) => {\n  return element.dataset['ojColumnKey'] as C;\n};\n\n/**\n * Returns the key for the column at the given index\n */\nexport const getColumnKeyForColumnIndex = (\n  rootElement: HTMLElement,\n  tableId: string,\n  index: number\n) => {\n  const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  if (headerElements.length > index) {\n    return getColumnKey(headerElements[index] as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the index of the given column header element or footer element\n */\nexport const getColumnIndexForHeaderFooterElement = (\n  rootElement: HTMLElement,\n  tableId: string,\n  cellElement: HTMLElement,\n  isHeader: boolean\n) => {\n  const columnElements = rootElement.querySelectorAll(\n    isHeader\n      ? `[data-oj-table-header-cell='${tableId}']`\n      : `[data-oj-table-footer-cell='${tableId}']`\n  );\n  const index = Array.prototype.indexOf.call(columnElements, cellElement);\n  if (index > -1) {\n    return index;\n  }\n  return undefined;\n};\n\n/**\n * Helper method to get the cell key definition from an element\n */\nexport function logicalCellExtractor<K extends string | number, D, C extends string>(\n  element: HTMLElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  cellSelector?: string,\n  onlyAncestors?: boolean\n): ActiveCell<K, C> | undefined {\n  const selectorString =\n    cellSelector != null ? cellSelector : `[data-oj-table-focusable='${tableId}']`;\n  const startingElement = onlyAncestors ? element.parentElement : element;\n  if (startingElement != null) {\n    const cellElement = startingElement.closest(selectorString) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'data') {\n        return {\n          rowKey: keyExtractor<K>(cellElement, `[data-oj-table-data-row='${tableId}']`)!,\n          columnKey: getColumnKey<C>(cellElement),\n          type: cellType\n        };\n      } else if (cellType === 'header' || cellType === 'footer') {\n        return { columnKey: getColumnKey<C>(cellElement), type: cellType };\n      } else if (cellType === 'noData' || cellType === 'pending') {\n        return { type: cellType };\n      } else if (cellType === 'loading' || cellType === 'loadMore') {\n        const columnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n        if (columnKey != null) {\n          return { columnKey: columnKey, type: cellType };\n        }\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n * Helper method to get an element from a cell descriptor\n */\nexport function getElementFromCell<K, C>(\n  rootElement: HTMLElement,\n  tableId: string,\n  cell: ActiveCell<K, C>\n): HTMLElement | undefined {\n  if (cell.type === 'header') {\n    // header case\n    const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n    for (const headerElement of headerElements) {\n      if (cell.columnKey === getColumnKey(headerElement as HTMLElement)) {\n        return headerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'footer') {\n    // footer case\n    const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n    for (const footerElement of footerElements) {\n      if (cell.columnKey === getColumnKey(footerElement as HTMLElement)) {\n        return footerElement as HTMLElement;\n      }\n    }\n  } else if (cell.type === 'data') {\n    // data body case\n    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    for (const rowElement of rowElements) {\n      if (cell.rowKey === getRowKey(rowElement as HTMLElement)) {\n        const cellElements = rowElement.querySelectorAll(`[data-oj-table-focusable='${tableId}']`);\n        for (const cellElement of cellElements) {\n          if (cell.columnKey === getColumnKey(cellElement as HTMLElement)) {\n            return cellElement as HTMLElement;\n          }\n        }\n      }\n    }\n  } else if (cell.type === 'noData') {\n    // no data case\n    return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'pending') {\n    // pending skeletons case\n    return rootElement.querySelector(`[data-oj-table-pending-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'loading') {\n    // loading skeletons case\n    return rootElement.querySelector(`[data-oj-table-loading-cell='${tableId}']`) as HTMLElement;\n  } else if (cell.type === 'loadMore') {\n    // loadMore skeletons case\n    return rootElement.querySelector(`[data-oj-table-load-more-cell='${tableId}']`) as HTMLElement;\n  }\n  return undefined;\n}\n\n/**\n * Helper method to get the top scroller offset of the Table\n */\nexport const getScrollerTopOffset = (rootElement: HTMLElement, tableId: string) => {\n  const headerRowElement = rootElement.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  return headerRowElement != null ? headerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Helper method to get the bottom scroller offset of the Table\n */\nexport const getScrollerBottomOffset = (rootElement: HTMLElement, tableId: string) => {\n  const footerRowElement = rootElement.querySelector(\n    `[data-oj-table-footer-row='${tableId}']`\n  ) as HTMLElement;\n  return footerRowElement != null ? footerRowElement.getBoundingClientRect().height : 0;\n};\n\n/**\n * Returns the key of the first focusable row in the Table\n */\nexport const getFirstFocusableRowKey = <K>(rootElement: HTMLElement, tableId: string) => {\n  const firstRowElement = rootElement.querySelector(`[data-oj-table-data-row='${tableId}']`);\n  if (firstRowElement != null) {\n    return getRowKey<K>(firstRowElement as HTMLElement);\n  }\n  return undefined;\n};\n\n/**\n * Returns the key of the last focusable row in the Table\n */\nexport const getLastFocusableRowKey = <K>(rootElement: HTMLElement, tableId: string) => {\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  const rowCount = rowElements.length;\n  if (rowCount > 0) {\n    return getRowKey(rowElements[rowCount - 1] as HTMLElement) as K;\n  }\n  return undefined;\n};\n\n/**\n * Returns the cell definition of the first rendered cell in the Table\n */\nexport const getFirstFocusableCell = <K extends string | number, C extends string>(\n  rootElement: HTMLElement,\n  tableId: string\n): ActiveCell<K, C> | undefined => {\n  const firstCellElement = rootElement.querySelector(\n    `[data-oj-table-focusable='${tableId}']`\n  ) as HTMLElement;\n  if (firstCellElement != null) {\n    const firstCellType = getCellType(firstCellElement);\n    if (firstCellType === 'header' || firstCellType === 'footer') {\n      return { columnKey: getColumnKey<C>(firstCellElement), type: firstCellType };\n    } else if (firstCellType === 'noData') {\n      return { type: 'noData' };\n    }\n    return {\n      rowKey: keyExtractor<K>(firstCellElement, `[data-oj-table-data-row='${tableId}']`)!,\n      columnKey: getColumnKey<C>(firstCellElement),\n      type: 'data'\n    };\n  }\n  return undefined;\n};\n\n/**\n * Helper function to get the first or last column key.\n */\nexport const getBoundaryColumnKey = <K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  isFirst: boolean\n) => {\n  if (columnsArray.length > 0) {\n    return isFirst ? columnsArray[0].key : columnsArray[columnsArray.length - 1].key;\n  }\n  return undefined;\n};\n\n/**\n * Helper method to get the 'pending' layout cell\n */\nexport const getPendingLayoutCellElement = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-pending-cell='${tableId}']`) as HTMLElement;\n};\n\n/**\n * Helper method to get the 'noData' cell\n */\nexport const getNoDataCellElement = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-nodata-cell='${tableId}']`) as HTMLElement;\n};\n\n/**\n * Helper method to determine if the 'loading' cell is present in the Table\n */\nexport const hasLoadingCell = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelector(`[data-oj-table-loading-cell='${tableId}']`) != null;\n};\n\n/**\n * Helper method to determine if the no data cell is present in the Table\n */\nexport const hasNoDataCell = (rootElement: HTMLElement, tableId: string) => {\n  return getNoDataCellElement(rootElement, tableId) != null;\n};\n\n/**\n * Helper method to determine if footer cells are present in the Table\n */\nexport const hasFooterCells = (rootElement: HTMLElement, tableId: string) => {\n  return rootElement.querySelectorAll(`[data-oj-table-footer-row='${tableId}']`).length > 0;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { getCellType, getElementFromCell, logicalCellExtractor } from './TableDomUtils';\nimport { preventBrowserTooltipStyle } from '../themes/Table.css';\nimport { ActiveCell, TableColumn } from '../Table';\nimport { Cell } from '../../UNSAFE_TableView';\n\n/**\n * Browser zoom levels are not handled identically between Range sizes and Element sizes, so this offset\n * should be used when comparing horizontal widths. Using a smaller value (0.01 for example) causes false\n * positives, while using a larger value (0.05 for example) causes actual truncations to be missed.\n */\nconst HORIZONTAL_TRUNCATION_OFFSET = 0.015;\n\n/**\n * Default Redwood line-height overrides cause false positives as the Range sizes are always for a 'normal'\n * line-height, and none of the default scale fonts have 'normal' line-height values. This causes offsets\n * of between 0.5px and 1.5px. As a true truncation will cause an offset of closer to a full line height\n * (at least 12px for 2xs text), use a larger offset value than the currently observed 1.5px max for safety.\n */\nconst VERTICAL_TRUNCATION_OFFSET = 5;\n\n/**\n * Helper method to determine if a given cell contains truncated text.\n */\nexport const hasTruncatedText = (cellElement: HTMLElement) => {\n  if (cellElement.getAttribute('data-oj-table-tooltip') !== 'enabled') {\n    return false;\n  }\n  const innerText = String(cellElement.innerText).trim();\n  if (innerText === '') {\n    return false;\n  }\n\n  const walker = document.createTreeWalker(cellElement, NodeFilter.SHOW_TEXT);\n  while (walker.nextNode()) {\n    const range = new Range();\n    const textNode = walker.currentNode;\n    range.selectNodeContents(textNode);\n    const untruncatedTextLength = range.getBoundingClientRect().width;\n    const untruncatedTextHeight = range.getBoundingClientRect().height;\n\n    let firstParent = true;\n    let parentElement = textNode.parentElement;\n    while (parentElement != null) {\n      const parentStyles = getComputedStyle(parentElement);\n      if (firstParent) {\n        // only verify truncation status of 'visible' text nodes\n        if (untruncatedTextLength === 0 || parentStyles.visibility === 'hidden') {\n          break;\n        }\n        firstParent = false;\n      }\n      const horizontalPadding =\n        parseFloat(parentStyles.paddingLeft) + parseFloat(parentStyles.paddingRight);\n      const horizontalBorder =\n        parseFloat(parentStyles.borderLeft) + parseFloat(parentStyles.borderRight);\n      const renderedTextLength =\n        parentElement.getBoundingClientRect().width - horizontalPadding - horizontalBorder;\n\n      const verticalPadding =\n        parseFloat(parentStyles.paddingTop) + parseFloat(parentStyles.paddingBottom);\n      const verticalBorder =\n        parseFloat(parentStyles.borderTop) + parseFloat(parentStyles.borderBottom);\n      const renderedTextHeight =\n        parentElement.getBoundingClientRect().height - verticalPadding - verticalBorder;\n\n      if (\n        untruncatedTextLength - renderedTextLength > HORIZONTAL_TRUNCATION_OFFSET ||\n        untruncatedTextHeight - renderedTextHeight > VERTICAL_TRUNCATION_OFFSET\n      ) {\n        return true;\n      }\n      if (parentElement === cellElement) {\n        break;\n      }\n      parentElement = parentElement.parentElement;\n    }\n  }\n  return false;\n};\n\n/**\n * Helper function to handle updating the Table's tooltip due to a focus navigation gesture.\n */\nexport function handleNavigationTooltipGesture<K, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  cell: ActiveCell<K, C>,\n  showTooltip: (cell: Cell<K, C>) => void,\n  hideTooltip: (isImmediate?: boolean) => void\n) {\n  hideTooltip(true);\n  if (cell.type === 'data' || cell.type === 'header' || cell.type === 'footer') {\n    const cellElement = getElementFromCell(rootElement, tableId, cell);\n    if (cellElement != null) {\n      showTooltip(cell);\n    }\n  }\n}\n\n/**\n * Helper function to handle updating the Table's tooltip due to a pointer move gesture.\n */\nexport function handleMoveTooltipGesture<K extends string | number, D, C extends string>(\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  event: PointerEvent,\n  showTooltip: (cell: Cell<K, C>) => void,\n  hideTooltip: (isImmediate?: boolean) => void,\n  tooltipId: string\n) {\n  let tooltipShown = false;\n  const targetElement = event.relatedTarget as HTMLElement;\n  if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {\n    return;\n  }\n  const cellElement = (event.target as HTMLElement).closest(\n    `[data-oj-table-focusable='${tableId}']`\n  ) as HTMLElement;\n  if (cellElement != null) {\n    const type = getCellType(cellElement);\n    if (type === 'data' || type === 'header' || type === 'footer') {\n      showTooltip(logicalCellExtractor<K, D, C>(cellElement, tableId, columnsArray) as Cell<K, C>);\n      tooltipShown = true;\n    }\n  }\n  if (!tooltipShown) {\n    hideTooltip();\n  }\n}\n\n/**\n * Helper function to handle updating the Table's tooltip due to a pointer leave gesture.\n */\nexport const handleLeaveTableTooltipGesture = (\n  rootElement: HTMLDivElement,\n  event: PointerEvent,\n  hideTooltip: (isImmediate?: boolean) => void,\n  tooltipId: string\n) => {\n  const targetElement = event.relatedTarget as HTMLElement;\n  if (targetElement != null && targetElement.closest(`#${tooltipId}`) != null) {\n    // the pointer 'left' the table, but is only over a cell tooltip - in most cases, we want\n    // to just return here as the pointer is still 'over' the table. however, this can also\n    // occur when the pointer is technically outside of the table's bounds, and in that case\n    // we don't actually want to return as we should clear out our cell tooltip as expected\n    const boundingRect = rootElement.getBoundingClientRect();\n    const isOutOfBounds =\n      event.clientX < boundingRect.left ||\n      event.clientX > boundingRect.right ||\n      event.clientY < boundingRect.top ||\n      event.clientY > boundingRect.bottom;\n    if (!isOutOfBounds) {\n      return;\n    }\n  }\n  hideTooltip();\n};\n\n// Pointer Enter handler for elements that need to prevent default browser tooltips\nconst _pointerEnterHandler = (event: PointerEvent) => {\n  const targetElement = event.target as HTMLElement;\n  targetElement.classList.add(preventBrowserTooltipStyle);\n};\n\n// Pointer Leave handler for elements that need to prevent default browser tooltips\nconst _pointerLeaveHandler = (event: PointerEvent) => {\n  const targetElement = event.target as HTMLElement;\n  targetElement.classList.remove(preventBrowserTooltipStyle);\n};\n\n/*\n * Props that can be spread on elements that need to prevent default browser tooltips\n */\nexport const preventBrowserTooltipProps = {\n  onPointerEnter: _pointerEnterHandler,\n  onPointerLeave: _pointerLeaveHandler\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport {\n  CurrentRowVariant,\n  DataCellFocusTarget,\n  DataCellPadding,\n  DataCellTooltip,\n  TableRendererContext,\n  TableRowContext\n} from '../UNSAFE_TableView';\nimport { FormContext } from '../hooks/UNSAFE_useFormContext';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { getFormTextAlign, getDataCellClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableCellProps<K, D, C> = {\n  tableId: string;\n  rowData: D;\n  columnKey: C;\n  columnIndex: number;\n  rowKey: K;\n  rowIndex: number;\n  isFinalRowIndex: boolean;\n  isFinalColumnIndex: boolean;\n  isFirstLogicalColumnIndex: boolean;\n  isFinalLogicalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasFooters: boolean;\n  hasVerticalUnderflow: boolean;\n  hasMore: boolean;\n  isRowSelected: boolean;\n  isPreviousRowSelected: boolean;\n  isColumnSelected: boolean;\n  isNextColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isSticky: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  hasStartEdge: boolean;\n  hasEndEdge: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  isAccRowHeader: boolean;\n  isRowSelectionEnabled: boolean;\n  isRowSingleSelection: boolean;\n  applyActiveStyle: boolean;\n  applyHoverStyle: boolean;\n  applyPseudoHoverStyle: boolean;\n  field?: keyof D;\n  focusTarget?: DataCellFocusTarget<K, D>;\n  renderer?: (context: TableRendererContext<K, D, C>) => ComponentChildren;\n  selectorRenderer?: () => ComponentChildren;\n  variant?: CurrentRowVariant;\n  padding?: DataCellPadding<K, D>;\n  tooltip?: DataCellTooltip<K, D>;\n  horizontalAlignment?: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment?: 'top' | 'center' | 'bottom';\n};\n\nfunction _defaultCellRenderer<K, D, C>({ rowData, field }: TableRendererContext<K, D, C>) {\n  return field != null ? String(rowData[field]) : undefined;\n}\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableCell<K, D, C>({\n  tableId,\n  rowData,\n  field,\n  columnKey,\n  columnIndex,\n  rowKey,\n  rowIndex,\n  isFinalRowIndex,\n  isFinalColumnIndex,\n  isFirstLogicalColumnIndex,\n  isFinalLogicalColumnIndex,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasFooters,\n  hasVerticalUnderflow,\n  hasMore,\n  isRowSelected,\n  isPreviousRowSelected,\n  isColumnSelected,\n  isNextColumnSelected,\n  isPreviousColumnSelected,\n  isSticky,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  isAccRowHeader,\n  focusTarget = 'cell',\n  renderer = _defaultCellRenderer,\n  selectorRenderer,\n  isRowSelectionEnabled,\n  isRowSingleSelection,\n  variant,\n  applyActiveStyle,\n  applyHoverStyle,\n  applyPseudoHoverStyle,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  hasStartEdge,\n  hasEndEdge,\n  isRtl,\n  isHighContrast,\n  padding,\n  tooltip,\n  horizontalAlignment = 'start',\n  verticalAlignment = 'center'\n}: TableCellProps<K, D, C>) {\n  const browser = getClientHints().browser;\n\n  const rowContext: TableRowContext<K, D> = { key: rowKey, data: rowData };\n  const columnPadding = typeof padding === 'function' ? padding(rowContext) : padding;\n  const columnTooltip = typeof tooltip === 'function' ? tooltip(rowContext) : tooltip;\n  const supportsDefaultTooltip = columnTooltip !== 'disabled';\n  const hasLastHorizontalGridline =\n    hasHorizontalGridlines && (hasMore || hasVerticalUnderflow || !hasFooters);\n\n  const cellClasses = classNames(\n    getDataCellClassArray({\n      isFirstColumnIndex: columnIndex === 0 || isFirstLogicalColumnIndex,\n      isFinalColumnIndex: isFinalColumnIndex || isFinalLogicalColumnIndex,\n      isFirstRowIndex: rowIndex === 0,\n      isFinalRowIndex,\n      hasVerticalGridlines,\n      hasHorizontalGridlines,\n      hasLastHorizontalGridline,\n      isRowSelected,\n      isPreviousRowSelected,\n      isColumnSelected,\n      isNextColumnSelected,\n      isPreviousColumnSelected,\n      isSticky,\n      hasStartEdge,\n      hasEndEdge,\n      isShowFocusRing,\n      isRowSelectionEnabled,\n      isRowSingleSelection,\n      isActive: applyActiveStyle,\n      isHover: applyHoverStyle,\n      isPseudoHover: applyPseudoHoverStyle,\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      isHighContrast,\n      horizontalAlignment,\n      verticalAlignment,\n      variant,\n      padding: columnPadding\n    })\n  );\n\n  const cellRendererProps = {\n    rowData: rowData,\n    rowKey: rowKey,\n    field: field,\n    columnKey: columnKey,\n    selector: selectorRenderer,\n    isTabbable: isTabbableMode\n  };\n\n  const supportsAutoFocus =\n    typeof focusTarget === 'function'\n      ? focusTarget(rowContext) === 'content'\n      : focusTarget === 'content';\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      class={cellClasses}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={isAccRowHeader ? 'rowheader' : 'gridcell'}\n      data-oj-cell-type={'data'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-data-cell={tableId}\n      data-oj-table-tooltip={supportsDefaultTooltip ? 'enabled' : undefined}\n      data-oj-table-auto-focus={supportsAutoFocus ? 'enabled' : undefined}\n      {...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {})}\n      {...(isColumnSelected ? { 'aria-selected': true } : {})}>\n      <FormContext.Provider value={{ textAlign: getFormTextAlign(horizontalAlignment, isRtl) }}>\n        {renderer(cellRendererProps)}\n      </FormContext.Provider>\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { memo } from 'preact/compat';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { Selector } from '../UNSAFE_Selector';\nimport { CurrentRowVariant, TableSelectionDetail } from '../UNSAFE_TableView';\nimport { tableRowStyles, tableRowStylesHC } from './themes/TableRowStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey, isSameKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableCell } from './TableCell';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useInteractionStyle } from '../hooks/UNSAFE_useInteractionStyle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableRow Component\n */\nexport type TableRowProps<K extends string | number, D, C extends string> = {\n  tableId: string;\n  rowKey: K;\n  rowData: D;\n  rowIndex: number;\n  isFinalRow: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  rowHeaderColumnKeys: Set<C>;\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasFooters: boolean;\n  hasVerticalUnderflow: boolean;\n  hasMore: boolean;\n  isSelected: boolean;\n  isPreviousSelected: boolean;\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  selectedRowKeys?: Keys<K>;\n  isShowFocusRing: boolean;\n  activeColumnKey?: C;\n  isTabbableMode: boolean;\n  selectedColumnKeys?: Keys<C>;\n  variant?: CurrentRowVariant;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  firstStickyColumnIndex?: number;\n  finalStickyColumnIndex?: number;\n  columnBorderEdges: { hasStart: boolean; hasEnd: boolean; width: number }[];\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a single row in Table.\n */\nfunction TableRow<K extends string | number, D, C extends string>({\n  tableId,\n  rowKey,\n  rowData,\n  rowIndex,\n  isFinalRow,\n  columnsArray,\n  rowHeaderColumnKeys,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasFooters,\n  hasVerticalUnderflow,\n  hasMore,\n  isSelected,\n  isPreviousSelected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isShowFocusRing,\n  activeColumnKey,\n  isTabbableMode,\n  selectedColumnKeys = { all: false, keys: new Set<C>() },\n  variant,\n  disabledInteractionKeys,\n  onSelectionChange,\n  startStickyEdge,\n  endStickyEdge,\n  firstStickyColumnIndex,\n  finalStickyColumnIndex,\n  columnBorderEdges,\n  isRtl,\n  isHighContrast\n}: TableRowProps<K, D, C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } =\n    useInteractionStyle({ disabledKeys: disabledInteractionKeys });\n\n  const rowStyles = isHighContrast ? tableRowStylesHC : tableRowStyles;\n  const classArray = [rowStyles.base, isFinalRow ? rowStyles.lastRowHeight : rowStyles.rowHeight];\n  const classes = classNames(classArray);\n\n  const accessibleRowName = (rowIndex + 2).toString();\n  const handleRowSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        {\n          value: {\n            row: detail.value,\n            column: { all: false, keys: new Set<C>() }\n          },\n          target: detail.target\n        },\n        false\n      );\n    }\n  };\n  const selectorRenderer =\n    isRowSelectionEnabled && !isSingleRowSelectionEnabled\n      ? () => {\n          // conversion from 0-based index and adding the header row as it is always rendered\n          return (\n            <Selector\n              aria-label={translations.collection_selectRow({ ROW_NAME: accessibleRowName })}\n              onChange={handleRowSelectorChange}\n              rowKey={rowKey}\n              selectedKeys={selectedRowKeys}\n            />\n          );\n        }\n      : undefined;\n\n  let isPreviousColumnSelected = false;\n  let isPreviousStickyColumnSelected = false;\n  return (\n    <tr\n      aria-rowindex={rowIndex + 2}\n      class={classes}\n      role={'row'}\n      data-oj-key={rowKey}\n      data-oj-table-data-row={tableId}\n      {...(isRowSelectionEnabled\n        ? isSelected\n          ? { 'aria-selected': true }\n          : { 'aria-selected': false }\n        : {})}\n      {...(typeof rowKey === 'number' && { 'data-oj-key-type': 'number' })}\n      {...(isRowSelectionEnabled && interactionProps)}>\n      {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n        const columnKey = column.key;\n        const isColumnSelected = containsKey(selectedColumnKeys, columnKey);\n        const isActive = columnKey === activeColumnKey;\n        const hasTabIndex = isActive && !isTabbableMode;\n        const isSticky = column.value.sticky === 'enabled';\n        let nextVisibleColumn;\n        let isNextVisibleColumnSelected = false;\n        let isPreviousVisibleColumnSelected = false;\n        let isFirstLogicalColumnIndex = false;\n        let isFinalLogicalColumnIndex = false;\n        if (isSticky) {\n          if (startStickyEdge != null && firstStickyColumnIndex === columnIndex) {\n            isFirstLogicalColumnIndex = true;\n          }\n          if (endStickyEdge != null && finalStickyColumnIndex === columnIndex) {\n            isFinalLogicalColumnIndex = true;\n          }\n          if (\n            (startStickyEdge != null && startStickyEdge > columnIndex) ||\n            (endStickyEdge != null && endStickyEdge <= columnIndex)\n          ) {\n            for (let i = columnIndex + 1; i < columnsArray.length; i++) {\n              if (columnsArray[i].value.sticky === 'enabled') {\n                nextVisibleColumn = columnsArray[i];\n                break;\n              }\n            }\n          } else {\n            nextVisibleColumn =\n              columnIndex < columnsArray.length - 1 ? columnsArray[columnIndex + 1] : undefined;\n          }\n          isNextVisibleColumnSelected =\n            startStickyEdge === columnIndex\n              ? false\n              : nextVisibleColumn != null && containsKey(selectedColumnKeys, nextVisibleColumn.key);\n          if (\n            (startStickyEdge != null && startStickyEdge >= columnIndex) ||\n            (endStickyEdge != null && endStickyEdge < columnIndex)\n          ) {\n            isPreviousVisibleColumnSelected = isPreviousStickyColumnSelected;\n          } else if (endStickyEdge !== columnIndex) {\n            isPreviousVisibleColumnSelected = isPreviousColumnSelected;\n          }\n        } else {\n          isPreviousVisibleColumnSelected = isPreviousColumnSelected;\n        }\n        const cellProps = {\n          tableId: tableId,\n          rowData: rowData,\n          field: column.value.field,\n          stickyColumn: column.value.sticky,\n          columnKey: columnKey,\n          columnIndex: columnIndex,\n          rowKey: rowKey,\n          rowIndex: rowIndex,\n          isFinalRowIndex: isFinalRow,\n          isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n          isFirstLogicalColumnIndex: isFirstLogicalColumnIndex,\n          isFinalLogicalColumnIndex: isFinalLogicalColumnIndex,\n          hasVerticalGridlines: hasVerticalGridlines,\n          hasHorizontalGridlines: hasHorizontalGridlines,\n          hasFooters: hasFooters,\n          hasVerticalUnderflow: hasVerticalUnderflow,\n          hasMore: hasMore,\n          isRowSelected: isSelected,\n          isPreviousRowSelected: isPreviousSelected,\n          isSticky: isSticky,\n          isColumnSelected: isColumnSelected,\n          isNextColumnSelected: isNextVisibleColumnSelected,\n          isPreviousColumnSelected: isPreviousVisibleColumnSelected,\n          isShowFocusRing: isShowFocusRing && isActive,\n          hasTabIndex: hasTabIndex,\n          isTabbableMode: isTabbableMode,\n          isAccRowHeader: rowHeaderColumnKeys.has(column.key),\n          renderer: column.value.renderer,\n          selectorRenderer: selectorRenderer,\n          isRowSelectionEnabled: isRowSelectionEnabled,\n          variant: variant,\n          isRowSingleSelection: isSingleRowSelectionEnabled,\n          applyActiveStyle: applyActiveStyle,\n          applyHoverStyle: applyHoverStyle,\n          applyPseudoHoverStyle: applyPseudoHoverStyle,\n          isStickyStartEdge: columnIndex === startStickyEdge,\n          isStickyEndEdge: columnIndex === endStickyEdge,\n          hasStartEdge: columnBorderEdges[columnIndex].hasStart,\n          hasEndEdge: columnBorderEdges[columnIndex].hasEnd,\n          isRtl: isRtl,\n          isHighContrast: isHighContrast,\n          padding: column.value.padding,\n          tooltip: column.value.tooltip,\n          focusTarget: column.value.focusTarget,\n          horizontalAlignment:\n            column.value.alignment?.horizontal != null\n              ? column.value.alignment.horizontal\n              : column.value.horizontalAlignment,\n          verticalAlignment: column.value.alignment?.vertical\n        };\n        isPreviousColumnSelected = isColumnSelected;\n        if (isSticky) {\n          isPreviousStickyColumnSelected = isColumnSelected;\n        }\n        return <TableCell {...cellProps} />;\n      })}\n    </tr>\n  );\n}\n\nconst _areStringSetsEquivalent = (set1?: Set<string>, set2?: Set<string>) => {\n  if (set1 == null) {\n    return set2 == null;\n  }\n  if (set2 == null) {\n    return false;\n  }\n  return set1.size === set2.size && [...set1].every((x) => set2.has(x));\n};\n\nconst _areColumnsArraysEquivalent = (\n  columnsArray1: TableColumn<string | number, unknown, string>[],\n  columnsArray2: TableColumn<string | number, unknown, string>[]\n) => {\n  if (columnsArray1.length === columnsArray2.length) {\n    for (let i = 0; i < columnsArray1.length; i++) {\n      if (\n        columnsArray1[i].key !== columnsArray2[i].key ||\n        columnsArray1[i].value !== columnsArray2[i].value\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\nexport const MemoizeTableRow = memo(\n  TableRow,\n  (\n    prev: TableRowProps<string | number, unknown, string>,\n    next: TableRowProps<string | number, unknown, string>\n  ) => {\n    if (prev && next) {\n      return (\n        prev.tableId === next.tableId &&\n        prev.rowKey === next.rowKey &&\n        prev.rowData === next.rowData &&\n        prev.rowIndex === next.rowIndex &&\n        prev.isFinalRow === next.isFinalRow &&\n        _areColumnsArraysEquivalent(prev.columnsArray, next.columnsArray) &&\n        prev.hasHorizontalGridlines === next.hasHorizontalGridlines &&\n        prev.hasVerticalGridlines === next.hasVerticalGridlines &&\n        (!next.isFinalRow ||\n          (prev.hasFooters === next.hasFooters &&\n            prev.hasVerticalUnderflow === next.hasVerticalUnderflow &&\n            prev.hasMore === next.hasMore)) &&\n        _areStringSetsEquivalent(prev.rowHeaderColumnKeys, next.rowHeaderColumnKeys) &&\n        prev.isSelected === next.isSelected &&\n        prev.isPreviousSelected === next.isPreviousSelected &&\n        prev.isRowSelectionEnabled === next.isRowSelectionEnabled &&\n        prev.isSingleRowSelectionEnabled === next.isSingleRowSelectionEnabled &&\n        (prev.isRowSelectionEnabled && !prev.isSingleRowSelectionEnabled\n          ? isSameKey(prev.selectedRowKeys, next.selectedRowKeys)\n          : true) &&\n        isSameKey(prev.selectedColumnKeys, next.selectedColumnKeys) &&\n        prev.isShowFocusRing === next.isShowFocusRing &&\n        prev.activeColumnKey === next.activeColumnKey &&\n        prev.isTabbableMode === next.isTabbableMode &&\n        prev.variant === next.variant &&\n        prev.onSelectionChange === next.onSelectionChange &&\n        prev.startStickyEdge === next.startStickyEdge &&\n        prev.endStickyEdge === next.endStickyEdge &&\n        prev.firstStickyColumnIndex === next.firstStickyColumnIndex &&\n        prev.finalStickyColumnIndex === next.finalStickyColumnIndex &&\n        prev.columnBorderEdges === next.columnBorderEdges &&\n        prev.isRtl === next.isRtl &&\n        prev.isHighContrast === next.isHighContrast &&\n        prev.disabledInteractionKeys === next.disabledInteractionKeys\n      );\n    }\n    return false;\n  }\n);\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { ComponentChildren, RefObject } from 'preact';\nimport { TableNoDataRendererContext } from '../UNSAFE_TableView';\nimport { useLayoutEffect } from 'preact/hooks';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { tableRowStyles } from './themes/TableRowStyles.css';\nimport { TableNoDataVariantOptions } from './themes/TableNoDataStyles.css';\nimport { TableNoDataRedwoodTheme } from './themes/redwood/TableNoDataTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\n\n/**\n * Props for the TableCell Component\n */\nexport type TableNoDataProps = {\n  rootRef: RefObject<HTMLDivElement>;\n  tableId: string;\n  columnsCount: number;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  ariaRowIndex: number;\n  renderer?: (context: TableNoDataRendererContext) => ComponentChildren;\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableNoData({\n  rootRef,\n  tableId,\n  columnsCount,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  ariaRowIndex,\n  renderer\n}: TableNoDataProps) {\n  const browser = getClientHints().browser;\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const rowClasses = classNames([tableRowStyles.base]);\n\n  const { classes: themeClasses } = useComponentTheme<TableNoDataVariantOptions>(\n    TableNoDataRedwoodTheme,\n    {\n      defaultRenderer: renderer == null ? 'isDefaultRenderer' : 'notDefaultRenderer',\n      showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing'\n    }\n  );\n\n  const cellClasses = classNames([themeClasses]);\n\n  function defaultContentRenderer() {\n    return translations.collection_noData();\n  }\n\n  const contentRenderer = renderer != null ? renderer : defaultContentRenderer;\n\n  // in firefox, table element heights are not stretched unless explicitly set in some cases\n  useLayoutEffect(() => {\n    if (browser === 'firefox') {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        const tableBodyElement = rootElement.querySelector(\n          `[data-oj-table-body='${tableId}']`\n        ) as HTMLElement;\n        const noDataElement = rootElement.querySelector(\n          `[data-oj-table-nodata-cell='${tableId}']`\n        ) as HTMLElement;\n        if (tableBodyElement != null && noDataElement != null) {\n          noDataElement.style.height = '';\n          noDataElement.style.height = `${tableBodyElement.getBoundingClientRect().height}px`;\n        }\n      }\n    }\n  });\n\n  return (\n    <tr aria-rowindex={ariaRowIndex} class={rowClasses} role={'row'}>\n      <td\n        aria-colindex={1}\n        class={cellClasses}\n        style={browser !== 'firefox' ? 'height: 100%;' : undefined}\n        tabIndex={hasTabIndex ? 0 : -1}\n        role={'gridcell'}\n        colSpan={columnsCount}\n        data-oj-cell-type={'noData'}\n        data-oj-table-focusable={tableId}\n        data-oj-table-nodata-cell={tableId}>\n        {contentRenderer({ isTabbable: isTabbableMode })}\n      </td>\n    </tr>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Fragment, type RefObject } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { LoadMoreCollection } from '../PRIVATE_LoadMoreCollection';\nimport { ActiveCell, TableColumn, TableData, ViewportInfo } from './Table';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { MemoizeTableRow } from './TableRow';\nimport { ItemContext } from '../UNSAFE_Collection';\nimport {\n  CurrentRowVariant,\n  TableNoDataRendererContext,\n  TableRowContext,\n  TableSelectionDetail\n} from '../UNSAFE_TableView';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { backgroundStyles } from './themes/Table.css';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableNoData } from './TableNoData';\nimport { ComponentChildren } from 'preact';\n\n/**\n * Props for the TableBody Component\n */\nexport type TableBodyProps<K extends string | number, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  isValidRender: boolean;\n  getAccessibleRowHeaders: (context: TableRowContext<K, D>) => Set<C>;\n  tableData: TableData<K, D>[];\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  hasHorizontalGridlines: boolean;\n  hasFooters: boolean;\n  hasVerticalUnderflow: boolean;\n  isShowFocusRing: boolean;\n  isTabbableMode: boolean;\n  hasMore: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  onLoadMore: () => void;\n  activeCell?: ActiveCell<K, C>;\n  currentRowKey?: K;\n  currentRowVariant?: CurrentRowVariant;\n  selected: { row?: Keys<K>; column?: Keys<C> };\n  isRowSelectionEnabled: boolean;\n  isSingleRowSelectionEnabled: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  noDataRenderer?: (context: TableNoDataRendererContext) => ComponentChildren;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  firstStickyColumnIndex?: number;\n  finalStickyColumnIndex?: number;\n  columnBorderEdges: { hasStart: boolean; hasEnd: boolean; width: number }[];\n  disabledInteractionKeys?: ('enter' | 'space')[];\n};\n\n/**\n * The internal component used to render a single cell in a TableRow.\n */\nexport function TableBody<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  isValidRender,\n  getAccessibleRowHeaders,\n  tableData,\n  columnsArray,\n  hasVerticalGridlines,\n  hasHorizontalGridlines,\n  hasFooters,\n  hasVerticalUnderflow,\n  isShowFocusRing,\n  isTabbableMode,\n  hasMore,\n  onLoadMore,\n  activeCell,\n  currentRowKey,\n  currentRowVariant,\n  selected,\n  isRowSelectionEnabled,\n  isSingleRowSelectionEnabled,\n  disabledInteractionKeys,\n  onSelectionChange,\n  noDataRenderer,\n  startStickyEdge,\n  endStickyEdge,\n  firstStickyColumnIndex,\n  finalStickyColumnIndex,\n  columnBorderEdges,\n  isRtl,\n  isHighContrast\n}: TableBodyProps<K, D, C>) {\n  const browser = getClientHints().browser;\n\n  // returns a TableRowContext based on ItemContext (added key)\n  const getRowContext = useCallback((context: ItemContext<TableData<K, D>>) => {\n    return {\n      index: context.index,\n      data: context.data.data,\n      key: context.data.metadata\n    };\n  }, []);\n\n  let isPreviousSelected = false;\n  const collectionChildrenFunc = (context: ItemContext<TableData<K, D>>) => {\n    const tableRowContext = getRowContext(context);\n    const rowKey = tableRowContext.key;\n    const containsActiveCell = activeCell?.rowKey === rowKey;\n    const activeColumnKey = containsActiveCell ? activeCell.columnKey : undefined;\n    const isSelected = containsKey(selected.row, rowKey);\n    const rowProps = {\n      tableId: tableId,\n      columnsArray: columnsArray,\n      rowHeaderColumnKeys: getAccessibleRowHeaders(tableRowContext),\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      hasFooters: hasFooters,\n      hasVerticalUnderflow: hasVerticalUnderflow,\n      hasMore: hasMore,\n      isSelected: isSelected,\n      isPreviousSelected: isPreviousSelected,\n      disabledInteractionKeys: disabledInteractionKeys,\n      onSelectionChange: onSelectionChange,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: isSingleRowSelectionEnabled,\n      variant: currentRowKey === rowKey ? currentRowVariant : 'none',\n      isShowFocusRing: isShowFocusRing && containsActiveCell,\n      activeColumnKey: activeColumnKey,\n      isTabbableMode: isTabbableMode,\n      selectedRowKeys: selected.row,\n      selectedColumnKeys: selected.column,\n      rowIndex: tableRowContext.index,\n      rowKey: rowKey,\n      rowData: tableRowContext.data,\n      isFinalRow: tableRowContext.index === tableData.length - 1,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      firstStickyColumnIndex: firstStickyColumnIndex,\n      finalStickyColumnIndex: finalStickyColumnIndex,\n      columnBorderEdges: columnBorderEdges,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n    isPreviousSelected = isSelected;\n    return <MemoizeTableRow {...rowProps} />;\n  };\n\n  const getNoDataProps = () => {\n    const isActive = activeCell?.type === 'noData';\n    const hasTabIndex = isActive && !isTabbableMode;\n    return {\n      rootRef: rootRef,\n      tableId: tableId,\n      columnsCount: columnsArray.length,\n      isShowFocusRing: isShowFocusRing && isActive,\n      hasTabIndex: hasTabIndex,\n      isTabbableMode: isTabbableMode,\n      ariaRowIndex: isValidRender ? 2 : 1,\n      renderer: isValidRender ? noDataRenderer : undefined\n    };\n  };\n\n  const isShowEmptyLoading = tableData.length === 0 && hasMore;\n  const isShowNoData = tableData.length === 0 && !hasMore;\n  const loadMoreViewportConfig = {\n    scroller: () => viewportInfo.viewportConfig.scroller().current\n  };\n\n  return (\n    <tbody class={backgroundStyles.inherit} role={'presentation'} data-oj-table-body={tableId}>\n      {isShowNoData || !isValidRender ? (\n        <TableNoData {...getNoDataProps()} />\n      ) : (\n        <Fragment>\n          <LoadMoreCollection<TableData<K, D>>\n            data={tableData}\n            loadMoreIndicator={\n              <TableSkeletonRow\n                tableId={tableId}\n                hasTabIndex={\n                  isShowEmptyLoading\n                    ? activeCell?.type === 'loading'\n                    : activeCell?.type === 'loadMore'\n                }\n                colspan={columnsArray.length}\n                isLoadMore={!isShowEmptyLoading}\n                isShowFocusRing={\n                  isShowFocusRing &&\n                  (isShowEmptyLoading\n                    ? activeCell?.type === 'loading'\n                    : activeCell?.type === 'loadMore')\n                }\n                isHighContrast={isHighContrast}\n              />\n            }\n            hasMore={hasMore}\n            onLoadMore={onLoadMore}\n            viewportConfig={loadMoreViewportConfig}>\n            {collectionChildrenFunc}\n          </LoadMoreCollection>\n          <tr\n            style={browser !== 'firefox' ? 'height: 100%;' : undefined}\n            role={'presentation'}\n            data-oj-table-spacer-row={tableId}\n          />\n        </Fragment>\n      )}\n    </tbody>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useCallback } from 'preact/hooks';\nimport { SelectionDetail } from '../UNSAFE_Collection';\nimport { SelectorAll } from '../UNSAFE_SelectorAll';\nimport {\n  CellPadding,\n  TableHeaderRendererContext,\n  TableSelectionDetail,\n  SortCriterionDetail\n} from '../UNSAFE_TableView';\nimport { FormContext } from '../hooks/UNSAFE_useFormContext';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, isSameKey } from '../utils/UNSAFE_keys';\nimport {\n  justifyContentStyles,\n  tableHeaderCellTextStyles,\n  tableHeaderSortContainerStyles\n} from './themes/Table.css';\nimport { tableHeaderCellStyles } from './themes/TableHeaderCellStyles.css';\nimport { getFormTextAlign, getHeaderFooterCellClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\nimport { BundleType } from '../resources/nls/bundle';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { SortControl } from '../UNSAFE_SortControl';\nimport { SortableContext } from '#hooks/UNSAFE_useSortableContext';\n\n/**\n * Props for the TableHeaderCell Component\n */\nexport type TableHeaderCellProps<K, C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  isFirstLogicalColumnIndex: boolean;\n  isFinalLogicalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isSelected: boolean;\n  isNextColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isSticky: boolean;\n  isColumnSelectable: boolean;\n  isRowSelectionEnabled: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  isRtl: boolean;\n  isAccColumnHeader: boolean;\n  isHighContrast: boolean;\n  headerText?: string;\n  selectedRowKeys?: Keys<K>;\n  stickyTopOffset?: number;\n  hasStartEdge: boolean;\n  hasEndEdge: boolean;\n  isActiveStyle: boolean;\n  isHoverStyle: boolean;\n  isPreviousCellActiveStyle: boolean;\n  isPreviousCellHoverStyle: boolean;\n  focusTarget?: 'cell' | 'content';\n  renderer?: (context: TableHeaderRendererContext<C>) => ComponentChildren;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  isShowSortIcon: boolean;\n  sortable?: 'enabled' | 'disabled';\n  sortDirection?: 'ascending' | 'descending' | 'unsorted';\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  padding?: CellPadding;\n  tooltip?: 'enabled' | 'disabled';\n  horizontalAlignment?: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment?: 'top' | 'center' | 'bottom';\n};\n\n/**\n * The internal component used to render a single cell in a TableHeaderRow.\n */\nexport function TableHeaderCell<K, C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  isFirstLogicalColumnIndex,\n  isFinalLogicalColumnIndex,\n  hasVerticalGridlines,\n  isSelected,\n  isNextColumnSelected,\n  isPreviousColumnSelected,\n  isSticky,\n  isColumnSelectable,\n  isRowSelectionEnabled,\n  selectedRowKeys = { all: false, keys: new Set<K>() },\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  headerText,\n  stickyTopOffset = 0,\n  focusTarget = 'cell',\n  renderer,\n  onSelectionChange,\n  isShowSortIcon,\n  sortable = 'disabled',\n  sortDirection = 'unsorted',\n  onSortCriterionChange,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  hasStartEdge,\n  hasEndEdge,\n  isActiveStyle,\n  isHoverStyle,\n  isPreviousCellActiveStyle,\n  isPreviousCellHoverStyle,\n  isRtl,\n  isAccColumnHeader,\n  isHighContrast,\n  padding,\n  tooltip,\n  horizontalAlignment = 'start',\n  verticalAlignment = 'center'\n}: TableHeaderCellProps<K, C>) {\n  const browser = getClientHints().browser;\n  const supportsDefaultTooltip = tooltip !== 'disabled';\n  const supportsAutoFocus = focusTarget === 'content';\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const cellClasses = classNames(\n    getHeaderFooterCellClassArray({\n      isHeader: true,\n      isActiveStyle,\n      isHoverStyle,\n      isPreviousCellActiveStyle,\n      isPreviousCellHoverStyle,\n      isFirstColumnIndex: columnIndex === 0 || isFirstLogicalColumnIndex,\n      isFinalColumnIndex: isFinalColumnIndex || isFinalLogicalColumnIndex,\n      hasVerticalGridlines,\n      isSelected,\n      isNextColumnSelected,\n      isPreviousColumnSelected,\n      isSticky,\n      isShowFocusRing,\n      isStickyStartEdge,\n      isStickyEndEdge,\n      hasStartEdge,\n      hasEndEdge,\n      isRtl,\n      horizontalAlignment,\n      verticalAlignment,\n      isHighContrast,\n      padding\n    })\n  );\n\n  let selectorAllState: 'all' | 'none' | 'partial' | 'partial-all';\n  if (isSameKey(selectedRowKeys, { all: true, deletedKeys: new Set<K>() })) {\n    selectorAllState = 'all';\n  } else if (isSameKey(selectedRowKeys, { all: false, keys: new Set<K>() })) {\n    selectorAllState = 'none';\n  } else {\n    selectorAllState = 'partial';\n  }\n\n  const handleSelectorChange = (detail: SelectionDetail<K>) => {\n    if (onSelectionChange != null) {\n      onSelectionChange(\n        {\n          value: {\n            row: detail.value,\n            column: { all: false, keys: new Set<C>() }\n          },\n          target: detail.target\n        },\n        false\n      );\n    }\n  };\n\n  const selectorRenderer = isRowSelectionEnabled\n    ? () => (\n        <SelectorAll\n          aria-label={translations.collection_selectAllRows()}\n          onChange={handleSelectorChange}\n          selected={selectorAllState}\n        />\n      )\n    : undefined;\n\n  const handleSortGesture = useCallback(() => {\n    if (onSortCriterionChange != null) {\n      const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n      onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n    }\n  }, [columnKey, sortDirection, onSortCriterionChange]);\n\n  const headerCellRendererProps = {\n    key: columnKey,\n    headerText: headerText,\n    sortable: sortable,\n    sortDirection: sortDirection,\n    selector: selectorRenderer,\n    isTabbable: isTabbableMode\n  };\n\n  const getHeaderCellRenderer = useCallback(() => {\n    if (renderer != null) {\n      return renderer;\n    }\n    return ({ headerText, sortable, sortDirection }: TableHeaderRendererContext<C>) => {\n      const text =\n        headerText != null ? (\n          <div class={tableHeaderCellTextStyles.base}>\n            <span class={tableHeaderCellStyles.defaultRendererSpan}>{headerText}</span>\n          </div>\n        ) : undefined;\n      if (sortable === 'enabled' || sortDirection !== 'unsorted') {\n        const isIconFirst =\n          horizontalAlignment === 'end' ||\n          (!isRtl && horizontalAlignment === 'right') ||\n          (isRtl && horizontalAlignment === 'left');\n\n        const containerClasses = classNames([\n          tableHeaderSortContainerStyles.base,\n          justifyContentStyles[horizontalAlignment]\n        ]);\n        return (\n          <div class={containerClasses}>\n            {isIconFirst && <SortControl />}\n            {text}\n            {!isIconFirst && <SortControl />}\n          </div>\n        );\n      }\n      return text;\n    };\n  }, [renderer, horizontalAlignment, isRtl]);\n\n  const getAriaSelected = () => {\n    if (isSelected) {\n      return { 'aria-selected': true };\n    }\n    return isColumnSelectable ? { 'aria-selected': false } : undefined;\n  };\n\n  const getAriaSort = () => {\n    if (sortDirection === 'ascending' || sortDirection === 'descending') {\n      return { 'aria-sort': sortDirection };\n    }\n    return undefined;\n  };\n\n  return (\n    <SortableContext.Provider\n      value={{ isRendered: isShowSortIcon, sortable, sortDirection, onSort: handleSortGesture }}>\n      <th\n        aria-colindex={columnIndex + 1}\n        {...getAriaSelected()}\n        {...getAriaSort()}\n        class={cellClasses}\n        style={`top:${stickyTopOffset}px;`}\n        tabIndex={hasTabIndex ? 0 : -1}\n        role={isAccColumnHeader ? 'columnheader' : 'gridcell'}\n        data-oj-cell-type={'header'}\n        data-oj-column-key={columnKey}\n        data-oj-table-focusable={tableId}\n        data-oj-table-header-cell={tableId}\n        data-oj-table-tooltip={supportsDefaultTooltip ? 'enabled' : undefined}\n        data-oj-table-auto-focus={supportsAutoFocus ? 'enabled' : undefined}\n        {...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {})}>\n        <FormContext.Provider value={{ textAlign: getFormTextAlign(horizontalAlignment, isRtl) }}>\n          {getHeaderCellRenderer()(headerCellRendererProps)}\n        </FormContext.Provider>\n      </th>\n    </SortableContext.Provider>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableSelectionDetail, SortCriterionDetail } from '../UNSAFE_TableView';\nimport { TableColumn } from './Table';\nimport { TableHeaderCell } from './TableHeaderCell';\nimport { backgroundStyles, tableHeaderRowStyles } from './themes/Table.css';\n\n/**\n * Props for the TableHeader Component\n */\nexport type TableHeaderProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  activeKey?: C;\n  isTabbableMode: boolean;\n  isShowFocusRing: boolean;\n  selectedColumnKeys?: Keys<C>;\n  selectedRowKeys?: Keys<K>;\n  isColumnSelectionEnabled: boolean;\n  isRowSelectionEnabled: boolean;\n  isResizeHover: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void;\n  isForceSortIcons: boolean;\n  activeStyleKey?: C;\n  hoverStyleKey?: C;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  stickyTopOffset?: number;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  firstStickyColumnIndex?: number;\n  finalStickyColumnIndex?: number;\n  columnBorderEdges: { hasStart: boolean; hasEnd: boolean; width: number }[];\n};\n\n/**\n * The internal component used to render a header region in Table.\n */\nexport function TableHeader<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  activeKey,\n  isTabbableMode,\n  isShowFocusRing,\n  selectedColumnKeys,\n  selectedRowKeys,\n  isColumnSelectionEnabled,\n  isRowSelectionEnabled,\n  onSelectionChange,\n  isForceSortIcons,\n  activeStyleKey,\n  hoverStyleKey,\n  sortCriterion,\n  onSortCriterionChange,\n  stickyTopOffset,\n  startStickyEdge,\n  endStickyEdge,\n  firstStickyColumnIndex,\n  finalStickyColumnIndex,\n  columnBorderEdges,\n  isResizeHover,\n  isRtl,\n  isHighContrast\n}: TableHeaderProps<K, D, C>) {\n  const rowClasses = classNames([tableHeaderRowStyles.base]);\n\n  const getStyle = () => {\n    return isResizeHover ? 'cursor: col-resize;' : '';\n  };\n\n  let previousColumnKey: C | undefined;\n  let previousStickyColumnKey: C | undefined;\n  let isPreviousSelectable = false;\n  let isPreviousStickySelectable = false;\n  let isPreviousColumnSelected = false;\n  let isPreviousStickyColumnSelected = false;\n  return isRendered ? (\n    <thead class={backgroundStyles.inherit} role={'presentation'}>\n      <tr\n        aria-rowindex={1}\n        class={rowClasses}\n        role={'row'}\n        style={getStyle()}\n        data-oj-table-header-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          let sortDirection;\n          if (sortCriterion != null) {\n            for (const criterion of sortCriterion) {\n              if (criterion.key === columnKey) {\n                sortDirection = criterion.sortDirection;\n                break;\n              }\n            }\n          }\n          const sortable = column.value.sortable;\n          const hasSortIcon = sortable === 'enabled' || sortDirection != null;\n          const isShowSortIcon =\n            hasSortIcon &&\n            (isForceSortIcons || sortDirection != null || hoverStyleKey === columnKey);\n          const isSticky = column.value.sticky === 'enabled';\n          const isSelectable = isColumnSelectionEnabled && column.value.selectable !== 'disabled';\n          const isSelected = containsKey(selectedColumnKeys, columnKey);\n          const isActive = columnKey === activeKey;\n          const hasTabIndex = isActive && !isTabbableMode;\n          let previousVisibleColumnKey;\n          let isPreviousVisibleColumnSelectable = false;\n          let isPreviousVisibleColumnSelected = false;\n          let nextVisibleColumn;\n          let isNextVisibleColumnSelected = false;\n          let isFirstLogicalColumnIndex = false;\n          let isFinalLogicalColumnIndex = false;\n          if (isSticky) {\n            if (startStickyEdge != null && firstStickyColumnIndex === columnIndex) {\n              isFirstLogicalColumnIndex = true;\n            }\n            if (endStickyEdge != null && finalStickyColumnIndex === columnIndex) {\n              isFinalLogicalColumnIndex = true;\n            }\n            if (\n              (startStickyEdge != null && startStickyEdge > columnIndex) ||\n              (endStickyEdge != null && endStickyEdge <= columnIndex)\n            ) {\n              for (let i = columnIndex + 1; i < columnsArray.length; i++) {\n                if (columnsArray[i].value.sticky === 'enabled') {\n                  nextVisibleColumn = columnsArray[i];\n                  break;\n                }\n              }\n            } else {\n              nextVisibleColumn =\n                columnIndex < columnsArray.length - 1 ? columnsArray[columnIndex + 1] : undefined;\n            }\n            isNextVisibleColumnSelected =\n              startStickyEdge === columnIndex\n                ? false\n                : nextVisibleColumn != null &&\n                  containsKey(selectedColumnKeys, nextVisibleColumn.key);\n            if (\n              (startStickyEdge != null && startStickyEdge >= columnIndex) ||\n              (endStickyEdge != null && endStickyEdge < columnIndex)\n            ) {\n              previousVisibleColumnKey = previousStickyColumnKey;\n              isPreviousVisibleColumnSelectable = isPreviousStickySelectable;\n              isPreviousVisibleColumnSelected = isPreviousStickyColumnSelected;\n            } else if (endStickyEdge !== columnIndex) {\n              previousVisibleColumnKey = previousColumnKey;\n              isPreviousVisibleColumnSelectable = isPreviousSelectable;\n              isPreviousVisibleColumnSelected = isPreviousColumnSelected;\n            }\n          } else {\n            previousVisibleColumnKey = previousColumnKey;\n            isPreviousVisibleColumnSelectable = isPreviousSelectable;\n            isPreviousVisibleColumnSelected = isPreviousColumnSelected;\n          }\n          const headerCellProps = {\n            tableId: tableId,\n            hasVerticalGridlines: hasVerticalGridlines,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            isFirstLogicalColumnIndex: isFirstLogicalColumnIndex,\n            isFinalLogicalColumnIndex: isFinalLogicalColumnIndex,\n            stickyTopOffset: stickyTopOffset,\n            isSticky: isSticky,\n            isSelected: isSelected,\n            isNextColumnSelected: isNextVisibleColumnSelected,\n            isPreviousColumnSelected: isPreviousVisibleColumnSelected,\n            hasStartEdge: columnBorderEdges[columnIndex].hasStart,\n            hasEndEdge: columnBorderEdges[columnIndex].hasEnd,\n            selectedRowKeys: selectedRowKeys,\n            isColumnSelectable: isSelectable,\n            isRowSelectionEnabled: isRowSelectionEnabled,\n            isShowFocusRing: isShowFocusRing && isActive,\n            hasTabIndex: hasTabIndex,\n            isTabbableMode: isTabbableMode,\n            headerText: column.value.headerText,\n            renderer: column.value.headerRenderer,\n            onSelectionChange: onSelectionChange,\n            isShowSortIcon: isShowSortIcon,\n            sortable: sortable,\n            sortDirection: sortDirection,\n            onSortCriterionChange: onSortCriterionChange,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isActiveStyle: isSelectable && activeStyleKey === columnKey,\n            isHoverStyle: isSelectable && hoverStyleKey === columnKey,\n            isPreviousCellActiveStyle:\n              activeStyleKey != null &&\n              activeStyleKey === previousVisibleColumnKey &&\n              isPreviousVisibleColumnSelectable,\n            isPreviousCellHoverStyle:\n              hoverStyleKey != null &&\n              hoverStyleKey === previousVisibleColumnKey &&\n              isPreviousVisibleColumnSelectable,\n            isRtl: isRtl,\n            isAccColumnHeader: column.value.accessibleColumnHeader !== 'disabled',\n            isHighContrast: isHighContrast,\n            padding: column.value.headerPadding,\n            tooltip: column.value.headerTooltip,\n            focusTarget: column.value.headerFocusTarget,\n            horizontalAlignment:\n              column.value.headerAlignment?.horizontal != null\n                ? column.value.headerAlignment.horizontal\n                : column.value.horizontalAlignment,\n            verticalAlignment: column.value.headerAlignment?.vertical\n          };\n          previousColumnKey = columnKey;\n          isPreviousSelectable = isSelectable;\n          isPreviousColumnSelected = isSelected;\n          if (isSticky) {\n            previousStickyColumnKey = columnKey;\n            isPreviousStickySelectable = isSelectable;\n            isPreviousStickyColumnSelected = isSelected;\n          }\n          return <TableHeaderCell {...headerCellProps} />;\n        })}\n      </tr>\n    </thead>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { CellPadding, TableFooterRendererContext } from '../UNSAFE_TableView';\nimport { FormContext } from '../hooks/UNSAFE_useFormContext';\nimport { getClientHints } from '../utils/PRIVATE_clientHints';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { getFormTextAlign, getHeaderFooterCellClassArray } from './utils/TableThemeUtils';\nimport { preventBrowserTooltipProps } from './utils/TableTooltipUtils';\n\n/**\n * Props for the TableFooterCell Component\n */\nexport type TableFooterCellProps<C> = {\n  tableId: string;\n  columnKey: C;\n  columnIndex: number;\n  isFinalColumnIndex: boolean;\n  isFirstLogicalColumnIndex: boolean;\n  isFinalLogicalColumnIndex: boolean;\n  hasVerticalGridlines: boolean;\n  isSelected: boolean;\n  isNextColumnSelected: boolean;\n  isPreviousColumnSelected: boolean;\n  isSticky: boolean;\n  isColumnSelectable: boolean;\n  isShowFocusRing: boolean;\n  hasTabIndex: boolean;\n  isTabbableMode: boolean;\n  isStickyStartEdge: boolean;\n  isStickyEndEdge: boolean;\n  hasStartEdge: boolean;\n  hasEndEdge: boolean;\n  isActiveStyle: boolean;\n  isHoverStyle: boolean;\n  isPreviousCellActiveStyle: boolean;\n  isPreviousCellHoverStyle: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  footerText?: string;\n  stickyBottomOffset?: number;\n  focusTarget?: 'cell' | 'content';\n  renderer?: (context: TableFooterRendererContext<C>) => ComponentChildren;\n  padding?: CellPadding;\n  tooltip?: 'enabled' | 'disabled';\n  horizontalAlignment?: 'start' | 'end' | 'left' | 'right' | 'center';\n  verticalAlignment?: 'top' | 'center' | 'bottom';\n};\n\nfunction _defaultFooterCellRenderer<C>({ footerText }: TableFooterRendererContext<C>) {\n  return footerText != null ? footerText : undefined;\n}\n\n/**\n * The internal component used to render a single cell in a TableFooterRow.\n */\nexport function TableFooterCell<C>({\n  tableId,\n  columnKey,\n  columnIndex,\n  isFinalColumnIndex,\n  isFirstLogicalColumnIndex,\n  isFinalLogicalColumnIndex,\n  hasVerticalGridlines,\n  isSelected,\n  isNextColumnSelected,\n  isPreviousColumnSelected,\n  isSticky,\n  isColumnSelectable,\n  isShowFocusRing,\n  hasTabIndex,\n  isTabbableMode,\n  stickyBottomOffset = 0,\n  focusTarget = 'cell',\n  footerText,\n  renderer = _defaultFooterCellRenderer,\n  isStickyStartEdge,\n  isStickyEndEdge,\n  hasStartEdge,\n  hasEndEdge,\n  isActiveStyle,\n  isHoverStyle,\n  isPreviousCellActiveStyle,\n  isPreviousCellHoverStyle,\n  isRtl,\n  isHighContrast,\n  padding,\n  tooltip,\n  horizontalAlignment = 'start',\n  verticalAlignment = 'center'\n}: TableFooterCellProps<C>) {\n  const browser = getClientHints().browser;\n  const supportsDefaultTooltip = tooltip !== 'disabled';\n  const supportsAutoFocus = focusTarget === 'content';\n\n  const cellClasses = classNames(\n    getHeaderFooterCellClassArray({\n      isHeader: false,\n      isActiveStyle,\n      isHoverStyle,\n      isPreviousCellActiveStyle,\n      isPreviousCellHoverStyle,\n      isFirstColumnIndex: columnIndex === 0 || isFirstLogicalColumnIndex,\n      isFinalColumnIndex: isFinalColumnIndex || isFinalLogicalColumnIndex,\n      hasVerticalGridlines,\n      isSelected,\n      isNextColumnSelected,\n      isPreviousColumnSelected,\n      isSticky,\n      hasStartEdge,\n      hasEndEdge,\n      isShowFocusRing,\n      isStickyStartEdge,\n      isStickyEndEdge,\n      isRtl,\n      horizontalAlignment,\n      verticalAlignment,\n      isHighContrast,\n      padding\n    })\n  );\n\n  const footerCellRendererProps = {\n    key: columnKey,\n    footerText: footerText,\n    isTabbable: isTabbableMode\n  };\n\n  return (\n    <td\n      aria-colindex={columnIndex + 1}\n      {...(isSelected\n        ? { 'aria-selected': true }\n        : isColumnSelectable\n        ? { 'aria-selected': false }\n        : {})}\n      class={cellClasses}\n      style={`bottom:${stickyBottomOffset}px;`}\n      tabIndex={hasTabIndex ? 0 : -1}\n      role={'gridcell'}\n      data-oj-cell-type={'footer'}\n      data-oj-column-key={columnKey}\n      data-oj-table-focusable={tableId}\n      data-oj-table-footer-cell={tableId}\n      data-oj-table-tooltip={supportsDefaultTooltip ? 'enabled' : undefined}\n      data-oj-table-auto-focus={supportsAutoFocus ? 'enabled' : undefined}\n      {...(supportsDefaultTooltip && browser === 'safari' ? preventBrowserTooltipProps : {})}>\n      <FormContext.Provider value={{ textAlign: getFormTextAlign(horizontalAlignment, isRtl) }}>\n        {renderer(footerCellRendererProps)}\n      </FormContext.Provider>\n    </td>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { Keys, containsKey } from '../utils/UNSAFE_keys';\nimport { TableColumn } from './Table';\nimport { TableFooterCell } from './TableFooterCell';\nimport { backgroundStyles, tableFooterRowStyles } from './themes/Table.css';\n\n/**\n * Props for the TableFooter Component\n */\nexport type TableFooterProps<K, D, C> = {\n  tableId: string;\n  isRendered: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  hasVerticalGridlines: boolean;\n  activeKey?: C;\n  isTabbableMode: boolean;\n  isShowFocusRing: boolean;\n  isRtl: boolean;\n  isHighContrast: boolean;\n  selectedColumnKeys?: Keys<C>;\n  isColumnSelectionEnabled: boolean;\n  activeStyleKey?: C;\n  hoverStyleKey?: C;\n  stickyBottomOffset?: number;\n  startStickyEdge?: number;\n  endStickyEdge?: number;\n  firstStickyColumnIndex?: number;\n  finalStickyColumnIndex?: number;\n  columnBorderEdges: { hasStart: boolean; hasEnd: boolean; width: number }[];\n  dataRowCount: number;\n};\n\n/**\n * The internal component used to render a footer region in Table.\n */\nexport function TableFooter<K, D, C>({\n  tableId,\n  isRendered,\n  columnsArray,\n  hasVerticalGridlines,\n  activeKey,\n  isTabbableMode,\n  isShowFocusRing,\n  selectedColumnKeys,\n  isColumnSelectionEnabled,\n  activeStyleKey,\n  hoverStyleKey,\n  stickyBottomOffset,\n  startStickyEdge,\n  endStickyEdge,\n  firstStickyColumnIndex,\n  finalStickyColumnIndex,\n  columnBorderEdges,\n  dataRowCount,\n  isRtl,\n  isHighContrast\n}: TableFooterProps<K, D, C>) {\n  const rowClasses = classNames([tableFooterRowStyles.base]);\n\n  let previousColumnKey: C | undefined;\n  let previousStickyColumnKey: C | undefined;\n  let isPreviousSelectable = false;\n  let isPreviousStickySelectable = false;\n  let isPreviousColumnSelected = false;\n  let isPreviousStickyColumnSelected = false;\n  return isRendered ? (\n    <tfoot class={backgroundStyles.inherit} role={'presentation'}>\n      <tr\n        aria-rowindex={Math.max(dataRowCount, 1) + 2}\n        class={rowClasses}\n        role={'row'}\n        data-oj-table-footer-row={tableId}>\n        {columnsArray.map((column: TableColumn<K, D, C>, columnIndex: number) => {\n          const columnKey = column.key;\n          const isSticky = column.value.sticky === 'enabled';\n          const isSelectable = isColumnSelectionEnabled && column.value.selectable !== 'disabled';\n          const isSelected = containsKey(selectedColumnKeys, columnKey);\n          const isActive = columnKey === activeKey;\n          const hasTabIndex = isActive && !isTabbableMode;\n          let previousVisibleColumnKey;\n          let isPreviousVisibleColumnSelectable = false;\n          let isPreviousVisibleColumnSelected = false;\n          let nextVisibleColumn;\n          let isNextVisibleColumnSelected = false;\n          let isFirstLogicalColumnIndex = false;\n          let isFinalLogicalColumnIndex = false;\n          if (isSticky) {\n            if (startStickyEdge != null && firstStickyColumnIndex === columnIndex) {\n              isFirstLogicalColumnIndex = true;\n            }\n            if (endStickyEdge != null && finalStickyColumnIndex === columnIndex) {\n              isFinalLogicalColumnIndex = true;\n            }\n            if (\n              (startStickyEdge != null && startStickyEdge > columnIndex) ||\n              (endStickyEdge != null && endStickyEdge <= columnIndex)\n            ) {\n              for (let i = columnIndex + 1; i < columnsArray.length; i++) {\n                if (columnsArray[i].value.sticky === 'enabled') {\n                  nextVisibleColumn = columnsArray[i];\n                  break;\n                }\n              }\n            } else {\n              nextVisibleColumn =\n                columnIndex < columnsArray.length - 1 ? columnsArray[columnIndex + 1] : undefined;\n            }\n            isNextVisibleColumnSelected =\n              startStickyEdge === columnIndex\n                ? false\n                : nextVisibleColumn != null &&\n                  containsKey(selectedColumnKeys, nextVisibleColumn.key);\n            if (\n              (startStickyEdge != null && startStickyEdge >= columnIndex) ||\n              (endStickyEdge != null && endStickyEdge < columnIndex)\n            ) {\n              previousVisibleColumnKey = previousStickyColumnKey;\n              isPreviousVisibleColumnSelectable = isPreviousStickySelectable;\n              isPreviousVisibleColumnSelected = isPreviousStickyColumnSelected;\n            } else if (endStickyEdge !== columnIndex) {\n              previousVisibleColumnKey = previousColumnKey;\n              isPreviousVisibleColumnSelectable = isPreviousSelectable;\n              isPreviousVisibleColumnSelected = isPreviousColumnSelected;\n            }\n          } else {\n            previousVisibleColumnKey = previousColumnKey;\n            isPreviousVisibleColumnSelectable = isPreviousSelectable;\n            isPreviousVisibleColumnSelected = isPreviousColumnSelected;\n          }\n          const footerCellProps = {\n            tableId: tableId,\n            columnKey: columnKey,\n            columnIndex: columnIndex,\n            isFinalColumnIndex: columnIndex === columnsArray.length - 1,\n            isFirstLogicalColumnIndex: isFirstLogicalColumnIndex,\n            isFinalLogicalColumnIndex: isFinalLogicalColumnIndex,\n            hasVerticalGridlines: hasVerticalGridlines,\n            stickyBottomOffset: stickyBottomOffset,\n            isSticky: isSticky,\n            isSelected: isSelected,\n            isNextColumnSelected: isNextVisibleColumnSelected,\n            isPreviousColumnSelected: isPreviousVisibleColumnSelected,\n            hasStartEdge: columnBorderEdges[columnIndex].hasStart,\n            hasEndEdge: columnBorderEdges[columnIndex].hasEnd,\n            isColumnSelectable: isSelectable,\n            isShowFocusRing: isShowFocusRing && isActive,\n            hasTabIndex: hasTabIndex,\n            isTabbableMode: isTabbableMode,\n            footerText: column.value.footerText,\n            renderer: column.value.footerRenderer,\n            isStickyStartEdge: columnIndex === startStickyEdge,\n            isStickyEndEdge: columnIndex === endStickyEdge,\n            isActiveStyle: isSelectable && activeStyleKey === columnKey,\n            isHoverStyle: isSelectable && hoverStyleKey === columnKey,\n            isPreviousCellActiveStyle:\n              activeStyleKey != null &&\n              activeStyleKey === previousVisibleColumnKey &&\n              isPreviousVisibleColumnSelectable,\n            isPreviousCellHoverStyle:\n              hoverStyleKey != null &&\n              hoverStyleKey === previousVisibleColumnKey &&\n              isPreviousVisibleColumnSelectable,\n            isRtl: isRtl,\n            isHighContrast: isHighContrast,\n            padding: column.value.footerPadding,\n            tooltip: column.value.footerTooltip,\n            focusTarget: column.value.footerFocusTarget,\n            horizontalAlignment:\n              column.value.footerAlignment?.horizontal != null\n                ? column.value.footerAlignment.horizontal\n                : column.value.horizontalAlignment,\n            verticalAlignment: column.value.footerAlignment?.vertical\n          };\n          previousColumnKey = columnKey;\n          isPreviousSelectable = isSelectable;\n          isPreviousColumnSelected = isSelected;\n          if (isSticky) {\n            previousStickyColumnKey = columnKey;\n            isPreviousStickySelectable = isSelectable;\n            isPreviousStickyColumnSelected = isSelected;\n          }\n          return <TableFooterCell {...footerCellProps} />;\n        })}\n      </tr>\n    </tfoot>\n  ) : null;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { tableDragIndicatorStyles } from './themes/Table.css';\n\n/**\n * Props for the TableDragIndicator Component\n */\nexport type TableDragIndicatorProps = {\n  isRtl: boolean;\n  position?: number;\n  height?: number;\n};\n\n/**\n * The internal component used to render a drag indicator line in the Table.\n */\nexport function TableDragIndicator({ position, isRtl, height }: TableDragIndicatorProps) {\n  const tableDragIndicatorClasses = classNames([tableDragIndicatorStyles.base]);\n\n  const getDragIndicatorStyle = () => {\n    const heightString = height != null ? `height:${height}px;` : '';\n    if (position != null) {\n      return isRtl\n        ? `right:${position}px;cursor:col-resize;${heightString}`\n        : `left:${position}px;cursor:col-resize;${heightString}`;\n    }\n    return `display:none;`;\n  };\n\n  return <div class={tableDragIndicatorClasses} style={getDragIndicatorStyle()} />;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentProps } from 'preact';\nimport { useCallback, useRef, useState, Dispatch, StateUpdater } from 'preact/hooks';\nimport { BundleType } from '../resources/nls/bundle';\nimport { FocusableHandle } from '../hooks/UNSAFE_useFocusableTextField';\nimport { SelectableHandle } from '../hooks/UNSAFE_useSelectableTextField';\nimport { useTranslationBundle } from '../hooks/UNSAFE_useTranslationBundle';\nimport { ValueUpdateDetail } from '../utils/UNSAFE_valueUpdateDetail';\nimport { AppliedColumnWidths } from './Table';\nimport { Button } from '../UNSAFE_Button';\nimport { Dialog } from '../UNSAFE_Dialog';\nimport { Flex } from '../UNSAFE_Flex';\nimport { Menu, MenuItem, SelectMenuItem, SelectSingleMenuGroup, Submenu } from '../UNSAFE_Menu';\nimport { NumberInputText } from '../UNSAFE_NumberInputText';\nimport {\n  CellContextMenuContext,\n  ColumnResizeDetail,\n  SortCriterionDetail,\n  TableContextMenuConfig\n} from '../UNSAFE_TableView';\n\ntype Props<K extends string | number, D, C extends string> = {\n  contextMenuConfig: TableContextMenuConfig<K, D, C>;\n  contextMenuContext: CellContextMenuContext<K, D, C>;\n} & Omit<ComponentProps<typeof Menu>, 'children'>;\n\n/**\n * The internal component used to render a custom context menu on the Table\n */\nexport function TableContextMenu<K extends string | number, D, C extends string>({\n  contextMenuConfig,\n  contextMenuContext,\n  ...menuProps\n}: Props<K, D, C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const accessibleLabel =\n    contextMenuConfig.accessibleLabel != null\n      ? contextMenuConfig.accessibleLabel\n      : translations.accContextMenuLabel();\n\n  return contextMenuConfig.itemsRenderer(contextMenuContext) != null ? (\n    <Menu aria-label={accessibleLabel} {...menuProps}>\n      {menuProps.isOpen && contextMenuConfig.itemsRenderer(contextMenuContext)}\n    </Menu>\n  ) : (\n    <></>\n  );\n}\n\ntype SortItemProps<C extends string> = {\n  columnKey: C;\n  isDisabled: boolean;\n  currentSortDirection?: 'ascending' | 'descending';\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n};\n\n/**\n * The internal component used to render the context menu sort item on the Table\n */\nexport function TableContextMenuSort<C extends string>({\n  columnKey,\n  isDisabled,\n  currentSortDirection,\n  onSortCriterionChange\n}: SortItemProps<C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const _handleSort: Required<ComponentProps<typeof SelectSingleMenuGroup>>['onCommit'] = ({\n    value\n  }) => {\n    if (onSortCriterionChange != null && value !== currentSortDirection) {\n      onSortCriterionChange([\n        { key: columnKey, sortDirection: value === 'ascending' ? 'ascending' : 'descending' }\n      ]);\n    }\n  };\n\n  return (\n    <Submenu label={translations.collection_sortColumnMenu()}>\n      <SelectSingleMenuGroup value={currentSortDirection} onCommit={_handleSort}>\n        <SelectMenuItem\n          isDisabled={isDisabled}\n          value=\"ascending\"\n          label={translations.collection_sortAscendingSubMenu()}\n        />\n        <SelectMenuItem\n          isDisabled={isDisabled}\n          value=\"descending\"\n          label={translations.collection_sortDescendingSubMenu()}\n        />\n      </SelectSingleMenuGroup>\n    </Submenu>\n  );\n}\n\ntype ResizeItemProps = {\n  isDisabled: boolean;\n  setIsResizeDialogOpen: Dispatch<StateUpdater<boolean>>;\n};\n\n/**\n * The internal component used to render the context menu column resize item on the Table\n */\nexport function TableContextMenuResize({ isDisabled, setIsResizeDialogOpen }: ResizeItemProps) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const handleResize = () => {\n    setIsResizeDialogOpen(true);\n  };\n\n  return (\n    <MenuItem\n      label={translations.collection_resizeColumnMenu()}\n      onAction={handleResize}\n      isDisabled={isDisabled}\n    />\n  );\n}\n\ntype ResizeDialogProps<C extends string> = {\n  isOpen: boolean;\n  columnKey: C;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  appliedColumnWidths: AppliedColumnWidths<C>;\n  setIsResizeDialogOpen: Dispatch<StateUpdater<boolean>>;\n};\n\n/**\n * The internal component used to render the column resize dialog on the Table\n */\nexport function TableResizeColumnDialog<C extends string>({\n  isOpen,\n  columnKey,\n  onColumnResize,\n  appliedColumnWidths,\n  setIsResizeDialogOpen\n}: ResizeDialogProps<C>) {\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  const initialWidth = Math.round(appliedColumnWidths.netColumnWidths[columnKey]);\n  const initialWidthRef = useRef<number>(initialWidth);\n\n  const numberInputRef = useRef<FocusableHandle & SelectableHandle>(null);\n\n  const [widthValue, setWidthValue] = useState<string | undefined>(String(initialWidth));\n\n  let isDisabled;\n  let messages: ComponentProps<typeof NumberInputText>['messages'];\n  if (\n    widthValue == null ||\n    Number.isNaN(parseInt(widthValue)) ||\n    String(parseInt(widthValue)) !== widthValue.trim() ||\n    parseInt(widthValue) < 16 ||\n    parseInt(widthValue) > 100000\n  ) {\n    messages = [\n      {\n        severity: 'error',\n        detail: translations.collection_resizeMessageDetail({ MIN: '16', MAX: '100000' })\n      }\n    ];\n    isDisabled = true;\n  } else {\n    isDisabled = false;\n  }\n\n  const apply = useCallback(() => {\n    if (columnKey != null && onColumnResize != null && widthValue != null) {\n      if (parseInt(widthValue) !== initialWidthRef.current) {\n        onColumnResize({\n          key: columnKey,\n          newWidth: parseInt(widthValue),\n          allColumnWidths: appliedColumnWidths.netColumnWidths,\n          paddingWidth: appliedColumnWidths.totalBorderOffset,\n          gesture: 'contextMenu',\n          type: 'absolute'\n        });\n      }\n    }\n    setIsResizeDialogOpen(false);\n  }, [columnKey, onColumnResize, widthValue, appliedColumnWidths, setIsResizeDialogOpen]);\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.key === 'Enter' && !isDisabled) {\n        apply();\n      }\n    },\n    [apply, isDisabled]\n  );\n\n  const cancel = useCallback(() => {\n    setIsResizeDialogOpen(false);\n  }, [setIsResizeDialogOpen]);\n\n  const handleOnInput = useCallback((detail: ValueUpdateDetail<string>) => {\n    setWidthValue(detail.value);\n  }, []);\n\n  const footer = (\n    <Flex gap=\"2x\">\n      <Button onAction={cancel} label={translations.collection_cancel()} />\n      <Button\n        variant=\"callToAction\"\n        onAction={apply}\n        label={translations.collection_apply()}\n        isDisabled={isDisabled}\n      />\n    </Flex>\n  );\n\n  return (\n    <Dialog\n      autoFocusRef={numberInputRef}\n      isOpen={isOpen}\n      modality={'modal'}\n      header={translations.collection_resizeColumnDialog()}\n      footer={footer}>\n      <div onKeyDown={handleKeyDown}>\n        <NumberInputText\n          label={translations.collection_width()}\n          onInput={handleOnInput}\n          suffix={translations.collection_pixels()}\n          messages={messages}\n          isRequired={true}\n          isRequiredShown={true}\n          ref={numberInputRef}\n          value={widthValue}\n        />\n      </div>\n    </Dialog>\n  );\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { Dispatch, MutableRef } from 'preact/hooks';\nimport { scrollerStyles } from '../themes/Table.css';\nimport {\n  AppliedColumnWidths,\n  ScrollDetail,\n  SizingInfo,\n  StickyColumnInfo,\n  TableColumn,\n  ViewportInfo\n} from '../Table';\nimport {\n  TableHorizontalScrollPosition,\n  TableVerticalScrollPosition,\n  TableViewportConfig\n} from '../../UNSAFE_TableView';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\nimport {\n  getColumnKey,\n  getElementFromCell,\n  getRowKey,\n  getRowKeyForRowIndex,\n  getScrollerBottomOffset,\n  getScrollerTopOffset\n} from './TableDomUtils';\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nfunction _scrollColumnIntoView<K, D, C extends string>(\n  columnElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  columnsArray: TableColumn<K, D, C>[],\n  stickyColumnInfo: StickyColumnInfo,\n  scrollbarWidth: number,\n  isRtl: boolean,\n  appliedColumnWidths?: AppliedColumnWidths<C>,\n  location?: 'inView' | 'start' | 'end'\n) {\n  const columnKey = getColumnKey(columnElement);\n\n  let columnIndex;\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].key === columnKey) {\n      columnIndex = i;\n      break;\n    }\n  }\n  if (columnIndex != null && appliedColumnWidths != null) {\n    let startOffset = 0;\n    let endOffset = 0;\n    if (viewportInfo.isExternalScroller) {\n      const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n      if (scrollerOffsetStart != null) {\n        startOffset = scrollerOffsetStart;\n      }\n      const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n      if (scrollerOffsetEnd != null) {\n        endOffset = scrollerOffsetEnd;\n      }\n    }\n\n    let stickyCount = 0;\n    const borderOffset = appliedColumnWidths.borderOffset;\n    const stickyColumns = stickyColumnInfo.stickyColumns;\n    for (let i = 0; i < stickyColumns.length; i++) {\n      const stickyIndex = stickyColumns[i];\n      if (stickyIndex < columnIndex) {\n        startOffset += appliedColumnWidths.netColumnWidths[columnsArray[stickyIndex].key];\n        stickyCount += 1;\n      } else {\n        break;\n      }\n    }\n    startOffset += startOffset > 0 ? stickyCount * borderOffset + borderOffset : 0;\n    if (!appliedColumnWidths.borderEdges[columnIndex].hasStart) {\n      startOffset += borderOffset;\n    }\n    stickyCount = 0;\n    for (let i = stickyColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyColumns[i];\n      if (stickyIndex > columnIndex) {\n        endOffset += appliedColumnWidths.netColumnWidths[columnsArray[stickyIndex].key];\n        stickyCount += 1;\n      } else {\n        break;\n      }\n    }\n    endOffset += endOffset > 0 ? stickyCount * borderOffset + borderOffset : 0;\n    if (!appliedColumnWidths.borderEdges[columnIndex].hasEnd) {\n      endOffset += borderOffset;\n    }\n\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      columnElement,\n      scrollerElement,\n      startOffset,\n      endOffset,\n      scrollbarWidth,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    // don't adjust scroll position if row has overflow in both directions\n    if (hasLeftOverflow && hasRightOverflow) {\n      return;\n    }\n\n    if (location == null || location === 'inView') {\n      // if column fits fully in viewport, scroll overflow side into view\n      // otherwise, scroll the shortest amount to fill viewport with column\n      if (hasLeftOverflow) {\n        if (Math.abs(rightOverflowDiff) > Math.abs(leftOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        }\n      } else if (hasRightOverflow) {\n        if (Math.abs(leftOverflowDiff) > Math.abs(rightOverflowDiff)) {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft + rightOverflowDiff,\n            true\n          );\n        } else {\n          scrollerElement.scrollLeft = _roundScrollValue(\n            scrollerElement.scrollLeft - leftOverflowDiff,\n            false\n          );\n        }\n      }\n    } else if (location === 'start') {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft - leftOverflowDiff,\n        false\n      );\n    } else {\n      scrollerElement.scrollLeft = _roundScrollValue(\n        scrollerElement.scrollLeft + rightOverflowDiff,\n        true\n      );\n    }\n  }\n}\n\n/**\n * A helper function to make sure specified elem is visible in the specified container\n */\nconst _scrollRowIntoView = (\n  rootElement: HTMLDivElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  rowElement: HTMLElement,\n  scrollerElement: HTMLElement,\n  scrollbarHeight: number,\n  location?: 'inView' | 'top' | 'bottom'\n) => {\n  let topOffset = 0;\n  let bottomOffset = 0;\n\n  if (viewportInfo.isExternalScroller) {\n    const scrollerOffsetTop = viewportInfo.viewportConfig.scrollerOffsetTop;\n    if (scrollerOffsetTop != null) {\n      topOffset = scrollerOffsetTop;\n    }\n    const scrollerOffsetBottom = viewportInfo.viewportConfig.scrollerOffsetBottom;\n    if (scrollerOffsetBottom != null) {\n      bottomOffset = scrollerOffsetBottom;\n    }\n  }\n  topOffset += getScrollerTopOffset(rootElement, tableId);\n  bottomOffset += getScrollerBottomOffset(rootElement, tableId);\n\n  const verticalOverflowDiff = _getVerticalOverflowDiff(\n    rowElement,\n    scrollerElement,\n    topOffset,\n    bottomOffset,\n    scrollbarHeight\n  );\n  const topOverflowDiff = verticalOverflowDiff.top;\n  const hasTopOverflow = topOverflowDiff >= 0;\n  const bottomOverflowDiff = verticalOverflowDiff.bottom;\n  const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n  // don't adjust scroll position if row has overflow in both directions\n  if (hasTopOverflow && hasBottomOverflow) {\n    return;\n  }\n  if (location == null || location === 'inView') {\n    // if row fits fully in viewport, scroll overflow side into view\n    // otherwise, scroll the shortest amount to fill viewport with row\n    if (hasBottomOverflow) {\n      if (Math.abs(topOverflowDiff) > Math.abs(bottomOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      }\n    } else if (hasTopOverflow) {\n      if (Math.abs(bottomOverflowDiff) > Math.abs(topOverflowDiff)) {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop - topOverflowDiff,\n          false\n        );\n      } else {\n        scrollerElement.scrollTop = _roundScrollValue(\n          scrollerElement.scrollTop + bottomOverflowDiff,\n          true\n        );\n      }\n    }\n  } else if (location === 'top') {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop - topOverflowDiff,\n      false\n    );\n  } else {\n    scrollerElement.scrollTop = _roundScrollValue(\n      scrollerElement.scrollTop + bottomOverflowDiff,\n      true\n    );\n  }\n};\n\n/**\n * Helper method to round a desired scrollTop or scrollLeft value to the nearest valid value\n * depending on the client browser.\n */\nconst _roundScrollValue = (value: number, isOver: boolean) => {\n  // use Math.floor() and Math.ceil() to ensure we round to nearest containing valid\n  // pixel value in either direction as valid scrollTop values are only integers\n  return isOver ? Math.ceil(value) : Math.floor(value);\n};\n\n/**\n * A helper to get the horizontal overflow diff of the given element\n */\nconst _getHorizontalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  startOffset: number,\n  endOffset: number,\n  scrollbarWidth: number,\n  isRtl: boolean\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  if (isRtl) {\n    return {\n      left: scrollerRect.left - elementRect.left + endOffset + scrollbarWidth,\n      right: elementRect.right - scrollerRect.right + startOffset\n    };\n  } else {\n    return {\n      left: scrollerRect.left - elementRect.left + startOffset,\n      right: elementRect.right - scrollerRect.right + endOffset + scrollbarWidth\n    };\n  }\n};\n\n/**\n * A helper to get the vertical overflow diff of the given element\n */\nexport const _getVerticalOverflowDiff = (\n  element: HTMLElement,\n  scrollerElement: HTMLElement,\n  topOffset: number,\n  bottomOffset: number,\n  scrollbarHeight: number\n) => {\n  const elementRect = element.getBoundingClientRect();\n  const scrollerRect = scrollerElement.getBoundingClientRect();\n\n  return {\n    top: scrollerRect.top - elementRect.top + topOffset,\n    bottom: elementRect.bottom - scrollerRect.bottom + bottomOffset + scrollbarHeight\n  };\n};\n\n/**\n * Helper to set the horizontal scroll position on the Table.\n */\nexport function setHorizontalScrollPosition<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  isRtl: boolean,\n  horizontalScrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  const x = _getScrollLeftFromScrollPosition(\n    scrollerElement,\n    columnsArray,\n    fullColumnWidths,\n    horizontalScrollPosition\n  );\n  scrollerElement.scrollLeft = x != null ? (isRtl ? -x : x) : 0;\n}\n\n/**\n * Helper to set the vertical scroll position on the Table.\n */\nexport function setVerticalScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  verticalScrollPosition?: TableVerticalScrollPosition<K>\n) {\n  const y = _getScrollTopFromScrollPosition(\n    rootElement,\n    scrollerElement,\n    tableId,\n    verticalScrollPosition\n  );\n  scrollerElement.scrollTop = y != null ? y : 0;\n}\n\n/**\n * Helper to determine the 'x' value of a given scroll position.\n */\nfunction _getScrollLeftFromScrollPosition<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  scrollPosition?: TableHorizontalScrollPosition<C>\n) {\n  if (scrollPosition != null) {\n    let columnKey;\n    let useColumn = false;\n    if (scrollPosition.columnKey != null) {\n      // columnKey takes precedence over everything else\n      useColumn = true;\n      columnKey = scrollPosition.columnKey;\n    } else if (scrollPosition.offsetX != null && scrollPosition.x == null) {\n      // offsetX can be used on its own if it is the only horizontal aspect provided\n      useColumn = true;\n      const currentHorizontalScrollPosition = getHorizontalScrollPosition(\n        scrollerElement,\n        columnsArray,\n        fullColumnWidths\n      );\n      columnKey = currentHorizontalScrollPosition.columnKey;\n    }\n    if (useColumn) {\n      if (columnKey != null) {\n        let x = 0;\n        for (let i = 0; i < fullColumnWidths.length; i++) {\n          if (columnsArray[i].key === columnKey) {\n            return x + (scrollPosition.offsetX != null ? scrollPosition.offsetX : 0);\n          }\n          if (columnsArray[i].value.sticky !== 'enabled') {\n            x += fullColumnWidths[i];\n          }\n        }\n      }\n    } else if (scrollPosition.x != null) {\n      return scrollPosition.x;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to determine the 'y' value of a given scroll position.\n */\nfunction _getScrollTopFromScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  scrollPosition?: TableVerticalScrollPosition<K>\n) {\n  if (scrollPosition != null) {\n    let rowKey;\n    let useRow = false;\n    if (scrollPosition.rowKey != null) {\n      // rowKey takes precedence over everything else\n      useRow = true;\n      rowKey = scrollPosition.rowKey;\n    } else if (scrollPosition.offsetY != null && scrollPosition.y == null) {\n      // offsetY can be used on its own if it is the only vertical aspect provided\n      useRow = true;\n      rowKey = getVerticalScrollPosition(rootElement, scrollerElement, tableId).rowKey;\n    }\n    if (useRow) {\n      if (rowKey != null) {\n        let y = 0;\n        const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n        for (let i = 0; i < rowElements.length; i++) {\n          if (rowKey === getRowKey(rowElements[i] as HTMLElement)) {\n            return y + (scrollPosition.offsetY != null ? scrollPosition.offsetY : 0);\n          }\n          y += rowElements[i].getBoundingClientRect().height;\n        }\n      }\n    } else if (scrollPosition.y != null) {\n      return scrollPosition.y;\n    }\n  }\n  // either nothing was provided, or what was provided was invalid\n  return undefined;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollLeft value. If no scrollLeft value is given,\n * it will use the current scrollLeft value of the Table.\n */\nexport function getHorizontalScrollPosition<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  fullColumnWidths: number[],\n  newScrollLeft?: number\n) {\n  // ensure scroll position x value is initialized\n  const scrollLeft = Math.abs(newScrollLeft == null ? scrollerElement.scrollLeft : newScrollLeft);\n\n  const scrollPosition: TableHorizontalScrollPosition<C> = {\n    x: scrollLeft,\n    columnKey: undefined,\n    offsetX: undefined\n  };\n\n  let columnEnd = 0;\n  if (columnsArray.length > 0) {\n    if (scrollLeft === 0) {\n      scrollPosition.columnKey = columnsArray[0].key;\n      scrollPosition.offsetX = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.sticky !== 'enabled') {\n      columnEnd += fullColumnWidths[i];\n    }\n    if (scrollLeft <= columnEnd - 0.5) {\n      scrollPosition.columnKey = columnsArray[i].key;\n      scrollPosition.offsetX = fullColumnWidths[i] + scrollLeft - columnEnd;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\n/**\n * Helper to get the logical scroll position for the given scrollTop value. If no scrollTop value is given,\n * it will use the current scrollTop value of the Table.\n */\nexport function getVerticalScrollPosition<K>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  newScrollTop?: number\n) {\n  // ensure scroll position y value is initialized\n  const scrollTop = Math.abs(newScrollTop == null ? scrollerElement.scrollTop : newScrollTop);\n\n  const scrollPosition: TableVerticalScrollPosition<K> = {\n    y: scrollTop,\n    rowKey: undefined,\n    offsetY: undefined\n  };\n\n  let rowBottom = 0;\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  if (rowElements.length > 0) {\n    if (scrollTop === 0) {\n      scrollPosition.rowKey = getRowKeyForRowIndex<K>(rootElement, tableId, 0)!;\n      scrollPosition.offsetY = 0;\n      return scrollPosition;\n    }\n  }\n  for (let i = 0; i < rowElements.length; i++) {\n    const rowHeight = rowElements[i].getBoundingClientRect().height;\n    rowBottom += rowHeight;\n    if (scrollTop <= rowBottom - 0.5) {\n      scrollPosition.rowKey = getRowKeyForRowIndex<K>(rootElement, tableId, i)!;\n      scrollPosition.offsetY = rowHeight + scrollTop - rowBottom;\n      break;\n    }\n  }\n  return scrollPosition;\n}\n\nexport function applyScrollDetail<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  stickyColumnInfo: StickyColumnInfo,\n  sizingInfo: SizingInfo,\n  scrollDetail: ScrollDetail<K, C>,\n  isRtl: boolean,\n  appliedColumnWidths?: AppliedColumnWidths<C>\n) {\n  if (scrollDetail.cell.type === 'data') {\n    const rowElement = findElementByKey(\n      rootElement,\n      scrollDetail.cell.rowKey,\n      `[data-oj-table-data-row='${tableId}']`\n    ) as HTMLElement;\n    if (rowElement != null && scrollDetail.locationY != null && !sizingInfo.isInitialRender) {\n      const scrollbarHeight = sizingInfo.boxHeight - sizingInfo.contentHeight;\n      _scrollRowIntoView(\n        rootElement,\n        viewportInfo,\n        tableId,\n        rowElement,\n        scrollerElement,\n        scrollbarHeight,\n        scrollDetail.locationY\n      );\n    }\n  }\n  if (\n    scrollDetail.cell.type === 'data' ||\n    scrollDetail.cell.type === 'header' ||\n    scrollDetail.cell.type === 'footer'\n  ) {\n    const cellElement = getElementFromCell(rootElement, tableId, scrollDetail.cell);\n    if (cellElement != null && scrollDetail.locationX != null && !sizingInfo.isInitialRender) {\n      const scrollbarWidth = sizingInfo.boxWidth - sizingInfo.contentWidth;\n      _scrollColumnIntoView(\n        cellElement,\n        scrollerElement,\n        viewportInfo,\n        columnsArray,\n        stickyColumnInfo,\n        scrollbarWidth,\n        isRtl,\n        appliedColumnWidths,\n        scrollDetail.locationX\n      );\n    }\n  }\n  if (scrollDetail.cell.type === 'loadMore' || scrollDetail.cell.type === 'loading') {\n    const cellElement = getElementFromCell(rootElement, tableId, scrollDetail.cell);\n    if (cellElement != null && scrollDetail.locationY != null && !sizingInfo.isInitialRender) {\n      const scrollbarHeight = sizingInfo.boxHeight - sizingInfo.contentHeight;\n      _scrollRowIntoView(\n        rootElement,\n        viewportInfo,\n        tableId,\n        cellElement,\n        scrollerElement,\n        scrollbarHeight,\n        scrollDetail.cell.type === 'loading' && scrollDetail.locationY === 'inView'\n          ? 'top'\n          : scrollDetail.locationY\n      );\n    }\n  }\n}\n\n/**\n * Helper function to update the 'left' and 'right' values of all sticky columns to correspond\n * to the given sizing information.\n */\nexport function updateStickyColumns<K, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  isRtl: boolean,\n  columnsArray: TableColumn<K, D, C>[],\n  stickyColumnInfo: StickyColumnInfo,\n  fullColumnWidths: number[],\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void,\n  isHorizontalScroll: boolean\n) {\n  let stickyIndex;\n  let stickyStartOffset = 0;\n  let stickyEndOffset = 0;\n  if (viewportInfo.isExternalScroller) {\n    const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n    if (scrollerOffsetStart != null) {\n      stickyStartOffset = scrollerOffsetStart;\n    }\n    const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n    if (scrollerOffsetEnd != null) {\n      stickyEndOffset = scrollerOffsetEnd;\n    }\n  }\n\n  const stickyIndicies = stickyColumnInfo.stickyColumns;\n  for (let i = 0; i < stickyIndicies.length; i++) {\n    stickyIndex = stickyIndicies[i];\n    _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyStartOffset, true);\n    stickyStartOffset += fullColumnWidths[stickyIndex];\n  }\n  for (let i = stickyIndicies.length - 1; i > -1; i--) {\n    stickyIndex = stickyIndicies[i];\n    _applyStickyColumnOffset(rootElement, tableId, isRtl, stickyIndex, stickyEndOffset, false);\n    stickyEndOffset += fullColumnWidths[stickyIndex];\n  }\n\n  // only apply sticky edge styling if horizontal overflow is present\n  if (isHorizontalScroll) {\n    updateStickyEdges(\n      scrollerElement,\n      columnsArray,\n      stickyColumnInfo,\n      fullColumnWidths,\n      stickyEdgesState,\n      setStickyEdgesState\n    );\n  } else if (stickyEdgesState.start != null || stickyEdgesState.end != null) {\n    setStickyEdgesState({});\n  }\n}\n\n/**\n * Helper function to get the sticky column indicies.\n */\nexport const getStickyColumnIndicies = <K, D, C>(columnsArray: TableColumn<K, D, C>[]) => {\n  const stickyColumns = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    if (columnsArray[i].value.sticky === 'enabled') {\n      stickyColumns.push(i);\n    }\n  }\n  return stickyColumns;\n};\n\n/**\n * Helper function to update the 'left' and 'right' values of a specific column.\n */\nconst _applyStickyColumnOffset = (\n  rootElement: HTMLDivElement,\n  tableId: string,\n  isRtl: boolean,\n  columnIndex: number,\n  stickyOffset: number,\n  isStart: boolean\n) => {\n  const styleProperty = (isStart && !isRtl) || (!isStart && isRtl) ? 'left' : 'right';\n  const styleValue = `${stickyOffset}px`;\n\n  const headerElements = rootElement.querySelectorAll(`[data-oj-table-header-cell='${tableId}']`);\n  const headerElement = headerElements[columnIndex] as HTMLElement;\n  headerElement.style[styleProperty] = styleValue;\n\n  const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n  for (let j = 0; j < rowElements.length; j++) {\n    const rowElement = rowElements[j] as HTMLElement;\n    const cellElements = rowElement.querySelectorAll(`[data-oj-table-data-cell='${tableId}']`);\n    const cellElement = cellElements[columnIndex] as HTMLElement;\n    cellElement.style[styleProperty] = styleValue;\n  }\n\n  const footerElements = rootElement.querySelectorAll(`[data-oj-table-footer-cell='${tableId}']`);\n  if (footerElements.length > 0) {\n    const footerElement = footerElements[columnIndex] as HTMLElement;\n    footerElement.style[styleProperty] = styleValue;\n  }\n};\n\n/**\n * Helper function to update the sticky edges based on the given scrollLeft value.\n */\nexport function updateStickyEdges<K, D, C>(\n  scrollerElement: HTMLElement,\n  columnsArray: TableColumn<K, D, C>[],\n  stickyColumnInfo: StickyColumnInfo,\n  fullColumnWidths: number[],\n  stickyEdgesState: { start?: number; end?: number },\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void,\n  scrollLeft?: number\n) {\n  if (columnsArray.length > 0) {\n    let i;\n    let currentScrollIndex;\n    const newScrollPosition = getHorizontalScrollPosition(\n      scrollerElement,\n      columnsArray,\n      fullColumnWidths,\n      scrollLeft\n    );\n    for (i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === newScrollPosition.columnKey) {\n        currentScrollIndex = i;\n        break;\n      }\n    }\n\n    let startIndex;\n    const stickyIndicies = stickyColumnInfo.stickyColumns;\n    // browser zoom levels cause rounding issues where the start scroll\n    // position may never be reached, but it should always be within 1\n    if (newScrollPosition.x! >= 1) {\n      for (i = 0; i < stickyIndicies.length; i++) {\n        const currentIndex = stickyIndicies[i];\n        if (currentIndex < currentScrollIndex!) {\n          startIndex = currentIndex;\n        } else {\n          break;\n        }\n      }\n    }\n\n    let endIndex;\n    let currentWidth = 0;\n    const maxScrollPos = scrollerElement.scrollWidth - scrollerElement.clientWidth;\n    const endOverflow = maxScrollPos - newScrollPosition.x!;\n    // browser zoom levels cause rounding issues where the max scroll\n    // position may never be reached, but it should always be within 1\n    if (endOverflow >= 1) {\n      for (let i = columnsArray.length - 1; i > -1; i--) {\n        if (stickyIndicies.indexOf(i) !== -1) {\n          endIndex = i;\n        } else {\n          currentWidth += fullColumnWidths[i];\n          if (currentWidth > endOverflow) {\n            break;\n          }\n        }\n      }\n    }\n    if (stickyEdgesState.start != startIndex || stickyEdgesState.end != endIndex) {\n      setStickyEdgesState({ start: startIndex, end: endIndex });\n    }\n  }\n}\n\n/**\n * Helper function to hide a currently shown tooltip once the anchor cell scrolls out of view.\n */\nexport function hideOutOfViewTooltip(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  sizingInfo: SizingInfo,\n  stickyColumnInfo: StickyColumnInfo,\n  fullColumnWidths: number[],\n  tooltipAnchorRef: MutableRef<HTMLElement | undefined>,\n  hideTooltip: (isImmediate?: boolean) => void,\n  isRtl: boolean\n) {\n  if (tooltipAnchorRef.current != null) {\n    const verticalOverflowDiff = _getVerticalOverflowDiff(\n      tooltipAnchorRef.current,\n      scrollerElement,\n      getScrollerTopOffset(rootElement, tableId),\n      getScrollerBottomOffset(rootElement, tableId),\n      sizingInfo.boxHeight! - sizingInfo.contentHeight!\n    );\n    const topOverflowDiff = verticalOverflowDiff.top;\n    const hasTopOverflow = topOverflowDiff >= 0;\n    const bottomOverflowDiff = verticalOverflowDiff.bottom;\n    const hasBottomOverflow = bottomOverflowDiff >= 0;\n\n    if (\n      (hasTopOverflow && Math.abs(topOverflowDiff) > tooltipAnchorRef.current.offsetHeight) ||\n      (hasBottomOverflow && Math.abs(bottomOverflowDiff) > tooltipAnchorRef.current.offsetHeight)\n    ) {\n      hideTooltip(true);\n      return;\n    }\n\n    let startOffset = 0;\n    let endOffset = 0;\n\n    const stickyColumns = stickyColumnInfo.stickyColumns;\n    for (let i = 0; i < stickyColumns.length; i++) {\n      const stickyIndex = stickyColumns[i];\n      startOffset += fullColumnWidths[stickyIndex];\n    }\n    for (let i = stickyColumns.length - 1; i > -1; i--) {\n      const stickyIndex = stickyColumns[i];\n      endOffset += fullColumnWidths[stickyIndex];\n    }\n    const horizontalOverflowDiff = _getHorizontalOverflowDiff(\n      tooltipAnchorRef.current,\n      scrollerElement,\n      startOffset,\n      endOffset,\n      sizingInfo.boxWidth! - sizingInfo.contentWidth!,\n      isRtl\n    );\n    const leftOverflowDiff = horizontalOverflowDiff.left;\n    const hasLeftOverflow = leftOverflowDiff >= 0;\n    const rightOverflowDiff = horizontalOverflowDiff.right;\n    const hasRightOverflow = rightOverflowDiff >= 0;\n\n    if (\n      (hasLeftOverflow && Math.abs(leftOverflowDiff) > tooltipAnchorRef.current.offsetWidth) ||\n      (hasRightOverflow && Math.abs(rightOverflowDiff) > tooltipAnchorRef.current.offsetWidth)\n    ) {\n      hideTooltip(true);\n    }\n  }\n}\n\n/**\n * Helper function to reset the scroll position of the scroller element\n */\nexport const resetVerticalScrollPosition = (scrollerElement: HTMLElement) => {\n  scrollerElement.scrollTop = 0;\n};\n\n/**\n * Helper function to get the viewport config. TODO: this needs help for table still\n */\nexport const getViewportConfig = (\n  scrollerRef: RefObject<HTMLElement>,\n  config?: TableViewportConfig\n) => {\n  return (\n    config ?? {\n      scroller: () => {\n        return scrollerRef;\n      }\n    }\n  );\n};\n\n/**\n * Helper function to update the scroller element's styling based on overflow status.\n */\nexport const applyOverflowStatus = (\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  contentWidth: number,\n  availableWidth: number,\n  contentHeight: number,\n  availableHeight: number,\n  scrollbarWidth: number,\n  overflowRef: MutableRef<{ isHorizontal: boolean; isVertical: boolean }>,\n  setHasVerticalUnderflow: Dispatch<boolean>\n) => {\n  // check for at least 0.5px difference to account for browser rounding issues\n  const hasHorizontalOverflow = contentWidth - availableWidth > 0.5;\n  const hasVerticalOverflow = contentHeight - availableHeight > 0.5;\n  if (hasHorizontalOverflow) {\n    scrollerElement.classList.remove(scrollerStyles.noHorizontalScroll);\n    scrollerElement.classList.add(scrollerStyles.horizontalScroll);\n  } else {\n    scrollerElement.classList.remove(scrollerStyles.horizontalScroll);\n    scrollerElement.classList.add(scrollerStyles.noHorizontalScroll);\n  }\n  if (hasVerticalOverflow) {\n    scrollerElement.classList.remove(scrollerStyles.noVerticalScroll);\n    scrollerElement.classList.add(scrollerStyles.verticalScroll);\n    scrollerElement.style.paddingInlineEnd = '';\n  } else {\n    scrollerElement.classList.remove(scrollerStyles.verticalScroll);\n    scrollerElement.classList.add(scrollerStyles.noVerticalScroll);\n    scrollerElement.style.paddingInlineEnd = `${scrollbarWidth}px`;\n  }\n  overflowRef.current.isHorizontal = hasHorizontalOverflow;\n  overflowRef.current.isVertical = hasVerticalOverflow;\n  applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);\n};\n\n/**\n * Helper function to update the undeflow status of the Table based on the spacer element sizing.\n */\nexport const applyUnderflowStatus = (\n  rootElement: HTMLDivElement,\n  tableId: string,\n  setHasVerticalUnderflow: Dispatch<boolean>\n) => {\n  const spacerRowElement = rootElement.querySelector(\n    `[data-oj-table-spacer-row='${tableId}']`\n  ) as HTMLElement;\n  if (spacerRowElement != null) {\n    setHasVerticalUnderflow(spacerRowElement.offsetHeight > 0);\n  }\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Dispatch, MutableRef, StateUpdater } from 'preact/hooks';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  AppliedColumnWidths,\n  CurrencyStatus,\n  SizingInfo,\n  StickyColumnInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { TableContextMenuResize, TableContextMenuSort } from '../TableContextMenu';\nimport { getBoundaryColumnKey, getElementFromCell, isAutoFocusCell } from './TableDomUtils';\nimport { applyScrollDetail, resetVerticalScrollPosition } from './TableScrollUtils';\nimport {\n  Cell,\n  CellContextMenuContext,\n  CellOverride,\n  SortCriterionDetail\n} from '../../UNSAFE_TableView';\n\n/**\n * Helper function to determine if a given active cell represents a 'transient' state.\n */\nexport function isTransientCell<K, C>(activeCell?: ActiveCell<K, C>) {\n  return (\n    activeCell != null &&\n    (activeCell.type === 'loadMore' ||\n      activeCell.type === 'loading' ||\n      activeCell.type === 'pending')\n  );\n}\n\n/**\n * Helper function to compare two given cell descriptors.\n */\nexport function cellComparator<K, C>(\n  cell1?: ActiveCell<K, C> | Cell<K, C>,\n  cell2?: ActiveCell<K, C> | Cell<K, C>\n) {\n  if (cell1 == null) {\n    return cell2 == null;\n  }\n  if (cell2 == null) {\n    return false;\n  }\n  if (cell1.type === cell2.type && cell1.rowKey === cell2.rowKey) {\n    // special case the transient 'loading' cell types as column keys are hints used for when a user\n    // navigates back to another region using the keyboard - otherwise we'd go to the first column\n    if (cell1.type === 'loading' || cell1.type === 'loadMore' || cell1.type === 'pending') {\n      return true;\n    }\n    return cell1.columnKey === cell2.columnKey;\n  }\n  return false;\n}\n\nexport function getCellContextMenuContextFromCell<K extends string | number, D, C extends string>(\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  setIsResizeDialogOpen: Dispatch<StateUpdater<boolean>>,\n  cell?: ActiveCell<K, C>,\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[],\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void\n) {\n  if (cell?.type === 'data' || cell?.type === 'header' || cell?.type === 'footer') {\n    let isSortable = false;\n    let isResizable = false;\n    for (let i = 0; i < columnsArray.length; i++) {\n      const column = columnsArray[i];\n      if (column.key === cell.columnKey) {\n        isSortable = column.value.sortable === 'enabled';\n        isResizable = column.value.resizable === 'enabled';\n        break;\n      }\n    }\n    let currentSortDirection;\n    if (sortCriterion != null) {\n      for (const criterion of sortCriterion) {\n        if (criterion.key === cell.columnKey) {\n          currentSortDirection = criterion.sortDirection;\n          break;\n        }\n      }\n    }\n    const allMenuItems = {\n      resizeColumn: (\n        <TableContextMenuResize\n          isDisabled={!isResizable}\n          setIsResizeDialogOpen={setIsResizeDialogOpen}\n        />\n      ),\n      sortColumn: (\n        <TableContextMenuSort\n          columnKey={cell.columnKey}\n          isDisabled={!isSortable}\n          currentSortDirection={currentSortDirection}\n          onSortCriterionChange={onSortCriterionChange}\n        />\n      )\n    };\n\n    const hasResizableColumns = columnsArray.some((column: TableColumn<K, D, C>) => {\n      return column.value.resizable === 'enabled';\n    });\n    const hasSortableColumns = columnsArray.some((column: TableColumn<K, D, C>) => {\n      return column.value.sortable === 'enabled';\n    });\n\n    const defaultMenuItems =\n      hasResizableColumns || hasSortableColumns ? (\n        <>\n          {hasResizableColumns ? allMenuItems['resizeColumn'] : undefined}\n          {hasSortableColumns ? allMenuItems['sortColumn'] : undefined}\n        </>\n      ) : undefined;\n\n    if (cell.type === 'data') {\n      for (const rowData of tableData) {\n        if (rowData.metadata === cell.rowKey) {\n          return {\n            allMenuItems,\n            defaultMenuItems,\n            rowData: rowData.data,\n            rowKey: cell.rowKey,\n            columnKey: cell.columnKey,\n            type: 'data'\n          } as CellContextMenuContext<K, D, C>;\n        }\n      }\n    } else {\n      return {\n        allMenuItems,\n        defaultMenuItems,\n        columnKey: cell.columnKey,\n        type: cell.type\n      } as CellContextMenuContext<K, D, C>;\n    }\n  }\n  return undefined;\n}\n\n/**\n * Helper function to determine the resulting cell from a cell override.\n */\nfunction _getCellFromCellOverride<K, D, C>(\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  cellOverride: CellOverride<K, C>,\n  currentCell?: Cell<K, C>\n): Cell<K, C> | undefined {\n  let cellType;\n  let cellRowKey;\n  let cellColumnKey;\n  if (cellOverride.rowKey != null) {\n    cellType = 'data';\n    cellRowKey = cellOverride.rowKey;\n    if (cellOverride.columnKey != null) {\n      cellColumnKey = cellOverride.columnKey;\n    } else if (currentCell?.columnKey != null) {\n      cellColumnKey = currentCell.columnKey;\n    } else {\n      cellColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n    }\n    if (cellColumnKey == null) {\n      return undefined;\n    }\n  } else if (cellOverride.columnKey != null) {\n    cellColumnKey = cellOverride.columnKey;\n    if (cellOverride.type != null) {\n      cellType = cellOverride.type;\n    } else if (currentCell?.type != null && currentCell.type !== 'noData') {\n      cellType = currentCell.type;\n    } else {\n      cellType = 'header';\n    }\n    if (cellType === 'data') {\n      if (currentCell?.rowKey != null) {\n        cellRowKey = currentCell.rowKey;\n      } else if (tableData.length > 0) {\n        cellRowKey = tableData[0].metadata;\n      }\n      if (cellRowKey == null) {\n        return undefined;\n      }\n    }\n  } else if (cellOverride.type != null) {\n    cellType = cellOverride.type;\n    if (cellType !== 'noData') {\n      if (currentCell?.columnKey != null) {\n        cellColumnKey = currentCell.columnKey;\n      } else {\n        cellColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n      }\n      if (cellColumnKey == null) {\n        return undefined;\n      }\n      if (cellType === 'data') {\n        if (currentCell?.rowKey != null) {\n          cellRowKey = currentCell.rowKey;\n        } else if (tableData.length > 0) {\n          cellRowKey = tableData[0].metadata;\n        }\n        if (cellRowKey == null) {\n          return undefined;\n        }\n      }\n    }\n  } else {\n    return undefined;\n  }\n  return { type: cellType, rowKey: cellRowKey, columnKey: cellColumnKey } as Cell<K, C>;\n}\n\n/**\n * Helper function to determine the resulting cell type from a cell override.\n */\nfunction _getCellTypeFromCellOverride<K, C>(\n  cellOverride: CellOverride<K, C>,\n  currentCell?: Cell<K, C>\n) {\n  if (cellOverride.type != null) {\n    return cellOverride.type;\n  }\n  if (cellOverride.rowKey != null) {\n    return 'data';\n  }\n  // if no type or rowKey was given, a columnKey must have been given\n  if (currentCell?.type != null && currentCell.type !== 'noData') {\n    return currentCell.type;\n  }\n  return 'header';\n}\n\n/**\n * Helper function to apply a current cell override if necessary.\n */\nexport function applyCurrentCellOverride<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  stickyColumnInfo: StickyColumnInfo,\n  sizingInfoRef: MutableRef<SizingInfo>,\n  currencyStatusRef: MutableRef<CurrencyStatus<K, D, C>>,\n  onActiveCellChanged: (\n    detail: ActiveCellDetail<K, C>,\n    isAutoFocus?: boolean,\n    isSelectionExtension?: boolean,\n    skipScrollCellIntoView?: boolean\n  ) => void,\n  isEmbeddedSelect: boolean,\n  isPendingLayout: boolean,\n  isDataLoaded: boolean,\n  isRtl: boolean,\n  currentCellOverride?: CellOverride<K, C>,\n  appliedColumnWidths?: AppliedColumnWidths<C>\n) {\n  // when embedded select, use most recent non-null current cell value as override base\n  const currentCell = isEmbeddedSelect\n    ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell\n    : currencyStatusRef.current.currentCell;\n  // ensure any new currentCellOverride settings are applied if necessary\n  if (\n    currencyStatusRef.current.hasPendingCurrentCellOverride ||\n    currencyStatusRef.current.currentCellOverride !== currentCellOverride\n  ) {\n    if (currentCellOverride != null) {\n      // attempt to find the cell the override specifies\n      const realizedCell = _getCellFromCellOverride<K, D, C>(\n        tableData,\n        columnsArray,\n        currentCellOverride,\n        currentCell\n      );\n      if (realizedCell != null) {\n        // override cell was determined - apply the override immediately\n        onActiveCellChanged(\n          { value: realizedCell },\n          isAutoFocusCell(rootElement, tableId, realizedCell)\n        );\n        currencyStatusRef.current.currentCellOverride = currentCellOverride;\n        currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n        if (isEmbeddedSelect) {\n          // scroll 'current-cell-override' vertically into view immediately for embedded select\n          // otherwise, cell will be scrolled into view once the component or cell receives focus\n          if (!isPendingLayout && getElementFromCell(rootElement, tableId, realizedCell) != null) {\n            applyScrollDetail(\n              rootElement,\n              scrollerElement,\n              viewportInfo,\n              tableId,\n              columnsArray,\n              stickyColumnInfo,\n              sizingInfoRef.current,\n              { cell: realizedCell, locationY: 'inView' },\n              isRtl,\n              appliedColumnWidths\n            );\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n          } else if (isPendingLayout || !isDataLoaded) {\n            // corresponding element was not found - data is not ready for scrolling\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = true;\n          } else {\n            // corresponding element was not found - value was garbage\n            currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n          }\n        } else {\n          // not in an embedded select, so no scrolling should be performed\n          currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n        }\n      } else if (!isDataLoaded) {\n        // override cell could not be determined - data is still fetching\n        currencyStatusRef.current.hasPendingCurrentCellOverride = true;\n      } else {\n        // override cell could not be determined - value was garbage\n        currencyStatusRef.current.currentCellOverride = currentCellOverride;\n        currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      }\n    } else {\n      // override is set to clear the current cell\n      onActiveCellChanged({ value: currentCellOverride });\n      currencyStatusRef.current.currentCellOverride = currentCellOverride;\n      currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n      if (isEmbeddedSelect) {\n        // scroll back to the top for embedded select\n        resetVerticalScrollPosition(scrollerElement);\n      }\n      currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n    }\n  } else if (currencyStatusRef.current.hasPendingCurrentCellOverrideScroll) {\n    // try and apply any pending scroll from a previous cell override at this time\n    if (currencyStatusRef.current.currentCell != null) {\n      if (\n        !isPendingLayout &&\n        getElementFromCell(rootElement, tableId, currencyStatusRef.current.currentCell) != null\n      ) {\n        applyScrollDetail(\n          rootElement,\n          scrollerElement,\n          viewportInfo,\n          tableId,\n          columnsArray,\n          stickyColumnInfo,\n          sizingInfoRef.current,\n          { cell: currencyStatusRef.current.currentCell, locationY: 'inView' },\n          isRtl,\n          appliedColumnWidths\n        );\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      } else if (!isPendingLayout && isDataLoaded) {\n        // corresponding element was not found - value was garbage\n        currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n      }\n    } else {\n      // there is no longer a current cell to try and scroll to\n      currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n    }\n  }\n}\n\n/**\n * Helper to determine if the given render state includes the cell specified.\n */\nfunction _renderIncludesCell<K, D, C>(\n  cell: ActiveCell<K, C>,\n  columnsArray: TableColumn<K, D, C>[],\n  tableData: TableData<K, D>[],\n  hasMore: boolean,\n  isPendingLayout: boolean,\n  hasFooters: boolean\n) {\n  // pending layout is special as other regions exist, but are not yet navigable\n  if (isPendingLayout) {\n    return cell.type === 'pending';\n  }\n  if (cell.type === 'header' || (hasFooters && cell.type === 'footer')) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (columnsArray[i].key === cell.columnKey) {\n        return true;\n      }\n    }\n  } else if (tableData.length > 0) {\n    if (cell.type === 'loadMore') {\n      return hasMore;\n    }\n    if (cell.type === 'data') {\n      let isColumnValid = false;\n      for (let i = 0; i < columnsArray.length; i++) {\n        if (columnsArray[i].key === cell.columnKey) {\n          isColumnValid = true;\n          break;\n        }\n      }\n      if (isColumnValid) {\n        for (let i = 0; i < tableData.length; i++) {\n          if (tableData[i].metadata === cell.rowKey) {\n            return true;\n          }\n        }\n      }\n    }\n  } else {\n    return (cell.type === 'loading' && hasMore) || (cell.type === 'noData' && !hasMore);\n  }\n  return false;\n}\n\n/**\n * Helper to get the cell that should currently be a tab stop for the given render state.\n */\nexport function determineActiveCell<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  currencyStatusRef: MutableRef<CurrencyStatus<K, D, C>>,\n  tableData: TableData<K, D>[],\n  hasMore: boolean,\n  isPendingLayout: boolean,\n  isEmbeddedSelect: boolean,\n  hasFooters: boolean,\n  currentCellOverride?: CellOverride<K, C>\n): ActiveCell<K, C> | undefined {\n  if (isPendingLayout) {\n    return { type: 'pending' };\n  }\n  // if no columns are specified, it is a special case 'noData' display\n  const firstColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n  if (firstColumnKey == null) {\n    return { type: 'noData' };\n  }\n  // if nothing specifies where focus should go, use the first header cell\n  const defaultFirstCell: ActiveCell<K, C> = {\n    type: 'header',\n    columnKey: firstColumnKey\n  };\n\n  // when embedded select, use most recent non-null current cell value as override base\n  const currentCell = isEmbeddedSelect\n    ? currencyStatusRef.current.previousEmbeddedSelectCurrentCell\n    : currencyStatusRef.current.currentCell;\n  if (\n    currencyStatusRef.current.hasPendingCurrentCellOverride ||\n    currencyStatusRef.current.currentCellOverride !== currentCellOverride\n  ) {\n    if (currentCellOverride != null) {\n      // attempt to find the cell the override specifies\n      const realizedCell = _getCellFromCellOverride<K, D, C>(\n        tableData,\n        columnsArray,\n        currentCellOverride,\n        currentCell\n      );\n      if (\n        realizedCell != null &&\n        _renderIncludesCell(\n          realizedCell,\n          columnsArray,\n          tableData,\n          hasMore,\n          isPendingLayout,\n          hasFooters\n        )\n      ) {\n        return realizedCell;\n      }\n      // if here, the resulting cell from the override could not be determined or was not valid\n      const overrideCellType = _getCellTypeFromCellOverride(currentCellOverride, currentCell);\n      if (overrideCellType === 'data') {\n        if (tableData.length === 0 && hasMore) {\n          // pending 'data' override when 'loading' skeletons are shown\n          return { type: 'loading', columnKey: currentCell?.columnKey as C };\n        }\n      } else if (overrideCellType === 'noData' && tableData.length === 0 && hasMore) {\n        // pending 'noData' override when 'loading' skeletons are shown\n        return { type: 'loading', columnKey: currentCell?.columnKey as C };\n      }\n    } else if (\n      _renderIncludesCell(\n        defaultFirstCell,\n        columnsArray,\n        tableData,\n        hasMore,\n        isPendingLayout,\n        hasFooters\n      )\n    ) {\n      return defaultFirstCell;\n    } else {\n      return undefined;\n    }\n  }\n\n  // if here, there is no current cell override that can be applied during this render\n  const activeCell = currencyStatusRef.current.activeCell;\n  if (activeCell != null) {\n    if (activeCell.type === 'loadMore') {\n      const initialData = currencyStatusRef.current.loadMoreInitialData;\n      // if loadMore skeletons are no longer shown, or the data has changed, shift to\n      // the next row in the data set if possible - otherwise just the closest row\n      if (tableData.length > 0 && tableData !== initialData) {\n        const rowKey =\n          initialData != null && tableData.length > initialData.length\n            ? tableData[initialData.length].metadata\n            : tableData[tableData.length - 1].metadata;\n        const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;\n        const cell: ActiveCell<K, C> = { type: 'data', rowKey: rowKey, columnKey: columnKey };\n        if (\n          _renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n        ) {\n          return cell;\n        }\n      } else if (tableData.length === 0) {\n        if (hasMore) {\n          return { type: 'loading', columnKey: currentCell?.columnKey as C };\n        } else {\n          return { type: 'noData' };\n        }\n      }\n    }\n    if (\n      _renderIncludesCell(activeCell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n    ) {\n      return activeCell;\n    } else if (activeCell.type === 'loading') {\n      if (currentCell != null && (currentCell.type === 'data' || currentCell.type === 'noData')) {\n        // if the current cell is already set to 'data' or 'noData', and is now available, return it\n        if (\n          _renderIncludesCell(\n            currentCell,\n            columnsArray,\n            tableData,\n            hasMore,\n            isPendingLayout,\n            hasFooters\n          )\n        ) {\n          return currentCell;\n        }\n      }\n      // otherwise, find the first row if available, and try and maintain the columnKey\n      if (tableData.length > 0) {\n        const rowKey = tableData[0].metadata;\n        const columnKey = currentCell?.columnKey != null ? currentCell.columnKey : firstColumnKey;\n        const cell: ActiveCell<K, C> = { type: 'data', rowKey: rowKey, columnKey: columnKey };\n        if (\n          _renderIncludesCell(cell, columnsArray, tableData, hasMore, isPendingLayout, hasFooters)\n        ) {\n          return cell;\n        }\n      } else {\n        return { type: 'noData' };\n      }\n    }\n  }\n\n  // if here, there is no active cell, or the active cell is no longer valid\n  if (currentCell != null) {\n    if (\n      _renderIncludesCell(\n        currentCell,\n        columnsArray,\n        tableData,\n        hasMore,\n        isPendingLayout,\n        hasFooters\n      )\n    ) {\n      return currentCell;\n    }\n    if (currentCell.type === 'data') {\n      if (tableData.length === 0 && hasMore) {\n        // pending 'data' override when 'loading' skeletons are shown\n        return { type: 'loading', columnKey: currentCell.columnKey };\n      }\n    } else if (currentCell.type === 'noData' && tableData.length === 0 && hasMore) {\n      // pending 'noData' override when 'loading' skeletons are shown\n      return { type: 'loading', columnKey: firstColumnKey };\n    }\n  }\n  if (\n    _renderIncludesCell(\n      defaultFirstCell,\n      columnsArray,\n      tableData,\n      hasMore,\n      isPendingLayout,\n      hasFooters\n    )\n  ) {\n    return defaultFirstCell;\n  }\n  return undefined;\n}\n","import { ComponentProps } from 'preact';\nimport { useCallback, useState, useRef } from 'preact/hooks';\nimport { Menu } from '../../UNSAFE_Menu';\nimport {\n  CellContextMenuContext,\n  SortCriterionDetail,\n  TableContextMenuConfig\n} from '../../UNSAFE_TableView';\nimport { useContextMenuGesture } from '../../hooks/UNSAFE_useContextMenuGesture';\nimport { ActiveCell, TableColumn, TableData } from '../Table';\nimport { getCellContextMenuContextFromCell } from '../utils/TableFocusUtils';\n\ntype MenuProps = Pick<\n  ComponentProps<typeof Menu>,\n  'anchorRef' | 'initialFocus' | 'placement' | 'offsetValue' | 'isOpen'\n>;\n\nconst TOUCH_OFFSET_VALUE = 40;\n\nconst menuPropGestureStates: Record<\n  'mouse' | 'keyboard' | 'touch',\n  Omit<Required<MenuProps>, 'anchorRef' | 'isOpen'>\n> = {\n  mouse: {\n    initialFocus: 'menu',\n    placement: 'bottom-start',\n    offsetValue: 2\n  },\n  keyboard: {\n    initialFocus: 'firstItem',\n    placement: 'bottom-start',\n    offsetValue: 0\n  },\n  touch: {\n    initialFocus: 'menu',\n    placement: 'end',\n    offsetValue: TOUCH_OFFSET_VALUE\n  }\n};\n\nconst _initialMenuProps: MenuProps = {\n  isOpen: false,\n  initialFocus: 'menu',\n  placement: 'bottom-start',\n  offsetValue: 0,\n  anchorRef: { current: null }\n};\n\nexport const useContextMenu = <K extends string | number, D, C extends string>(\n  tableId: string,\n  tableData: TableData<K, D>[],\n  columnsArray: TableColumn<K, D, C>[],\n  activeCell?: ActiveCell<K, C>,\n  contextMenuConfig?: TableContextMenuConfig<K, D, C>,\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[],\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void\n) => {\n  const [contextMenuContext, setContextMenuContext] = useState<CellContextMenuContext<K, D, C>>();\n  const [menuProps, setMenuProps] = useState<MenuProps>(_initialMenuProps);\n  const currentCellElementRef = useRef<HTMLElement>();\n\n  const [isResizeDialogOpen, setIsResizeDialogOpen] = useState<boolean>(false);\n\n  const { triggerProps } = useContextMenuGesture(\n    ({ gesture, anchor, target }) => {\n      if (activeCell != null) {\n        const cellContextMenuContext = getCellContextMenuContextFromCell<K, D, C>(\n          tableData,\n          columnsArray,\n          setIsResizeDialogOpen,\n          activeCell,\n          sortCriterion,\n          onSortCriterionChange\n        );\n        if (cellContextMenuContext != null) {\n          // find the cell element the menu is being launched from\n          const cellElement = (target as HTMLElement).closest(\n            `[data-oj-table-focusable='${tableId}']`\n          ) as HTMLElement;\n          if (cellElement != null) {\n            currentCellElementRef.current = cellElement;\n            const anchorBasedOnGesture = gesture === 'keyboard' ? cellElement : anchor;\n            setContextMenuContext(cellContextMenuContext);\n            setMenuProps({\n              ...menuPropGestureStates[gesture],\n              anchorRef: { current: anchorBasedOnGesture },\n              isOpen: true\n            });\n          }\n        }\n      }\n    },\n    {\n      isDisabled: !contextMenuConfig\n    }\n  );\n\n  const handleCloseContextMenu = useCallback<Required<ComponentProps<typeof Menu>>['onClose']>(\n    (detail) => {\n      // set focus back on the cell that was determined as the initial target\n      if (detail.reason === 'dismissed' || detail.reason === 'itemAction') {\n        currentCellElementRef.current?.focus({ preventScroll: true });\n      }\n      // close the menu\n      setMenuProps({ ..._initialMenuProps });\n    },\n    []\n  );\n\n  return {\n    menuProps: { ...menuProps, onClose: handleCloseContextMenu },\n    onClose: handleCloseContextMenu,\n    contextMenuContext: contextMenuContext,\n    contextMenuTriggerProps: triggerProps,\n    isResizeDialogOpen: isResizeDialogOpen,\n    setIsResizeDialogOpen: setIsResizeDialogOpen\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useEffect, useRef, useState, MutableRef } from 'preact/hooks';\nimport { useId } from '../../hooks/UNSAFE_useId';\nimport { useColorScheme } from '../../hooks/UNSAFE_useColorScheme';\nimport { useScale } from '../../hooks/UNSAFE_useScale';\nimport { TooltipContent } from '../../hooks/UNSAFE_useTooltip/TooltipContent';\nimport {\n  getGlobalTooltipManager,\n  getWrappedTooltipContent,\n  SHOW_TOOLTIP_DELAY,\n  HIDE_TOOLTIP_DELAY\n} from '../../utils/PRIVATE_tooltipUtils';\nimport { ColumnResizeInfo } from '../Table';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport { cellComparator } from '../utils/TableFocusUtils';\nimport { hasTruncatedText } from '../utils/TableTooltipUtils';\nimport { Cell } from '../../UNSAFE_TableView';\n\ntype UseTruncationTooltipOptions<C> = {\n  rootRef: RefObject<HTMLDivElement>;\n  tableId: string;\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>;\n};\n\n// delay small interaction times concerning a tooltip\nconst SMALL_INTERACTION_DELAY = 50;\nconst TABLE_HIDE_TOOLTIP_DELAY = Math.max(\n  Math.min(SHOW_TOOLTIP_DELAY - SMALL_INTERACTION_DELAY, HIDE_TOOLTIP_DELAY),\n  0\n);\n\n/**\n * Hook that manages cell template tooltip interactions on the Table when truncation is present.\n */\nexport function useTruncationTooltip<K, C>({\n  rootRef,\n  tableId,\n  resizeInfoRef\n}: UseTruncationTooltipOptions<C>) {\n  const globalTooltipManager = getGlobalTooltipManager();\n\n  const tooltipId = useId();\n\n  const tooltipCellRef = useRef<Cell<K, C>>();\n  const pendingShowTooltipCellRef = useRef<Cell<K, C>>();\n  const tooltipAnchorRef = useRef<HTMLElement>();\n  const tooltipTextRef = useRef<string>();\n  const [tooltipText, setTooltipText] = useState<string>();\n\n  const pointerDownRef = useRef<boolean>(false);\n  const pointerDownTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  const showTooltipTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n  const hideTooltipTimeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  // helper method for clearing the hide tooltip timeout\n  const _clearHideTooltipTimeout = useCallback(() => {\n    clearTimeout(hideTooltipTimeoutRef.current);\n    hideTooltipTimeoutRef.current = undefined;\n  }, []);\n\n  // helper method for clearing the show tooltip timeout\n  const _clearShowTooltipTimeout = useCallback(() => {\n    clearTimeout(showTooltipTimeoutRef.current);\n    showTooltipTimeoutRef.current = undefined;\n    pendingShowTooltipCellRef.current = undefined;\n  }, []);\n\n  // helper method for setting up the show tooltip timeout\n  const _setupShowTooltipTimeout = useCallback(() => {\n    showTooltipTimeoutRef.current = setTimeout(function () {\n      // when showing a tooltip, clear any pending 'clear tooltip timeouts'\n      if (hideTooltipTimeoutRef.current != null) {\n        _clearHideTooltipTimeout();\n      }\n      // only show a tooltip if not currently performing a column resize gesture\n      if (!resizeInfoRef.current.isResizing) {\n        showTooltipTimeoutRef.current = undefined;\n        const cell = pendingShowTooltipCellRef.current;\n        const rootElement = rootRef.current;\n        if (rootElement != null && cell != null) {\n          const cellElement = getElementFromCell(rootElement, tableId, cell);\n          if (cellElement != null && hasTruncatedText(cellElement)) {\n            setTooltipText(String(cellElement.innerText).trim());\n            tooltipAnchorRef.current = cellElement;\n            tooltipCellRef.current = cell;\n          }\n        }\n      }\n      pendingShowTooltipCellRef.current = undefined;\n    }, SHOW_TOOLTIP_DELAY);\n  }, [rootRef, tableId, resizeInfoRef, _clearHideTooltipTimeout]);\n\n  // helper method for setting up the hide tooltip timeout\n  const _setupHideTooltipTimeout = useCallback(() => {\n    hideTooltipTimeoutRef.current = setTimeout(function () {\n      // unlike in the showtooltip timeout logic, we do not want to clear\n      // pending show tooltip timeouts when clearing a tooltip as it could\n      // still be waiting to be shown in another location at this time\n      hideTooltipTimeoutRef.current = undefined;\n      setTooltipText(undefined);\n      tooltipAnchorRef.current = undefined;\n      tooltipCellRef.current = undefined;\n    }, TABLE_HIDE_TOOLTIP_DELAY);\n  }, []);\n\n  // callback method to signal a tooltip is desired on the given cell\n  const showTooltip = useCallback(\n    (anchorCell: Cell<K, C>) => {\n      if (cellComparator(tooltipCellRef.current, anchorCell)) {\n        // if the tooltip is already showing in the right cell, clear all timeouts\n        if (showTooltipTimeoutRef.current != null) {\n          _clearShowTooltipTimeout();\n        }\n        if (hideTooltipTimeoutRef.current != null) {\n          _clearHideTooltipTimeout();\n        }\n        return;\n      }\n      if (showTooltipTimeoutRef.current == null) {\n        // if no tooltip is already pending, start a new tooltip timeout\n        pendingShowTooltipCellRef.current = anchorCell;\n        _setupShowTooltipTimeout();\n      } else if (!cellComparator(pendingShowTooltipCellRef.current, anchorCell)) {\n        // if a different tooltip is already pending, start a new tooltip timeout\n        _clearShowTooltipTimeout();\n        pendingShowTooltipCellRef.current = anchorCell;\n        _setupShowTooltipTimeout();\n      }\n      if (tooltipCellRef.current != null && hideTooltipTimeoutRef.current == null) {\n        // if the tooltip is showing on a different cell, ensure a hide timeout is setup\n        _setupHideTooltipTimeout();\n      }\n    },\n    [\n      _setupShowTooltipTimeout,\n      _setupHideTooltipTimeout,\n      _clearShowTooltipTimeout,\n      _clearHideTooltipTimeout\n    ]\n  );\n\n  // callback method to signal the current tooltip is no longer desired\n  const hideTooltip = useCallback(\n    (isImmediate?: boolean) => {\n      // ignore hide tooltip calls if due to focus loss from a pointer down on the tooltip itself\n      if (pointerDownRef.current) {\n        return;\n      }\n      if (showTooltipTimeoutRef.current != null) {\n        _clearShowTooltipTimeout();\n      }\n      if (isImmediate) {\n        if (hideTooltipTimeoutRef.current != null) {\n          _clearHideTooltipTimeout();\n        }\n        setTooltipText(undefined);\n        tooltipAnchorRef.current = undefined;\n        tooltipCellRef.current = undefined;\n      } else if (hideTooltipTimeoutRef.current == null) {\n        _setupHideTooltipTimeout();\n      }\n    },\n    [_setupHideTooltipTimeout, _clearShowTooltipTimeout, _clearHideTooltipTimeout]\n  );\n\n  // Pointer move handler for the tooltip.\n  const _pointerMoveHandler = useCallback((_event: PointerEvent) => {\n    if (showTooltipTimeoutRef.current != null) {\n      clearTimeout(showTooltipTimeoutRef.current);\n      showTooltipTimeoutRef.current = undefined;\n      pendingShowTooltipCellRef.current = undefined;\n    }\n    if (hideTooltipTimeoutRef.current != null) {\n      clearTimeout(hideTooltipTimeoutRef.current);\n      hideTooltipTimeoutRef.current = undefined;\n    }\n  }, []);\n\n  // Pointer leave handler for the tooltip.\n  const _pointerLeaveHandler = useCallback(\n    (event: PointerEvent) => {\n      const targetElement = event.relatedTarget as HTMLElement;\n      if (targetElement != null && targetElement.closest(`#${tableId}`) != null) {\n        return;\n      }\n      hideTooltip();\n    },\n    [tableId, hideTooltip]\n  );\n\n  // Pointer down handler for the tooltip.\n  const _pointerDownHandler = useCallback((_event: PointerEvent) => {\n    pointerDownRef.current = true;\n    if (pointerDownTimeoutRef.current != null) {\n      clearTimeout(pointerDownTimeoutRef.current);\n    }\n    pointerDownTimeoutRef.current = setTimeout(function () {\n      pointerDownRef.current = false;\n      pointerDownTimeoutRef.current = undefined;\n    }, SMALL_INTERACTION_DELAY);\n  }, []);\n\n  // handles logic involving competing tooltips managed outside of the TableView.\n  // make sure this check runs BEFORE the rendered content is created below\n  const isOpenOverrideRef = useRef<boolean>(true);\n  if (tooltipText != null && tooltipText !== tooltipTextRef.current) {\n    isOpenOverrideRef.current = true;\n  }\n\n  const tooltipPointerProps = {\n    onPointerLeave: _pointerLeaveHandler,\n    onPointerMove: _pointerMoveHandler,\n    onPointerDown: _pointerDownHandler\n  };\n\n  // avoid applying undefined text after initial render completes as it can appear\n  // while the tooltip is going through its closing animation and looks broken\n  const renderRawContent = (\n    <TooltipContent\n      {...tooltipPointerProps}\n      id={tooltipId}\n      isOpen={isOpenOverrideRef.current}\n      isDatatip={false}>\n      {tooltipText != null ? tooltipText : tooltipTextRef.current}\n    </TooltipContent>\n  );\n\n  // make sure these are in sync AFTER the rendered content is created above - this helps ensure\n  // that empty text does not show up while the tooltip is going through a closing animation.\n  tooltipTextRef.current = tooltipText;\n\n  // offsets attempt to show the tooltip without overlapping content of nearby cells\n  const scale = useScale();\n  let mainAxisOffset = -8;\n  let crossAxisOffset = -14;\n  if (scale === 'md') {\n    mainAxisOffset = -7;\n    crossAxisOffset = -12;\n  } else if (scale === 'sm') {\n    mainAxisOffset = -6;\n    crossAxisOffset = -11;\n  }\n  const currentColorScheme = useColorScheme();\n  const tooltipContent =\n    tooltipAnchorRef.current != null\n      ? getWrappedTooltipContent(\n          renderRawContent,\n          'tooltip',\n          currentColorScheme,\n          tooltipAnchorRef as RefObject<HTMLElement>,\n          'end-top',\n          { mainAxis: mainAxisOffset, crossAxis: crossAxisOffset }\n        )\n      : undefined;\n\n  const destroyCallback = useCallback(() => {\n    hideTooltip(true);\n  }, [hideTooltip]);\n\n  useEffect(() => {\n    if (isOpenOverrideRef.current && tooltipAnchorRef.current != null) {\n      globalTooltipManager.register(destroyCallback);\n    } else {\n      globalTooltipManager.unregister(destroyCallback);\n    }\n  }, [tooltipAnchorRef, destroyCallback, tooltipText, globalTooltipManager]);\n\n  return { tooltipContent, tooltipId, showTooltip, hideTooltip, tooltipAnchorRef };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useEffect, useMemo, useRef, useState, MutableRef } from 'preact/hooks';\nimport {\n  getElementContainsFunc,\n  handleEnterActionableMode,\n  handleWrapActionableFocus\n} from '../../utils/PRIVATE_collectionUtils';\nimport {\n  FocusableElement,\n  allTabbableElements,\n  getActiveElement,\n  getBodyElement,\n  isTabbableElement\n} from '../../utils/PRIVATE_tabbableUtils';\nimport type { FocusGuardCallbackDetail } from '../../PRIVATE_FocusTracker';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  AppliedColumnWidths,\n  CurrencyStatus,\n  ScrollDetail,\n  SizingInfo,\n  StickyColumnInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport {\n  getCellType,\n  getElementFromCell,\n  isAutoFocusCell,\n  logicalCellExtractor\n} from '../utils/TableDomUtils';\nimport {\n  applyCurrentCellOverride,\n  cellComparator,\n  determineActiveCell,\n  isTransientCell\n} from '../utils/TableFocusUtils';\nimport { applyScrollDetail } from '../utils/TableScrollUtils';\nimport { handleNavigationTooltipGesture } from '../utils/TableTooltipUtils';\nimport { Cell, CellOverride, CurrentCellDetail } from '../../UNSAFE_TableView';\n\ntype UseFocusHandlingProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  hasMore: boolean;\n  hasFooters: boolean;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  stickyColumnInfo: StickyColumnInfo;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  cellSupportsTabbable: (cell: ActiveCell<K, C>) => boolean;\n  appliedColumnWidths?: AppliedColumnWidths<C>;\n  currentCellOverride?: CellOverride<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n  showTooltip: (cell: Cell<K, C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n  isPendingLayout: boolean;\n  isEmbeddedSelect: boolean;\n  isDataLoaded: boolean;\n};\n\n// constant timeout values for delays following a input gesture until enabling focus rings\nconst MOUSE_FOCUS_SHIFT_TIMEOUT = 100;\nconst TOUCH_FOCUS_SHIFT_TIMEOUT = 200;\n\n// constant event.key values that trigger focus ring logic\nconst NAVIGATION_KEYS = [\n  ' ',\n  'F2',\n  'Enter',\n  'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n  'Escape',\n  'ArrowLeft',\n  'ArrowUp',\n  'ArrowRight',\n  'ArrowDown',\n  'Home',\n  'End',\n  'PageUp',\n  'PageDown'\n];\n\n// constant event.key values that trigger 'scroll to current' logic\nconst SCROLL_KEYS = [\n  ' ',\n  'F2',\n  'Enter',\n  'Esc', // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n  'Escape'\n];\n\n/**\n * Hook that manages focus interactions on the Preact Table\n */\nexport function useFocusHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  isRtl,\n  tableData,\n  hasMore,\n  hasFooters,\n  columnsArray,\n  stickyColumnInfo,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  cellSupportsTabbable,\n  appliedColumnWidths,\n  currentCellOverride,\n  onPersistCurrentCell,\n  showTooltip,\n  hideTooltip,\n  isPendingLayout,\n  isEmbeddedSelect,\n  isDataLoaded\n}: UseFocusHandlingProps<K, D, C>) {\n  // tracks whether the most recent 'blur' was caused by focus being lost by the browser window (or iframe)\n  const blurFromWindowRef = useRef<boolean>(false);\n\n  // tracks focus loss during render cycle for potential focus recapture cases\n  const isRenderCycle = useRef<boolean>(true);\n  isRenderCycle.current = true;\n  const blurredRenderCycleElementRef = useRef<FocusableElement | null>(null);\n  const isPendingLayoutFocusRef = useRef<boolean>(false);\n\n  // track current 'focus info' state\n  const hasFocusRef = useRef<boolean>(false);\n  const [isTabbableMode, setIsTabbableMode] = useState<boolean>(false);\n  const [isShowFocusRing, setIsShowFocusRing] = useState<boolean>(false);\n\n  // track pointer down information\n  const recentPointerRef = useRef<boolean>(false);\n  const pointerTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const isShowFocusRingOverrideRef = useRef<boolean | null>(null);\n\n  // track the active and current cell information\n  const [activeCell, setActiveCell] = useState<ActiveCell<K, C> | undefined>(undefined);\n  const currencyStatusRef = useRef<CurrencyStatus<K, D, C>>({\n    hasPendingCurrentCellOverride: false,\n    hasPendingCurrentCellOverrideScroll: false\n  });\n\n  // track pending scrolls to minimize 'flash' of focus rings when scrolling\n  const [deferredScrollDetail, setDeferredScrollDetail] = useState<ScrollDetail<K, C> | undefined>(\n    undefined\n  );\n  const deferredScrollDetailRef = useRef<ScrollDetail<K, C>>();\n\n  // keep state and ref in-sync to avoid edge cases where a gesture updating the scroll detail is handled\n  // inbetween a render cycle that changes the scroll detail and the useEffect that applies the detail\n  const updateDeferredScrollDetail = useCallback((scrollDetail: ScrollDetail<K, C>) => {\n    setDeferredScrollDetail(scrollDetail);\n    deferredScrollDetailRef.current = scrollDetail;\n  }, []);\n\n  const wasTransient = isTransientCell(currencyStatusRef.current.activeCell);\n  const currentActiveCell = determineActiveCell<K, D, C>(\n    columnsArray,\n    currencyStatusRef,\n    tableData,\n    hasMore,\n    isPendingLayout,\n    isEmbeddedSelect,\n    hasFooters,\n    currentCellOverride\n  );\n\n  // intercept onPersistCurrentCell calls to ensure internal state is updated appropriately\n  const onActiveCellChanged = useMemo(() => {\n    return (\n      detail: ActiveCellDetail<K, C>,\n      isAutoFocus?: boolean,\n      isSelectionExtension?: boolean,\n      skipScrollCellIntoView?: boolean\n    ) => {\n      const newActiveCell = detail.value;\n      if (!cellComparator(currencyStatusRef.current.activeCell, newActiveCell)) {\n        setActiveCell(newActiveCell);\n        currencyStatusRef.current.activeCell = newActiveCell;\n        if (!isTransientCell(newActiveCell)) {\n          const newCurrentCell = newActiveCell as Cell<K, C>;\n          // only update current cell when 'active' is not one of the transient 'skeleton' regions\n          if (onPersistCurrentCell != null) {\n            onPersistCurrentCell({ value: newCurrentCell });\n          }\n          currencyStatusRef.current.currentCell = newCurrentCell;\n\n          // make sure pending current cell override states are updated on current changed\n          if (newCurrentCell != null) {\n            currencyStatusRef.current.previousEmbeddedSelectCurrentCell = newCurrentCell;\n          }\n          currencyStatusRef.current.currentCellOverride = currentCellOverride;\n          currencyStatusRef.current.hasPendingCurrentCellOverride = false;\n          currencyStatusRef.current.hasPendingCurrentCellOverrideScroll = false;\n        } else if (newActiveCell?.type === 'loadMore') {\n          currencyStatusRef.current.loadMoreInitialData = tableData;\n        }\n        if (!isSelectionExtension) {\n          selectionExtensionElementRef.current = undefined;\n          if (isAutoFocus && newActiveCell != null && cellSupportsTabbable(newActiveCell)) {\n            // attempt to auto-focus cell contents\n            setIsTabbableMode(true);\n            setIsShowFocusRing(false);\n          } else if (isTabbableMode) {\n            // exit tabbable mode when navigating away from auto-focus cell\n            setIsTabbableMode(false);\n          }\n        }\n      }\n      if (newActiveCell != null && !recentPointerRef.current && !skipScrollCellIntoView) {\n        updateDeferredScrollDetail({\n          cell: newActiveCell,\n          locationX: 'inView',\n          locationY: 'inView'\n        });\n      }\n    };\n  }, [\n    currentCellOverride,\n    isTabbableMode,\n    cellSupportsTabbable,\n    tableData,\n    onPersistCurrentCell,\n    selectionExtensionElementRef,\n    updateDeferredScrollDetail\n  ]);\n\n  // Helper function to set the Table's focus tracking state to reflect that it is inactive.\n  const _setAsInactive = useCallback(() => {\n    hasFocusRef.current = false;\n    isPendingLayoutFocusRef.current = false;\n\n    setIsTabbableMode(false);\n    setIsShowFocusRing(false);\n    hideTooltip();\n  }, [hideTooltip]);\n\n  // Helper function to set the Table's focus tracking state to reflect that one of its cells has focus.\n  const _enableNavigationMode = useCallback(\n    (cell: ActiveCell<K, C>, skipScrollCellIntoView?: boolean) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        setIsTabbableMode(false);\n        const focusRingState =\n          isShowFocusRingOverrideRef.current !== null\n            ? isShowFocusRingOverrideRef.current\n            : !recentPointerRef.current;\n        setIsShowFocusRing(focusRingState);\n        if (focusRingState) {\n          handleNavigationTooltipGesture(rootElement, tableId, cell, showTooltip, hideTooltip);\n        }\n        onActiveCellChanged({ value: cell }, false, false, skipScrollCellIntoView);\n      }\n    },\n    [rootRef, viewportInfo, tableId, onActiveCellChanged, showTooltip, hideTooltip]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that it is tabbable.\n  const _enableTabbableMode = useCallback(\n    (cell: ActiveCell<K, C>, isKeyboard?: boolean, skipScrollCellIntoView?: boolean) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        setIsTabbableMode(true);\n        if (!isKeyboard) {\n          setIsShowFocusRing(false);\n          onActiveCellChanged({ value: cell }, true, false, skipScrollCellIntoView);\n        }\n      }\n    },\n    [rootRef, viewportInfo, onActiveCellChanged]\n  );\n\n  // Helper function to set the Table's focus tracking state to reflect that a user has\n  // exited tabbable mode via the keyboard (esc or 'F2')\n  const _disableTabbableMode = useCallback(\n    (cell: ActiveCell<K, C>) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        setIsTabbableMode(false);\n        const cellElement = getElementFromCell(rootElement, tableId, cell);\n        if (cellElement != null) {\n          cellElement.focus({ preventScroll: true });\n        } else {\n          rootElement.focus({ preventScroll: true });\n        }\n      }\n    },\n    [rootRef, tableId]\n  );\n\n  const notifyFocusFromPointer = useCallback((isTouch: boolean) => {\n    if (pointerTimerRef.current != null) {\n      clearTimeout(pointerTimerRef.current);\n    }\n    recentPointerRef.current = true;\n    pointerTimerRef.current = setTimeout(\n      () => {\n        recentPointerRef.current = false;\n      },\n      isTouch ? TOUCH_FOCUS_SHIFT_TIMEOUT : MOUSE_FOCUS_SHIFT_TIMEOUT\n    );\n  }, []);\n\n  // PointerDown handler for the outer Table. Focus transfers that occur following a pointerdown\n  // on desktop devices should not result in a focus ring being shown on the focused element\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      if (isShowFocusRing) {\n        setIsShowFocusRing(false);\n      }\n      if (event.pointerType !== 'touch') {\n        notifyFocusFromPointer(false);\n      }\n    },\n    [isShowFocusRing, notifyFocusFromPointer]\n  );\n\n  // PointerUp handler for the outer Table. Focus transfers that occur following a pointerup\n  // on any type of device should not result in a focus ring being shown on the focused element\n  const _pointerUpHandler = useCallback(\n    (event: PointerEvent) => {\n      notifyFocusFromPointer(event.pointerType === 'touch');\n    },\n    [notifyFocusFromPointer]\n  );\n\n  // Focus handler for the outer Table. On focus, a focusable area needs to be 'active'.\n  // If an 'active' area already exists, nothing further is needed. Otherwise, the first\n  // focusable element should be made 'active'.\n  const _onFocusHandler = (event: FocusEvent) => {\n    hasFocusRef.current = true;\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (rootElement != null) {\n      // don't scroll active into view if previous blur was due to window focus loss\n      const skipScrollCellIntoView = blurFromWindowRef.current || isPendingLayout;\n      blurFromWindowRef.current = false;\n\n      const targetElement = event.target as HTMLElement;\n      if (targetElement === rootElement || targetElement === scrollerElement) {\n        if (currentActiveCell != null) {\n          _enableNavigationMode(currentActiveCell, skipScrollCellIntoView);\n        }\n      } else {\n        const cell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n        if (cell != null) {\n          if (getCellType(targetElement) != null) {\n            // handle individual focusable regions receiving focus\n            _enableNavigationMode(cell, skipScrollCellIntoView);\n          } else {\n            _enableTabbableMode(cell, false, skipScrollCellIntoView);\n          }\n        }\n      }\n    }\n    isShowFocusRingOverrideRef.current = null;\n  };\n\n  // Blur handler for the outer Table. When a blur is caused by the browser window itself\n  // losing focus (changing tabs or leaving an iframe for example), an eventual re-focus due\n  // to the window re-gaining focus needs to be handled differently (no auto-scroll mostly).\n  const _onBlurHandler = useCallback(\n    (event: FocusEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        if (event.target === document.activeElement) {\n          // save focus ring state so it's set once focus comes back\n          isShowFocusRingOverrideRef.current = isShowFocusRing;\n        }\n        const relatedTarget = event.relatedTarget as Element;\n        const isUnknownRelatedTarget = relatedTarget == null;\n        blurFromWindowRef.current = isUnknownRelatedTarget;\n        if (isUnknownRelatedTarget || !getElementContainsFunc(rootElement, true)(relatedTarget)) {\n          _setAsInactive();\n          if (isRenderCycle.current) {\n            // store element that loses focus during a render cycle for recapturing focus logic\n            blurredRenderCycleElementRef.current = event.target as FocusableElement;\n          }\n        }\n      }\n    },\n    [rootRef, isShowFocusRing, _setAsInactive]\n  );\n\n  // KeyDown handler for the outer Table. This specific handler tracks 'focus' transfer keys\n  // Esc, F2, Enter, and Tab. It also ensures the active cell is scrolled into view on any key\n  const _onKeyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        const isNavigationKey = NAVIGATION_KEYS.indexOf(event.key) > -1;\n        if (isNavigationKey) {\n          if (pointerTimerRef.current != null) {\n            clearTimeout(pointerTimerRef.current);\n          }\n          pointerTimerRef.current = null;\n          recentPointerRef.current = false;\n        }\n        if (isPendingLayout) {\n          if (isNavigationKey) {\n            setIsShowFocusRing(true);\n          }\n        } else if (activeCell != null) {\n          if (cellSupportsTabbable(activeCell)) {\n            if (event.key === 'F2') {\n              if (isTabbableMode) {\n                _disableTabbableMode(activeCell);\n              } else {\n                _enableTabbableMode(activeCell, true);\n              }\n            } else if (event.key === 'Esc' || event.key === 'Escape') {\n              // Firefox 36 and earlier uses 'Esc' instead of 'Escape'\n              _disableTabbableMode(activeCell);\n            } else if (event.key === 'Enter' && !isTabbableMode) {\n              _enableTabbableMode(activeCell, true);\n            }\n          }\n          if (!isTabbableMode) {\n            if (isNavigationKey) {\n              setIsShowFocusRing(true);\n            }\n            if (SCROLL_KEYS.indexOf(event.key) > -1) {\n              updateDeferredScrollDetail({\n                cell: activeCell,\n                locationX: 'inView',\n                locationY: 'inView'\n              });\n            }\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      isTabbableMode,\n      activeCell,\n      cellSupportsTabbable,\n      isPendingLayout,\n      _enableTabbableMode,\n      _disableTabbableMode,\n      updateDeferredScrollDetail\n    ]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onStartFocusTracking = useCallback(\n    (detail: {\n      activeElement: FocusableElement;\n      hasFocusWithin: boolean;\n      tabbableElements: FocusableElement[];\n    }) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null && activeCell != null) {\n        handleEnterActionableMode(\n          detail.hasFocusWithin && getCellType(detail.activeElement) == null,\n          allTabbableElements(\n            getElementFromCell(rootElement, tableId, activeCell) as FocusableElement\n          ),\n          (value?: ActiveCell<K, D>) => {\n            setIsTabbableMode(value != undefined);\n          }\n        );\n      }\n    },\n    [rootRef, activeCell, tableId]\n  );\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusStartEdge = useCallback((detail: FocusGuardCallbackDetail) => {\n    handleWrapActionableFocus(true, detail.tabbableElements, (value?: ActiveCell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Callback for the outer Table's FocusTracker usage.\n  const onFocusEndEdge = useCallback((detail: FocusGuardCallbackDetail) => {\n    handleWrapActionableFocus(false, detail.tabbableElements, (value?: ActiveCell<K, D>) => {\n      setIsTabbableMode(value != undefined);\n    });\n  }, []);\n\n  // Ensure focus is properly set at the completion of every render cycle\n  // NO DEPENDENCY ARRAY HERE TO ENSURE THIS RUNS ON EVERY RENDER CYCLE\n  useEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (rootElement != null && scrollerElement != null) {\n      // internal method responsible for ensuring focus is applied to the appropriate cells or contents\n      const _applyInternalFocus = (\n        rootElement: HTMLDivElement,\n        activeElement: FocusableElement,\n        isCaptureFocus?: boolean\n      ) => {\n        if (currentActiveCell != null) {\n          // ensure real browser focus is on the correct cell element\n          const cellElement = getElementFromCell(rootElement, tableId, currentActiveCell);\n          if (cellElement != null) {\n            // cell is valid, so set focus on it if needed\n            if (!isTabbableMode && activeElement !== cellElement) {\n              if (\n                wasTransient &&\n                !isTransientCell(currentActiveCell) &&\n                isAutoFocusCell(rootElement, tableId, currentActiveCell) &&\n                cellSupportsTabbable(currentActiveCell)\n              ) {\n                _enableTabbableMode(currentActiveCell);\n              } else {\n                cellElement.focus({ preventScroll: true });\n              }\n              return;\n            } else if (\n              isTabbableMode &&\n              !getElementContainsFunc(cellElement, true)(activeElement)\n            ) {\n              handleEnterActionableMode(\n                false,\n                allTabbableElements(cellElement),\n                (value?: ActiveCell<K, D>) => {\n                  setIsTabbableMode(value != undefined);\n                  if (isCaptureFocus) {\n                    rootElement.focus({ preventScroll: true });\n                  }\n                },\n                true\n              );\n              return;\n            }\n          }\n        }\n        if (isCaptureFocus) {\n          rootElement.focus({ preventScroll: true });\n        }\n      };\n\n      // ensure the current cell is scrolled into view when necessary\n      // only run if the state and ref match - otherwise another render cycle may be pending\n      if (\n        deferredScrollDetail != null &&\n        deferredScrollDetail === deferredScrollDetailRef.current\n      ) {\n        applyScrollDetail(\n          rootElement,\n          scrollerElement,\n          viewportInfo,\n          tableId,\n          columnsArray,\n          stickyColumnInfo,\n          sizingInfoRef.current,\n          deferredScrollDetail,\n          isRtl,\n          appliedColumnWidths\n        );\n        deferredScrollDetailRef.current = undefined;\n      }\n\n      // ensure current-cell-override is up to date on each render\n      applyCurrentCellOverride(\n        rootElement,\n        scrollerElement,\n        viewportInfo,\n        tableId,\n        tableData,\n        columnsArray,\n        stickyColumnInfo,\n        sizingInfoRef,\n        currencyStatusRef,\n        onActiveCellChanged,\n        isEmbeddedSelect,\n        isPendingLayout,\n        isDataLoaded,\n        isRtl,\n        currentCellOverride,\n        appliedColumnWidths\n      );\n\n      const blurredRenderCycleElement = blurredRenderCycleElementRef.current;\n      blurredRenderCycleElementRef.current = null;\n      isRenderCycle.current = false;\n\n      const activeElement = getActiveElement(rootElement);\n      // if we were tracking focus during the render cycle, ensure we recapture focus if needed\n      if (\n        blurredRenderCycleElement != null &&\n        activeElement === getBodyElement(rootElement) &&\n        (!getElementContainsFunc(rootElement, true)(blurredRenderCycleElement) ||\n          !isTabbableElement(blurredRenderCycleElement, true))\n      ) {\n        _applyInternalFocus(rootElement, activeElement, true);\n      } else if (\n        hasFocusRef.current &&\n        cellComparator(activeCell, currencyStatusRef.current.activeCell)\n      ) {\n        _applyInternalFocus(rootElement, activeElement);\n      }\n    }\n  });\n\n  return {\n    focusHandlingProps: {\n      onPointerDown: _pointerDownHandler,\n      onPointerUp: _pointerUpHandler,\n      onFocus: _onFocusHandler,\n      onBlur: _onBlurHandler,\n      onKeyDown: _onKeyDownHandler\n    },\n    activeCell,\n    onActiveCellChanged,\n    currentCell: currencyStatusRef.current.currentCell,\n    currentActiveCell,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    updateDeferredScrollDetail\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { getRowIndexForRowElement, getElementFromCell } from './TableDomUtils';\nimport { ActiveCell, TableColumn, TableData } from '../Table';\nimport { RowActionDetail, SortCriterionDetail } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to get the row action context from a pointer or keyboard event\n */\nfunction _getRowActionGestureContext<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  targetElement: HTMLElement,\n  targetCell?: ActiveCell<K, C>\n) {\n  let rowKey: K | null;\n  let rowElement;\n  if (targetCell?.type === 'data') {\n    rowKey = targetCell.rowKey;\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (targetCellElement != null) {\n      rowElement = targetCellElement.parentElement;\n    }\n  } else {\n    rowKey = keyExtractor<K>(targetElement, `[data-oj-table-data-row='${tableId}']`);\n    if (rowKey != null) {\n      rowElement = targetElement.closest(`[data-oj-table-data-row='${tableId}']`);\n    }\n  }\n  if (rowKey != null && rowElement != null) {\n    const rowIndex = getRowIndexForRowElement(rootElement, tableId, rowElement as HTMLElement);\n    if (rowIndex != null) {\n      return {\n        key: rowKey,\n        data: tableData[rowIndex].data\n      };\n    }\n  }\n  return undefined;\n}\n\n/**\n * Helper function to handle a row action gesture from a pointer or keyboard event\n */\nexport function handleRowActionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  tableData: TableData<K, D>[],\n  onRowAction: (detail: RowActionDetail<K, D>) => void,\n  targetElement: HTMLElement,\n  targetCell?: ActiveCell<K, C>\n) {\n  const rowActionContext = _getRowActionGestureContext(\n    rootElement,\n    tableId,\n    tableData,\n    targetElement,\n    targetCell\n  );\n  if (rowActionContext != null) {\n    onRowAction({ context: rowActionContext, target: targetElement });\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper function to determine if a pointer or keyboard event should trigger a sort action gesture\n */\nfunction _isSortActionGesture<K, D, C>(columnsArray: TableColumn<K, D, C>[], columnKey: C) {\n  for (const column of columnsArray) {\n    if (column.key === columnKey) {\n      return column.value.sortable === 'enabled';\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a sort action gesture\n */\nexport function handleSortActionGesture<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  columnKey: C,\n  onSortCriterionChange: (detail: SortCriterionDetail<C>) => void,\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[]\n) {\n  if (_isSortActionGesture(columnsArray, columnKey)) {\n    let sortDirection;\n    if (sortCriterion != null) {\n      for (const criterion of sortCriterion) {\n        if (criterion.key === columnKey) {\n          sortDirection = criterion.sortDirection;\n          break;\n        }\n      }\n    }\n    const newDirection = sortDirection === 'ascending' ? 'descending' : 'ascending';\n    onSortCriterionChange([{ key: columnKey, sortDirection: newDirection }]);\n    return true;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { Dispatch, StateUpdater } from 'preact/hooks';\nimport { ActiveCell, ColumnHeaderFooterInfo } from '../Table';\nimport { getCellType, getColumnKey } from './TableDomUtils';\n\n/**\n * Helper function to handle a hover gesture over a column header or footer region.\n */\nexport function handleOverColumnHeaderFooterGesture<C>(\n  tableId: string,\n  event: PointerEvent,\n  setHoverStyleColumnInfo: Dispatch<StateUpdater<ColumnHeaderFooterInfo<C> | undefined>>,\n  hoverStyleColumnInfo?: ColumnHeaderFooterInfo<C>\n) {\n  // only track 'hover' information for mouse events\n  if (event.pointerType === 'mouse') {\n    const cellElement = (event.target as HTMLElement).closest(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'header' || cellType === 'footer') {\n        const isHeader = cellType === 'header';\n        const columnKey = getColumnKey<C>(cellElement);\n        if (\n          columnKey !== hoverStyleColumnInfo?.key ||\n          !hoverStyleColumnInfo?.isHeader !== isHeader\n        ) {\n          setHoverStyleColumnInfo({ key: columnKey, isHeader: cellType === 'header' });\n          return;\n        }\n      }\n    }\n  }\n  handleEndInteractionColumnHeaderFooterGesture(setHoverStyleColumnInfo, hoverStyleColumnInfo);\n}\n\n/**\n * Helper function to handle an active gesture over a column header or footer region.\n */\nexport function handleActiveColumnHeaderFooterGesture<K, C>(\n  tableId: string,\n  event: KeyboardEvent | PointerEvent,\n  setActiveStyleColumnInfo: Dispatch<StateUpdater<ColumnHeaderFooterInfo<C> | undefined>>,\n  activeStyleColumnInfo?: ColumnHeaderFooterInfo<C>,\n  activeCell?: ActiveCell<K, C>\n) {\n  let cellType;\n  let columnKey;\n  if (activeCell != null) {\n    cellType = activeCell.type;\n    columnKey = activeCell.columnKey;\n  } else if (event instanceof PointerEvent && event.pointerType === 'touch') {\n    // only handle touch events since hover events have the same treatment\n    const cellElement = (event.target as HTMLElement).closest(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (cellElement != null) {\n      cellType = getCellType(cellElement);\n      columnKey = getColumnKey<C>(cellElement);\n    }\n  }\n  if (columnKey != null && (cellType === 'header' || cellType === 'footer')) {\n    const isHeader = cellType === 'header';\n    if (columnKey !== activeStyleColumnInfo?.key || !activeStyleColumnInfo?.isHeader !== isHeader) {\n      setActiveStyleColumnInfo({ key: columnKey, isHeader: cellType === 'header' });\n      return;\n    }\n  }\n  handleEndInteractionColumnHeaderFooterGesture(setActiveStyleColumnInfo, activeStyleColumnInfo);\n}\n\n/**\n * Helper function to handle the end of an interaction style gesture for the table region.\n */\nexport function handleEndInteractionColumnHeaderFooterGesture<C>(\n  setInteractionStyleColumnInfo: Dispatch<StateUpdater<ColumnHeaderFooterInfo<C> | undefined>>,\n  interactionStyleColumnInfo?: ColumnHeaderFooterInfo<C>\n) {\n  if (interactionStyleColumnInfo != null) {\n    setInteractionStyleColumnInfo(undefined);\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { ActiveCell, ActiveCellDetail, ScrollDetail, SizingInfo, TableColumn } from '../Table';\nimport {\n  getBoundaryColumnKey,\n  getElementFromCell,\n  getFirstFocusableRowKey,\n  getLastFocusableRowKey,\n  getRowKey,\n  hasFooterCells,\n  hasNoDataCell,\n  isAutoFocusCell,\n  getScrollerBottomOffset,\n  getRowKeyForRowIndex,\n  getRowIndexForRowKey\n} from './TableDomUtils';\nimport { cellComparator } from './TableFocusUtils';\nimport { getVerticalScrollPosition } from './TableScrollUtils';\nimport { findElementByKey } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle an 'Up' or 'Down' arrow key press.\n * Up - Moves to the same cell in the previous row (including headers and footers). No op if already on the first row.\n * Down - Moves to the same cell in the next row (including headers and footers). No op if already on the last row.\n */\nexport function handleAdjacentRowGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (\n    detail: ActiveCellDetail<K, C>,\n    isAutoFocus?: boolean,\n    isSelectionExtension?: boolean,\n    skipScrollCellIntoView?: boolean\n  ) => void,\n  isPrevious: boolean,\n  isExtendSelectionGesture: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  updateDeferredScrollDetail: (scrollDetail: ScrollDetail<K, C>) => void\n) {\n  const firstColumnKey = getBoundaryColumnKey<K, D, C>(columnsArray, true);\n  if (firstColumnKey == null) {\n    return;\n  }\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'noData') {\n    const newColumnKey = firstColumnKey;\n    if (isPrevious) {\n      newCell = { columnKey: newColumnKey, type: 'header' };\n      onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: newColumnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n    }\n  } else if (cellType === 'loading') {\n    if (isPrevious) {\n      newCell = { columnKey: initialCell.columnKey, type: 'header' };\n      onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n    }\n  } else if (cellType === 'loadMore') {\n    if (isPrevious) {\n      const rowKey = getLastFocusableRowKey<K>(rootElement, tableId);\n      if (rowKey != null) {\n        newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n      }\n    } else if (hasFooterCells(rootElement, tableId)) {\n      newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n      onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n    }\n  } else if (cellType !== 'pending') {\n    if (cellType === 'data') {\n      const currentRowKey = initialCell.rowKey;\n      const currentRowElement = findElementByKey(\n        rootElement,\n        currentRowKey,\n        `[data-oj-table-data-row='${tableId}']`\n      );\n      if (currentRowElement != null) {\n        const adjacentRowElement = isPrevious\n          ? (currentRowElement.previousElementSibling as HTMLElement)\n          : (currentRowElement.nextElementSibling as HTMLElement);\n        // if adjacent row has no children, it is the 'buffer' row used for height sizing\n        if (adjacentRowElement != null && adjacentRowElement.children.length > 0) {\n          const rowKey = getRowKey<K>(adjacentRowElement);\n          if (rowKey != null) {\n            newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n            onActiveCellChanged(\n              { value: newCell },\n              isAutoFocusCell(rootElement, tableId, newCell),\n              isExtendSelectionGesture\n            );\n          } else if (!isExtendSelectionGesture) {\n            newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };\n            if (getElementFromCell(rootElement, tableId, newCell) != null) {\n              onActiveCellChanged(\n                { value: newCell },\n                isAutoFocusCell(rootElement, tableId, newCell)\n              );\n            }\n          }\n        } else if (!isExtendSelectionGesture && isPrevious) {\n          newCell = { columnKey: initialCell.columnKey, type: 'header' };\n          onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n        } else if (!isExtendSelectionGesture && hasFooterCells(rootElement, tableId)) {\n          newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n          onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n        }\n      }\n    } else if (cellType === 'header' && !isPrevious) {\n      const rowKey = getFirstFocusableRowKey<K>(rootElement, tableId);\n      if (rowKey != null) {\n        newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n      } else if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n      } else {\n        newCell = { columnKey: initialCell.columnKey, type: 'loading' };\n        if (getElementFromCell(rootElement, tableId, newCell) != null) {\n          onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n        } else if (hasFooterCells(rootElement, tableId)) {\n          newCell = { columnKey: initialCell.columnKey, type: 'footer' };\n          onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n        }\n      }\n    } else if (cellType === 'footer' && isPrevious) {\n      if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n      } else {\n        newCell = { columnKey: initialCell.columnKey, type: 'loading' };\n        if (getElementFromCell(rootElement, tableId, newCell) != null) {\n          onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n        } else {\n          newCell = { columnKey: initialCell.columnKey, type: 'loadMore' };\n          if (getElementFromCell(rootElement, tableId, newCell) != null) {\n            onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n          } else {\n            const rowKey = getLastFocusableRowKey<K>(rootElement, tableId);\n            if (rowKey != null) {\n              newCell = { rowKey: rowKey, columnKey: initialCell.columnKey, type: 'data' };\n              onActiveCellChanged(\n                { value: newCell },\n                isAutoFocusCell(rootElement, tableId, newCell)\n              );\n            } else {\n              newCell = { columnKey: initialCell.columnKey, type: 'header' };\n              onActiveCellChanged(\n                { value: newCell },\n                isAutoFocusCell(rootElement, tableId, newCell)\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  } else {\n    updateDeferredScrollDetail({ cell: newCell, locationX: 'inView', locationY: 'inView' });\n  }\n}\n\n/**\n * Helper function to handle a 'PageUp' or 'PageDown' arrow key press.\n * PageUp - Moves to the same cell in the first visible row in the current viewport,\n * and scrolls the Table so it becomes the last visible row in the viewport when able.\n * PageDown - Moves to the same cell in the last visible row in the current viewport,\n * and scrolls the Table so it becomes the first visible row in the viewport when able.\n */\nexport function handlePageRowGesture<K extends string | number, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  sizingInfoRef: MutableRef<SizingInfo>,\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (\n    detail: ActiveCellDetail<K, C>,\n    isAutoFocus?: boolean,\n    isSelectionExtension?: boolean,\n    skipScrollCellIntoView?: boolean\n  ) => void,\n  isPrevious: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  updateDeferredScrollDetail: (scrollDetail: ScrollDetail<K, C>) => void\n) {\n  if (initialCell.type !== 'noData' && initialCell.type !== 'pending') {\n    const rowElements = rootElement.querySelectorAll(`[data-oj-table-data-row='${tableId}']`);\n    if (rowElements.length > 0) {\n      const verticalScrollPosition = getVerticalScrollPosition(\n        rootElement,\n        scrollerElement,\n        tableId\n      );\n      const verticalRowIndex = getRowIndexForRowKey(\n        rootElement,\n        tableId,\n        verticalScrollPosition.rowKey!\n      );\n      let targetRowIndex;\n      if (isPrevious) {\n        if (verticalScrollPosition.offsetY === 0) {\n          targetRowIndex = Math.max(verticalRowIndex! - 1, 0);\n        } else {\n          targetRowIndex = verticalRowIndex!;\n        }\n      } else {\n        const scrollerRect = scrollerElement.getBoundingClientRect();\n        const scrollbarHeight =\n          sizingInfoRef.current.boxHeight! - sizingInfoRef.current.contentHeight!;\n        const scrollerBottom =\n          scrollerRect.bottom + getScrollerBottomOffset(rootElement, tableId) + scrollbarHeight;\n        targetRowIndex = verticalRowIndex!;\n        while (rowElements.length > targetRowIndex + 1) {\n          targetRowIndex += 1;\n          const elementBottom = rowElements[targetRowIndex].getBoundingClientRect().bottom;\n          if (elementBottom > scrollerBottom) {\n            break;\n          }\n        }\n      }\n      const newRowKey = getRowKeyForRowIndex<K>(rootElement, tableId, targetRowIndex);\n      if (newRowKey != null) {\n        const newCell: ActiveCell<K, C> = {\n          rowKey: newRowKey,\n          columnKey: initialCell.columnKey,\n          type: 'data'\n        };\n        if (newRowKey !== initialCell.rowKey) {\n          onActiveCellChanged(\n            { value: newCell },\n            isAutoFocusCell(rootElement, tableId, newCell),\n            false,\n            true\n          );\n        }\n        if (!cellComparator(initialCell, newCell)) {\n          hideTooltip(true);\n        }\n        updateDeferredScrollDetail({\n          cell: newCell,\n          locationX: 'inView',\n          locationY: isPrevious ? 'bottom' : 'top'\n        });\n      }\n    }\n  }\n}\n\n/**\n * Helper function to get the column key next to the given column key in the specified direction. Returns\n * null if there is no adjacent column in the direction specified.\n */\nfunction _getAdjacentColumnKey<K, D, C>(\n  initialKey: C,\n  columnsArray: TableColumn<K, D, C>[],\n  isPrevious: boolean\n) {\n  let currentIndex = -1;\n  const columnsCount = columnsArray.length;\n  for (let i = 0; i < columnsCount; i++) {\n    if (columnsArray[i].key === initialKey) {\n      currentIndex = i;\n      break;\n    }\n  }\n  if (isPrevious && currentIndex !== 0) {\n    return columnsArray[currentIndex - 1].key;\n  } else if (!isPrevious && currentIndex !== columnsCount - 1) {\n    return columnsArray[currentIndex + 1].key;\n  }\n  return undefined;\n}\n\n/**\n * Helper function to handle a 'Previous' or 'Next' arrow key press.\n * Previous - Moves to the previous cell in the current row. No op if already on the first cell in that row.\n * Next - Moves to the next cell in the current row. No op if already on the last cell in that row.\n */\nexport function handleAdjacentColumnGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (\n    detail: ActiveCellDetail<K, C>,\n    isAutoFocus?: boolean,\n    isSelectionExtension?: boolean,\n    skipScrollCellIntoView?: boolean\n  ) => void,\n  isPrevious: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  updateDeferredScrollDetail: (scrollDetail: ScrollDetail<K, C>) => void\n) {\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {\n    const initialKey = initialCell.columnKey;\n    const newKey = _getAdjacentColumnKey(initialKey, columnsArray, isPrevious);\n    if (newKey != null) {\n      if (cellType === 'data') {\n        newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n      } else {\n        newCell = { columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  } else {\n    updateDeferredScrollDetail({ cell: newCell, locationX: 'inView', locationY: 'inView' });\n  }\n}\n\n/**\n * Helper function to handle a 'Home' or 'End' key press.\n * Home - Jumps to the first cell in the current row. No op if already on the first cell in that row.\n * Ctrl/Cmd + Home - Jumps to the first cell in the first data row. If no data rows are present,\n * jumps to the first cell in the current region (header or footer). No op if already on that cell.\n * End - Jumps to the last cell in the current row. No op if already on the last cell in that row.\n * Ctrl/Cmd + End - Jumps to the last cell in the last data row. If no data rows are present,\n * jumps to the last cell in the current region (header or footer). No op if already on that cell.\n */\nexport function handleJumpColumnGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  initialCell: ActiveCell<K, C>,\n  onActiveCellChanged: (\n    detail: ActiveCellDetail<K, C>,\n    isAutoFocus?: boolean,\n    isSelectionExtension?: boolean,\n    skipScrollCellIntoView?: boolean\n  ) => void,\n  isPrevious: boolean,\n  includeRows: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  updateDeferredScrollDetail: (scrollDetail: ScrollDetail<K, C>) => void\n) {\n  const newKey = getBoundaryColumnKey<K, D, C>(columnsArray, isPrevious);\n  if (newKey == null) {\n    return;\n  }\n  let newCell = initialCell;\n  const cellType = initialCell.type;\n  if (cellType === 'data' || cellType === 'header' || cellType === 'footer') {\n    const initialKey = initialCell.columnKey;\n    if (includeRows) {\n      if (hasNoDataCell(rootElement, tableId)) {\n        newCell = { type: 'noData' };\n        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n      } else {\n        const newRowKey = isPrevious\n          ? getFirstFocusableRowKey<K>(rootElement, tableId)\n          : getLastFocusableRowKey<K>(rootElement, tableId);\n        if (newRowKey != null) {\n          newCell = { rowKey: newRowKey, columnKey: newKey, type: 'data' };\n          onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n        }\n      }\n    } else if (newKey !== initialKey) {\n      if (cellType === 'data') {\n        newCell = { rowKey: initialCell.rowKey, columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n      } else {\n        newCell = { columnKey: newKey, type: cellType };\n        onActiveCellChanged({ value: newCell }, isAutoFocusCell(rootElement, tableId, newCell));\n      }\n    }\n  }\n  if (!cellComparator(initialCell, newCell)) {\n    hideTooltip(true);\n  } else {\n    updateDeferredScrollDetail({ cell: newCell, locationX: 'inView', locationY: 'inView' });\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { keyExtractor } from '../../utils/PRIVATE_collectionUtils';\nimport { Keys, containsKey, isSameKey, addKey, removeKey } from '../../utils/UNSAFE_keys';\nimport { ActiveCell, ActiveCellDetail, ScrollDetail, TableColumn } from '../Table';\nimport {\n  logicalCellExtractor,\n  getCellType,\n  getRowKey,\n  getRowKeyForRowIndex,\n  getRowIndexForRowElement,\n  getElementFromCell,\n  getColumnIndexForHeaderFooterElement\n} from './TableDomUtils';\nimport { TableSelectionDetail, TableSelectionMode } from '../../UNSAFE_TableView';\n\n/**\n * Helper function to handle a selection gesture (click, spacebar, etc...)\n */\nexport function handleSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  isModifierKey: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  selectionMode?: TableSelectionMode,\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  const newRowKey = keyExtractor<K>(targetElement, `[data-oj-table-data-row='${tableId}']`);\n  if (newRowKey != null) {\n    if (\n      selectionMode?.row === 'single' ||\n      selectionMode?.row === 'multiple' ||\n      selectionMode?.row === 'multipleToggle'\n    ) {\n      const isToggleSelectionMode = isDropDownSelection || selectionMode.row === 'multipleToggle';\n      const isMultiSelectRowGesture = isModifierKey || isToggleSelectionMode;\n      if (selectedRows == null) {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      } else if (!containsKey(selectedRows, newRowKey)) {\n        if (isMultiSelectRowGesture && selectionMode.row !== 'single') {\n          selectedRows = addKey(selectedRows, newRowKey);\n        } else {\n          selectedRows = { all: false, keys: new Set([newRowKey]) };\n        }\n      } else if (isMultiSelectRowGesture) {\n        selectedRows = removeKey(selectedRows, newRowKey, false);\n      } else {\n        selectedRows = { all: false, keys: new Set([newRowKey]) };\n      }\n      selectedColumns = emptyKeys as Keys<C>;\n    }\n  } else if (selectionMode?.column === 'single' || selectionMode?.column === 'multiple') {\n    const cellElement = targetElement.closest(\n      `[data-oj-table-focusable='${tableId}']`\n    ) as HTMLElement;\n    if (cellElement != null) {\n      const cellType = getCellType(cellElement);\n      if (cellType === 'header' || cellType === 'footer') {\n        const index = getColumnIndexForHeaderFooterElement(\n          rootElement,\n          tableId,\n          cellElement,\n          cellType === 'header'\n        );\n        if (index != null) {\n          const column = columnsArray[index];\n          if (column.value.selectable !== 'disabled') {\n            if (selectedColumns == null) {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            } else if (!containsKey(selectedColumns, column.key)) {\n              if (isModifierKey && selectionMode.column === 'multiple') {\n                selectedColumns = addKey(selectedColumns, column.key);\n              } else {\n                selectedColumns = { all: false, keys: new Set([column.key]) };\n              }\n            } else if (isModifierKey) {\n              selectedColumns = removeKey(selectedColumns, column.key, false);\n            } else {\n              selectedColumns = { all: false, keys: new Set([column.key]) };\n            }\n            selectedRows = emptyKeys as Keys<K>;\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      false\n    );\n  }\n}\n\n/**\n * Helper function to calculate and apply a new selection state corresponding to the range provided\n */\nfunction _applyRangeSelection<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  startIndex: number,\n  endIndex: number,\n  isRowGesture: boolean,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  selectionMode?: TableSelectionMode,\n  selected?: { row?: Keys<K>; column?: Keys<C> },\n  previousEndIndex?: number\n) {\n  const emptyKeys = { all: false, keys: new Set() };\n  let selectedRows = selected?.row != null ? selected.row : (emptyKeys as Keys<K>);\n  let selectedColumns = selected?.column != null ? selected.column : (emptyKeys as Keys<C>);\n\n  if (isRowGesture) {\n    selectedColumns = emptyKeys as Keys<C>;\n    if (selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle') {\n      const isToggleSelectionMode = isDropDownSelection || selectionMode.row === 'multipleToggle';\n      selectedRows = isToggleSelectionMode ? selectedRows : (emptyKeys as Keys<K>);\n      // selected rows should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n        // toggle selection gesture is additive except for rows added from previous gesture\n        if (isToggleSelectionMode && previousEndIndex != null) {\n          if (previousEndIndex > endIndex) {\n            for (let i = previousEndIndex; i > endIndex; i--) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          } else if (previousEndIndex < startIndex) {\n            for (let i = previousEndIndex; i < startIndex; i++) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          }\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n          selectedRows = addKey(selectedRows, key) as Keys<K>;\n        }\n        // toggle selection gesture is additive except for rows added from previous gesture\n        if (isToggleSelectionMode && previousEndIndex != null) {\n          if (previousEndIndex < endIndex) {\n            for (let i = previousEndIndex; i < endIndex; i++) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          } else if (previousEndIndex > startIndex) {\n            for (let i = previousEndIndex; i > startIndex; i--) {\n              const key = getRowKeyForRowIndex<K>(rootElement, tableId, i);\n              selectedRows = removeKey(selectedRows, key, false) as Keys<K>;\n            }\n          }\n        }\n      }\n    }\n  } else {\n    selectedRows = emptyKeys as Keys<K>;\n    if (selectionMode?.column === 'multiple') {\n      selectedColumns = emptyKeys as Keys<C>;\n      // selected columns should be added in the order that they are selected\n      if (startIndex <= endIndex) {\n        for (let i = startIndex; i <= endIndex; i++) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      } else {\n        for (let i = startIndex; i >= endIndex; i--) {\n          const column = columnsArray[i];\n          if (column.value.selectable !== 'disabled') {\n            selectedColumns = addKey(selectedColumns, column.key);\n          }\n        }\n      }\n    }\n  }\n\n  if (!isSameKey(selectedRows, selected?.row) || !isSameKey(selectedColumns, selected?.column)) {\n    onSelectionChange(\n      { value: { row: selectedRows, column: selectedColumns }, target: targetElement },\n      true\n    );\n  }\n}\n\n/**\n * Determines whether a potential range selection gesture is valid based on the given target\n */\nexport function isRangeSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  activeCell: ActiveCell<K, C>,\n  selectionMode?: TableSelectionMode\n) {\n  const targetCell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n  if (\n    (((selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle') &&\n      activeCell.type === 'data') ||\n      (selectionMode?.column === 'multiple' &&\n        (activeCell.type === 'header' || activeCell.type === 'footer'))) &&\n    targetCell?.type === activeCell.type\n  ) {\n    const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (activeCellElement != null && targetCellElement != null) {\n      const isRow = targetCell.type === 'data';\n      if (isRow) {\n        return (\n          getRowIndexForRowElement(\n            rootElement,\n            tableId,\n            activeCellElement.parentElement as HTMLElement\n          ) != null &&\n          getRowIndexForRowElement(\n            rootElement,\n            tableId,\n            targetCellElement.parentElement as HTMLElement\n          ) != null\n        );\n      } else if (targetCell.type === 'header' || targetCell.type === 'footer') {\n        const isHeader = targetCell.type === 'header';\n        return (\n          getColumnIndexForHeaderFooterElement(rootElement, tableId, activeCellElement, isHeader) !=\n            null &&\n          getColumnIndexForHeaderFooterElement(rootElement, tableId, targetCellElement, isHeader) !=\n            null\n        );\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a range selection gesture (shift+click)\n */\nexport function handleRangeSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  activeCell: ActiveCell<K, C>,\n  onActiveCellChanged: (\n    detail: ActiveCellDetail<K, C>,\n    isAutoFocus?: boolean,\n    isSelectionExtension?: boolean,\n    skipScrollCellIntoView?: boolean\n  ) => void,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  selectionMode?: TableSelectionMode,\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const targetCell = logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray);\n  if (targetCell != null) {\n    const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n    const targetCellElement = getElementFromCell(rootElement, tableId, targetCell);\n    if (activeCellElement != null && targetCellElement != null) {\n      if (\n        (((selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle') &&\n          targetCell.type === 'data') ||\n          (selectionMode?.column === 'multiple' &&\n            (targetCell.type === 'header' || targetCell.type === 'footer'))) &&\n        targetCell.type === activeCell.type\n      ) {\n        let startIndex;\n        let endIndex;\n        let previousEndIndex;\n        let endElement;\n        const isToggleSelectionMode = isDropDownSelection || selectionMode.row === 'multipleToggle';\n        const isRow = targetCell.type === 'data';\n        if (isRow) {\n          endElement = targetCellElement.parentElement as HTMLElement;\n          const startElement =\n            isToggleSelectionMode && selectionExtensionElementRef.current != null\n              ? selectionExtensionElementRef.current\n              : (activeCellElement.parentElement as HTMLElement);\n          startIndex = getRowIndexForRowElement(rootElement, tableId, startElement);\n          endIndex = getRowIndexForRowElement(rootElement, tableId, endElement);\n          const previousElement = isToggleSelectionMode\n            ? (activeCellElement.parentElement as HTMLElement)\n            : selectionExtensionElementRef.current;\n          if (previousElement != null) {\n            previousEndIndex = getRowIndexForRowElement(rootElement, tableId, previousElement);\n          }\n        } else if (targetCell.type === 'header' || targetCell.type === 'footer') {\n          const isHeader = targetCell.type === 'header';\n          endElement = targetCellElement;\n          startIndex = getColumnIndexForHeaderFooterElement(\n            rootElement,\n            tableId,\n            activeCellElement,\n            isHeader\n          );\n          endIndex = getColumnIndexForHeaderFooterElement(\n            rootElement,\n            tableId,\n            targetCellElement,\n            isHeader\n          );\n        }\n        if (startIndex != null && endIndex != null) {\n          if (!isRow || !isToggleSelectionMode) {\n            selectionExtensionElementRef.current = endElement;\n          } else {\n            if (selectionExtensionElementRef.current == null) {\n              selectionExtensionElementRef.current = activeCellElement.parentElement as HTMLElement;\n            }\n            onActiveCellChanged({ value: targetCell }, false, true);\n            targetCellElement.focus({ preventScroll: true });\n          }\n          _applyRangeSelection(\n            rootElement,\n            tableId,\n            columnsArray,\n            targetElement,\n            startIndex,\n            endIndex,\n            isRow,\n            onSelectionChange,\n            isDropDownSelection,\n            selectionMode,\n            selected,\n            previousEndIndex\n          );\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * Helper function to handle a selection extension gesture (shift+arrow key)\n */\nexport function handleExtendSelectionGesture<K extends string | number, D, C extends string>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  columnsArray: TableColumn<K, D, C>[],\n  targetElement: HTMLElement,\n  isPrevious: boolean,\n  activeCell: ActiveCell<K, C>,\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>,\n  onSelectionChange: (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => void,\n  isDropDownSelection: boolean,\n  updateDeferredScrollDetail: (scrollDetail: ScrollDetail<K, C>) => void,\n  selectionMode?: TableSelectionMode,\n  selected?: { row?: Keys<K>; column?: Keys<C> }\n) {\n  const activeCellElement = getElementFromCell(rootElement, tableId, activeCell);\n  if (activeCellElement != null) {\n    let startIndex;\n    let startElement;\n    const isToggleSelectionMode = isDropDownSelection || selectionMode?.row === 'multipleToggle';\n    const isRow = activeCell.type === 'data';\n    const isHeader = activeCell.type === 'header';\n    if (isRow) {\n      startElement =\n        isToggleSelectionMode && selectionExtensionElementRef.current != null\n          ? selectionExtensionElementRef.current\n          : (activeCellElement.parentElement as HTMLElement);\n      startIndex = getRowIndexForRowElement(rootElement, tableId, startElement);\n    } else {\n      startElement = activeCellElement;\n      startIndex = getColumnIndexForHeaderFooterElement(\n        rootElement,\n        tableId,\n        startElement,\n        isHeader\n      );\n    }\n    if (startIndex != null) {\n      let endIndex;\n      let previousEndIndex;\n      let extendedElement;\n      const cursorElement =\n        isToggleSelectionMode && isRow\n          ? (activeCellElement.parentElement as HTMLElement)\n          : selectionExtensionElementRef.current;\n      if (cursorElement != null) {\n        previousEndIndex = isRow\n          ? getRowIndexForRowElement(rootElement, tableId, cursorElement)\n          : getColumnIndexForHeaderFooterElement(rootElement, tableId, cursorElement, isHeader);\n        extendedElement = isPrevious\n          ? (cursorElement.previousElementSibling as HTMLElement)\n          : (cursorElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null && (!isRow || (isRow && getRowKey(extendedElement) != null))) {\n          if (!isToggleSelectionMode || !isRow) {\n            selectionExtensionElementRef.current = extendedElement;\n          } else if (selectionExtensionElementRef.current == null) {\n            selectionExtensionElementRef.current = activeCellElement.parentElement as HTMLElement;\n          }\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, cursorElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, cursorElement, isHeader);\n        }\n      } else {\n        extendedElement = isPrevious\n          ? (startElement.previousElementSibling as HTMLElement)\n          : (startElement.nextElementSibling as HTMLElement);\n        if (extendedElement != null && (!isRow || (isRow && getRowKey(extendedElement) != null))) {\n          selectionExtensionElementRef.current = extendedElement;\n          endIndex = isRow\n            ? getRowIndexForRowElement(rootElement, tableId, extendedElement)\n            : getColumnIndexForHeaderFooterElement(rootElement, tableId, extendedElement, isHeader);\n        } else {\n          endIndex = startIndex;\n        }\n      }\n      if (endIndex != null) {\n        _applyRangeSelection(\n          rootElement,\n          tableId,\n          columnsArray,\n          targetElement,\n          startIndex,\n          endIndex,\n          isRow,\n          onSelectionChange,\n          isDropDownSelection,\n          selectionMode,\n          selected,\n          previousEndIndex\n        );\n      }\n\n      // scroll 'extensionElement' into view if focus is not shifted\n      if (!isRow || !isToggleSelectionMode) {\n        const extensionElement =\n          selectionExtensionElementRef.current != null\n            ? selectionExtensionElementRef.current\n            : activeCellElement;\n        let extensionCell;\n        if (isRow) {\n          const rowKey = keyExtractor<K>(extensionElement, `[data-oj-table-data-row='${tableId}']`);\n          if (rowKey != null) {\n            extensionCell = {\n              type: activeCell.type,\n              rowKey: rowKey,\n              columnKey: activeCell.columnKey\n            };\n          }\n        } else {\n          extensionCell = logicalCellExtractor<K, D, C>(extensionElement, tableId, columnsArray);\n        }\n        if (extensionCell != null) {\n          updateDeferredScrollDetail({\n            cell: extensionCell,\n            locationX: 'inView',\n            locationY: 'inView'\n          });\n        }\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { AppliedColumnWidths, ColumnResizeInfo, TableColumn } from '../Table';\nimport { ColumnResizingDetail, ColumnResizeDetail } from '../../UNSAFE_TableView';\nimport { getElementContainsFunc } from '../../utils/PRIVATE_collectionUtils';\n\n/**\n * Helper function to handle a hover over a resizable column region gesture.\n */\nexport function handleOverResizeRegionGesture<K, D, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  // handle hover feedback around potentially resizable columns\n  _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);\n}\n\n/**\n * Helper function to handle a column resize start gesture (pointer down).\n */\nexport function handleColumnResizeStartGesture<K, D, C extends string>(\n  rootElement: HTMLDivElement,\n  scrollerElement: HTMLElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  appliedColumnWidths: AppliedColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  hideTooltip: (isImmediate?: boolean) => void,\n  onColumnResizing?: (detail: ColumnResizingDetail<C>) => void\n) {\n  if (resizeInfoRef.current.key == null) {\n    _updateResizingState(rootElement, tableId, event, columnsArray, resizeInfoRef, isRtl);\n  }\n  if (resizeInfoRef.current.key != null) {\n    const rect = scrollerElement.getBoundingClientRect();\n    const pointerX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n    resizeInfoRef.current = {\n      isResizing: true,\n      isResizeHover: true,\n      key: resizeInfoRef.current.key,\n      startX: pointerX,\n      delta: 0,\n      ignoreClick: resizeInfoRef.current.ignoreClick\n    };\n    if (onColumnResizing != null) {\n      onColumnResizing({\n        key: resizeInfoRef.current.key,\n        delta: 0,\n        allColumnWidths: appliedColumnWidths.netColumnWidths,\n        paddingWidth: appliedColumnWidths.totalBorderOffset\n      });\n    }\n    hideTooltip(true);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper function to ensure the resizing state is updated based on the latest pointer event.\n */\nfunction _updateResizingState<K, D, C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  event: PointerEvent,\n  columnsArray: TableColumn<K, D, C>[],\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean\n) {\n  const headerRowElement = rootElement.querySelector(\n    `[data-oj-table-header-row='${tableId}']`\n  ) as HTMLElement;\n  if (headerRowElement != null) {\n    const headerElements = headerRowElement.querySelectorAll(\n      `[data-oj-table-header-cell='${tableId}']`\n    ) as NodeListOf<HTMLElement>;\n    if (getElementContainsFunc(headerRowElement)(event.target as HTMLElement)) {\n      let isResizeHover = false;\n      for (let i = 0; i < headerElements.length; i++) {\n        const headerElement = headerElements[i];\n        const cellRect = headerElement.getBoundingClientRect();\n        const endEdge = isRtl ? cellRect.left : cellRect.right;\n        if (Math.abs(endEdge - event.pageX) <= 8) {\n          if (columnsArray[i].value.edgeResizable !== 'enabled') {\n            break;\n          }\n          // resize operation on end side of header cell\n          resizeInfoRef.current.key = columnsArray[i].key;\n          headerRowElement.style.cursor = 'col-resize';\n          isResizeHover = true;\n          resizeInfoRef.current.isResizeHover = true;\n        }\n      }\n      if (!isResizeHover) {\n        headerRowElement.style.cursor = '';\n        resizeInfoRef.current.key = undefined;\n        resizeInfoRef.current.isResizeHover = false;\n      }\n    } else {\n      if (headerRowElement != null) {\n        headerRowElement.style.cursor = '';\n      }\n      resizeInfoRef.current.key = undefined;\n      resizeInfoRef.current.isResizeHover = false;\n    }\n  }\n}\n\n/**\n * Helper function to handle a pointer move gesture during a column resize.\n */\nexport function handleColumnResizingGesture<C extends string>(\n  scrollerElement: HTMLElement,\n  event: PointerEvent,\n  appliedColumnWidths: AppliedColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResizing?: (detail: ColumnResizingDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing) {\n    const rect = scrollerElement.getBoundingClientRect();\n    const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n    resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n    // handle resize move operation\n    if (onColumnResizing != null) {\n      onColumnResizing({\n        key: resizeInfoRef.current.key,\n        delta: resizeInfoRef.current.delta,\n        allColumnWidths: appliedColumnWidths.netColumnWidths,\n        paddingWidth: appliedColumnWidths.totalBorderOffset\n      });\n    }\n  }\n}\n\n/**\n * Helper function to handle a column resize end gesture (pointer up).\n */\nexport function handleColumnResizeEndGesture<C extends string>(\n  scrollerElement: HTMLElement,\n  event: PointerEvent,\n  appliedColumnWidths: AppliedColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  if (resizeInfoRef.current.isResizing) {\n    if (onColumnResize != null) {\n      const rect = scrollerElement.getBoundingClientRect();\n      const currentX = isRtl ? rect.right - event.clientX : event.clientX - rect.left;\n\n      resizeInfoRef.current.delta = currentX - resizeInfoRef.current.startX;\n      onColumnResize({\n        key: resizeInfoRef.current.key,\n        delta: resizeInfoRef.current.delta,\n        allColumnWidths: appliedColumnWidths.netColumnWidths,\n        paddingWidth: appliedColumnWidths.totalBorderOffset,\n        gesture: 'pointer',\n        type: 'delta'\n      });\n    }\n  }\n  resizeInfoRef.current = {\n    isResizing: false,\n    isResizeHover: resizeInfoRef.current.isResizeHover,\n    ignoreClick: resizeInfoRef.current.ignoreClick\n  };\n}\n\n/**\n * Helper function to handle the pointer leaving the entire Table when previously hovering\n * over a column resize region.\n */\nexport function handleLeaveResizingGesture<C>(\n  rootElement: HTMLDivElement,\n  tableId: string,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>\n) {\n  if (!resizeInfoRef.current.isResizing) {\n    const headerRowElement = rootElement.querySelector(\n      `[data-oj-table-header-row='${tableId}']`\n    ) as HTMLElement;\n    if (headerRowElement != null) {\n      headerRowElement.style.cursor = '';\n    }\n    resizeInfoRef.current.isResizeHover = false;\n  }\n}\n\n/**\n * Helper function to handle a pointer entering the Table when it was previously handling\n * a column resize gesture.\n */\nexport function handleEnterResizingGesture<C extends string>(\n  scrollerElement: HTMLElement,\n  event: PointerEvent,\n  appliedColumnWidths: AppliedColumnWidths<C>,\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>,\n  isRtl: boolean,\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void\n) {\n  // handle case where user was resizing, moved pointer out of the Table,\n  // released the button, and has now entered the table once again\n  if (resizeInfoRef.current.isResizing && event.buttons === 0) {\n    handleColumnResizeEndGesture(\n      scrollerElement,\n      event,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      onColumnResize\n    );\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useRef, useState, Dispatch, MutableRef, StateUpdater } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { getIsSelectionPending } from '../../utils/PRIVATE_textSelectionUtils';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  AppliedColumnWidths,\n  ColumnHeaderFooterInfo,\n  ColumnResizeInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { handleRowActionGesture } from '../utils/TableActionUtils';\nimport { logicalCellExtractor } from '../utils/TableDomUtils';\nimport {\n  handleSelectionGesture,\n  handleRangeSelectionGesture,\n  isRangeSelectionGesture\n} from '../utils/TableSelectionUtils';\nimport {\n  handleOverResizeRegionGesture,\n  handleColumnResizeStartGesture,\n  handleColumnResizingGesture,\n  handleColumnResizeEndGesture,\n  handleLeaveResizingGesture,\n  handleEnterResizingGesture\n} from '../utils/TableSizingUtils';\nimport {\n  handleActiveColumnHeaderFooterGesture,\n  handleOverColumnHeaderFooterGesture,\n  handleEndInteractionColumnHeaderFooterGesture\n} from '../utils/TableInteractionUtils';\nimport {\n  handleLeaveTableTooltipGesture,\n  handleMoveTooltipGesture\n} from '../utils/TableTooltipUtils';\nimport {\n  Cell,\n  RowActionDetail,\n  ColumnResizingDetail,\n  ColumnResizeDetail,\n  TableSelectionDetail,\n  TableSelectionMode\n} from '../../UNSAFE_TableView';\n\ntype PointerInfo = {\n  target: EventTarget | null;\n  x: number;\n  y: number;\n};\n\ntype UsePointerHandlingOptions<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  appliedColumnWidths?: AppliedColumnWidths<C>;\n  resizeInfoRef: MutableRef<ColumnResizeInfo<C>>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  onColumnResizing?: (detail: ColumnResizingDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  activeCell?: ActiveCell<K, C>;\n  onActiveCellChanged: (\n    detail: ActiveCellDetail<K, C>,\n    isAutoFocus?: boolean,\n    isSelectionExtension?: boolean,\n    skipScrollCellIntoView?: boolean\n  ) => void;\n  isDropDownSelection: boolean;\n  selectionMode?: TableSelectionMode;\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isSelectionExtension: boolean\n  ) => void;\n  activeStyleColumnInfo: ColumnHeaderFooterInfo<C> | undefined;\n  setActiveStyleColumnInfo: Dispatch<StateUpdater<ColumnHeaderFooterInfo<C> | undefined>>;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  showTooltip: (cell: Cell<K, C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n  tooltipId: string;\n};\n\n/**\n * Hook that manages pointer interactions on the Preact Table\n */\nexport function usePointerHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  tableData,\n  isRtl,\n  columnsArray,\n  appliedColumnWidths,\n  resizeInfoRef,\n  selectionExtensionElementRef,\n  onColumnResizing,\n  onColumnResize,\n  activeCell,\n  onActiveCellChanged,\n  isDropDownSelection,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  activeStyleColumnInfo,\n  setActiveStyleColumnInfo,\n  onRowAction,\n  showTooltip,\n  hideTooltip,\n  tooltipId\n}: UsePointerHandlingOptions<K, D, C>) {\n  // tracks whether the most recent 'pointerdown' event was due to a touch gesture\n  const selectionTouchRef = useRef<boolean>(false);\n\n  // tracks the column key for any header or footer being hovered over\n  const [hoverStyleColumnInfo, setHoverStyleColumnInfo] = useState<ColumnHeaderFooterInfo<C>>();\n\n  // tracks the current 'pointer over' element for comparison during 'click' event handling to\n  // prevent screen readers from triggering undesired selection gestures from simulated events\n  const pointerInfoRef = useRef<PointerInfo>();\n\n  // Pointer move handler for the outer Table.\n  const _pointerMoveHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null) {\n        pointerInfoRef.current = { target: event.target, x: event.clientX, y: event.clientY };\n        handleMoveTooltipGesture(tableId, columnsArray, event, showTooltip, hideTooltip, tooltipId);\n        if (onColumnResizing != null) {\n          if (!resizeInfoRef.current.isResizing) {\n            handleOverResizeRegionGesture(\n              rootElement,\n              tableId,\n              event,\n              columnsArray,\n              resizeInfoRef,\n              isRtl\n            );\n          } else if (scrollerElement != null && appliedColumnWidths != null) {\n            handleColumnResizingGesture(\n              scrollerElement,\n              event,\n              appliedColumnWidths,\n              resizeInfoRef,\n              isRtl,\n              onColumnResizing\n            );\n          }\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      isRtl,\n      onColumnResizing,\n      showTooltip,\n      hideTooltip,\n      tooltipId\n    ]\n  );\n\n  // Pointer over handler for the outer Table.\n  const _pointerOverHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        pointerInfoRef.current = { target: event.target, x: event.clientX, y: event.clientY };\n        handleOverColumnHeaderFooterGesture(\n          tableId,\n          event,\n          setHoverStyleColumnInfo,\n          hoverStyleColumnInfo\n        );\n      }\n    },\n    [rootRef, tableId, hoverStyleColumnInfo]\n  );\n\n  // Pointer down handler for the outer Table. It ensures the area targeted is 'current'.\n  // NOTE - This event handling is triggered prior to 'onFocus' handling and ensures the\n  // 'pending current' area is set when an initial pointer interaction focuses the Table.\n  const _pointerDownHandler = useCallback(\n    (event: PointerEvent) => {\n      handleActiveColumnHeaderFooterGesture(\n        tableId,\n        event,\n        setActiveStyleColumnInfo,\n        activeStyleColumnInfo\n      );\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null) {\n        selectionTouchRef.current = event.pointerType === 'touch';\n        const targetElement = event.target as HTMLElement;\n        if (\n          onTableSelectionChange != null &&\n          activeCell != null &&\n          event.shiftKey &&\n          isRangeSelectionGesture(\n            rootElement,\n            tableId,\n            columnsArray,\n            targetElement,\n            activeCell,\n            selectionMode\n          )\n        ) {\n          // prevent focus change on selection extension gesture\n          if (!getIsSelectionPending()) {\n            event.preventDefault();\n          }\n        } else if (\n          scrollerElement != null &&\n          appliedColumnWidths != null &&\n          handleColumnResizeStartGesture(\n            rootElement,\n            scrollerElement,\n            tableId,\n            event,\n            columnsArray,\n            appliedColumnWidths,\n            resizeInfoRef,\n            isRtl,\n            hideTooltip,\n            onColumnResizing\n          )\n        ) {\n          // prevent focus change on column resize gesture\n          event.preventDefault();\n          resizeInfoRef.current.ignoreClick = true;\n        } else if (logicalCellExtractor<K, D, C>(targetElement, tableId, columnsArray) == null) {\n          // prevent focus shift when interacting with 'non-focusable' regions (ie - scrollbar)\n          event.preventDefault();\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      appliedColumnWidths,\n      resizeInfoRef,\n      activeStyleColumnInfo,\n      setActiveStyleColumnInfo,\n      isRtl,\n      hideTooltip,\n      activeCell,\n      selectionMode,\n      onTableSelectionChange,\n      onColumnResizing\n    ]\n  );\n\n  // Pointer up handler for the outer Table.\n  const _pointerUpHandler = useCallback(\n    (event: PointerEvent) => {\n      handleEndInteractionColumnHeaderFooterGesture(\n        setActiveStyleColumnInfo,\n        activeStyleColumnInfo\n      );\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (scrollerElement != null && appliedColumnWidths != null) {\n        handleColumnResizeEndGesture(\n          scrollerElement,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [\n      viewportInfo,\n      appliedColumnWidths,\n      resizeInfoRef,\n      activeStyleColumnInfo,\n      setActiveStyleColumnInfo,\n      isRtl,\n      onColumnResize\n    ]\n  );\n\n  // Pointer leave handler for the outer Table.\n  const _pointerLeaveHandler = useCallback(\n    (event: PointerEvent) => {\n      handleEndInteractionColumnHeaderFooterGesture(setHoverStyleColumnInfo, hoverStyleColumnInfo);\n      handleEndInteractionColumnHeaderFooterGesture(\n        setActiveStyleColumnInfo,\n        activeStyleColumnInfo\n      );\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        handleLeaveResizingGesture(rootElement, tableId, resizeInfoRef);\n        handleLeaveTableTooltipGesture(rootElement, event, hideTooltip, tooltipId);\n      }\n      pointerInfoRef.current = undefined;\n    },\n    [\n      rootRef,\n      tableId,\n      resizeInfoRef,\n      activeStyleColumnInfo,\n      setActiveStyleColumnInfo,\n      hoverStyleColumnInfo,\n      hideTooltip,\n      tooltipId\n    ]\n  );\n\n  // Pointer enter handler for the outer Table.\n  const _pointerEnterHandler = useCallback(\n    (event: PointerEvent) => {\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (scrollerElement != null && appliedColumnWidths != null) {\n        handleEnterResizingGesture(\n          scrollerElement,\n          event,\n          appliedColumnWidths,\n          resizeInfoRef,\n          isRtl,\n          onColumnResize\n        );\n      }\n    },\n    [viewportInfo, appliedColumnWidths, resizeInfoRef, isRtl, onColumnResize]\n  );\n\n  // Click handler for the outer Table. It ensures the Table's selection state is\n  // updated to reflect the area targeted, and any action events are fired correctly.\n  const _clickHandler = useCallback(\n    (event: PointerEvent) => {\n      const rootElement = rootRef.current;\n      if (rootElement != null) {\n        // only handle click events that match the latest mouse over/move info to prevent screen readers\n        // from triggering undesired selections due to simulated click events when transferring focus\n        if (\n          event.pointerType !== 'mouse' ||\n          (pointerInfoRef.current != null &&\n            pointerInfoRef.current.target === event.target &&\n            Math.abs(pointerInfoRef.current.x - event.clientX) <= 1 &&\n            Math.abs(pointerInfoRef.current.y - event.clientY) <= 1)\n        ) {\n          let isSelectionExtension = false;\n          const platform = getClientHints().platform;\n          const target = event.target as HTMLElement;\n          if (\n            onTableSelectionChange != null &&\n            !resizeInfoRef.current.ignoreClick &&\n            !getIsSelectionPending()\n          ) {\n            if (activeCell != null && event.shiftKey) {\n              isSelectionExtension = handleRangeSelectionGesture(\n                rootElement,\n                tableId,\n                columnsArray,\n                target,\n                activeCell,\n                onActiveCellChanged,\n                selectionExtensionElementRef,\n                onTableSelectionChange,\n                isDropDownSelection,\n                selectionMode,\n                selected\n              );\n            }\n            if (!isSelectionExtension) {\n              handleSelectionGesture(\n                rootElement,\n                tableId,\n                columnsArray,\n                target,\n                (platform === 'mac' ? event.metaKey : event.ctrlKey) || selectionTouchRef.current,\n                onTableSelectionChange,\n                isDropDownSelection,\n                selectionMode,\n                selected\n              );\n            }\n          }\n          if (\n            onRowAction != null &&\n            !getIsSelectionPending() &&\n            handleRowActionGesture(rootElement, tableId, tableData, onRowAction, target)\n          ) {\n            event.stopPropagation();\n          }\n        }\n      }\n      resizeInfoRef.current.ignoreClick = false;\n    },\n    [\n      rootRef,\n      tableId,\n      columnsArray,\n      tableData,\n      resizeInfoRef,\n      selectionExtensionElementRef,\n      activeCell,\n      onActiveCellChanged,\n      isDropDownSelection,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      onRowAction\n    ]\n  );\n\n  return {\n    pointerHandlingProps: {\n      onPointerOver: _pointerOverHandler,\n      onPointerMove: _pointerMoveHandler,\n      onPointerDown: _pointerDownHandler,\n      onPointerUp: _pointerUpHandler,\n      onPointerLeave: _pointerLeaveHandler,\n      onPointerEnter: _pointerEnterHandler,\n      onClick: _clickHandler\n    },\n    hoverStyleColumnInfo\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, useLayoutEffect, useRef, MutableRef } from 'preact/hooks';\nimport { TableHorizontalScrollPosition, TableVerticalScrollPosition } from '../../UNSAFE_TableView';\nimport { SizingInfo, StickyColumnInfo, TableColumn, ViewportInfo } from '../Table';\nimport {\n  hideOutOfViewTooltip,\n  setHorizontalScrollPosition,\n  setVerticalScrollPosition,\n  updateStickyEdges\n} from '../utils/TableScrollUtils';\n\ntype UseScrollHandlingProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  isLayoutRequired: boolean;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  columnsArray: TableColumn<K, D, C>[];\n  stickyColumnInfo: StickyColumnInfo;\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  fullColumnWidths?: number[];\n  horizontalScrollPositionOverride?: TableHorizontalScrollPosition<C>;\n  verticalScrollPositionOverride?: TableVerticalScrollPosition<K>;\n  tooltipAnchorRef: MutableRef<HTMLElement | undefined>;\n  hideTooltip: (isImmediate?: boolean) => void;\n  isPendingLayout: boolean;\n  isRtl: boolean;\n};\n\n/**\n * Hook that manages handling scroll events on the Preact Table\n */\nexport function useScrollHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  isLayoutRequired,\n  sizingInfoRef,\n  columnsArray,\n  stickyColumnInfo,\n  stickyEdgesState,\n  setStickyEdgesState,\n  fullColumnWidths,\n  horizontalScrollPositionOverride,\n  verticalScrollPositionOverride,\n  tooltipAnchorRef,\n  hideTooltip,\n  isPendingLayout,\n  isRtl\n}: UseScrollHandlingProps<K, D, C>) {\n  const horizontalScrollPositionOverrideRef = useRef<TableHorizontalScrollPosition<C>>();\n  const verticalScrollPositionOverrideRef = useRef<TableVerticalScrollPosition<K>>();\n\n  // update horizontal and/or vertical scroll position if a new value is provided\n  // NO DEPENDENCY ARRAY AS THIS SHOULD RUN ON EVERY RENDER\n  useLayoutEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (\n      rootElement != null &&\n      scrollerElement != null &&\n      !isPendingLayout &&\n      !isLayoutRequired &&\n      fullColumnWidths != null\n    ) {\n      if (horizontalScrollPositionOverrideRef.current !== horizontalScrollPositionOverride) {\n        setHorizontalScrollPosition(\n          scrollerElement,\n          columnsArray,\n          fullColumnWidths,\n          isRtl,\n          horizontalScrollPositionOverride\n        );\n        horizontalScrollPositionOverrideRef.current = horizontalScrollPositionOverride;\n      }\n      if (verticalScrollPositionOverrideRef.current !== verticalScrollPositionOverride) {\n        setVerticalScrollPosition(\n          rootElement,\n          scrollerElement,\n          tableId,\n          verticalScrollPositionOverride\n        );\n        verticalScrollPositionOverrideRef.current = verticalScrollPositionOverride;\n      }\n    }\n  });\n\n  // Scroll hander for the outer Table. It ensures the Table's sticky edges are updated\n  // and any out of view tooltips are hidden.\n  const _scrollHandler = useCallback(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (rootElement != null && scrollerElement != null && fullColumnWidths != null) {\n      updateStickyEdges(\n        scrollerElement,\n        columnsArray,\n        stickyColumnInfo,\n        fullColumnWidths,\n        stickyEdgesState,\n        setStickyEdgesState,\n        scrollerElement.scrollLeft\n      );\n      hideOutOfViewTooltip(\n        rootElement,\n        scrollerElement,\n        tableId,\n        sizingInfoRef.current,\n        stickyColumnInfo,\n        fullColumnWidths,\n        tooltipAnchorRef,\n        hideTooltip,\n        isRtl\n      );\n    }\n  }, [\n    rootRef,\n    viewportInfo,\n    tableId,\n    sizingInfoRef,\n    columnsArray,\n    stickyColumnInfo,\n    stickyEdgesState,\n    setStickyEdgesState,\n    fullColumnWidths,\n    tooltipAnchorRef,\n    hideTooltip,\n    isRtl\n  ]);\n\n  useLayoutEffect(() => {\n    const isExternalScroller = viewportInfo.isExternalScroller;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    let scrollerEventElement: Element | typeof globalThis;\n    if (isExternalScroller && scrollerElement != null) {\n      if (scrollerElement === document.body || scrollerElement === document.documentElement) {\n        scrollerEventElement = window;\n      } else {\n        scrollerEventElement = scrollerElement;\n      }\n      scrollerEventElement.addEventListener('scroll', _scrollHandler);\n    }\n    return () => {\n      if (isExternalScroller && scrollerEventElement != null) {\n        scrollerEventElement.removeEventListener('scroll', _scrollHandler);\n      }\n    };\n  }, [viewportInfo, _scrollHandler]);\n\n  return viewportInfo.isExternalScroller ? {} : { onScroll: _scrollHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useImperativeHandle, useMemo, useRef, useState, MutableRef } from 'preact/hooks';\nimport { ForwardedRef } from 'preact/compat';\nimport { useCollectionInteractionContext } from '../../hooks/UNSAFE_useCollectionInteractionContext';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport {\n  ActiveCell,\n  AppliedColumnWidths,\n  ColumnHeaderFooterInfo,\n  ColumnResizeInfo,\n  SizingInfo,\n  StickyColumnInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { getElementFromCell } from '../utils/TableDomUtils';\nimport { useContextMenu } from './useContextMenu';\nimport { useTruncationTooltip } from './useTruncationTooltip';\nimport { useFocusHandling } from './useFocusHandling';\nimport { useKeyboardHandling } from './useKeyboardHandling';\nimport { usePointerHandling } from './usePointerHandling';\nimport { useScrollHandling } from './useScrollHandling';\nimport { getHorizontalScrollPosition, getVerticalScrollPosition } from '../utils/TableScrollUtils';\nimport {\n  CellOverride,\n  ColumnResizeDetail,\n  ColumnResizingDetail,\n  CurrentCellDetail,\n  RowActionDetail,\n  SortCriterionDetail,\n  TableContextMenuConfig,\n  TableHorizontalScrollPosition,\n  TableSelectionDetail,\n  TableSelectionMode,\n  TableVerticalScrollPosition,\n  TableViewHandle\n} from '../../UNSAFE_TableView';\n\ntype UseInteractionManagerOptions<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  ref?: ForwardedRef<TableViewHandle<K, C>>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  hasMore: boolean;\n  hasFooters: boolean;\n  isRtl: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  stickyColumnInfo: StickyColumnInfo;\n  appliedColumnWidths?: AppliedColumnWidths<C>;\n  isLayoutRequired: boolean;\n  sizingInfoRef: MutableRef<SizingInfo>;\n  stickyEdgesState: { start?: number; end?: number };\n  setStickyEdgesState: (stickyEdgesState: { start?: number; end?: number }) => void;\n  cellHasRenderer: (cell: ActiveCell<K, C>) => boolean;\n  horizontalScrollPositionOverride?: TableHorizontalScrollPosition<C>;\n  verticalScrollPositionOverride?: TableVerticalScrollPosition<K>;\n  onColumnResizing?: (detail: ColumnResizingDetail<C>) => void;\n  onColumnResize?: (detail: ColumnResizeDetail<C>) => void;\n  currentCellOverride?: CellOverride<K, C>;\n  onPersistCurrentCell?: (detail: CurrentCellDetail<K, C>) => void;\n  selectionMode?: TableSelectionMode;\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onSelectionChange?: (detail: TableSelectionDetail<K, C>) => void;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  isPendingLayout: boolean;\n  contextMenuConfig?: TableContextMenuConfig<K, D, C>;\n};\n\nconst _defaultDisabledRowInteractionKeys: ('enter' | 'space')[] = ['enter'];\n\n/**\n * Hook that manages interactions and events on the Preact Table\n */\nexport function useInteractionManager<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  ref,\n  tableId,\n  tableData,\n  hasMore,\n  hasFooters,\n  isRtl,\n  columnsArray,\n  stickyColumnInfo,\n  appliedColumnWidths,\n  isLayoutRequired,\n  sizingInfoRef,\n  stickyEdgesState,\n  setStickyEdgesState,\n  cellHasRenderer,\n  horizontalScrollPositionOverride,\n  verticalScrollPositionOverride,\n  onColumnResizing,\n  onColumnResize,\n  currentCellOverride,\n  onPersistCurrentCell,\n  selectionMode,\n  selected,\n  onSelectionChange,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange,\n  isPendingLayout,\n  contextMenuConfig\n}: UseInteractionManagerOptions<K, D, C>) {\n  // tracks the current column resize state\n  const resizeInfoRef = useRef<ColumnResizeInfo<C>>({\n    isResizing: false,\n    isResizeHover: false,\n    ignoreClick: false\n  });\n\n  // tracks the column key for any header or footer being hovered over\n  const [activeStyleColumnInfo, setActiveStyleColumnInfo] = useState<ColumnHeaderFooterInfo<C>>();\n\n  // handles default tooltip state management\n  const { tooltipContent, tooltipId, tooltipAnchorRef, showTooltip, hideTooltip } =\n    useTruncationTooltip<K, C>({ rootRef, tableId, resizeInfoRef });\n\n  // whether row selection is triggered on 'enter' keypresses in addition to 'spacebar'\n  const isEmbeddedSelect = useCollectionInteractionContext() === 'embedded';\n  const disabledRowInteractionKeys = isEmbeddedSelect\n    ? undefined\n    : _defaultDisabledRowInteractionKeys;\n\n  // tracks the current selection extension element (if any)\n  const selectionExtensionElementRef = useRef<HTMLElement>();\n\n  // intercept onSelectionChange calls to ensure local selectionExtensionElementRef is cleared\n  const onTableSelectionChange = useMemo(() => {\n    return onSelectionChange != null\n      ? (detail: TableSelectionDetail<K, C>, isExtendableSelection: boolean) => {\n          if (!isExtendableSelection) {\n            selectionExtensionElementRef.current = undefined;\n          }\n          onSelectionChange(detail);\n        }\n      : undefined;\n  }, [onSelectionChange]);\n\n  // setup focus tracking using the useFocusHandling hook\n  const {\n    focusHandlingProps,\n    activeCell,\n    onActiveCellChanged,\n    currentActiveCell,\n    currentCell,\n    isShowFocusRing,\n    isTabbableMode,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    updateDeferredScrollDetail\n  } = useFocusHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    tableData,\n    hasMore,\n    hasFooters,\n    columnsArray,\n    stickyColumnInfo,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    isRtl,\n    cellSupportsTabbable: cellHasRenderer,\n    appliedColumnWidths,\n    currentCellOverride,\n    onPersistCurrentCell,\n    showTooltip,\n    hideTooltip,\n    isPendingLayout,\n    isEmbeddedSelect,\n    isDataLoaded: !hasMore || tableData.length > 0\n  });\n\n  const keyboardHandlingProps = useKeyboardHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    tableData,\n    isRtl,\n    isTabbableMode,\n    columnsArray,\n    sizingInfoRef,\n    selectionExtensionElementRef,\n    activeCell,\n    onActiveCellChanged,\n    isDropDownSelection: isEmbeddedSelect,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    activeStyleColumnInfo,\n    setActiveStyleColumnInfo,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    hideTooltip,\n    updateDeferredScrollDetail\n  });\n\n  const { hoverStyleColumnInfo, pointerHandlingProps } = usePointerHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    tableData,\n    isRtl,\n    columnsArray,\n    appliedColumnWidths,\n    resizeInfoRef,\n    selectionExtensionElementRef,\n    onColumnResizing,\n    onColumnResize,\n    activeCell,\n    onActiveCellChanged,\n    isDropDownSelection: isEmbeddedSelect,\n    selectionMode,\n    selected,\n    onTableSelectionChange,\n    activeStyleColumnInfo,\n    setActiveStyleColumnInfo,\n    onRowAction,\n    showTooltip,\n    hideTooltip,\n    tooltipId\n  });\n\n  const scrollHandlingProps = useScrollHandling({\n    rootRef,\n    viewportInfo,\n    tableId,\n    isLayoutRequired,\n    sizingInfoRef,\n    columnsArray,\n    stickyColumnInfo,\n    stickyEdgesState,\n    setStickyEdgesState,\n    fullColumnWidths: appliedColumnWidths?.fullColumnWidths,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    tooltipAnchorRef,\n    hideTooltip,\n    isPendingLayout,\n    isRtl\n  });\n\n  const {\n    contextMenuTriggerProps,\n    menuProps,\n    contextMenuContext,\n    isResizeDialogOpen,\n    setIsResizeDialogOpen\n  } = useContextMenu<K, D, C>(\n    tableId,\n    tableData,\n    columnsArray,\n    activeCell,\n    contextMenuConfig,\n    sortCriterion,\n    onSortCriterionChange\n  );\n\n  const interactionManagerProps = !isPendingLayout\n    ? mergeProps(\n        focusHandlingProps,\n        keyboardHandlingProps,\n        pointerHandlingProps,\n        contextMenuTriggerProps\n      )\n    : focusHandlingProps;\n\n  // setup imperative handle implementation\n  useImperativeHandle(\n    ref!,\n    () => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      return {\n        focus: () => {\n          if (rootElement != null) {\n            if (currentActiveCell != null) {\n              const cellElement = getElementFromCell(rootElement, tableId, currentActiveCell);\n              if (cellElement != null) {\n                cellElement.focus();\n                return;\n              }\n            }\n            // if no current cell element was found, just focus the root element\n            rootElement.focus();\n          }\n        },\n        getHorizontalScrollPosition: () => {\n          if (scrollerElement == null || isLayoutRequired || appliedColumnWidths == null) {\n            return {};\n          }\n          return getHorizontalScrollPosition<K, D, C>(\n            scrollerElement,\n            columnsArray,\n            appliedColumnWidths.fullColumnWidths\n          );\n        },\n        getVerticalScrollPosition: () => {\n          if (rootElement == null || scrollerElement == null || isLayoutRequired) {\n            return {};\n          }\n          return getVerticalScrollPosition<K>(rootElement, scrollerElement, tableId);\n        }\n      };\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      columnsArray,\n      currentActiveCell,\n      isLayoutRequired,\n      appliedColumnWidths\n    ]\n  );\n\n  return {\n    interactionManagerProps,\n    scrollHandlingProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    currentActiveCell,\n    resizeInfoRef,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    activeStyleColumnInfo,\n    hoverStyleColumnInfo,\n    tooltipContent,\n    contextMenuContext,\n    menuProps,\n    isResizeDialogOpen,\n    setIsResizeDialogOpen,\n    disabledRowInteractionKeys\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject } from 'preact';\nimport { useCallback, Dispatch, MutableRef, StateUpdater } from 'preact/hooks';\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { Keys } from '../../utils/UNSAFE_keys';\nimport {\n  ActiveCell,\n  ActiveCellDetail,\n  ColumnHeaderFooterInfo,\n  ScrollDetail,\n  SizingInfo,\n  TableColumn,\n  TableData,\n  ViewportInfo\n} from '../Table';\nimport { handleRowActionGesture, handleSortActionGesture } from '../utils/TableActionUtils';\nimport { getElementFromCell, isAutoFocusCell } from '../utils/TableDomUtils';\nimport {\n  handleActiveColumnHeaderFooterGesture,\n  handleEndInteractionColumnHeaderFooterGesture\n} from '../utils/TableInteractionUtils';\nimport {\n  handleAdjacentRowGesture,\n  handleAdjacentColumnGesture,\n  handlePageRowGesture,\n  handleJumpColumnGesture\n} from '../utils/TableNavigationUtils';\nimport { handleSelectionGesture, handleExtendSelectionGesture } from '../utils/TableSelectionUtils';\nimport {\n  RowActionDetail,\n  SortCriterionDetail,\n  TableSelectionDetail,\n  TableSelectionMode\n} from '../../UNSAFE_TableView';\n\ntype UseKeyboardHandlingProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  viewportInfo: ViewportInfo;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  isRtl: boolean;\n  isTabbableMode: boolean;\n  columnsArray: TableColumn<K, D, C>[];\n  sizingInfoRef: MutableRef<SizingInfo>;\n  selectionExtensionElementRef: MutableRef<HTMLElement | undefined>;\n  onActiveCellChanged: (\n    detail: ActiveCellDetail<K, C>,\n    isAutoFocus?: boolean,\n    isSelectionExtension?: boolean,\n    skipScrollCellIntoView?: boolean\n  ) => void;\n  activeCell?: ActiveCell<K, C>;\n  isDropDownSelection: boolean;\n  selectionMode?: TableSelectionMode;\n  selected?: { row?: Keys<K>; column?: Keys<C> };\n  onTableSelectionChange?: (\n    detail: TableSelectionDetail<K, C>,\n    isExtendableSelection: boolean\n  ) => void;\n  activeStyleColumnInfo: ColumnHeaderFooterInfo<C> | undefined;\n  setActiveStyleColumnInfo: Dispatch<StateUpdater<ColumnHeaderFooterInfo<C> | undefined>>;\n  onRowAction?: (detail: RowActionDetail<K, D>) => void;\n  sortCriterion?: { key: C; sortDirection: 'ascending' | 'descending' }[];\n  onSortCriterionChange?: (detail: SortCriterionDetail<C>) => void;\n  hideTooltip: (isImmediate?: boolean) => void;\n  updateDeferredScrollDetail: (scrollDetail: ScrollDetail<K, C>) => void;\n};\n\n/**\n * Hook that manages keyboard interactions on the Preact Table\n */\nexport function useKeyboardHandling<K extends string | number, D, C extends string>({\n  rootRef,\n  viewportInfo,\n  tableId,\n  tableData,\n  isRtl,\n  isTabbableMode,\n  columnsArray,\n  sizingInfoRef,\n  selectionExtensionElementRef,\n  activeCell,\n  onActiveCellChanged,\n  isDropDownSelection,\n  selectionMode,\n  selected,\n  onTableSelectionChange,\n  activeStyleColumnInfo,\n  setActiveStyleColumnInfo,\n  onRowAction,\n  sortCriterion,\n  onSortCriterionChange,\n  hideTooltip,\n  updateDeferredScrollDetail\n}: UseKeyboardHandlingProps<K, D, C>) {\n  // Keydown handler for the outer Table. This handles all internal\n  // keyboard navigation for the Table.\n  const _keyDownHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const rootElement = rootRef.current;\n      const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n      if (rootElement != null && scrollerElement != null) {\n        const platform = getClientHints().platform;\n        const keyHandlers: Record<string, () => void> = {\n          ' ': function () {\n            if (activeCell != null) {\n              if (!isTabbableMode) {\n                handleActiveColumnHeaderFooterGesture(\n                  tableId,\n                  event,\n                  setActiveStyleColumnInfo,\n                  activeStyleColumnInfo,\n                  activeCell\n                );\n                if (onTableSelectionChange != null && !event.repeat) {\n                  handleSelectionGesture(\n                    rootElement,\n                    tableId,\n                    columnsArray,\n                    getElementFromCell(rootElement, tableId, activeCell) as HTMLElement,\n                    true,\n                    onTableSelectionChange,\n                    isDropDownSelection,\n                    selectionMode,\n                    selected\n                  );\n                }\n                event.preventDefault();\n              }\n              if (\n                onRowAction != null &&\n                !event.repeat &&\n                handleRowActionGesture(\n                  rootElement,\n                  tableId,\n                  tableData,\n                  onRowAction,\n                  event.target as HTMLElement,\n                  activeCell\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          },\n          Enter: function () {\n            if (activeCell != null) {\n              if (activeCell.type === 'data') {\n                if (isDropDownSelection && !isTabbableMode) {\n                  if (onTableSelectionChange != null && !event.repeat) {\n                    handleSelectionGesture(\n                      rootElement,\n                      tableId,\n                      columnsArray,\n                      getElementFromCell(rootElement, tableId, activeCell) as HTMLElement,\n                      true,\n                      onTableSelectionChange,\n                      isDropDownSelection,\n                      selectionMode,\n                      selected\n                    );\n                  }\n                  event.preventDefault();\n                }\n                if (\n                  onRowAction != null &&\n                  !event.repeat &&\n                  handleRowActionGesture(\n                    rootElement,\n                    tableId,\n                    tableData,\n                    onRowAction,\n                    event.target as HTMLElement,\n                    activeCell\n                  )\n                ) {\n                  event.stopPropagation();\n                }\n              } else if (\n                activeCell.type === 'header' &&\n                !isTabbableMode &&\n                !event.repeat &&\n                onSortCriterionChange != null &&\n                handleSortActionGesture(\n                  columnsArray,\n                  activeCell.columnKey,\n                  onSortCriterionChange,\n                  sortCriterion\n                )\n              ) {\n                event.stopPropagation();\n              }\n            }\n          },\n          ArrowUp: function () {\n            if (\n              activeCell != null &&\n              (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))\n            ) {\n              let isExtendSelectionGesture = false;\n              if (\n                !isTabbableMode &&\n                activeCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                (selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle')\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  tableId,\n                  columnsArray,\n                  rootElement,\n                  true,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  updateDeferredScrollDetail,\n                  selectionMode,\n                  selected\n                );\n                isExtendSelectionGesture = true;\n              }\n              if (\n                !isExtendSelectionGesture ||\n                isDropDownSelection ||\n                selectionMode?.row === 'multipleToggle'\n              ) {\n                handleAdjacentRowGesture(\n                  rootElement,\n                  tableId,\n                  columnsArray,\n                  activeCell,\n                  onActiveCellChanged,\n                  true,\n                  isExtendSelectionGesture,\n                  hideTooltip,\n                  updateDeferredScrollDetail\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowDown: function () {\n            if (\n              activeCell != null &&\n              (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))\n            ) {\n              let isExtendSelectionGesture = false;\n              if (\n                !isTabbableMode &&\n                activeCell.type === 'data' &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                (selectionMode?.row === 'multiple' || selectionMode?.row === 'multipleToggle')\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  tableId,\n                  columnsArray,\n                  rootElement,\n                  false,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  updateDeferredScrollDetail,\n                  selectionMode,\n                  selected\n                );\n                isExtendSelectionGesture = true;\n              }\n              if (\n                !isExtendSelectionGesture ||\n                isDropDownSelection ||\n                selectionMode?.row === 'multipleToggle'\n              ) {\n                handleAdjacentRowGesture(\n                  rootElement,\n                  tableId,\n                  columnsArray,\n                  activeCell,\n                  onActiveCellChanged,\n                  false,\n                  isExtendSelectionGesture,\n                  hideTooltip,\n                  updateDeferredScrollDetail\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowLeft: function () {\n            if (\n              activeCell != null &&\n              (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))\n            ) {\n              if (\n                !isTabbableMode &&\n                (activeCell.type === 'header' || activeCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  tableId,\n                  columnsArray,\n                  rootElement,\n                  true,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  updateDeferredScrollDetail,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  rootElement,\n                  tableId,\n                  columnsArray,\n                  activeCell,\n                  onActiveCellChanged,\n                  !isRtl,\n                  hideTooltip,\n                  updateDeferredScrollDetail\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          ArrowRight: function () {\n            if (\n              activeCell != null &&\n              (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))\n            ) {\n              if (\n                !isTabbableMode &&\n                (activeCell.type === 'header' || activeCell.type === 'footer') &&\n                event.shiftKey &&\n                onTableSelectionChange != null &&\n                selectionMode?.column === 'multiple'\n              ) {\n                handleExtendSelectionGesture(\n                  rootElement,\n                  tableId,\n                  columnsArray,\n                  rootElement,\n                  false,\n                  activeCell,\n                  selectionExtensionElementRef,\n                  onTableSelectionChange,\n                  isDropDownSelection,\n                  updateDeferredScrollDetail,\n                  selectionMode,\n                  selected\n                );\n              } else {\n                handleAdjacentColumnGesture(\n                  rootElement,\n                  tableId,\n                  columnsArray,\n                  activeCell,\n                  onActiveCellChanged,\n                  isRtl,\n                  hideTooltip,\n                  updateDeferredScrollDetail\n                );\n              }\n              event.preventDefault();\n            }\n          },\n          PageUp: function () {\n            if (\n              activeCell != null &&\n              (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))\n            ) {\n              handlePageRowGesture(\n                rootElement,\n                scrollerElement,\n                tableId,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                true,\n                hideTooltip,\n                updateDeferredScrollDetail\n              );\n              event.preventDefault();\n            }\n          },\n          PageDown: function () {\n            if (\n              activeCell != null &&\n              (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))\n            ) {\n              handlePageRowGesture(\n                rootElement,\n                scrollerElement,\n                tableId,\n                sizingInfoRef,\n                activeCell,\n                onActiveCellChanged,\n                false,\n                hideTooltip,\n                updateDeferredScrollDetail\n              );\n              event.preventDefault();\n            }\n          },\n          Home: function () {\n            if (\n              activeCell != null &&\n              (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))\n            ) {\n              handleJumpColumnGesture(\n                rootElement,\n                tableId,\n                columnsArray,\n                activeCell,\n                onActiveCellChanged,\n                true,\n                platform === 'mac' ? event.metaKey : event.ctrlKey,\n                hideTooltip,\n                updateDeferredScrollDetail\n              );\n              event.preventDefault();\n            }\n          },\n          End: function () {\n            if (\n              activeCell != null &&\n              (!isTabbableMode || isAutoFocusCell(rootElement, tableId, activeCell))\n            ) {\n              handleJumpColumnGesture(\n                rootElement,\n                tableId,\n                columnsArray,\n                activeCell,\n                onActiveCellChanged,\n                false,\n                platform === 'mac' ? event.metaKey : event.ctrlKey,\n                hideTooltip,\n                updateDeferredScrollDetail\n              );\n              event.preventDefault();\n            }\n          }\n        };\n        if (Object.keys(keyHandlers).includes(event.key)) {\n          keyHandlers[event.key]();\n        }\n      }\n    },\n    [\n      rootRef,\n      viewportInfo,\n      tableId,\n      tableData,\n      isRtl,\n      isTabbableMode,\n      columnsArray,\n      sizingInfoRef,\n      selectionExtensionElementRef,\n      activeCell,\n      onActiveCellChanged,\n      isDropDownSelection,\n      selectionMode,\n      selected,\n      onTableSelectionChange,\n      activeStyleColumnInfo,\n      setActiveStyleColumnInfo,\n      onRowAction,\n      sortCriterion,\n      onSortCriterionChange,\n      hideTooltip,\n      updateDeferredScrollDetail\n    ]\n  );\n\n  // Keyup handler for the outer Table.\n  const _keyUpHandler = useCallback(\n    (event: KeyboardEvent) => {\n      const keyHandlers: Record<string, () => void> = {\n        ' ': function () {\n          if (activeCell != null) {\n            handleEndInteractionColumnHeaderFooterGesture(\n              setActiveStyleColumnInfo,\n              activeStyleColumnInfo\n            );\n          }\n        }\n      };\n      if (Object.keys(keyHandlers).includes(event.key)) {\n        keyHandlers[event.key]();\n      }\n    },\n    [activeCell, activeStyleColumnInfo, setActiveStyleColumnInfo]\n  );\n\n  return { onKeyDown: _keyDownHandler, onKeyUp: _keyUpHandler };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { MutableRef } from 'preact/hooks';\nimport { BorderEdges, SampledWidths, TableColumn, ViewportInfo } from '../Table';\nimport { ColumnWidths } from '../../UNSAFE_TableView';\n\n/**\n * Helper method to extract the individual column widths of the Table\n * depending on its layout. With a 'fixed' layout, an initial 'availableWidth'\n * is required, while with a 'contents' layout, -1 can be provided as the\n * 'availableWidth' initially. This will trigger the layout logic to ensure\n * a non-contstrained Table width is supported, and is needed to match\n * current Redwood behaviors with a 'contents' layout.\n */\nexport function applyLayoutColumnWidths<K, D, C extends string>(\n  scrollerElement: HTMLElement,\n  viewportInfo: ViewportInfo,\n  innerTableElement: HTMLTableElement,\n  widthOffset: number,\n  tableId: string,\n  isFixed: boolean,\n  sampledColumnNetWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableRealWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  columnBorderEdges: BorderEdges,\n  borderOffset: number,\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  let newNetColumnWidths;\n  let totalRealWidth = 0;\n  let realWidthsArray = [];\n  const tableCols = innerTableElement.querySelectorAll(\n    `[data-oj-table-col='${tableId}']`\n  ) as NodeListOf<HTMLTableColElement>;\n\n  let totalBorderWidth = 0;\n  for (const borderEdge of columnBorderEdges) {\n    totalBorderWidth += borderEdge.width;\n  }\n  const availableNetWidth = availableRealWidth !== -1 ? availableRealWidth - totalBorderWidth : -1;\n\n  if (isFixed) {\n    newNetColumnWidths = _getFixedLayoutColumnNetWidths(\n      availableNetWidth,\n      columnsArray,\n      staticColumnWidths\n    );\n    for (let i = 0; i < columnsArray.length; i++) {\n      const width = newNetColumnWidths[i] + columnBorderEdges[i].width;\n      realWidthsArray.push(width);\n      totalRealWidth += width;\n    }\n    _updateTableSizing(innerTableElement, tableCols, realWidthsArray, totalRealWidth);\n    return _createColumnWidths(\n      columnsArray,\n      newNetColumnWidths,\n      realWidthsArray,\n      columnBorderEdges,\n      borderOffset,\n      totalBorderWidth\n    );\n  }\n\n  const headerElements = innerTableElement.querySelectorAll(\n    `[data-oj-table-header-cell='${tableId}']`\n  ) as NodeListOf<HTMLElement>;\n\n  newNetColumnWidths = _getContentsLayoutColumnNetWidths(\n    innerTableElement,\n    headerElements,\n    sampledColumnNetWidthsRef,\n    availableNetWidth,\n    columnsArray,\n    columnBorderEdges,\n    staticColumnWidths\n  );\n  for (let i = 0; i < columnsArray.length; i++) {\n    const realWidth = newNetColumnWidths[i] + columnBorderEdges[i].width;\n    realWidthsArray.push(realWidth);\n    totalRealWidth += realWidth;\n  }\n  _updateTableSizing(innerTableElement, tableCols, realWidthsArray, totalRealWidth);\n\n  if (availableRealWidth === -1) {\n    // for content sizing, check to see if all space is actually utilized\n    // this supports no width constraint scenarios\n    if (!viewportInfo.isExternalScroller) {\n      availableRealWidth = scrollerElement.getBoundingClientRect().width - widthOffset;\n    } else {\n      availableRealWidth = scrollerElement.clientWidth - widthOffset;\n    }\n    if (Math.abs(totalRealWidth - availableRealWidth) > 0.005) {\n      newNetColumnWidths = _getContentsLayoutColumnNetWidths(\n        innerTableElement,\n        headerElements,\n        sampledColumnNetWidthsRef,\n        availableRealWidth - totalBorderWidth,\n        columnsArray,\n        columnBorderEdges,\n        staticColumnWidths\n      );\n      totalRealWidth = 0;\n      realWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        const width = newNetColumnWidths[i] + columnBorderEdges[i].width;\n        realWidthsArray.push(width);\n        totalRealWidth += width;\n      }\n      _updateTableSizing(innerTableElement, tableCols, realWidthsArray, totalRealWidth);\n    }\n  }\n  return _createColumnWidths(\n    columnsArray,\n    newNetColumnWidths,\n    realWidthsArray,\n    columnBorderEdges,\n    borderOffset,\n    totalBorderWidth\n  );\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'fixed' layout table that already has its root width applied.\n */\nfunction _getFixedLayoutColumnNetWidths<K, D, C extends string>(\n  availableNetWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_WEIGHT = 1;\n  const DEFAULT_COLUMN_MIN_WIDTH = 100;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  let totalWorkingWeight = 0;\n  let forcedTotalNetWidth = 0;\n  let pendingTotalNetWidth = 0;\n  const columnMaxWidthsArray = [];\n  const columnWeightsArray = [];\n  const forcedColumnNetWidthsArray = [];\n  const newColumnNetWidthsArray = [];\n  const appliedColumnNetWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < columnMinWidth) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    let columnWeight = column.value.weight;\n    if (columnWeight == null || columnWeight < 1) {\n      columnWeight = DEFAULT_COLUMN_WEIGHT;\n    }\n    columnWeightsArray.push(columnWeight);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedTotalNetWidth += columnWidth;\n      pendingTotalNetWidth += columnWidth;\n      forcedColumnNetWidthsArray.push(columnWidth);\n      newColumnNetWidthsArray.push(columnWidth);\n      appliedColumnNetWidthsArray.push(columnWidth);\n    } else {\n      requiresActiveSizing = true;\n      pendingTotalNetWidth += columnMinWidth;\n      totalWorkingWeight += columnWeight;\n      forcedColumnNetWidthsArray.push(undefined);\n      newColumnNetWidthsArray.push(columnMinWidth);\n      appliedColumnNetWidthsArray.push(columnMinWidth);\n    }\n  }\n\n  // enforce min and max rules if active sizing is required and available space remains\n  if (requiresActiveSizing && pendingTotalNetWidth < availableNetWidth) {\n    _enforceFixedMinMaxRules(\n      columnsArray,\n      availableNetWidth,\n      totalWorkingWeight,\n      forcedTotalNetWidth,\n      forcedColumnNetWidthsArray,\n      columnWeightsArray,\n      columnMaxWidthsArray,\n      newColumnNetWidthsArray,\n      appliedColumnNetWidthsArray\n    );\n  }\n  return newColumnNetWidthsArray;\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceFixedMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWorkingWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    _enforceWeightedMinRules(\n      columnsArray,\n      availableWidth,\n      totalWorkingWeight,\n      forcedTotalWidth,\n      forcedColumnWidthsArray,\n      columnWeightsArray,\n      newColumnWidthsArray,\n      appliedColumnWidthsArray\n    );\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper method to extract the individual column widths of the Table\n * for a 'contents' layout table that already has its root width applied.\n */\nfunction _getContentsLayoutColumnNetWidths<K, D, C extends string>(\n  innerTableElement: HTMLTableElement,\n  headerElements: NodeListOf<HTMLElement>,\n  sampledColumnNetWidthsRef: MutableRef<SampledWidths<C> | undefined>,\n  availableNetWidth: number,\n  columnsArray: TableColumn<K, D, C>[],\n  columnBorderEdges: { hasStart: boolean; hasEnd: boolean; width: number }[],\n  staticColumnWidths?: ColumnWidths<C>\n) {\n  const DEFAULT_COLUMN_MIN_WIDTH = undefined;\n  const DEFAULT_COLUMN_MAX_WIDTH = undefined;\n\n  let requiresActiveSizing = false;\n  const columnMinWidthsArray = [] as (number | undefined)[];\n  const columnMaxWidthsArray = [];\n  const forcedColumnNetWidthsArray = [];\n  const newColumnNetWidthsArray = [];\n  for (let i = 0; i < columnsArray.length; i++) {\n    const column = columnsArray[i];\n    let columnMinWidth = column.value.minWidth;\n    if (columnMinWidth == null || columnMinWidth <= 0) {\n      columnMinWidth = DEFAULT_COLUMN_MIN_WIDTH;\n    }\n    columnMinWidthsArray.push(columnMinWidth);\n    let columnMaxWidth = column.value.maxWidth;\n    if (columnMaxWidth == null || columnMaxWidth < (columnMinWidth != null ? columnMinWidth : 0)) {\n      columnMaxWidth = DEFAULT_COLUMN_MAX_WIDTH;\n    }\n    columnMaxWidthsArray.push(columnMaxWidth);\n    const columnWidth = staticColumnWidths != null ? staticColumnWidths[column.key] : undefined;\n    if (columnWidth != null) {\n      forcedColumnNetWidthsArray.push(columnWidth);\n      newColumnNetWidthsArray[i] = columnWidth;\n    } else {\n      requiresActiveSizing = true;\n      forcedColumnNetWidthsArray.push(undefined);\n    }\n  }\n\n  // short-circuit normal contents sizing if each column specifies a 'width' value\n  if (requiresActiveSizing) {\n    // if active sizing is required, update min width values to reflect actual widths\n    // performance note - this should be the only logic that requires DOM measurements\n    let forcedTotalNetWidth = 0;\n    let pendingTotalNetWidth = 0;\n    let totalPreferredNetWidth = 0;\n    let totalWorkingWeight = 0;\n    let totalRemainingWeight = 0;\n    const sampledNetWidths = sampledColumnNetWidthsRef.current;\n    const sampledMinNetWidthsArray = [];\n    const sampledWeightNetWidthsArray = [] as number[];\n    const appliedColumnNetWidthsArray = [];\n    if (sampledNetWidths != null) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        sampledMinNetWidthsArray.push(sampledNetWidths.minWidths[columnsArray[i].key]);\n        sampledWeightNetWidthsArray.push(sampledNetWidths.weightWidths[columnsArray[i].key]);\n      }\n    } else {\n      sampledColumnNetWidthsRef.current = {\n        minWidths: {} as ColumnWidths<C>,\n        weightWidths: {} as ColumnWidths<C>\n      };\n      // when sampledColumnNetWidths are not populated, table has 'max-content' width applied,\n      // which allows for measurements to represent the column weights\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledWeightNetWidth =\n          (headerElements[i] as HTMLElement).getBoundingClientRect().width -\n          columnBorderEdges[i].width;\n        sampledWeightNetWidthsArray.push(sampledWeightNetWidth);\n        sampledColumnNetWidthsRef.current.weightWidths[columnsArray[i].key] = sampledWeightNetWidth;\n      }\n      // specify 'min-content' width, allowing measurements to represent minimum auto-resizable column widths\n      innerTableElement.style.width = 'min-content';\n      for (let i = 0; i < headerElements.length; i++) {\n        const sampledMinNetWidth =\n          (headerElements[i] as HTMLElement).getBoundingClientRect().width -\n          columnBorderEdges[i].width;\n        sampledMinNetWidthsArray.push(sampledMinNetWidth);\n        sampledColumnNetWidthsRef.current.minWidths[columnsArray[i].key] = sampledMinNetWidth;\n      }\n    }\n\n    for (let i = 0; i < sampledMinNetWidthsArray.length; i++) {\n      const forcedWidth = forcedColumnNetWidthsArray[i];\n      if (forcedWidth == null) {\n        let columnNetWidth;\n        const sampledMinNetWidth = sampledMinNetWidthsArray[i];\n        const minWidth = columnMinWidthsArray[i];\n        const maxWidth = columnMaxWidthsArray[i];\n        if (minWidth != null && minWidth >= sampledMinNetWidth) {\n          columnNetWidth = minWidth;\n        } else if (maxWidth != null && sampledMinNetWidth >= maxWidth) {\n          columnNetWidth = maxWidth;\n        } else {\n          columnNetWidth = sampledMinNetWidth;\n        }\n        pendingTotalNetWidth += columnNetWidth;\n        // replace sampled weight with min width if needed\n        const columnWeight =\n          minWidth != null && minWidth >= sampledWeightNetWidthsArray[i]\n            ? minWidth\n            : sampledWeightNetWidthsArray[i];\n        sampledWeightNetWidthsArray[i] = columnWeight;\n        totalPreferredNetWidth +=\n          maxWidth != null && maxWidth <= columnWeight ? maxWidth : columnWeight;\n        totalWorkingWeight += columnWeight;\n        totalRemainingWeight += columnWeight - columnNetWidth;\n        // newColumnWidthsArray already has content, so update in place rather than 'push'\n        newColumnNetWidthsArray[i] = columnNetWidth;\n        appliedColumnNetWidthsArray.push(columnNetWidth);\n      } else {\n        forcedTotalNetWidth += forcedWidth;\n        pendingTotalNetWidth += forcedWidth;\n        totalPreferredNetWidth += forcedWidth;\n        appliedColumnNetWidthsArray.push(forcedWidth);\n      }\n    }\n    // special case for initial rendering where we don't know if overall width is constrained\n    if (availableNetWidth === -1) {\n      availableNetWidth = totalPreferredNetWidth;\n    }\n    if (pendingTotalNetWidth < availableNetWidth) {\n      _enforceContentsMinMaxRules(\n        columnsArray,\n        availableNetWidth,\n        totalPreferredNetWidth,\n        totalRemainingWeight,\n        totalWorkingWeight,\n        pendingTotalNetWidth,\n        forcedTotalNetWidth,\n        forcedColumnNetWidthsArray,\n        sampledWeightNetWidthsArray,\n        columnMaxWidthsArray,\n        newColumnNetWidthsArray,\n        appliedColumnNetWidthsArray\n      );\n    }\n  }\n  return newColumnNetWidthsArray;\n}\n\n/**\n * Helper function to enforce all of the layout sizing rules on the Table's columns.\n */\nfunction _enforceContentsMinMaxRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalPreferredWidth: number,\n  totalRemainingWeight: number,\n  totalWorkingWeight: number,\n  appliedPendingTotalWidth: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  columnMaxWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  // try and honor the weights of each column combined with the min widths, and then check that against\n  // any max widths once completed. if the final result doesn't fill the space AND at least 1 max width\n  // rule was enforced, repeat the process until no max rules are enforced OR the space is filled.\n  let isMaxRuleApplied = true;\n  while (isMaxRuleApplied) {\n    isMaxRuleApplied = false;\n    if (totalPreferredWidth > availableWidth) {\n      _enforceConstrainedWeightRules(\n        columnsArray,\n        availableWidth - appliedPendingTotalWidth,\n        totalRemainingWeight,\n        columnWeightsArray,\n        forcedColumnWidthsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    } else {\n      _enforceWeightedMinRules(\n        columnsArray,\n        availableWidth,\n        totalWorkingWeight,\n        forcedTotalWidth,\n        forcedColumnWidthsArray,\n        columnWeightsArray,\n        newColumnWidthsArray,\n        appliedColumnWidthsArray\n      );\n    }\n\n    let pendingTotalWidth = 0;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (forcedColumnWidthsArray[i] == null) {\n        const maxWidth = columnMaxWidthsArray[i];\n        if (maxWidth != null && newColumnWidthsArray[i] > maxWidth) {\n          isMaxRuleApplied = true;\n          forcedColumnWidthsArray[i] = maxWidth;\n          forcedTotalWidth += maxWidth;\n          appliedPendingTotalWidth += maxWidth - appliedColumnWidthsArray[i];\n          totalWorkingWeight -= columnWeightsArray[i];\n          newColumnWidthsArray[i] = maxWidth;\n          appliedColumnWidthsArray[i] = maxWidth;\n        }\n      }\n      pendingTotalWidth += newColumnWidthsArray[i];\n    }\n    isMaxRuleApplied = isMaxRuleApplied && pendingTotalWidth < availableWidth;\n  }\n}\n\n/**\n * Helper function to enforce constrained weights / min width rules on the Table's columns.\n */\nfunction _enforceConstrainedWeightRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  initialExtraWidth: number,\n  totalRemainingWeight: number,\n  columnWeightsArray: number[],\n  forcedColumnWidthsArray: (number | undefined)[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  if (initialExtraWidth > 0) {\n    let availableWidth = initialExtraWidth;\n    let currentWeightTotal = totalRemainingWeight;\n    for (let i = 0; i < columnsArray.length; i++) {\n      if (currentWeightTotal > 0 && forcedColumnWidthsArray[i] == null) {\n        const currentWeight = columnWeightsArray[i] - appliedColumnWidthsArray[i];\n        const weightWidth = (currentWeight / currentWeightTotal) * availableWidth;\n        newColumnWidthsArray[i] = weightWidth + appliedColumnWidthsArray[i];\n        availableWidth -= weightWidth;\n        currentWeightTotal -= currentWeight;\n      }\n    }\n  }\n}\n\n/**\n * Helper function to enforce the weights / min width rules on the Table's columns.\n */\nfunction _enforceWeightedMinRules<K, D, C>(\n  columnsArray: TableColumn<K, D, C>[],\n  availableWidth: number,\n  totalWeight: number,\n  forcedTotalWidth: number,\n  forcedColumnWidthsArray: (number | undefined)[],\n  columnWeightsArray: number[],\n  newColumnWidthsArray: number[],\n  appliedColumnWidthsArray: number[]\n) {\n  const pendingForcedColumnWidths = [] as (number | undefined)[];\n  let isMinRuleApplied = true;\n  while (isMinRuleApplied) {\n    isMinRuleApplied = false;\n    let currentWeightTotal = totalWeight;\n    let widthDiff = availableWidth - forcedTotalWidth;\n    if (widthDiff > 0) {\n      for (let i = 0; i < columnsArray.length; i++) {\n        if (\n          currentWeightTotal > 0 &&\n          forcedColumnWidthsArray[i] == null &&\n          pendingForcedColumnWidths[i] == null\n        ) {\n          const currentWeight = columnWeightsArray[i];\n          const newWidth = (currentWeight / currentWeightTotal) * widthDiff;\n\n          // if calculated width breaks min width requirement, force min width as needed\n          const minWidth = appliedColumnWidthsArray[i];\n          if (newWidth < minWidth) {\n            // the preferred weighted size conflicts with the min size, so set pending to min size\n            pendingForcedColumnWidths[i] = minWidth;\n            forcedTotalWidth += minWidth;\n            newColumnWidthsArray[i] = minWidth;\n            isMinRuleApplied = true;\n            totalWeight -= currentWeight;\n            break;\n          }\n          newColumnWidthsArray[i] = newWidth;\n          widthDiff -= newWidth;\n          currentWeightTotal -= currentWeight;\n        }\n      }\n    }\n  }\n}\n\n/**\n * Helper function to create a ColumnWidths object from a TableColumn array and a widths array.\n */\nfunction _createColumnWidths<K, D, C extends string>(\n  columnsArray: TableColumn<K, D, C>[],\n  netWidthsArray: number[],\n  realWidthsArray: number[],\n  borderEdges: BorderEdges,\n  borderOffset: number,\n  totalBorderOffset: number\n) {\n  const logicalWidthsArray: number[] = [];\n  const columnWidths = {} as ColumnWidths<C>;\n  for (let i = 0; i < columnsArray.length; i++) {\n    columnWidths[columnsArray[i].key] = netWidthsArray[i];\n    logicalWidthsArray.push(netWidthsArray[i] + borderEdges[i].offset);\n  }\n  return {\n    netColumnWidths: columnWidths,\n    fullColumnWidths: logicalWidthsArray,\n    realColumnWidths: realWidthsArray,\n    borderEdges,\n    borderOffset,\n    totalBorderOffset\n  };\n}\n\n/**\n * Helper method to apply the given sizing object to the currently rendered Table\n * and column elements.\n */\nfunction _updateTableSizing(\n  innerTableElement: HTMLTableElement,\n  tableCols: NodeListOf<HTMLTableColElement>,\n  realWidthsArray: number[],\n  totalRealWidth: number\n) {\n  for (let i = 0; i < tableCols.length; i++) {\n    const tableCol = tableCols[i];\n    tableCol.style.width = `${realWidthsArray[i]}px`;\n  }\n  innerTableElement.style.width = `${totalRealWidth}px`;\n  innerTableElement.style.tableLayout = 'fixed';\n}\n\n/**\n * Helper function to compare two ColumnWidths instances for equality.\n */\nexport const columnWidthsComparator = <C extends string>(\n  columnWidths1: ColumnWidths<C>,\n  columnWidths2: ColumnWidths<C>\n) => {\n  const keys1 = Object.keys(columnWidths1);\n  const keys2 = Object.keys(columnWidths2);\n  if (keys1.length === keys2.length) {\n    for (const key of keys1) {\n      const columnKey = key as C;\n      if (columnWidths1[columnKey] !== columnWidths2[columnKey]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { createRef, Ref, RefObject } from 'preact';\nimport {\n  useCallback,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState\n} from 'preact/hooks';\nimport { useAddBusyState } from '../../hooks/PRIVATE_useAddBusyState';\nimport { useResizeObserver } from '../../hooks/UNSAFE_useResizeObserver';\nimport { UnsafeDomHandle, UNSAFE_DOM_ACCESS } from '../../utils/UNSAFE_unsafeDomAccess';\nimport { Column, Columns, ColumnWidths, TableViewportConfig } from '../../UNSAFE_TableView';\nimport {\n  AppliedColumnWidths,\n  BorderEdges,\n  SampledWidths,\n  SizingInfo,\n  StickyColumnInfo,\n  TableData\n} from '../Table';\nimport { applyLayoutColumnWidths, columnWidthsComparator } from '../utils/TableLayoutUtils';\nimport {\n  applyOverflowStatus,\n  applyUnderflowStatus,\n  getStickyColumnIndicies,\n  getViewportConfig,\n  updateStickyColumns,\n  updateStickyEdges\n} from '../utils/TableScrollUtils';\n\ntype UseSizingManagerProps<K, D, C extends string> = {\n  rootRef: RefObject<HTMLDivElement>;\n  innerTableRef: RefObject<HTMLTableElement>;\n  tableId: string;\n  tableData: TableData<K, D>[];\n  viewportConfig?: TableViewportConfig;\n  externalScrollerRef?: Ref<UnsafeDomHandle>;\n  layout?: 'contents' | 'fixed' | 'pending';\n  columns: Columns<K, D, C>;\n  columnOrder?: C[];\n  columnWidths?: ColumnWidths<C>;\n  isRtl: boolean;\n  isHighContrast: boolean;\n};\n\n/**\n * Hook that manages column sizing on the Preact Table\n */\nexport function useSizingManager<K extends string | number, D, C extends string>({\n  rootRef,\n  innerTableRef,\n  tableId,\n  tableData,\n  viewportConfig,\n  externalScrollerRef,\n  layout,\n  columns,\n  columnOrder,\n  columnWidths,\n  isRtl,\n  isHighContrast\n}: UseSizingManagerProps<K, D, C>) {\n  // scrollerRef is callback-based to meet useResizeObserver hook's state management requirements\n  const [scrollerRef, setScrollerRef] = useState(createRef<HTMLElement>());\n  const scrollerRefCallback = useCallback((node: HTMLDivElement | null) => {\n    setScrollerRef({ current: node });\n  }, []);\n\n  useImperativeHandle(\n    externalScrollerRef!,\n    () => {\n      if (viewportConfig?.scroller != null) {\n        return { [UNSAFE_DOM_ACCESS]: viewportConfig.scroller().current! };\n      }\n      return { [UNSAFE_DOM_ACCESS]: scrollerRef.current! };\n    },\n    [scrollerRef, viewportConfig]\n  );\n\n  // setup busy start and busy end callbacks for the 2 resize observer regions\n  const { onBusyStart: onResizeScrollerBusyStart, onBusyEnd: onResizeScrollerBusyEnd } =\n    useAddBusyState('handling scroller resize');\n  const { onBusyStart: onResizeTableBusyStart, onBusyEnd: onResizeTableBusyEnd } =\n    useAddBusyState('handling table resize');\n\n  // state to force a rerender following the initial render where scrollbars are forced\n  const [_isScrollbarSizeKnown, setIsScrollbarSizeKnown] = useState<boolean>(false);\n\n  // column width state information\n  const sampledColumnNetWidthsRef = useRef<SampledWidths<C>>();\n  const [appliedColumnWidths, setAppliedColumnWidths] = useState<\n    AppliedColumnWidths<C> | undefined\n  >();\n\n  const [innerTableHeight, setInnerTableHeight] = useState<number | undefined>();\n  const [hasVerticalUnderflow, setHasVerticalUnderflow] = useState<boolean>(false);\n\n  // general table sizing state information\n  const sizingInfoRef = useRef<SizingInfo>({\n    isInitialRender: true,\n    isScrollbarSizeKnown: false\n  });\n  const pendingResizeEntriesRef = useRef<{\n    scroller?: ResizeObserverEntry | undefined;\n    innerTable?: ResizeObserverEntry | undefined;\n  }>({});\n\n  // scrollbar overflow state\n  const overflowRef = useRef<{ isHorizontal: boolean; isVertical: boolean }>({\n    isHorizontal: false,\n    isVertical: false\n  });\n\n  // sticky edge state management\n  const [stickyEdgesState, setStickyEdgesState] = useState<{ start?: number; end?: number }>({});\n\n  // current viewport information\n  const viewportInfo = useMemo(() => {\n    const tableViewportConfig = getViewportConfig(scrollerRef, viewportConfig);\n    return {\n      isExternalScroller: viewportConfig?.scroller() != null,\n      viewportConfig: tableViewportConfig\n    };\n  }, [scrollerRef, viewportConfig]);\n\n  // memoize realized columns array on 'columns' and 'columnOrder'\n  const columnsArray = useMemo(() => {\n    const newColumnsArray = [];\n    if (columnOrder != null) {\n      for (const key of columnOrder) {\n        if (columns[key] != null) {\n          newColumnsArray.push({\n            key: key,\n            value: columns[key]\n          });\n        }\n      }\n    } else {\n      for (const [key, value] of Object.entries(columns)) {\n        newColumnsArray.push({\n          key: key as C,\n          value: value as Column<K, D, C>\n        });\n      }\n    }\n    return newColumnsArray;\n  }, [columnOrder, columns]);\n\n  const stickyColumnInfo: StickyColumnInfo = useMemo(() => {\n    const stickyColumns = getStickyColumnIndicies(columnsArray);\n\n    let firstStickyColumnIndex: number | undefined;\n    let finalStickyColumnIndex: number | undefined;\n    const stickyColumnsCount = stickyColumns.length;\n    if (stickyColumns.length > 0) {\n      firstStickyColumnIndex = stickyColumns[0];\n      finalStickyColumnIndex = stickyColumns[stickyColumnsCount - 1];\n    }\n    return { stickyColumns, firstStickyColumnIndex, finalStickyColumnIndex };\n  }, [columnsArray]);\n\n  const borderOffset = isHighContrast ? 3 : 1;\n  const columnBorderEdges: BorderEdges = useMemo(() => {\n    const newColumnBorderEdges: BorderEdges = [];\n    let isPreviousColumnHasEnd = false;\n    for (let i = 0; i < columnsArray.length; i++) {\n      const hasStart = !isPreviousColumnHasEnd;\n      const isLastColumn = i === columnsArray.length - 1;\n      const isColumnSticky = stickyColumnInfo.stickyColumns.includes(i);\n      const isLastStickyColumn = isColumnSticky && stickyColumnInfo.finalStickyColumnIndex === i;\n      const hasEnd = isLastColumn || isLastStickyColumn || stickyEdgesState?.start === i;\n      const width = (hasStart ? borderOffset : 0) + (hasEnd ? borderOffset : 0);\n      let offset;\n      if (\n        isLastStickyColumn ||\n        (isLastColumn && stickyColumnInfo.finalStickyColumnIndex !== i - 1)\n      ) {\n        offset = 2 * borderOffset;\n      } else {\n        offset =\n          !isLastColumn && stickyColumnInfo.finalStickyColumnIndex === i - 1 ? 0 : borderOffset;\n      }\n      newColumnBorderEdges.push({ hasStart, hasEnd, width, offset });\n      isPreviousColumnHasEnd = hasEnd;\n    }\n    return newColumnBorderEdges;\n  }, [borderOffset, columnsArray, stickyEdgesState, stickyColumnInfo]);\n\n  // determine if a new layout is required\n  let isLayoutRequired = false;\n  const netWidthsArray = [];\n  if (appliedColumnWidths != null) {\n    for (let i = 0; i < columnsArray.length; i++) {\n      const key = columnsArray[i].key;\n      const netWidth = appliedColumnWidths.netColumnWidths[key];\n      const staticWidth = columnWidths != null ? columnWidths[key] : undefined;\n      if (netWidth == null || (staticWidth != null && staticWidth !== netWidth)) {\n        isLayoutRequired = true;\n        break;\n      }\n      netWidthsArray.push(netWidth);\n    }\n  } else {\n    isLayoutRequired = true;\n  }\n\n  // ensure sampled column sizes are cleared if 'columns', 'columnOrder', or 'layout' is updated\n  useLayoutEffect(() => {\n    sampledColumnNetWidthsRef.current = undefined;\n    setAppliedColumnWidths(undefined);\n  }, [columns, columnOrder, layout]);\n\n  // ensure applied column widths are cleared if 'columnWidths' is updated\n  useLayoutEffect(() => {\n    setAppliedColumnWidths(undefined);\n  }, [columnWidths, stickyEdgesState]);\n\n  // setup sizing calculation updates for subsequent renders\n  useLayoutEffect(() => {\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    const innerTableElement = innerTableRef.current;\n    if (\n      layout !== 'pending' &&\n      scrollerElement != null &&\n      innerTableElement != null &&\n      !sizingInfoRef.current.isInitialRender &&\n      (viewportInfo.isExternalScroller || sizingInfoRef.current.isScrollbarSizeKnown) &&\n      isLayoutRequired &&\n      columnsArray.length > 0\n    ) {\n      let widthOffset = 0;\n      if (viewportInfo.isExternalScroller) {\n        const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n        if (scrollerOffsetStart != null) {\n          widthOffset += scrollerOffsetStart;\n        }\n        const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n        if (scrollerOffsetEnd != null) {\n          widthOffset += scrollerOffsetEnd;\n        }\n      } else if (sizingInfoRef.current.isScrollbarSizeKnown) {\n        widthOffset = sizingInfoRef.current.defaultScrollbarWidth;\n      }\n      const totalWidth = layout === 'fixed' ? sizingInfoRef.current.contentWidth - widthOffset : -1;\n      const newColumnWidths = applyLayoutColumnWidths(\n        scrollerElement,\n        viewportInfo,\n        innerTableElement,\n        widthOffset,\n        tableId,\n        layout === 'fixed',\n        sampledColumnNetWidthsRef,\n        totalWidth,\n        columnsArray,\n        columnBorderEdges,\n        borderOffset,\n        columnWidths\n      );\n      setAppliedColumnWidths(newColumnWidths);\n    }\n  }, [\n    viewportInfo,\n    innerTableRef,\n    tableId,\n    columnsArray,\n    columnBorderEdges,\n    borderOffset,\n    columnWidths,\n    layout,\n    isLayoutRequired,\n    isHighContrast\n  ]);\n\n  useLayoutEffect(() => {\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    if (\n      layout !== 'pending' &&\n      rootElement != null &&\n      scrollerElement != null &&\n      appliedColumnWidths != null\n    ) {\n      updateStickyColumns(\n        rootElement,\n        scrollerElement,\n        viewportInfo,\n        tableId,\n        isRtl,\n        columnsArray,\n        stickyColumnInfo,\n        appliedColumnWidths.fullColumnWidths,\n        stickyEdgesState,\n        setStickyEdgesState,\n        viewportInfo.isExternalScroller || overflowRef.current.isHorizontal\n      );\n    }\n  }, [\n    tableData,\n    rootRef,\n    viewportInfo,\n    tableId,\n    appliedColumnWidths,\n    columnsArray,\n    stickyColumnInfo,\n    layout,\n    stickyEdgesState,\n    isRtl\n  ]);\n\n  // helper method to update the sticky edge styling due to resize events\n  const _updateStickyEdgesFromResize = useCallback(\n    (scrollerElement: HTMLElement) => {\n      if (appliedColumnWidths != null) {\n        if (viewportInfo.isExternalScroller || overflowRef.current.isHorizontal) {\n          // ensure sticky edges are applied correctly if horizontal overflow is present\n          updateStickyEdges(\n            scrollerElement,\n            columnsArray,\n            stickyColumnInfo,\n            appliedColumnWidths.fullColumnWidths,\n            stickyEdgesState,\n            setStickyEdgesState\n          );\n        } else if (stickyEdgesState.start != null || stickyEdgesState.end != null) {\n          // otherwise clear sticky edges if necessary\n          setStickyEdgesState({});\n        }\n      }\n    },\n    [appliedColumnWidths, columnsArray, stickyColumnInfo, stickyEdgesState, viewportInfo]\n  );\n\n  // callback function to handle resizes of the scroller and inner table elements\n  const handleResizeCallback = useCallback(() => {\n    let currentEntry = pendingResizeEntriesRef.current.scroller;\n    const rootElement = rootRef.current;\n    const scrollerElement = viewportInfo.viewportConfig.scroller().current;\n    const innerTableElement = innerTableRef.current;\n    let isOveralSizeHandled = false;\n\n    // handle scroller element resize notification\n    if (\n      currentEntry != null &&\n      rootElement != null &&\n      scrollerElement != null &&\n      innerTableElement != null\n    ) {\n      const newContentWidth = currentEntry.contentBoxSize[0].inlineSize;\n      const newContentHeight = currentEntry.contentBoxSize[0].blockSize;\n      const newBoxWidth = currentEntry.borderBoxSize[0].inlineSize;\n      const newBoxHeight = currentEntry.borderBoxSize[0].blockSize;\n\n      if (newBoxWidth !== 0 || newBoxHeight !== 0) {\n        isOveralSizeHandled = true;\n        let availableWidth;\n        let availableWidthOffset = 0;\n        let defaultScrollbarWidth = 0;\n        if (viewportInfo.isExternalScroller) {\n          const scrollerOffsetStart = viewportInfo.viewportConfig.scrollerOffsetStart;\n          if (scrollerOffsetStart != null) {\n            availableWidthOffset += scrollerOffsetStart;\n          }\n          const scrollerOffsetEnd = viewportInfo.viewportConfig.scrollerOffsetEnd;\n          if (scrollerOffsetEnd != null) {\n            availableWidthOffset += scrollerOffsetEnd;\n          }\n          if (sizingInfoRef.current.isScrollbarSizeKnown) {\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: true,\n              defaultScrollbarWidth: sizingInfoRef.current.defaultScrollbarWidth,\n              defaultScrollbarHeight: sizingInfoRef.current.defaultScrollbarHeight\n            };\n          } else {\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: false\n            };\n          }\n          availableWidth = newContentWidth - availableWidthOffset;\n        } else {\n          const isInitialRender = sizingInfoRef.current.isInitialRender;\n          if (sizingInfoRef.current.isScrollbarSizeKnown) {\n            availableWidthOffset = sizingInfoRef.current.defaultScrollbarWidth;\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: true,\n              defaultScrollbarWidth: sizingInfoRef.current.defaultScrollbarWidth,\n              defaultScrollbarHeight: sizingInfoRef.current.defaultScrollbarHeight\n            };\n          } else {\n            // on the first render that does not specify an external scroller, horizontal and\n            // vertical scrollbars are forced in order to determine default browser sizes\n            availableWidthOffset = newBoxWidth - newContentWidth;\n            sizingInfoRef.current = {\n              isInitialRender: false,\n              contentWidth: newContentWidth,\n              boxWidth: newBoxWidth,\n              contentHeight: newContentHeight,\n              boxHeight: newBoxHeight,\n              isScrollbarSizeKnown: true,\n              defaultScrollbarWidth: availableWidthOffset,\n              defaultScrollbarHeight: newBoxHeight - newContentHeight\n            };\n            setIsScrollbarSizeKnown(true);\n          }\n          defaultScrollbarWidth = sizingInfoRef.current.defaultScrollbarWidth;\n          availableWidth = !isInitialRender || layout === 'fixed' ? newContentWidth : -1;\n        }\n        if (columnsArray.length > 0) {\n          let newColumnWidths;\n          if (layout !== 'pending') {\n            newColumnWidths = applyLayoutColumnWidths(\n              scrollerElement,\n              viewportInfo,\n              innerTableElement,\n              availableWidthOffset,\n              tableId,\n              layout === 'fixed',\n              sampledColumnNetWidthsRef,\n              availableWidth,\n              columnsArray,\n              columnBorderEdges,\n              borderOffset,\n              columnWidths\n            );\n            if (\n              appliedColumnWidths == null ||\n              !columnWidthsComparator(\n                appliedColumnWidths.netColumnWidths,\n                newColumnWidths.netColumnWidths\n              )\n            ) {\n              setAppliedColumnWidths(newColumnWidths);\n            } else {\n              newColumnWidths = undefined;\n            }\n          }\n          // ensure scrollbars are applied correctly - a scrollbar could be needed\n          if (viewportInfo.isExternalScroller) {\n            applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);\n          } else {\n            const innerTableRect = innerTableElement.getBoundingClientRect();\n            applyOverflowStatus(\n              rootElement,\n              scrollerElement,\n              tableId,\n              innerTableRect.width,\n              newContentWidth,\n              innerTableRect.height,\n              newContentHeight,\n              defaultScrollbarWidth,\n              overflowRef,\n              setHasVerticalUnderflow\n            );\n          }\n          if (layout !== 'pending') {\n            if (newColumnWidths != null) {\n              updateStickyColumns(\n                rootElement,\n                scrollerElement,\n                viewportInfo,\n                tableId,\n                isRtl,\n                columnsArray,\n                stickyColumnInfo,\n                newColumnWidths.fullColumnWidths,\n                stickyEdgesState,\n                setStickyEdgesState,\n                viewportInfo.isExternalScroller || overflowRef.current.isHorizontal\n              );\n            } else {\n              _updateStickyEdgesFromResize(scrollerElement);\n            }\n          }\n        }\n      }\n    }\n    currentEntry = pendingResizeEntriesRef.current.innerTable;\n    if (currentEntry != null) {\n      const newBoxWidth = currentEntry.borderBoxSize[0].inlineSize;\n      const newBoxHeight = currentEntry.borderBoxSize[0].blockSize;\n      // if only an inner table resize occurred, ensure scrollbars are applied correctly\n      if (\n        !isOveralSizeHandled &&\n        rootElement != null &&\n        scrollerElement != null &&\n        columnsArray.length > 0 &&\n        (newBoxWidth !== 0 || newBoxHeight !== 0)\n      ) {\n        if (viewportInfo.isExternalScroller) {\n          applyUnderflowStatus(rootElement, tableId, setHasVerticalUnderflow);\n        } else if (sizingInfoRef.current.isScrollbarSizeKnown) {\n          applyOverflowStatus(\n            rootElement,\n            scrollerElement,\n            tableId,\n            newBoxWidth,\n            sizingInfoRef.current.contentWidth,\n            newBoxHeight,\n            sizingInfoRef.current.contentHeight,\n            sizingInfoRef.current.defaultScrollbarWidth,\n            overflowRef,\n            setHasVerticalUnderflow\n          );\n        }\n        if (layout !== 'pending') {\n          _updateStickyEdgesFromResize(scrollerElement);\n        }\n      }\n      setInnerTableHeight(newBoxHeight);\n    }\n    pendingResizeEntriesRef.current = {};\n  }, [\n    rootRef,\n    viewportInfo,\n    innerTableRef,\n    tableId,\n    layout,\n    columnsArray,\n    stickyColumnInfo,\n    columnBorderEdges,\n    borderOffset,\n    columnWidths,\n    appliedColumnWidths,\n    stickyEdgesState,\n    isRtl,\n    _updateStickyEdgesFromResize\n  ]);\n\n  // ensure resize observers have access to the latest state information\n  const handleResizeCallbackRef = useRef<() => void>(handleResizeCallback);\n  handleResizeCallbackRef.current = handleResizeCallback;\n\n  // resize observer callback functions are static to avoid hook re-subscribing each render\n  const staticHandleScrollerResize = useCallback(\n    (entry: ResizeObserverEntry) => {\n      // only queue up an animation frame if there isn't one already pending\n      if (\n        pendingResizeEntriesRef.current.scroller == null ||\n        pendingResizeEntriesRef.current.innerTable == null\n      ) {\n        onResizeScrollerBusyStart();\n        window.requestAnimationFrame(() => {\n          handleResizeCallbackRef.current();\n          onResizeScrollerBusyEnd();\n        });\n      }\n      pendingResizeEntriesRef.current.scroller = entry;\n    },\n    [onResizeScrollerBusyStart, onResizeScrollerBusyEnd]\n  );\n  const staticHandleInnerTableResize = useCallback(\n    (entry: ResizeObserverEntry) => {\n      // only queue up an animation frame if there isn't one already pending\n      if (\n        pendingResizeEntriesRef.current.scroller == null ||\n        pendingResizeEntriesRef.current.innerTable == null\n      ) {\n        onResizeTableBusyStart();\n        window.requestAnimationFrame(() => {\n          handleResizeCallbackRef.current();\n          onResizeTableBusyEnd();\n        });\n      }\n      pendingResizeEntriesRef.current.innerTable = entry;\n    },\n    [onResizeTableBusyStart, onResizeTableBusyEnd]\n  );\n  useResizeObserver(viewportInfo.viewportConfig.scroller(), staticHandleScrollerResize);\n  useResizeObserver(innerTableRef, staticHandleInnerTableResize);\n\n  return {\n    columnBorderEdges,\n    isLayoutRequired,\n    viewportInfo,\n    columnsArray,\n    appliedColumnWidths,\n    sizingInfoRef,\n    innerTableHeight,\n    hasVerticalUnderflow,\n    stickyEdgesState,\n    setStickyEdgesState,\n    stickyColumnInfo,\n    overflowRef,\n    scrollerRefCallback\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { createRef } from 'preact';\nimport { useCallback, useRef, useState } from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { JSXInternal } from 'preact/src/jsx';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { Cell, CellOverride, Column, ColumnWidths, TableViewportConfig } from '../UNSAFE_TableView';\nimport { TableColGroup } from './TableColGroup';\nimport { TableBody } from './TableBody';\nimport { TableHeader } from './TableHeader';\nimport { TableFooter } from './TableFooter';\nimport { TableDragIndicator } from './TableDragIndicator';\nimport { TableSkeletonRow } from './TableSkeletonRow';\nimport { TableContextMenu, TableResizeColumnDialog } from './TableContextMenu';\nimport { FocusTracker } from '../PRIVATE_FocusTracker';\nimport { Props, TableViewHandle } from '../UNSAFE_TableView';\nimport { useDataManager } from './hooks/useDataManager';\nimport { useInteractionManager } from './hooks/useInteractionManager';\nimport { useSizingManager } from './hooks/useSizingManager';\nimport { innerTableStyles, scrollerStyles } from './themes/Table.css';\nimport { tableSkeletonStyles, tableSkeletonStylesHC } from './themes/TableSkeletonStyles.css';\nimport { TableVariantOptions } from './themes/TableStyles.css';\nimport { TableRedwoodTheme } from './themes/redwood/TableTheme';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { useTestId } from '../hooks/UNSAFE_useTestId';\n\nexport type ActiveCell<K, C> =\n  | Cell<K, C>\n  | {\n      rowKey?: never;\n      columnKey: C;\n      type: 'loading';\n    }\n  | {\n      rowKey?: never;\n      columnKey: C;\n      type: 'loadMore';\n    }\n  | {\n      rowKey?: never;\n      columnKey?: never;\n      type: 'pending';\n    };\n\nexport type ActiveCellDetail<K, C> = {\n  value?: ActiveCell<K, C>;\n};\n\nexport type TableColumn<K, D, C> = {\n  key: C;\n  value: Column<K, D, C>;\n};\n\nexport type BorderEdges = {\n  hasStart: boolean;\n  hasEnd: boolean;\n  width: number;\n  offset: number;\n}[];\n\nexport type AppliedColumnWidths<C extends string> = {\n  netColumnWidths: ColumnWidths<C>;\n  fullColumnWidths: number[];\n  realColumnWidths: number[];\n  borderEdges: BorderEdges;\n  borderOffset: number;\n  totalBorderOffset: number;\n};\n\nexport type StickyColumnInfo = {\n  stickyColumns: number[];\n  firstStickyColumnIndex?: number;\n  finalStickyColumnIndex?: number;\n};\n\nexport type ColumnHeaderFooterInfo<C> = {\n  key: C;\n  isHeader: boolean;\n};\n\nexport type TableData<K, D> = {\n  data: D;\n  metadata: K;\n};\n\nexport type CurrencyStatus<K, D, C> = {\n  activeCell?: ActiveCell<K, C>;\n  currentCell?: Cell<K, C>;\n  currentCellOverride?: CellOverride<K, C>;\n  hasPendingCurrentCellOverride: boolean;\n  hasPendingCurrentCellOverrideScroll: boolean;\n  previousEmbeddedSelectCurrentCell?: Cell<K, C>;\n  loadMoreInitialData?: TableData<K, D>[];\n};\n\nexport type SampledWidths<C extends string> = {\n  minWidths: ColumnWidths<C>;\n  weightWidths: ColumnWidths<C>;\n};\n\nexport type ViewportInfo = {\n  isExternalScroller: boolean;\n  viewportConfig: TableViewportConfig;\n};\n\nexport type SizingInfo =\n  | {\n      isInitialRender: true;\n      boxWidth?: number;\n      contentWidth?: number;\n      boxHeight?: number;\n      contentHeight?: number;\n      isScrollbarSizeKnown: false;\n      defaultScrollbarWidth?: number;\n      defaultScrollbarHeight?: number;\n    }\n  | {\n      isInitialRender: false;\n      boxWidth: number;\n      contentWidth: number;\n      boxHeight: number;\n      contentHeight: number;\n      isScrollbarSizeKnown: true;\n      defaultScrollbarWidth: number;\n      defaultScrollbarHeight: number;\n    }\n  | {\n      isInitialRender: false;\n      boxWidth: number;\n      contentWidth: number;\n      boxHeight: number;\n      contentHeight: number;\n      isScrollbarSizeKnown: false;\n      defaultScrollbarWidth?: number;\n      defaultScrollbarHeight?: number;\n    };\n\nexport type ColumnResizeInfo<C> =\n  | {\n      isResizing: false;\n      isResizeHover: boolean;\n      key?: C;\n      startX?: never;\n      delta?: never;\n      ignoreClick: boolean;\n    }\n  | {\n      isResizing: true;\n      isResizeHover: boolean;\n      key: C;\n      startX: number;\n      delta: number;\n      ignoreClick: boolean;\n    };\n\nexport type ScrollDetail<K, C> = {\n  cell: ActiveCell<K, C> | Cell<K, C>;\n  locationX?: 'inView' | 'start' | 'end';\n  locationY?: 'inView' | 'top' | 'bottom';\n};\n\nconst _defaultSelected = {\n  row: { all: false, keys: new Set() },\n  column: { all: false, keys: new Set() }\n};\n\nconst _disabledHeaderFooterInteractionKeys: ('enter' | 'space')[] = ['enter'];\n\n/**\n * Component that renders data in a flat table.\n */\nexport const Table = forwardRef(function Table<K extends string | number, D, C extends string>(\n  {\n    'aria-label': ariaLabel,\n    'aria-labelledby': ariaLabelledBy,\n    getAccessibleRowHeaders,\n    columns,\n    columnOrder,\n    columnWidths,\n    contextMenuConfig,\n    viewportConfig,\n    layout = 'contents',\n    data,\n    getRowKey,\n    hasMore = false,\n    onLoadMore = () => {},\n    currentCellOverride,\n    onPersistCurrentCell,\n    currentRowVariant = 'none',\n    gridlines,\n    selectionMode,\n    selected = _defaultSelected as NonNullable<Props<K, D, C>['selected']>,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    columnResizingIndicator,\n    onColumnResizing,\n    onColumnResize,\n    noDataRenderer,\n    scrollerRef,\n    testId\n  }: Props<K, D, C>,\n  ref?: ForwardedRef<TableViewHandle<K, C>>\n) {\n  const tableId = useId();\n  const testIdProps = useTestId(testId);\n\n  // rootRef is callback-based to meet useResizeObserver hook's state management requirements\n  const [rootRef, setRootRef] = useState(createRef<HTMLDivElement>());\n  const rootRefCallback = useCallback((node: HTMLDivElement | null) => {\n    setRootRef({ current: node });\n  }, []);\n  const innerTableRef = useRef<HTMLTableElement>(null);\n\n  const { direction, forcedColors } = useUser();\n  const isHighContrast = forcedColors === 'active';\n  const isRtl = direction === 'rtl';\n\n  const { tableData, onTableLoadMore } = useDataManager<K, D>({\n    data,\n    getRowKey,\n    hasMore,\n    onLoadMore\n  });\n\n  const {\n    columnBorderEdges,\n    isLayoutRequired,\n    viewportInfo,\n    columnsArray,\n    appliedColumnWidths,\n    sizingInfoRef,\n    innerTableHeight,\n    hasVerticalUnderflow,\n    stickyEdgesState,\n    setStickyEdgesState,\n    stickyColumnInfo,\n    overflowRef,\n    scrollerRefCallback\n  } = useSizingManager<K, D, C>({\n    rootRef,\n    innerTableRef,\n    tableId,\n    tableData,\n    viewportConfig,\n    externalScrollerRef: scrollerRef,\n    layout,\n    columns,\n    columnOrder,\n    columnWidths,\n    isRtl,\n    isHighContrast\n  });\n\n  const cellHasRenderer = useCallback(\n    (cell: ActiveCell<K, C>) => {\n      let hasRenderer = false;\n      if (cell.type === 'noData') {\n        hasRenderer = noDataRenderer != null;\n      } else if (cell.type !== 'loadMore' && cell.type !== 'loading' && cell.type !== 'pending') {\n        for (const column of columnsArray) {\n          if (column.key === cell.columnKey) {\n            if (cell.type === 'data') {\n              hasRenderer = column.value.renderer != null;\n            } else if (cell.type === 'header') {\n              hasRenderer = column.value.headerRenderer != null;\n            } else if (cell.type === 'footer') {\n              hasRenderer = column.value.footerRenderer != null;\n            }\n            break;\n          }\n        }\n      }\n      return hasRenderer;\n    },\n    [columnsArray, noDataRenderer]\n  );\n\n  const isPendingLayout = layout === 'pending';\n\n  // aria-rowcount includes header and footer rows\n  const hasFooters = columnsArray.some((column: TableColumn<K, D, C>) => {\n    return column.value.footerRenderer != null || column.value.footerText != null;\n  });\n  const ariaRowCount = hasMore || isPendingLayout ? -1 : tableData.length + (hasFooters ? 2 : 1);\n  const ariaColumnCount = Math.max(columnsArray.length, 1);\n\n  const {\n    interactionManagerProps,\n    scrollHandlingProps,\n    onTableSelectionChange,\n    isShowFocusRing,\n    isTabbableMode,\n    currentCell,\n    currentActiveCell,\n    resizeInfoRef,\n    onStartFocusTracking,\n    onFocusStartEdge,\n    onFocusEndEdge,\n    activeStyleColumnInfo,\n    hoverStyleColumnInfo,\n    tooltipContent,\n    contextMenuContext,\n    menuProps,\n    isResizeDialogOpen,\n    setIsResizeDialogOpen,\n    disabledRowInteractionKeys\n  } = useInteractionManager<K, D, C>({\n    rootRef,\n    viewportInfo,\n    ref,\n    tableId,\n    tableData,\n    hasMore,\n    hasFooters,\n    isRtl,\n    columnsArray,\n    stickyColumnInfo,\n    appliedColumnWidths,\n    isLayoutRequired,\n    sizingInfoRef,\n    stickyEdgesState,\n    setStickyEdgesState,\n    cellHasRenderer,\n    horizontalScrollPositionOverride,\n    verticalScrollPositionOverride,\n    onColumnResizing,\n    onColumnResize,\n    currentCellOverride,\n    onPersistCurrentCell,\n    selectionMode,\n    selected,\n    onSelectionChange,\n    onRowAction,\n    sortCriterion,\n    onSortCriterionChange,\n    isPendingLayout,\n    contextMenuConfig\n  });\n\n  // initialize base Table style classes\n  const { classes: themeClasses } = useComponentTheme<TableVariantOptions>(TableRedwoodTheme, {\n    pendingLayout: isPendingLayout ? 'isPendingLayout' : 'notPendingLayout',\n    showFocusRing: isShowFocusRing ? 'isShowFocusRing' : 'notShowFocusRing',\n    externalScroller: viewportInfo.isExternalScroller ? 'isExternalScroller' : 'notExternalScroller'\n  });\n\n  let scrollerStyle;\n  let scrollerPadding = '';\n  const scrollerClassArray = [scrollerStyles.base];\n  if (viewportInfo.isExternalScroller) {\n    scrollerClassArray.push(scrollerStyles.externalScroller);\n  } else if (!sizingInfoRef.current.isScrollbarSizeKnown) {\n    scrollerClassArray.push(scrollerStyles.forceScroll);\n  } else {\n    if (overflowRef.current.isHorizontal) {\n      scrollerClassArray.push(scrollerStyles.horizontalScroll);\n    } else {\n      scrollerClassArray.push(scrollerStyles.noHorizontalScroll);\n    }\n    if (overflowRef.current.isVertical) {\n      scrollerClassArray.push(scrollerStyles.verticalScroll);\n    } else {\n      scrollerClassArray.push(scrollerStyles.noVerticalScroll);\n      scrollerPadding = `padding-inline-end: ${sizingInfoRef.current.defaultScrollbarWidth}px;`;\n    }\n  }\n  // hide the table contents when layout is required and otherwise valid\n  if (isLayoutRequired && columnsArray.length > 0) {\n    scrollerStyle = `${scrollerPadding}opacity:0.001;`;\n  } else {\n    scrollerStyle = scrollerPadding;\n  }\n\n  const scrollerClasses = classNames(scrollerClassArray);\n\n  const classes = classNames([themeClasses]);\n  const tableClasses = classNames([innerTableStyles.base]);\n\n  const startStickyEdge = stickyEdgesState.start;\n  const endStickyEdge = stickyEdgesState.end;\n\n  const hasVerticalGridlines = gridlines?.vertical === 'visible';\n  const hasHorizontalGridlines = gridlines?.horizontal !== 'hidden';\n\n  const isRowSelectionEnabled =\n    selectionMode?.row === 'single' ||\n    selectionMode?.row === 'multiple' ||\n    selectionMode?.row === 'multipleToggle';\n  const isColumnSelectionEnabled =\n    selectionMode?.column === 'single' || selectionMode?.column === 'multiple';\n  const supportsMultipleSelection =\n    selectionMode?.column === 'multiple' ||\n    selectionMode?.row === 'multiple' ||\n    selectionMode?.row === 'multipleToggle';\n\n  const getTableBodyProps = () => {\n    return {\n      rootRef: rootRef,\n      viewportInfo: viewportInfo,\n      tableId: tableId,\n      isValidRender: columnsArray.length > 0,\n      tableData: tableData,\n      columnsArray: columnsArray,\n      getAccessibleRowHeaders: getAccessibleRowHeaders,\n      hasVerticalGridlines: hasVerticalGridlines,\n      hasHorizontalGridlines: hasHorizontalGridlines,\n      hasFooters: hasFooters,\n      hasVerticalUnderflow: hasVerticalUnderflow,\n      selected: selected,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      isSingleRowSelectionEnabled: selectionMode?.row === 'single',\n      activeCell: currentActiveCell,\n      currentRowKey: currentCell?.type === 'data' ? currentCell.rowKey : undefined,\n      currentRowVariant: currentRowVariant,\n      isShowFocusRing: isShowFocusRing,\n      isTabbableMode: isTabbableMode,\n      hasMore: hasMore,\n      onLoadMore: onTableLoadMore,\n      noDataRenderer: noDataRenderer,\n      disabledInteractionKeys: disabledRowInteractionKeys,\n      onSelectionChange: onTableSelectionChange,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      firstStickyColumnIndex: stickyColumnInfo.firstStickyColumnIndex,\n      finalStickyColumnIndex: stickyColumnInfo.finalStickyColumnIndex,\n      columnBorderEdges: columnBorderEdges,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n  };\n\n  const getTableColGroupProps = () => {\n    let columnWidthsArray;\n    if (!isLayoutRequired && appliedColumnWidths?.realColumnWidths != null) {\n      columnWidthsArray = appliedColumnWidths.realColumnWidths;\n    } else if (layout === 'fixed') {\n      // default to 100px for each column when layout is not yet available\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = 100;\n      }\n    } else {\n      columnWidthsArray = [];\n      for (let i = 0; i < columnsArray.length; i++) {\n        columnWidthsArray[i] = undefined;\n      }\n    }\n    return {\n      tableId: tableId,\n      isRendered: columnsArray.length > 0,\n      columnWidthsArray: columnWidthsArray\n    };\n  };\n\n  const getTableHeaderProps = () => {\n    return {\n      tableId: tableId,\n      isRendered: columnsArray.length > 0,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      activeKey: currentActiveCell?.type === 'header' ? currentActiveCell.columnKey : undefined,\n      isTabbableMode: isTabbableMode,\n      selectedColumnKeys: selected.column,\n      selectedRowKeys: selected.row,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      isRowSelectionEnabled: isRowSelectionEnabled,\n      disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,\n      onSelectionChange: onTableSelectionChange,\n      isForceSortIcons: layout === 'contents' && isLayoutRequired,\n      activeStyleKey: activeStyleColumnInfo?.isHeader ? activeStyleColumnInfo?.key : undefined,\n      hoverStyleKey: hoverStyleColumnInfo?.isHeader ? hoverStyleColumnInfo?.key : undefined,\n      sortCriterion: sortCriterion,\n      onSortCriterionChange: onSortCriterionChange,\n      isShowFocusRing: isShowFocusRing,\n      stickyTopOffset: viewportInfo.viewportConfig.scrollerOffsetTop,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      firstStickyColumnIndex: stickyColumnInfo.firstStickyColumnIndex,\n      finalStickyColumnIndex: stickyColumnInfo.finalStickyColumnIndex,\n      columnBorderEdges: columnBorderEdges,\n      isResizeHover: resizeInfoRef.current.isResizeHover,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n  };\n\n  const getTableFooterProps = () => {\n    return {\n      tableId: tableId,\n      isRendered: hasFooters,\n      columnsArray: columnsArray,\n      hasVerticalGridlines: hasVerticalGridlines,\n      activeKey: currentActiveCell?.type === 'footer' ? currentActiveCell.columnKey : undefined,\n      isTabbableMode: isTabbableMode,\n      selectedColumnKeys: selected.column,\n      isColumnSelectionEnabled: isColumnSelectionEnabled,\n      activeStyleKey: !activeStyleColumnInfo?.isHeader ? activeStyleColumnInfo?.key : undefined,\n      hoverStyleKey: !hoverStyleColumnInfo?.isHeader ? hoverStyleColumnInfo?.key : undefined,\n      isShowFocusRing: isShowFocusRing,\n      disabledInteractionKeys: _disabledHeaderFooterInteractionKeys,\n      stickyBottomOffset: viewportInfo.viewportConfig.scrollerOffsetBottom,\n      startStickyEdge: startStickyEdge,\n      endStickyEdge: endStickyEdge,\n      firstStickyColumnIndex: stickyColumnInfo.firstStickyColumnIndex,\n      finalStickyColumnIndex: stickyColumnInfo.finalStickyColumnIndex,\n      columnBorderEdges: columnBorderEdges,\n      dataRowCount: tableData.length,\n      isRtl: isRtl,\n      isHighContrast: isHighContrast\n    };\n  };\n\n  const getTableDragIndicator = () => {\n    if (\n      columnResizingIndicator != null &&\n      !isLayoutRequired &&\n      appliedColumnWidths?.fullColumnWidths != null\n    ) {\n      let position = 0;\n      for (let i = 0; i < columnsArray.length; i++) {\n        position += appliedColumnWidths.fullColumnWidths[i];\n        if (columnsArray[i].key === columnResizingIndicator.key) {\n          if (columnResizingIndicator.delta != null) {\n            position += columnResizingIndicator.delta;\n          }\n          break;\n        }\n      }\n      return <TableDragIndicator position={position} isRtl={isRtl} height={innerTableHeight} />;\n    }\n    return undefined;\n  };\n\n  const getTableStyle = () => {\n    if (!isLayoutRequired && appliedColumnWidths?.realColumnWidths != null) {\n      let totalWidth = 0;\n      for (let i = 0; i < appliedColumnWidths.realColumnWidths.length; i++) {\n        totalWidth += appliedColumnWidths.realColumnWidths[i];\n      }\n      return `width:${totalWidth}px;table-layout:fixed;`;\n    } else if (columnsArray.length > 0) {\n      if (layout === 'fixed') {\n        // default to 100px for each column when layout is not yet available\n        return `width:${columnsArray.length * 100}px;table-layout:fixed;`;\n      } else {\n        // shrink table down as much as possible when a 'contents' layout is required, otherwise\n        // the sampled column widths will not reflect the true weight sizes with line-clamping\n        return 'width:max-content;will-change:width;';\n      }\n    }\n    // no columns are present\n    return 'width:100%;';\n  };\n\n  const skeletonStyles = isHighContrast ? tableSkeletonStylesHC : tableSkeletonStyles;\n  const getPendingLayoutSkeletons = () => {\n    return isPendingLayout ? (\n      <div class={skeletonStyles.pendingLayout}>\n        <table role={'presentation'} style={'width:100%;table-layout:fixed;'}>\n          <tbody role={'presentation'}>\n            <TableSkeletonRow\n              tableId={tableId}\n              hasTabIndex={currentActiveCell?.type === 'pending'}\n              colspan={ariaColumnCount}\n              isPendingLayout={true}\n              isShowFocusRing={false}\n              isHighContrast={isHighContrast}\n            />\n          </tbody>\n        </table>\n      </div>\n    ) : undefined;\n  };\n\n  return (\n    <>\n      <div\n        {...testIdProps}\n        ref={rootRefCallback}\n        aria-colcount={ariaColumnCount}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        aria-rowcount={ariaRowCount}\n        {...(supportsMultipleSelection ? { 'aria-multiselectable': true } : {})}\n        class={classes}\n        id={tableId}\n        role={'grid'}\n        tabIndex={currentActiveCell != null ? -1 : 0}\n        {...interactionManagerProps}>\n        <div\n          ref={scrollerRefCallback}\n          class={scrollerClasses}\n          role={'rowgroup'}\n          style={scrollerStyle}\n          tabIndex={-1}\n          {...scrollHandlingProps}>\n          <FocusTracker\n            isDisabled={!isTabbableMode}\n            onFocusStartEdge={onFocusStartEdge}\n            onFocusEndEdge={onFocusEndEdge}\n            onStartTracking={onStartFocusTracking}>\n            <TabbableModeContext.Provider value={{ isTabbable: isTabbableMode }}>\n              <table\n                ref={innerTableRef}\n                aria-hidden={isPendingLayout ? true : undefined}\n                class={tableClasses}\n                role={'presentation'}\n                style={getTableStyle()}\n                data-oj-table-inner-table={tableId}>\n                <TableColGroup {...getTableColGroupProps()} />\n                <TableHeader {...getTableHeaderProps()} />\n                <TableBody {...getTableBodyProps()} />\n                <TableFooter {...getTableFooterProps()} />\n              </table>\n            </TabbableModeContext.Provider>\n            {getTableDragIndicator()}\n          </FocusTracker>\n          {tooltipContent}\n        </div>\n        {getPendingLayoutSkeletons()}\n      </div>\n      {contextMenuConfig != null && contextMenuContext != null && (\n        <>\n          <TableContextMenu\n            {...menuProps}\n            contextMenuConfig={contextMenuConfig}\n            contextMenuContext={contextMenuContext}\n          />\n          {isResizeDialogOpen &&\n          currentActiveCell?.columnKey != null &&\n          appliedColumnWidths != null ? (\n            <TableResizeColumnDialog\n              isOpen={isResizeDialogOpen}\n              columnKey={currentActiveCell.columnKey}\n              appliedColumnWidths={appliedColumnWidths}\n              onColumnResize={onColumnResize}\n              setIsResizeDialogOpen={setIsResizeDialogOpen}\n            />\n          ) : undefined}\n        </>\n      )}\n    </>\n  );\n}) as <K extends string | number, D, C extends string>(\n  p: Props<K, D, C> & { ref?: ForwardedRef<TableViewHandle<K, C>> }\n) => JSXInternal.Element;\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useMemo, useRef } from 'preact/hooks';\nimport { TableData } from '../Table';\n\ntype UseDataManagerProps<K, D> = {\n  data?: D[];\n  getRowKey: (data: D) => K;\n  hasMore: boolean;\n  onLoadMore: () => void;\n};\n\n/**\n * Hook that manages data on the Preact Table\n */\nexport function useDataManager<K extends string | number, D>({\n  data,\n  getRowKey,\n  hasMore,\n  onLoadMore\n}: UseDataManagerProps<K, D>) {\n  const tableData = useMemo(() => {\n    const newDataArray =\n      data != null\n        ? data.map((d: D) => {\n            const key = getRowKey(d);\n            return { data: d, metadata: key };\n          })\n        : [];\n    return newDataArray as Array<TableData<K, D>>;\n  }, [data, getRowKey]);\n\n  // debounce loadMore calls to prevent state changes from triggering multiple calls\n  const loadMoreDataRef = useRef<TableData<K, D>[]>();\n  if (!hasMore) {\n    // clear loadMoreData cache once more data is not available\n    loadMoreDataRef.current = undefined;\n  }\n  const onTableLoadMore = useCallback(() => {\n    if (tableData === loadMoreDataRef.current) {\n      return;\n    }\n    loadMoreDataRef.current = tableData;\n    return onLoadMore();\n  }, [tableData, onLoadMore]);\n\n  return { tableData, onTableLoadMore };\n}\n"],"names":["TableColGroup","tableId","isRendered","columnWidthsArray","getColStyle","columnWidth","_jsx","jsx","children","map","style","skeletonDimensionInterpolation","Array","from","x","dimensionInterpolations","interpolations","Object","values","SkeletonInterpolations","mergeInterpolations","TableSkeleton","props","skeletonStyles","isHighContrast","tableSkeletonStylesHC","tableSkeletonStyles","classes","classNames","bar","skeletonDimensions","width","class","TableSkeletonRow","colspan","hasTabIndex","isShowFocusRing","isPendingLayout","isLoadMore","translations","useTranslationBundle","cellClassArray","cell","push","focus","cellClasses","innerCellClasses","innerCell","rowClasses","row","rowHeight","firstRowClasses","headerHeight","accCellContent","collection_loading","LOADMORE_STYLE_CLASS","role","colSpan","tabIndex","_jsxs","_element","index","height","getHeaderFooterCellClassArray","isHeader","isActiveStyle","isHoverStyle","isPreviousCellActiveStyle","isPreviousCellHoverStyle","isFirstColumnIndex","isFinalColumnIndex","hasVerticalGridlines","isSelected","isNextColumnSelected","isPreviousColumnSelected","isSticky","isStickyStartEdge","isStickyEndEdge","hasStartEdge","hasEndEdge","isRtl","horizontalAlignment","verticalAlignment","padding","cellStyles","tableHeaderCellStylesHC","tableHeaderCellStyles","tableFooterCellStylesHC","tableFooterCellStyles","classArray","base","isTopPadding","isBottomPadding","isStartPadding","isEndPadding","_getPaddingInfo","bottomPadding","bottomNoPadding","topPadding","topNoPadding","_applyAlignmentStyling","_applyStickyStyling","_applyFocusStyling","activeSelected","hoverSelected","selectedBackground","_applySelectedColumnStyling","active","hover","background","_applyColumnStyling","isPaddingDisabled","isComplexPadding","bottom","end","start","top","textAlignStyles","verticalAlignStyles","focused","stickyColumn","stickyEdge","stickyEdgeLeft","stickyEdgeRight","verticalSelectedGridStart","selectedBorderStartPadding","selectedBorderStartNoPadding","verticalGridStart","borderStartPadding","borderStartNoPadding","startSpacerPadding","startSpacerNoPadding","startPadding","startNoPadding","verticalSelectedGridEnd","selectedBorderEndPadding","selectedBorderEndNoPadding","verticalGridEnd","borderEndPadding","borderEndNoPadding","endSpacerPadding","endSpacerNoPadding","endPadding","endNoPadding","getFormTextAlign","getCellType","element","dataset","getRowKey","Number","isAutoFocusCell","rootElement","activeCell","cellElement","getElementFromCell","getRowKeyForRowIndex","rowElements","querySelectorAll","length","getRowIndexForRowElement","rowElement","prototype","indexOf","call","getColumnKey","getColumnIndexForHeaderFooterElement","columnElements","logicalCellExtractor","columnsArray","cellSelector","onlyAncestors","selectorString","startingElement","parentElement","closest","cellType","rowKey","keyExtractor","columnKey","type","getBoundaryColumnKey","headerElements","headerElement","footerElements","footerElement","cellElements","querySelector","getScrollerTopOffset","headerRowElement","getBoundingClientRect","getScrollerBottomOffset","footerRowElement","getFirstFocusableRowKey","firstRowElement","getLastFocusableRowKey","rowCount","isFirst","key","hasNoDataCell","getNoDataCellElement","hasFooterCells","preventBrowserTooltipProps","onPointerEnter","event","target","classList","add","preventBrowserTooltipStyle","onPointerLeave","remove","_defaultCellRenderer","rowData","field","String","undefined","TableCell","columnIndex","rowIndex","isFinalRowIndex","isFirstLogicalColumnIndex","isFinalLogicalColumnIndex","hasHorizontalGridlines","hasFooters","hasVerticalUnderflow","hasMore","isRowSelected","isPreviousRowSelected","isColumnSelected","isTabbableMode","isAccRowHeader","focusTarget","renderer","selectorRenderer","isRowSelectionEnabled","isRowSingleSelection","variant","applyActiveStyle","applyHoverStyle","applyPseudoHoverStyle","tooltip","browser","getClientHints","rowContext","data","columnPadding","supportsDefaultTooltip","hasLastHorizontalGridline","isFirstRowIndex","isActive","isHover","isPseudoHover","tableCellStylesHC","tableCellStyles","pseudoHover","rowHighlight","hasBackground","horizontalSelectedGridTop","selectedBorderTopPadding","selectedBorderTopNoPadding","horizontalGridTop","borderTopPadding","borderTopNoPadding","topSpacerPadding","topSpacerNoPadding","lastRow","horizontalSelectedGridBottom","selectedBorderBottomPadding","selectedBorderBottomNoPadding","horizontalGridBottom","borderBottomPadding","borderBottomNoPadding","bottomSpacerPadding","bottomSpacerNoPadding","notLastRow","getDataCellClassArray","cellRendererProps","selector","isTabbable","supportsAutoFocus","FormContext","Provider","value","textAlign","MemoizeTableRow","memo","isFinalRow","rowHeaderColumnKeys","isPreviousSelected","isSingleRowSelectionEnabled","selectedRowKeys","all","keys","Set","activeColumnKey","selectedColumnKeys","disabledInteractionKeys","onSelectionChange","startStickyEdge","endStickyEdge","firstStickyColumnIndex","finalStickyColumnIndex","columnBorderEdges","interactionProps","useInteractionStyle","disabledKeys","rowStyles","tableRowStylesHC","tableRowStyles","lastRowHeight","accessibleRowName","toString","handleRowSelectorChange","detail","column","Selector","collection_selectRow","ROW_NAME","onChange","selectedKeys","isPreviousStickyColumnSelected","containsKey","sticky","nextVisibleColumn","isNextVisibleColumnSelected","isPreviousVisibleColumnSelected","i","cellProps","has","hasStart","hasEnd","alignment","horizontal","vertical","prev","next","columnsArray1","columnsArray2","_areColumnsArraysEquivalent","set1","set2","size","every","isSameKey","TableNoData","rootRef","columnsCount","ariaRowIndex","themeClasses","useComponentTheme","TableNoDataRedwoodTheme","defaultRenderer","showFocusRing","contentRenderer","collection_noData","useLayoutEffect","current","tableBodyElement","noDataElement","TableBody","viewportInfo","isValidRender","getAccessibleRowHeaders","tableData","onLoadMore","currentRowKey","currentRowVariant","selected","noDataRenderer","getRowContext","useCallback","context","metadata","isShowEmptyLoading","isShowNoData","loadMoreViewportConfig","scroller","viewportConfig","backgroundStyles","inherit","getNoDataProps","jsxs","Fragment","LoadMoreCollection","loadMoreIndicator","tableRowContext","containsActiveCell","rowProps","TableHeaderCell","isColumnSelectable","headerText","stickyTopOffset","isShowSortIcon","sortable","sortDirection","onSortCriterionChange","isAccColumnHeader","selectorAllState","deletedKeys","handleSelectorChange","SelectorAll","collection_selectAllRows","handleSortGesture","headerCellRendererProps","getHeaderCellRenderer","text","tableHeaderCellTextStyles","defaultRendererSpan","isIconFirst","containerClasses","tableHeaderSortContainerStyles","justifyContentStyles","SortControl","SortableContext","onSort","getAriaSort","TableHeader","activeKey","isColumnSelectionEnabled","isForceSortIcons","activeStyleKey","hoverStyleKey","sortCriterion","isResizeHover","tableHeaderRowStyles","previousColumnKey","previousStickyColumnKey","isPreviousSelectable","isPreviousStickySelectable","criterion","isSelectable","selectable","previousVisibleColumnKey","isPreviousVisibleColumnSelectable","headerCellProps","headerRenderer","accessibleColumnHeader","headerPadding","headerTooltip","headerFocusTarget","headerAlignment","_defaultFooterCellRenderer","footerText","TableFooterCell","stickyBottomOffset","footerCellRendererProps","TableFooter","dataRowCount","tableFooterRowStyles","Math","max","footerCellProps","footerRenderer","footerPadding","footerTooltip","footerFocusTarget","footerAlignment","TableDragIndicator","position","tableDragIndicatorClasses","tableDragIndicatorStyles","heightString","getDragIndicatorStyle","TableContextMenu","contextMenuConfig","contextMenuContext","menuProps","accessibleLabel","accContextMenuLabel","itemsRenderer","Menu","isOpen","_Fragment","TableContextMenuSort","isDisabled","currentSortDirection","Submenu","label","collection_sortColumnMenu","SelectSingleMenuGroup","onCommit","SelectMenuItem","collection_sortAscendingSubMenu","collection_sortDescendingSubMenu","TableContextMenuResize","setIsResizeDialogOpen","MenuItem","collection_resizeColumnMenu","onAction","TableResizeColumnDialog","onColumnResize","appliedColumnWidths","initialWidth","round","netColumnWidths","initialWidthRef","useRef","numberInputRef","widthValue","setWidthValue","useState","messages","isNaN","parseInt","trim","severity","collection_resizeMessageDetail","MIN","MAX","apply","newWidth","allColumnWidths","paddingWidth","totalBorderOffset","gesture","handleKeyDown","cancel","handleOnInput","footer","Flex","gap","Button","collection_cancel","collection_apply","Dialog","autoFocusRef","modality","header","collection_resizeColumnDialog","onKeyDown","NumberInputText","collection_width","onInput","suffix","collection_pixels","isRequired","isRequiredShown","ref","_scrollRowIntoView","scrollerElement","scrollbarHeight","location","topOffset","bottomOffset","isExternalScroller","scrollerOffsetTop","scrollerOffsetBottom","verticalOverflowDiff","_getVerticalOverflowDiff","topOverflowDiff","hasTopOverflow","bottomOverflowDiff","hasBottomOverflow","abs","scrollTop","_roundScrollValue","isOver","ceil","floor","_getHorizontalOverflowDiff","startOffset","endOffset","scrollbarWidth","elementRect","scrollerRect","left","right","setHorizontalScrollPosition","fullColumnWidths","horizontalScrollPosition","scrollPosition","useColumn","offsetX","getHorizontalScrollPosition","_getScrollLeftFromScrollPosition","scrollLeft","setVerticalScrollPosition","verticalScrollPosition","y","useRow","offsetY","getVerticalScrollPosition","_getScrollTopFromScrollPosition","newScrollLeft","columnEnd","newScrollTop","rowBottom","applyScrollDetail","stickyColumnInfo","sizingInfo","scrollDetail","findElementByKey","locationY","isInitialRender","boxHeight","contentHeight","locationX","columnElement","scrollerOffsetStart","scrollerOffsetEnd","stickyCount","borderOffset","stickyColumns","stickyIndex","borderEdges","horizontalOverflowDiff","leftOverflowDiff","hasLeftOverflow","rightOverflowDiff","hasRightOverflow","_scrollColumnIntoView","boxWidth","contentWidth","updateStickyColumns","stickyEdgesState","setStickyEdgesState","isHorizontalScroll","stickyStartOffset","stickyEndOffset","stickyIndicies","_applyStickyColumnOffset","updateStickyEdges","stickyOffset","isStart","styleProperty","styleValue","j","currentScrollIndex","newScrollPosition","startIndex","currentIndex","endIndex","currentWidth","endOverflow","scrollWidth","clientWidth","applyOverflowStatus","availableWidth","availableHeight","overflowRef","setHasVerticalUnderflow","hasHorizontalOverflow","hasVerticalOverflow","scrollerStyles","noHorizontalScroll","horizontalScroll","noVerticalScroll","verticalScroll","paddingInlineEnd","isHorizontal","isVertical","applyUnderflowStatus","spacerRowElement","offsetHeight","isTransientCell","cellComparator","cell1","cell2","_getCellFromCellOverride","cellOverride","currentCell","cellRowKey","cellColumnKey","_renderIncludesCell","isColumnValid","menuPropGestureStates","mouse","initialFocus","placement","offsetValue","keyboard","touch","_initialMenuProps","anchorRef","useContextMenu","setContextMenuContext","setMenuProps","currentCellElementRef","isResizeDialogOpen","triggerProps","useContextMenuGesture","anchor","cellContextMenuContext","isSortable","isResizable","resizable","allMenuItems","resizeColumn","sortColumn","hasResizableColumns","some","hasSortableColumns","defaultMenuItems","getCellContextMenuContextFromCell","anchorBasedOnGesture","handleCloseContextMenu","reason","preventScroll","onClose","contextMenuTriggerProps","TABLE_HIDE_TOOLTIP_DELAY","min","SHOW_TOOLTIP_DELAY","HIDE_TOOLTIP_DELAY","useTruncationTooltip","resizeInfoRef","globalTooltipManager","getGlobalTooltipManager","tooltipId","useId","tooltipCellRef","pendingShowTooltipCellRef","tooltipAnchorRef","tooltipTextRef","tooltipText","setTooltipText","pointerDownRef","pointerDownTimeoutRef","showTooltipTimeoutRef","hideTooltipTimeoutRef","_clearHideTooltipTimeout","clearTimeout","_clearShowTooltipTimeout","_setupShowTooltipTimeout","setTimeout","isResizing","getAttribute","innerText","walker","document","createTreeWalker","NodeFilter","SHOW_TEXT","nextNode","range","Range","textNode","currentNode","selectNodeContents","untruncatedTextLength","untruncatedTextHeight","firstParent","parentStyles","getComputedStyle","visibility","horizontalPadding","parseFloat","paddingLeft","paddingRight","horizontalBorder","borderLeft","borderRight","renderedTextLength","verticalPadding","paddingTop","paddingBottom","verticalBorder","borderTop","borderBottom","renderedTextHeight","hasTruncatedText","_setupHideTooltipTimeout","showTooltip","anchorCell","hideTooltip","isImmediate","_pointerMoveHandler","_event","_pointerLeaveHandler","targetElement","relatedTarget","_pointerDownHandler","isOpenOverrideRef","tooltipPointerProps","onPointerMove","onPointerDown","renderRawContent","TooltipContent","id","isDatatip","scale","useScale","mainAxisOffset","crossAxisOffset","currentColorScheme","useColorScheme","tooltipContent","getWrappedTooltipContent","mainAxis","crossAxis","destroyCallback","useEffect","register","unregister","NAVIGATION_KEYS","SCROLL_KEYS","useFocusHandling","sizingInfoRef","selectionExtensionElementRef","cellSupportsTabbable","currentCellOverride","onPersistCurrentCell","isEmbeddedSelect","isDataLoaded","blurFromWindowRef","isRenderCycle","blurredRenderCycleElementRef","isPendingLayoutFocusRef","hasFocusRef","setIsTabbableMode","setIsShowFocusRing","recentPointerRef","pointerTimerRef","isShowFocusRingOverrideRef","setActiveCell","currencyStatusRef","hasPendingCurrentCellOverride","hasPendingCurrentCellOverrideScroll","deferredScrollDetail","setDeferredScrollDetail","deferredScrollDetailRef","updateDeferredScrollDetail","wasTransient","currentActiveCell","firstColumnKey","defaultFirstCell","previousEmbeddedSelectCurrentCell","realizedCell","overrideCellType","_getCellTypeFromCellOverride","initialData","loadMoreInitialData","determineActiveCell","onActiveCellChanged","useMemo","isAutoFocus","isSelectionExtension","skipScrollCellIntoView","newActiveCell","newCurrentCell","_setAsInactive","_enableNavigationMode","focusRingState","handleNavigationTooltipGesture","_enableTabbableMode","isKeyboard","_disableTabbableMode","notifyFocusFromPointer","isTouch","pointerType","_pointerUpHandler","_onBlurHandler","activeElement","isUnknownRelatedTarget","getElementContainsFunc","_onKeyDownHandler","isNavigationKey","onStartFocusTracking","handleEnterActionableMode","hasFocusWithin","allTabbableElements","onFocusStartEdge","handleWrapActionableFocus","tabbableElements","onFocusEndEdge","_applyInternalFocus","isCaptureFocus","resetVerticalScrollPosition","applyCurrentCellOverride","blurredRenderCycleElement","getActiveElement","getBodyElement","isTabbableElement","focusHandlingProps","onPointerUp","onFocus","onBlur","handleRowActionGesture","onRowAction","targetCell","rowActionContext","targetCellElement","_getRowActionGestureContext","handleActiveColumnHeaderFooterGesture","setActiveStyleColumnInfo","activeStyleColumnInfo","PointerEvent","handleEndInteractionColumnHeaderFooterGesture","setInteractionStyleColumnInfo","interactionStyleColumnInfo","handleAdjacentRowGesture","initialCell","isPrevious","isExtendSelectionGesture","newCell","newColumnKey","currentRowElement","adjacentRowElement","previousElementSibling","nextElementSibling","handlePageRowGesture","verticalRowIndex","getRowIndexForRowKey","targetRowIndex","scrollerBottom","newRowKey","handleAdjacentColumnGesture","newKey","initialKey","_getAdjacentColumnKey","handleJumpColumnGesture","includeRows","handleSelectionGesture","isModifierKey","isDropDownSelection","selectionMode","emptyKeys","selectedRows","selectedColumns","isToggleSelectionMode","isMultiSelectRowGesture","removeKey","addKey","_applyRangeSelection","isRowGesture","previousEndIndex","handleExtendSelectionGesture","activeCellElement","startElement","isRow","extendedElement","cursorElement","extensionElement","extensionCell","_updateResizingState","cellRect","endEdge","pageX","edgeResizable","cursor","handleColumnResizeEndGesture","rect","currentX","clientX","delta","startX","ignoreClick","usePointerHandling","onColumnResizing","onTableSelectionChange","selectionTouchRef","hoverStyleColumnInfo","setHoverStyleColumnInfo","pointerInfoRef","clientY","tooltipShown","handleMoveTooltipGesture","handleColumnResizingGesture","handleOverResizeRegionGesture","_pointerOverHandler","handleOverColumnHeaderFooterGesture","shiftKey","isRangeSelectionGesture","getIsSelectionPending","preventDefault","pointerX","handleColumnResizeStartGesture","handleLeaveResizingGesture","boundingRect","handleLeaveTableTooltipGesture","_pointerEnterHandler","buttons","handleEnterResizingGesture","_clickHandler","platform","endElement","previousElement","handleRangeSelectionGesture","metaKey","ctrlKey","stopPropagation","pointerHandlingProps","onPointerOver","onClick","useScrollHandling","isLayoutRequired","horizontalScrollPositionOverride","verticalScrollPositionOverride","horizontalScrollPositionOverrideRef","verticalScrollPositionOverrideRef","_scrollHandler","offsetWidth","hideOutOfViewTooltip","scrollerEventElement","body","documentElement","window","addEventListener","removeEventListener","onScroll","_defaultDisabledRowInteractionKeys","useInteractionManager","cellHasRenderer","useCollectionInteractionContext","disabledRowInteractionKeys","isExtendableSelection","keyboardHandlingProps","_keyDownHandler","keyHandlers","repeat","Enter","_isSortActionGesture","handleSortActionGesture","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Home","End","includes","onKeyUp","useKeyboardHandling","scrollHandlingProps","interactionManagerProps","mergeProps","useImperativeHandle","applyLayoutColumnWidths","innerTableElement","widthOffset","isFixed","sampledColumnNetWidthsRef","availableRealWidth","staticColumnWidths","newNetColumnWidths","totalRealWidth","realWidthsArray","tableCols","totalBorderWidth","borderEdge","availableNetWidth","DEFAULT_COLUMN_WEIGHT","DEFAULT_COLUMN_MIN_WIDTH","DEFAULT_COLUMN_MAX_WIDTH","requiresActiveSizing","totalWorkingWeight","forcedTotalNetWidth","pendingTotalNetWidth","columnMaxWidthsArray","columnWeightsArray","forcedColumnNetWidthsArray","newColumnNetWidthsArray","appliedColumnNetWidthsArray","columnMinWidth","minWidth","columnMaxWidth","maxWidth","columnWeight","weight","forcedTotalWidth","forcedColumnWidthsArray","newColumnWidthsArray","appliedColumnWidthsArray","isMaxRuleApplied","_enforceWeightedMinRules","pendingTotalWidth","_enforceFixedMinMaxRules","_getFixedLayoutColumnNetWidths","_updateTableSizing","_createColumnWidths","_getContentsLayoutColumnNetWidths","realWidth","columnMinWidthsArray","totalPreferredNetWidth","totalRemainingWeight","sampledNetWidths","sampledMinNetWidthsArray","sampledWeightNetWidthsArray","minWidths","weightWidths","sampledWeightNetWidth","sampledMinNetWidth","forcedWidth","columnNetWidth","totalPreferredWidth","appliedPendingTotalWidth","_enforceConstrainedWeightRules","_enforceContentsMinMaxRules","initialExtraWidth","currentWeightTotal","currentWeight","weightWidth","totalWeight","pendingForcedColumnWidths","isMinRuleApplied","widthDiff","netWidthsArray","logicalWidthsArray","columnWidths","offset","realColumnWidths","tableLayout","useSizingManager","innerTableRef","externalScrollerRef","layout","columns","columnOrder","scrollerRef","setScrollerRef","createRef","scrollerRefCallback","node","UNSAFE_DOM_ACCESS","onBusyStart","onResizeScrollerBusyStart","onBusyEnd","onResizeScrollerBusyEnd","useAddBusyState","onResizeTableBusyStart","onResizeTableBusyEnd","_isScrollbarSizeKnown","setIsScrollbarSizeKnown","setAppliedColumnWidths","innerTableHeight","setInnerTableHeight","isScrollbarSizeKnown","pendingResizeEntriesRef","tableViewportConfig","config","getViewportConfig","newColumnsArray","entries","getStickyColumnIndicies","stickyColumnsCount","newColumnBorderEdges","isPreviousColumnHasEnd","isLastColumn","isLastStickyColumn","netWidth","staticWidth","defaultScrollbarWidth","totalWidth","newColumnWidths","_updateStickyEdgesFromResize","handleResizeCallback","currentEntry","isOveralSizeHandled","newContentWidth","contentBoxSize","inlineSize","newContentHeight","blockSize","newBoxWidth","borderBoxSize","newBoxHeight","availableWidthOffset","defaultScrollbarHeight","columnWidths1","columnWidths2","keys1","keys2","columnWidthsComparator","innerTableRect","innerTable","handleResizeCallbackRef","staticHandleScrollerResize","entry","requestAnimationFrame","staticHandleInnerTableResize","useResizeObserver","_defaultSelected","_disabledHeaderFooterInteractionKeys","Table","forwardRef","ariaLabel","ariaLabelledBy","gridlines","columnResizingIndicator","testId","testIdProps","useTestId","setRootRef","rootRefCallback","direction","forcedColors","useUser","onTableLoadMore","d","loadMoreDataRef","useDataManager","hasRenderer","ariaRowCount","ariaColumnCount","TableRedwoodTheme","pendingLayout","externalScroller","scrollerStyle","scrollerPadding","scrollerClassArray","forceScroll","scrollerClasses","tableClasses","innerTableStyles","supportsMultipleSelection","FocusTracker","onStartTracking","TabbableModeContext","getTableStyle","getTableColGroupProps","getTableDragIndicator"],"mappings":"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"}