{"version":3,"file":"mergeProps-bcfa6a92.js","sources":["../../src/utils/UNSAFE_mergeProps/mergeProps.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2011 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\n//  MIT License\n\n//  Copyright (c) 2018 Andrew Branch\n\n//  Permission is hereby granted, free of charge, to any person obtaining a copy\n//  of this software and associated documentation files (the \"Software\"), to deal\n//  in the Software without restriction, including without limitation the rights\n//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n//  copies of the Software, and to permit persons to whom the Software is\n//  furnished to do so, subject to the following conditions:\n\n//  The above copyright notice and this permission notice shall be included in all\n//  copies or substantial portions of the Software.\n\n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n//  SOFTWARE.\n\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never;\n\n/**\n * pushProps\n * @param target\n * @param key\n * @param value\n * @returns\n */\nfunction pushProp(target: Record<string, any>, key: string, value: any): void {\n  if (key === 'class') {\n    const oldClass = target['class'];\n    target['class'] = oldClass ? [oldClass, value].join(' ').trim() : value;\n  } else if (key === 'style') {\n    if (typeof value == 'object') {\n      target['style'] = { ...target['style'], ...value };\n    } else {\n      throw new Error(\n        `Unable to merge prop '${key}'. ` + `Only support 'style' objects not 'style' strings`\n      );\n    }\n  } else if (typeof value === 'function') {\n    type AnyFunc = (...args: any) => void;\n    const oldFn = target[key] as AnyFunc | undefined;\n    target[key] = oldFn\n      ? (...args: any[]) => {\n          oldFn(...args);\n          (value as AnyFunc)(...args);\n        }\n      : value;\n  } else if (\n    // skip undefined values\n    value === undefined ||\n    // skip if same\n    (typeof value !== 'object' && value === target[key])\n  ) {\n    return;\n  } else if (!(key in target)) {\n    target[key] = value;\n  } else if (\n    key === 'aria-describedby' ||\n    key === 'aria-labelledby' ||\n    key === 'aria-owns' ||\n    key === 'aria-controls' ||\n    key === 'aria-details'\n  ) {\n    // concatenate values together using a space delimiter as per\n    // https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes\n    const oldAria = target[key];\n    target[key] = oldAria ? [oldAria, value].join(' ').trim() : value;\n  } else {\n    // Currently the primary use of this utility is to merge together the spread properties returned by multiple hooks.\n    // Given that we don't want to overwrite a property that was returned from one hook with the value from another hook.\n    // Potentially it will break functionality of the hook whose value was overwritten. That is why we prefer to throw an error\n    // instead of merging the given properties. We can revisit this if we ever run into a case where our hooks\n    // produce conflicting properties.\n    throw new Error(\n      `Unable to merge prop '${key}'. ` +\n        `Only support 'className', 'style', some aria properties, and event handlers`\n    );\n  }\n}\n\n/**\n * Merges allProps together:\n *  - duplicate className and class allProps concatenated\n *  - duplicate style allProps merged - note that only style objects supported at this point\n *  - duplicate functions chained\n * @param allProps Props to merge together.\n */\nexport function mergeProps<T extends { [key: string]: any }[]>(\n  ...allProps: T\n): {\n  [K in keyof UnionToIntersection<T[number]>]: K extends 'class'\n    ? string\n    : K extends 'style'\n    ? UnionToIntersection<T[number]>[K]\n    : Exclude<Extract<T[number], { [Q in K]: unknown }>[K], undefined>;\n} {\n  if (allProps.length === 1) {\n    return allProps[0] as any;\n  }\n\n  return allProps.reduce((merged, props: any) => {\n    for (const key in props) {\n      pushProp(merged, key, props[key]);\n    }\n    return merged;\n  }, {}) as any;\n}\n"],"names":["pushProp","target","key","value","oldClass","join","trim","Error","oldFn","args","undefined","oldAria","allProps","length","reduce","merged","props"],"mappings":"6CAyCA,SAASA,EAASC,EAA6BC,EAAaC,GAC1D,GAAY,UAARD,EAAiB,CACnB,MAAME,EAAWH,EAAc,MAC/BA,EAAc,MAAIG,EAAW,CAACA,EAAUD,GAAOE,KAAK,KAAKC,OAASH,CACnE,MAAM,GAAY,UAARD,EAAiB,CAC1B,GAAoB,iBAATC,EAGT,MAAM,IAAII,MACR,yBAAyBL,wDAH3BD,EAAc,MAAI,IAAKA,EAAc,SAAME,EAM9C,MAAM,GAAqB,mBAAVA,EAAsB,CAEtC,MAAMK,EAAQP,EAAOC,GACrBD,EAAOC,GAAOM,EACV,IAAIC,KACFD,KAASC,GACRN,KAAqBM,EAAK,EAE7BN,CACL,KAAM,SAEKO,IAAVP,GAEkB,iBAAVA,GAAsBA,IAAUF,EAAOC,GAE/C,OACK,GAAMA,KAAOD,EAEb,IACG,qBAARC,GACQ,oBAARA,GACQ,cAARA,GACQ,kBAARA,GACQ,iBAARA,EAYA,MAAM,IAAIK,MACR,yBAAyBL,mFAZ3B,CAGA,MAAMS,EAAUV,EAAOC,GACvBD,EAAOC,GAAOS,EAAU,CAACA,EAASR,GAAOE,KAAK,KAAKC,OAASH,CAC7D,CAUA,MAtBCF,EAAOC,GAAOC,CAsBf,CACH,cASgB,YACXS,GAQH,OAAwB,IAApBA,EAASC,OACJD,EAAS,GAGXA,EAASE,QAAO,CAACC,EAAQC,KAC9B,IAAK,MAAMd,KAAOc,EAChBhB,EAASe,EAAQb,EAAKc,EAAMd,IAE9B,OAAOa,CAAM,GACZ,CAAE,EACP"}