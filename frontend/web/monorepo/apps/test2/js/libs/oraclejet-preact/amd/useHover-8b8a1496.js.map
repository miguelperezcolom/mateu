{"version":3,"file":"useHover-8b8a1496.js","sources":["../../src/hooks/UNSAFE_useHover/useHover.ts"],"sourcesContent":["import { useToggle } from '../UNSAFE_useToggle';\nimport { useCallback } from 'preact/hooks';\n\nexport type HoverOptions = {\n  isDisabled?: boolean;\n};\n\n/**\n * Returns listeners and status for hover\n * If only visual changes are required, :hover is faster.\n *\n * @returns\n */\nexport function useHover(settings: HoverOptions = { isDisabled: false }): {\n  isHover: boolean;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  hoverProps: Record<string, any>;\n} {\n  // :hover is faster than event handlers, but doesn't work for all platforms.\n  // For touch-first devices, the media query for hover is enough.\n  // Hybrid devices support hover upon pointer usage, but tapping would toggle hover state\n  // so disable :hover and use event handlers for such devices.\n  // Use getClientHints to check if hybrid\n  // const isHybrid = getClientHints().hoverSupport === 'events';\n  // Classes can be done via :\n  //     !isHybrid && compStyles.pseudohover,\n  //      isHybrid && isHover && compStyles.hover\n  // and the props can be done via:\n  //     const { hoverProps, isHover } = useHover( {isDisabled: !isHybrid});\n  //\n  // For the algorithm below, There are 2 possible sequences:\n  // 1. A pointer (mouse, trackpad) would generate a mouseEnter event that would initiate hover.\n  // 2. A touch generates a touchstart/touchend/mouseEnter event sequence.\n  // Hover has no meaning in a touch context, so the isHover state should be avoided.\n  // To avoid, we set an ignore flag when a touchend is encountered.\n  // Each time mouseEnter is encountered, the flag is checked.\n  // If ignore, we know that it is a touch device, so don't set hover state.\n  // In all cases, reset the flag for the next sequence.\n  //\n  const { bool, setTrue, setFalse } = useToggle(false);\n  const { bool: ignore, setTrue: setIgnoreTrue, setFalse: setIgnoreFalse } = useToggle(false);\n\n  const startHover = useCallback(() => {\n    if (ignore) {\n      setIgnoreFalse();\n    } else {\n      setTrue();\n    }\n  }, [ignore, setIgnoreFalse, setTrue]);\n\n  const hoverProps = settings.isDisabled\n    ? {}\n    : { onTouchEnd: setIgnoreTrue, onMouseEnter: startHover, onMouseLeave: setFalse };\n  return {\n    isHover: settings.isDisabled ? false : bool,\n    hoverProps: hoverProps\n  };\n}\n"],"names":["settings","isDisabled","bool","setTrue","setFalse","useToggle","ignore","setIgnoreTrue","setIgnoreFalse","startHover","useCallback","hoverProps","onTouchEnd","onMouseEnter","onMouseLeave","isHover"],"mappings":"kGAaM,SAAmBA,EAAyB,CAAEC,YAAY,IA0B9D,MAAMC,KAAEA,EAAIC,QAAEA,EAAOC,SAAEA,GAAaC,EAAAA,WAAU,IACtCH,KAAMI,EAAQH,QAASI,EAAeH,SAAUI,GAAmBH,aAAU,GAE/EI,EAAaC,EAAAA,aAAY,KACzBJ,EACFE,IAEAL,GACD,GACA,CAACG,EAAQE,EAAgBL,IAEtBQ,EAAaX,EAASC,WACxB,CAAE,EACF,CAAEW,WAAYL,EAAeM,aAAcJ,EAAYK,aAAcV,GACzE,MAAO,CACLW,SAASf,EAASC,YAAqBC,EACvCS,WAAYA,EAEhB"}