{"version":3,"file":"lineUtils-81206f70.js","sources":["../../src/utils/PRIVATE_visSVGUtils/pathUtils.ts","../../src/utils/PRIVATE_visSVGUtils/lineUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Point, lineCardinal, lineCardinalClosed, lineMonotone } from './lineUtils';\n\nconst SPLINE_TYPE_MONOTONE_VERTICAL = 'mv';\nconst SPLINE_TYPE_MONOTONE_HORIZONTAL = 'mh';\nconst SPLINE_TYPE_CARDINAL_CLOSED = 'cc';\n\n/**\n * Returns a curved path command, based on cubic hermite splines, that goes through the points in the points array.\n * @param {array} points Polyline points array.\n * @param {boolean} connectWithLine Whether the first point is reached using lineTo. Otherwise, moveTo is used.\n * @param {string} type The spline type.\n * @return {string} Path commands.\n */\nexport function curveThroughPoints(points: Point[], connectWithLine: boolean, splineType: string) {\n  if (points.length == 0) return '';\n\n  const prefix = connectWithLine ? 'L' : 'M';\n\n  if (splineType == SPLINE_TYPE_MONOTONE_VERTICAL) {\n    return prefix + lineMonotone(points, false);\n  } else if (splineType == SPLINE_TYPE_MONOTONE_HORIZONTAL) {\n    return prefix + lineMonotone(points, true);\n  } else if (splineType == SPLINE_TYPE_CARDINAL_CLOSED) {\n    return prefix + lineCardinalClosed(points, 0.7);\n  } else {\n    return prefix + lineCardinal(points, 0.7);\n  }\n}\n\n/**\n * Returns a path command for a move to the specified coordinates\n * @param x the destination x coordinate\n * @param y the destination y coordinate\n * @returns the moveTo path command\n */\nexport function moveTo(x: number, y: number) {\n  return 'M' + x + ',' + y;\n}\n\n/**\n * Returns a path command for a line to the specified coordinates\n * @param x the destination x coordinate\n * @param y the destination y coordinate\n * @returns the lineTo path command\n */\nexport function lineTo(x: number, y: number) {\n  return 'L' + x + ',' + y;\n}\n\n/**\n * Returns a path command for a vertical line to the specified x coordinate\n * @param x the destination x coordinate\n * @returns the horizontal line path command\n */\nexport function horizontalLineTo(x: number) {\n  return 'H' + x;\n}\n\n/**\n * Returns a path command for a horizontal line to the specified y coordinate\n * @param y the destination y coordinate\n * @returns the vertical line path command\n */\nexport function verticalLineTo(y: number) {\n  return 'V' + y;\n}\n\n/**\n * Returns a path command for a rectangle.\n * @param x Rectangle x.\n * @param y Rectangle y.\n * @param w Rectangle width.\n * @param h Rectangle height.\n * @returns Path command.\n */\nfunction rectangle(x: number, y: number, w: number, h: number) {\n  const cmd =\n    moveTo(x, y) +\n    horizontalLineTo(x + w) +\n    verticalLineTo(y + h) +\n    horizontalLineTo(x) +\n    closePath();\n\n  return cmd;\n}\n\n/**\n * Returns a path command for an arc to the specified coordinates\n * @param rx the x radius of the ellipse whose arc will be drawn\n * @param ry the y radius of the ellipse whose arc will be drawn\n * @param angleExtent the sweep of the arc to be drawn\n * @param direction 1 for clockwise, 0 for counter-clockwise\n * @param x the ending x coordinate\n * @param y the ending y coordinate\n */\nexport function arcTo(\n  rx: number,\n  ry: number,\n  angleExtent: number,\n  direction: number,\n  x: number,\n  y: number\n) {\n  let cmd = 'A' + rx + ',' + ry + ',0,';\n  if (angleExtent > Math.PI) {\n    cmd += '1,';\n  } else {\n    cmd += '0,';\n  }\n  cmd += direction + ',' + x + ',' + y;\n  return cmd;\n}\n\n/**\n * Returns a path command that closes the path.\n */\nexport function closePath() {\n  return 'Z';\n}\n\n/**\n * Parse corner radii and return the new shape.\n *\n * Sample (valid) radius values:\n *  '5px' - 5px all corners\n *  '50% 50% 0 0' - 50% top corners, 0 bottom corners\n *  '50% 10' - 50% top left bottom right, 10px top right bottom left.\n *  '5px / 10px' - 5px horizontal radius, 10px vertical radius all corners\n *  '50% 50% 25% 25% / 25% 25% 50% 50%' - 50% h radius 25% v radius top corners, 25% h radius 50% v radius bottom corners\n *\n * Note that all non-% values (including unitless) get interpreted as 'px'.\n *\n * @param x Rectangle x.\n * @param y Rectangle y.\n * @param w Rectangle width.\n * @param h Rectangle height.\n * @param radius The string to be parsed.\n * @param multiplier The value used for when a percent radius is provided\n * @param defaultValue A specified value for the border radius\n * @returns Path command of shape with border radius.\n */\nexport function rectangleWithBorderRadius(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  radius: string,\n  multiplier: number,\n  defaultValue: string\n) {\n  if (radius == '0' || radius === '0px') return rectangle(x, y, w, h);\n\n  let topLeftX = defaultValue;\n  let topLeftY = defaultValue;\n  let topRightX = defaultValue;\n  let topRightY = defaultValue;\n  let bottomRightX = defaultValue;\n  let bottomRightY = defaultValue;\n  let bottomLeftX = defaultValue;\n  let bottomLeftY = defaultValue;\n  if (radius.indexOf('/') != -1) {\n    const splitHorizVert = radius.split('/');\n    const horiz = splitHorizVert[0].trim().split(/\\s+/);\n    const vert = splitHorizVert[1].trim().split(/\\s+/);\n    if (horiz.length == 1) topLeftX = topRightX = bottomRightX = bottomLeftX = horiz[0];\n    else if (horiz.length == 2) {\n      topLeftX = bottomRightX = horiz[0];\n      topRightX = bottomLeftX = horiz[1];\n    } else if (horiz.length == 3) {\n      topLeftX = horiz[0];\n      topRightX = bottomLeftX = horiz[1];\n      bottomRightX = horiz[2];\n    } else if (horiz.length == 4) {\n      topLeftX = horiz[0];\n      topRightX = horiz[1];\n      bottomRightX = horiz[2];\n      bottomLeftX = horiz[3];\n    }\n    if (vert.length == 1) topLeftY = topRightY = bottomRightY = bottomLeftY = vert[0];\n    else if (vert.length == 2) {\n      topLeftY = bottomRightY = vert[0];\n      topRightY = bottomLeftY = vert[1];\n    } else if (vert.length == 3) {\n      topLeftY = vert[0];\n      topRightY = bottomLeftY = vert[1];\n      bottomRightY = vert[2];\n    } else if (vert.length == 4) {\n      topLeftY = vert[0];\n      topRightY = vert[1];\n      bottomRightY = vert[2];\n      bottomLeftY = vert[3];\n    }\n  } else if (radius != 'auto') {\n    const split = radius.trim().split(/\\s+/);\n    if (split.length == 1) {\n      topLeftX =\n        topRightX =\n        bottomRightX =\n        bottomLeftX =\n        topLeftY =\n        topRightY =\n        bottomRightY =\n        bottomLeftY =\n          split[0];\n    } else if (split.length == 2) {\n      topLeftX = bottomRightX = topLeftY = bottomRightY = split[0];\n      topRightX = bottomLeftX = topRightY = bottomLeftY = split[1];\n    } else if (split.length == 3) {\n      topLeftX = topLeftY = split[0];\n      topRightX = bottomLeftX = topRightY = bottomLeftY = split[1];\n      bottomRightX = bottomRightY = split[2];\n    } else if (split.length == 4) {\n      topLeftX = topLeftY = split[0];\n      topRightX = topRightY = split[1];\n      bottomRightX = bottomRightY = split[2];\n      bottomLeftX = bottomLeftY = split[3];\n    }\n  }\n\n  return roundedRectangle(\n    x,\n    y,\n    w,\n    h,\n    parseBorderRadiusItem(topLeftX, multiplier),\n    parseBorderRadiusItem(topLeftY, multiplier),\n    parseBorderRadiusItem(topRightX, multiplier),\n    parseBorderRadiusItem(topRightY, multiplier),\n    parseBorderRadiusItem(bottomRightX, multiplier),\n    parseBorderRadiusItem(bottomRightY, multiplier),\n    parseBorderRadiusItem(bottomLeftX, multiplier),\n    parseBorderRadiusItem(bottomLeftY, multiplier)\n  );\n}\n\n/**\n * Parses a single corner radius dimension\n * @param item The x or y radius input need to be parsed\n * @param multiplier The value used for when a percent radius is provided\n * @returns The integer value of the corner radius\n */\nfunction parseBorderRadiusItem(item: string, multiplier: number) {\n  let radius = Math.min(parseFloat(item), multiplier / 2);\n  if (item.indexOf('%') != -1) {\n    radius = Math.min(50, parseFloat(item)) * 0.01 * multiplier;\n  }\n  return radius;\n}\n\n/**\n * Returns a path command for a rounded rectangle.\n * @param x Rectangle x.\n * @param y Rectangle y.\n * @param w Rectangle width.\n * @param h Rectangle height.\n * @param tlcrX Top left corner x radius.\n * @param tlcrY Top left corner y radius.\n * @param trcrX Top right corner x radius.\n * @param trcrY Top right corner y radius.\n * @param brcrX Bottom right corner x radius.\n * @param brcrY Bottom right corner y radius.\n * @param blcrX Bottom left corner x radius.\n * @param blcrY Bottom left corner  y radius.\n * @returns Path command.\n */\nfunction roundedRectangle(\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  tlcrX: number,\n  tlcrY: number,\n  trcrX: number,\n  trcrY: number,\n  brcrX: number,\n  brcrY: number,\n  blcrX: number,\n  blcrY: number\n) {\n  tlcrY = Math.min(tlcrY, 0.5 * h);\n  trcrY = Math.min(trcrY, 0.5 * h);\n  brcrY = Math.min(brcrY, 0.5 * h);\n  blcrY = Math.min(blcrY, 0.5 * h);\n  tlcrX = Math.min(tlcrX, 0.5 * w);\n  trcrX = Math.min(trcrX, 0.5 * w);\n  brcrX = Math.min(brcrX, 0.5 * w);\n  blcrX = Math.min(blcrX, 0.5 * w);\n  const cmd =\n    moveTo(x + tlcrX, y) +\n    lineTo(x + w - trcrX, y) +\n    arcTo(trcrX, trcrY, Math.PI / 2, 1, x + w, y + trcrY) +\n    lineTo(x + w, y + h - brcrY) +\n    arcTo(brcrX, brcrY, Math.PI / 2, 1, x + w - brcrX, y + h) +\n    lineTo(x + blcrX, y + h) +\n    arcTo(blcrX, blcrY, Math.PI / 2, 1, x, y + h - blcrY) +\n    lineTo(x, y + tlcrY) +\n    arcTo(tlcrX, tlcrY, Math.PI / 2, 1, x + tlcrX, y) +\n    closePath();\n\n  return cmd;\n}\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getCmdPoints } from '#utils/PRIVATE_chartUtils/utils';\nimport { AllLineType } from '#utils/UNSAFE_visTypes/common/common.types';\nimport { curveThroughPoints } from './pathUtils';\n\nexport type Point = [number, number];\n\n/**\n * Adapted from D3.js -- d3_svg_lineLinear\n * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].\n * @return {string} Path commands.\n */\nexport function lineLinear(points: Point[]) {\n  return points.join('L');\n}\n\n/**\n * Adapted from D3.js -- d3_svg_lineCardinalClosed\n * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].\n * @param {number} tension A number from 0 to 1 specifying the tension.\n * @return {string} Path commands.\n */\nexport function lineCardinalClosed(points: Point[], tension: number) {\n  // TODO: remove ts-ignores\n  if (points.length < 3) {\n    return lineLinear(points);\n  }\n  /** @ts-ignore */\n  const tangents: Point[] = lineCardinalTangents(\n    [points[points.length - 2]].concat(points, [points[1]]),\n    tension\n  );\n\n  return (\n    points[0] +\n    lineHermite(\n      (points.push(points[0]), points),\n      points,\n      /** @ts-ignore */\n      tangents\n    )\n  );\n}\n\n/**\n * Adapted from D3.js -- d3_svg_lineCardinal\n * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].\n * @param {number} tension A number from 0 to 1 specifying the tension.\n * @return {string} Path commands.\n */\nexport function lineCardinal(points: Point[], tension: number) {\n  return points.length < 3\n    ? lineLinear(points)\n    : points[0] +\n        lineHermite(\n          points,\n          // @ts-ignore\n          lineCardinalTangents(points, tension)\n        );\n}\n\n/**\n * Adapted from D3.js -- d3_svg_lineHermite\n * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].\n * @param {array} tangents Tangents in the form of [[t0x t0y] [t1x t1y] ...].\n * @return {string} Path commands.\n */\nexport function lineHermite(points: Point[], tangents: Point[]) {\n  if (\n    tangents.length < 1 ||\n    (points.length != tangents.length && points.length != tangents.length + 2)\n  ) {\n    return lineLinear(points);\n  }\n  const quad = points.length != tangents.length;\n  let path = '';\n  let p0 = points[0];\n  let p = points[1];\n  const t0 = tangents[0];\n  let t = t0;\n  let pi = 1;\n  if (quad) {\n    path +=\n      'Q' +\n      Math.round(p[0] - (t0[0] * 2) / 3) +\n      ',' +\n      Math.round(p[1] - (t0[1] * 2) / 3) +\n      ',' +\n      Math.round(p[0]) +\n      ',' +\n      Math.round(p[1]);\n    p0 = points[1];\n    pi = 2;\n  }\n  if (tangents.length > 1) {\n    t = tangents[1];\n    p = points[pi];\n    pi++;\n    path +=\n      'C' +\n      Math.round(p0[0] + t0[0]) +\n      ',' +\n      Math.round(p0[1] + t0[1]) +\n      ',' +\n      Math.round(p[0] - t[0]) +\n      ',' +\n      Math.round(p[1] - t[1]) +\n      ',' +\n      Math.round(p[0]) +\n      ',' +\n      Math.round(p[1]);\n    for (let i = 2; i < tangents.length; i++, pi++) {\n      p = points[pi];\n      t = tangents[i];\n      path +=\n        'S' +\n        Math.round(p[0] - t[0]) +\n        ',' +\n        Math.round(p[1] - t[1]) +\n        ',' +\n        Math.round(p[0]) +\n        ',' +\n        Math.round(p[1]);\n    }\n  }\n  if (quad) {\n    const lp = points[pi];\n    path +=\n      'Q' +\n      Math.round(p[0] + (t[0] * 2) / 3) +\n      ',' +\n      Math.round(p[1] + (t[1] * 2) / 3) +\n      ',' +\n      Math.round(lp[0]) +\n      ',' +\n      Math.round(lp[1]);\n  }\n  return path;\n}\n\n/**\n * Adapted from D3.js -- d3_svg_lineCardinalTangents\n * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].\n * @param {number} tension A number from 0 to 1 specifying the tension.\n * @return {array} Tangents in the form of [[t0x t0y] [t1x t1y] ...].\n */\nexport function lineCardinalTangents(points: Point[], tension: number) {\n  const tangents = [];\n  const a = (1 - tension) / 2;\n  let p0;\n  let p1 = points[0];\n  let p2 = points[1];\n  let i = 1;\n  const n = points.length;\n  while (++i < n) {\n    p0 = p1;\n    p1 = p2;\n    p2 = points[i];\n    tangents.push([a * (p2[0] - p0[0]), a * (p2[1] - p0[1])]);\n  }\n  return tangents;\n}\n\n/**\n * Adapted from D3.js -- d3_svg_lineSlope\n * @param {array} p0 Point in the form of [x y].\n * @param {array} p1 Point in the form of [x y].\n * @return {number} Slope.\n */\nexport function lineSlope(p0: Point, p1: Point) {\n  return (p1[1] - p0[1]) / (p1[0] - p0[0]);\n}\n\n/**\n * Adapted from D3.js -- d3_svg_lineFiniteDifferences\n * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].\n * @return {array} Finite differences.\n */\nexport function lineFiniteDifferences(points: Point[]) {\n  let i = 0;\n  const j = points.length - 1;\n  const m = [];\n  let p0 = points[0];\n  let p1 = points[1];\n  let d = (m[0] = lineSlope(p0, p1));\n  while (++i < j) {\n    m[i] = (d + (d = lineSlope((p0 = p1), (p1 = points[i + 1])))) / 2;\n  }\n  m[i] = d;\n  return m;\n}\n\n/**\n * Adapted from D3.js -- d3_svg_lineMonotoneTangents\n * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].\n * @param {boolean} isHoriz If true, the spline is monotonic in X. Otherwise, it is monotonic in Y.\n * @return {array} Tangents in the form of [[t0x t0y] [t1x t1y] ...].\n */\nexport function lineMonotoneTangents(points: Point[], isHoriz: boolean) {\n  if (isHoriz)\n    // swap x and y\n    points = _rotatePoints(points);\n\n  let tangents: Point[] = [],\n    d,\n    a,\n    b,\n    s;\n  const m = lineFiniteDifferences(points);\n  let i = -1;\n  const j = points.length - 1;\n  while (++i < j) {\n    d = lineSlope(points[i], points[i + 1]);\n    if (Math.abs(d) < 1e-6) {\n      m[i] = m[i + 1] = 0;\n    } else {\n      a = m[i] / d;\n      b = m[i + 1] / d;\n      s = a * a + b * b;\n      if (s > 9) {\n        s = (d * 3) / Math.sqrt(s);\n        m[i] = s * a;\n        m[i + 1] = s * b;\n      }\n    }\n  }\n  i = -1;\n  while (++i <= j) {\n    s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\n    tangents.push([s || 0, m[i] * s || 0]);\n  }\n\n  if (isHoriz)\n    // swap x and y again\n    tangents = _rotatePoints(tangents);\n\n  return tangents;\n}\n\n/**\n * Adapted from D3.js -- d3_svg_lineMonotone\n * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].\n * @param {boolean} isHoriz If true, the spline is monotonic in X. Otherwise, it is monotonic in Y.\n * @return {string} Path commands.\n */\nexport function lineMonotone(points: Point[], isHoriz: boolean) {\n  return points.length < 3\n    ? lineLinear(points)\n    : points[0] + lineHermite(points, lineMonotoneTangents(points, isHoriz));\n}\n\n/**\n * Rotate the points by swapping the x and y.\n * @param {array} points Points in the form of [[p0x p0y] [p1x p1y] ...].\n * @return {array} Rotated points.\n * @private\n */\nexport function _rotatePoints(points: Point[]): Point[] {\n  const rPoints: Point[] = [];\n  for (let i = 0; i < points.length; i++) {\n    rPoints.push([points[i][1], points[i][0]]);\n  }\n  return rPoints;\n}\n\nexport function getCmdsForLine(\n  lineSegmentCoords: Point[],\n  lineType: AllLineType,\n  isHoriz: boolean,\n  groupWidth?: number,\n  isRtl?: boolean,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n) {\n  const l = lineSegmentCoords.map((coord) => fixCoord(coord, isHoriz));\n  if (lineType === 'straight') {\n    return l.join();\n  } else if (lineType === 'curved') {\n    return curveThroughPoints(l, false, isHoriz ? 'mh' : 'mv');\n  } else {\n    return getCmdPoints(lineSegmentCoords, lineType, isHoriz, isRtl, groupWidth, timeAxisType);\n  }\n}\n\nexport function fixCoord(coord: Point, isHoriz: boolean): Point {\n  if (isHoriz) {\n    return [coord[1], coord[0]];\n  }\n  return [coord[0], coord[1]];\n}\n"],"names":["curveThroughPoints","points","connectWithLine","splineType","length","prefix","lineMonotone","lineCardinalClosed","lineCardinal","moveTo","x","y","lineTo","horizontalLineTo","verticalLineTo","arcTo","rx","ry","angleExtent","direction","cmd","Math","PI","closePath","parseBorderRadiusItem","item","multiplier","radius","min","parseFloat","indexOf","lineLinear","join","tension","lineCardinalTangents","concat","lineHermite","push","tangents","quad","path","p0","p","t0","t","pi","round","i","lp","a","p1","p2","n","lineSlope","lineFiniteDifferences","j","m","d","lineMonotoneTangents","isHoriz","_rotatePoints","b","s","abs","sqrt","max","rPoints","fixCoord","coord","lineSegmentCoords","lineType","groupWidth","isRtl","timeAxisType","l","map","getCmdPoints","w","h","defaultValue","rectangle","topLeftX","topLeftY","topRightX","topRightY","bottomRightX","bottomRightY","bottomLeftX","bottomLeftY","splitHorizVert","split","horiz","trim","vert","tlcrX","tlcrY","trcrX","trcrY","brcrX","brcrY","blcrX","blcrY","roundedRectangle"],"mappings":"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"}