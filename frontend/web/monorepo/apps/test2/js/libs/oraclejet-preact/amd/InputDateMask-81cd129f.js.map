{"version":3,"file":"InputDateMask-81cd129f.js","sources":["../../src/UNSAFE_InputDateMask/DateSegment.tsx","../../src/UNSAFE_InputDateMask/LiteralSegment.tsx","../../src/UNSAFE_InputDateMask/dateReducer.ts","../../src/UNSAFE_InputDateMask/useDateFieldHandlers.ts","../../src/UNSAFE_InputDateMask/DateField.tsx","../../src/UNSAFE_InputDateMask/useDateField.ts","../../src/UNSAFE_InputDateMask/InputDateMaskContext.ts","../../src/UNSAFE_InputDateMask/InputDateMask.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport type { RefObject, JSX } from 'preact';\nimport { useCallback, useEffect, useRef } from 'preact/hooks';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\nimport { BundleType } from '#resources/nls/bundle';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { DateReducerAction } from './dateReducer';\nimport { getClientHints } from '#utils/PRIVATE_clientHints';\nimport { EditableDateSegment } from './types';\nimport { isBackspaceOrDelete, isSelectAll } from '#utils/PRIVATE_keyboardUtils';\nimport { isNumberOnlyString } from '#utils/PRIVATE_dayUtils';\nimport { segmentStyles } from './themes/SegmentStyles.css';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\n\ntype AriaProps = Pick<\n  UnpackSignals<JSX.AriaAttributes>,\n  'aria-label' | 'aria-valuemax' | 'aria-valuemin' | 'aria-valuenow' | 'aria-valuetext'\n>;\n\ntype Props = AriaProps & {\n  /** A ref that is provided for the first segment in a date field. */\n  inputRef?: RefObject<HTMLDivElement>;\n\n  /**\n   * True if the segment is complete in the sense that it contains a complete valid value.\n   * For instance, entering '0' and then '1-9' is considered a complete value for month and day.\n   * Also true if typing any additional digit would cause the segment value to exceed the max.\n   */\n  isComplete?: boolean;\n\n  /**\n   * True if the segment is disabled.\n   */\n  isDisabled?: boolean;\n\n  /**\n   * True if the segment should be hidden.\n   */\n  isHidden?: boolean;\n\n  /**\n   * True if the segment is highlighted.\n   */\n  isHighlighted?: boolean;\n\n  /**\n   * True if the segment is invalid.\n   */\n  isInvalid?: boolean;\n\n  /**\n   * Specifies for accessibility purposes whether a value is required.\n   */\n  isRequired?: boolean;\n\n  /**\n   * True if the segment is selected.\n   */\n  isSelected?: boolean;\n\n  /**\n   * Placeholder displayed when the segment has no display value.\n   */\n  placeholder?: string;\n\n  /**\n   * The text to display for this segment.\n   */\n  text?: string;\n\n  /**\n   * The segment of a calendar date which is being represented, i.e. the month, day, or year.\n   */\n  type: EditableDateSegment;\n\n  /**\n   * Callback invoked when a change to the segment is requested via user action, such as typing\n   * a new value or pressing the Backspace or Delete keys.\n   */\n  onChange?: (action: DateReducerAction) => void;\n};\n\n// Used to disable browser cut and paste, which don't really work with segments (copy is fine).\nconst preventDefaultHandler = (e: Event) => {\n  e.preventDefault();\n};\n\nconst isIos = () => getClientHints().platform === 'ios';\n\n/**\n * A DateSegment renders a part of a calendar date, e.g. the day, month, or year.\n * It can be used as a spinbutton to step or spin its value.\n */\nexport const DateSegment = ({\n  'aria-label': ariaLabel,\n  'aria-valuemax': ariaValueMax,\n  'aria-valuemin': ariaValueMin,\n  'aria-valuenow': ariaValueNow,\n  'aria-valuetext': ariaValueText,\n  inputRef,\n  isComplete,\n  isDisabled,\n  isHidden,\n  isHighlighted,\n  isInvalid,\n  isRequired,\n  isSelected,\n  onChange,\n  placeholder,\n  text,\n  type\n}: Props) => {\n  const hasDisplayValue = text && text.length > 0;\n  const rootClasses = classNames([\n    segmentStyles.base,\n    isSelected && segmentStyles.selected,\n    isHighlighted && segmentStyles.highlighted\n  ]);\n  const placeholderClasses = classNames([\n    segmentStyles.placeholder,\n    isHidden || hasDisplayValue ? segmentStyles.hidden : segmentStyles.notHidden\n  ]);\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n  const emptySegmentValueText = translations.inputDateMask_empty_segment();\n\n  // If a ref was passed in, use it, otherwise get a ref.\n  const sRef = useRef<HTMLDivElement>(null);\n  const segmentRef = inputRef ?? sRef;\n\n  const hasLeadingZero = useRef<boolean>(false);\n  const { locale } = useUser();\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (\n        isDisabled ||\n        event.key === 'Tab' ||\n        event.key === 'ArrowLeft' ||\n        event.key === 'ArrowRight' ||\n        event.key === 'Enter' ||\n        // JET-73224: let Escape pass through in order to close a popup or dialog.\n        event.key === 'Escape' ||\n        isSelectAll(event)\n      ) {\n        // Let the event pass through.\n        return;\n      }\n\n      if (isHighlighted) {\n        // If date is selected, ignore edits and let backspace/delete pass through to clear.\n        if (isBackspaceOrDelete(event) || event.key === 'Backspace') {\n          return;\n        }\n      } else if (event.key === '0' && (isComplete || text === undefined)) {\n        // Typing '0' is considered a leading zero if the segment is complete, in which case\n        // the user is typing a new value, or if there is no current value.\n        hasLeadingZero.current = true;\n      } else if (isNumberOnlyString(event.key)) {\n        onChange?.({\n          actionType: 'updateSegment',\n          data: { type, text: event.key, hasLeadingZero: hasLeadingZero.current, locale }\n        });\n        hasLeadingZero.current = false;\n      } else if (isBackspaceOrDelete(event) || event.key === 'Backspace') {\n        // Android sends Backspace as event.key, not event.code, so check for it.\n        onChange?.({ actionType: 'clearSegment', data: { type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'ArrowUp') {\n        onChange?.({ actionType: 'step', data: { direction: 'increase', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'ArrowDown') {\n        onChange?.({ actionType: 'step', data: { direction: 'decrease', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'PageUp') {\n        onChange?.({ actionType: 'page', data: { direction: 'increase', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'PageDown') {\n        onChange?.({ actionType: 'page', data: { direction: 'decrease', locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'Home') {\n        onChange?.({ actionType: 'goToHome', data: { locale, type } });\n        hasLeadingZero.current = false;\n      } else if (event.key === 'End') {\n        onChange?.({ actionType: 'goToEnd', data: { locale, type } });\n        hasLeadingZero.current = false;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n    },\n    [isComplete, isDisabled, isHighlighted, locale, onChange, text, type]\n  );\n\n  // Used to focus the segment when isSelected is true.\n  useEffect(() => {\n    if (isSelected) {\n      segmentRef.current?.focus();\n    }\n  }, [isSelected, segmentRef]);\n\n  // This attribute is used to distinguish between segments when clicked (see DateField.tsx).\n  const customDataAttribute = { 'data-segment': [type] };\n\n  // If ariaValueText is undefined, substitute a string that indicates the segment is empty.\n  // If ariaValueNow and ariaValueText represent the same value, omit the value text; this\n  // is the same as what we do in NumberInputText.\n  const valueText =\n    ariaValueText === undefined\n      ? emptySegmentValueText\n      : ariaValueNow?.toString() === ariaValueText\n      ? undefined\n      : ariaValueText;\n\n  return (\n    // Introduce a div wrapper around the contentEditable element to prevent it from grabbing focus.\n    // https://stackoverflow.com/questions/34354085/clicking-outside-a-contenteditable-div-stills-give-focus-to-it\n    // JET-64874: We change the segment's role to \"textbox\" on iOS to work around a VoiceOver bug, and when we do that\n    // we need to add aria-multiline={false}\n    <div>\n      <div\n        ref={segmentRef}\n        role={isIos() ? 'textbox' : 'spinbutton'}\n        aria-disabled={isDisabled}\n        aria-invalid={isInvalid || undefined}\n        aria-label={ariaLabel}\n        aria-multiline={isIos() ? false : undefined}\n        aria-required={isRequired}\n        aria-valuemin={isIos() ? undefined : ariaValueMin}\n        aria-valuemax={isIos() ? undefined : ariaValueMax}\n        aria-valuenow={isIos() ? undefined : ariaValueNow}\n        aria-valuetext={isIos() ? undefined : valueText}\n        autocapitalize=\"off\"\n        autocorrect=\"off\"\n        class={rootClasses}\n        contentEditable={!isDisabled}\n        {...customDataAttribute}\n        enterkeyhint={isDisabled ? undefined : 'done'}\n        inputMode={isDisabled ? 'none' : 'numeric'}\n        onCut={preventDefaultHandler}\n        onKeyDown={onKeyDown}\n        onPaste={preventDefaultHandler}\n        spellcheck={false}\n        tabIndex={isSelected ? 0 : -1}>\n        <span aria-hidden=\"true\" class={placeholderClasses} {...customDataAttribute}>\n          {placeholder}\n        </span>\n        {text}\n      </div>\n    </div>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { segmentStyles } from './themes/SegmentStyles.css';\n\ntype Props = {\n  /**\n   * True if the segment should be hidden.\n   */\n  isHidden?: boolean;\n\n  /**\n   * True if the segment should be highlighted.\n   */\n  isHighlighted?: boolean;\n\n  /**\n   * True if the literal is part of a date placeholder, such as mm/dd/yyyy.\n   * If the date is partially specified or complete, this is false.\n   */\n  isPlaceholder?: boolean;\n\n  /**\n   * The text to display for this segment.\n   */\n  text: string;\n};\n\n/**\n * LiteralSegment is used to represent a literal separator in a calendar date,\n * such as the '/' in 11/29/2023.\n */\nexport const LiteralSegment = ({ isHidden, isHighlighted, isPlaceholder, text }: Props) => {\n  const spanClasses = classNames([\n    segmentStyles.literalBase,\n    isPlaceholder && segmentStyles.placeholder,\n    isHighlighted && segmentStyles.highlighted,\n    isHidden ? segmentStyles.hidden : segmentStyles.notHidden\n  ]);\n\n  return (\n    <span aria-hidden=\"true\" class={spanClasses}>\n      {text}\n    </span>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { DateFieldState, DateSegmentState } from './useDateField';\nimport { BCP47Locale } from '#UNSAFE_IntlDateTime';\nimport { CalendarDate, EditableDateSegment, IsoMonth } from './types';\nimport { getMonthName, getTodayAsCalendarDate } from '#utils/PRIVATE_dayUtils';\nimport { getDaysInMonth, getMonthsInYear, MAX_ISO_YEAR } from '#utils/UNSAFE_calendarDateUtils';\nimport { isLeapYear } from '#UNSAFE_IntlDateTime/dateTimeUtils';\n\ntype DirectionType = 'increase' | 'decrease';\ntype SegmentActionData = Pick<DateSegmentState, 'type'>;\ntype HomeEndActionData = SegmentActionData & {\n  locale: BCP47Locale;\n};\ntype PageStepActionData = SegmentActionData & {\n  direction: DirectionType;\n  locale: BCP47Locale;\n};\ntype UpdateActionData = SegmentActionData & {\n  text: string;\n  hasLeadingZero: boolean;\n  locale: BCP47Locale;\n};\ntype DateReducerAction =\n  | { actionType: 'clearDate'; data?: never }\n  | { actionType: 'clearSegment'; data: SegmentActionData }\n  | { actionType: 'commitOnBlur'; data?: never }\n  | { actionType: 'commitOnEnter'; data?: never }\n  | { actionType: 'committed'; data?: never }\n  | { actionType: 'deselectAndComplete'; data?: never }\n  | { actionType: 'goToEnd'; data: HomeEndActionData }\n  | { actionType: 'goToHome'; data: HomeEndActionData }\n  | { actionType: 'page'; data: PageStepActionData }\n  | { actionType: 'selectDateOrSegment'; data?: never }\n  | { actionType: 'selectFirst'; data?: never }\n  | { actionType: 'selectNext'; data?: never }\n  | { actionType: 'selectPrevious'; data?: never }\n  | { actionType: 'selectSegment'; data: SegmentActionData }\n  | { actionType: 'step'; data: PageStepActionData }\n  | { actionType: 'updateSegment'; data: UpdateActionData }\n  | { actionType: 'reset'; data: DateFieldState };\n\n/**\n * Reducer function for updating DateFieldState per the specified action.\n * @param state\n * @param action\n */\nconst dateReducer = (state: DateFieldState, action: DateReducerAction) => {\n  // On mount, the reducer is initialized with initial state derived from the DateField's value.\n  // If that value is changed programmatically afterwards, the only way to push that update\n  // into the reducer is to define a \"reset\" action.\n  if (action.actionType === 'reset') {\n    return action.data;\n  }\n\n  switch (action.actionType) {\n    case 'clearDate': {\n      const updatedSegments = selectFirst(clearDate(state.segments), state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'clearSegment': {\n      const updatedSegment = clearSegment(findSegment(state.segments, action.data.type));\n      return createDateFieldState(state, action.data.type, updatedSegment);\n    }\n    case 'deselectAndComplete': {\n      let updatedSegments = checkFeb29EdgeCase(state.segments);\n      updatedSegments = clearSelectionAndComplete(updatedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'commitOnBlur': {\n      const updatedSegments = checkFeb29EdgeCase(state.segments);\n      const updatedSegmentsClearedAndComplete = clearSelectionAndComplete(updatedSegments);\n      const newState = createDateFieldStateWithSelectedDate(\n        state,\n        updatedSegmentsClearedAndComplete,\n        false\n      );\n      return { ...newState, isCommitting: true };\n    }\n    case 'commitOnEnter': {\n      const updatedSegments = checkFeb29EdgeCase(state.segments);\n      const newState = createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n      return { ...newState, isCommitting: true };\n    }\n    case 'committed': {\n      return { ...state, isCommitting: false };\n    }\n    case 'goToEnd': {\n      const updatedSegment = goToEnd(\n        action.data.type,\n        findSegment(state.segments, action.data.type),\n        state.segments,\n        action.data.locale\n      );\n      return createDateFieldState(state, action.data.type, updatedSegment, false);\n    }\n    case 'goToHome': {\n      const updatedSegment = goToHome(\n        action.data.type,\n        findSegment(state.segments, action.data.type),\n        state.segments,\n        action.data.locale\n      );\n      return createDateFieldState(state, action.data.type, updatedSegment, false);\n    }\n    case 'page': {\n      const direction = action.data.direction;\n      const locale = action.data.locale;\n      const updatedSegment = doStepOrPage(\n        action.data.type,\n        findSegment(state.segments, action.data.type),\n        state.segments,\n        'page',\n        direction,\n        locale\n      );\n      return createDateFieldState(state, action.data.type, updatedSegment, false);\n    }\n    case 'selectDateOrSegment': {\n      return selectDateOrSegment(state);\n    }\n    case 'selectFirst': {\n      const updatedSegments = selectFirst(state.segments, state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'selectNext': {\n      const updatedSegments = selectNext(state.segments, state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'selectPrevious': {\n      const updatedSegments = selectPrevious(state.segments, state.orderedSegments);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'selectSegment': {\n      const updatedSegments = selectSegment(state.segments, action.data.type);\n      return createDateFieldStateWithSelectedDate(state, updatedSegments, false);\n    }\n    case 'step': {\n      const direction = action.data.direction;\n      const locale = action.data.locale;\n      const updatedSegment = doStepOrPage(\n        action.data.type,\n        findSegment(state.segments, action.data.type),\n        state.segments,\n        'step',\n        direction,\n        locale\n      );\n      return createDateFieldState(state, action.data.type, updatedSegment, false);\n    }\n    case 'updateSegment': {\n      const updatedSegment = updateSegment(\n        action.data.type,\n        findSegment(state.segments, action.data.type),\n        action,\n        state.segments\n      );\n      return createDateFieldState(state, action.data.type, updatedSegment);\n    }\n    default: {\n      throw new Error('Unknown action type');\n    }\n  }\n};\n\nconst stringToNumber = (s: string) => +s;\nconst numberToString = (n: number) => n.toString();\nconst withinRange = (n: number, min: number, max: number) => n >= min && n <= max;\n\nconst findSegment = (segments: DateSegmentState[], type: EditableDateSegment): DateSegmentState => {\n  return segments.find((segment) => segment.type === type)!;\n};\n\n// A segment is considered complete if appending a zero to the current value causes it\n// to exceed the max. For instance, if you type 2-9 into month or 4-9 into day, the\n// segment is complete because you can't type any more digits and have it be a valid value.\nconst isSegmentComplete = (val: number, max: number) => {\n  const num = stringToNumber(numberToString(val) + '0');\n  return num > max;\n};\n\n// A date is considered complete if all of its segments have values.\nconst isDateComplete = (allSegments: DateSegmentState[]) => {\n  return allSegments.every((seg) => seg.text && seg.text.length > 0);\n};\n\n// A date is considered a partial date if at least one segment has a value.\nconst isPartialDate = (allSegments: DateSegmentState[]) => {\n  return allSegments.some((seg) => seg['aria-valuenow'] !== undefined);\n};\n\n// Construct a calendar date that reflects the values of each segment.\n// If none of the segments have a value, return undefined.\nconst createCalendarDateFromSegments = (segments: DateSegmentState[]) => {\n  const hasAnySegmentWithAValue = isPartialDate(segments);\n  if (!hasAnySegmentWithAValue) {\n    return undefined;\n  }\n\n  // This returns something that looks like [ {month: 12}, {day: 25}, {year: 2020} ].\n  // Note: we use the aria-valuenow to get the current value as a number (not string).\n  const segmentValues = segments.map((seg) => {\n    return { [seg.type]: seg['aria-valuenow'] };\n  });\n\n  // Iterate over segmentValues and spread each value to get {month: 12, day:25, year: 2020}.\n  const iterator = segmentValues.values();\n  let cd: CalendarDate = {};\n  for (const segValue of iterator) {\n    cd = { ...cd, ...segValue };\n  }\n  return cd;\n};\n\n// Find the current value for year.\nconst getYearValue = (segments: DateSegmentState[]) => {\n  const yearState = findSegment(segments, 'year');\n  return yearState['aria-valuenow'];\n};\n\n// Find the current value for month.\nconst getMonthValue = (segments: DateSegmentState[]) => {\n  const monthState = findSegment(segments, 'month');\n  return monthState['aria-valuenow'] as IsoMonth;\n};\n\n// Determine the aria-valuetext for the given month, which includes the month name.\nconst getMonthAria = (locale: BCP47Locale, month: IsoMonth, year: number | undefined) => {\n  const monthName = getMonthName(locale, month, year ?? '*', 'long');\n  return `${month} - ${monthName}`;\n};\n\n// Return a copy of the ordered segments array.\nconst getOrderedSegments = (currentState: DateFieldState) => {\n  return [...currentState.orderedSegments];\n};\n\n// Replace the updated segment and return a new DateSegmentState[].\nconst replaceDateSegment = (\n  existingSegments: DateSegmentState[],\n  updatedSegmentType: EditableDateSegment,\n  updatedSegment: DateSegmentState\n) => {\n  return existingSegments.map((seg) => (seg.type === updatedSegmentType ? updatedSegment : seg));\n};\n\n// Return a new DateSegmentState[] that reflects changes across all segments.\n// When you change the month this can affect the day, for instance.\nconst createDateSegmentStates = (\n  existingSegments: DateSegmentState[],\n  orderedSegments: EditableDateSegment[],\n  updatedSegmentType: EditableDateSegment,\n  updatedSegment: DateSegmentState,\n  autoAdvance: boolean\n) => {\n  const modifiedSegments = replaceDateSegment(existingSegments, updatedSegmentType, updatedSegment);\n  let updatedSegments = modifiedSegments;\n\n  if (updatedSegmentType === 'month' || updatedSegmentType === 'year') {\n    // If month was changed, update the day as needed; this includes adjusting the\n    // day value if it now exceeds the max number of days in the month.\n    // If year was changed, that can also affect the max number of days (if month is February).\n    const daySeg = findSegment(modifiedSegments, 'day');\n    if (daySeg) {\n      const monthValue =\n        updatedSegmentType == 'month'\n          ? (updatedSegment['aria-valuenow'] as IsoMonth)\n          : getMonthValue(modifiedSegments);\n      const yearValue =\n        updatedSegmentType === 'year'\n          ? updatedSegment['aria-valuenow']\n          : getYearValue(modifiedSegments);\n\n      // We will leave dayMax for Feb to 29 until the year is a 4-digit year when the user is typing.\n      // JET-75124 Leap year date of 02/29 is converted to 28 automatically (as soon as you type the first number of the year)\n      const isFebAndLessThanFourDigitYear =\n        monthValue && monthValue === 2 && yearValue && yearValue < 1000;\n      // autoAdvance is true when you type and it is false when you spin. If the user is typing into the year,\n      // then we want max day to be 29.\n      const dayMax =\n        isFebAndLessThanFourDigitYear && updatedSegmentType === 'year' && autoAdvance\n          ? 29\n          : getDaysInMonth(monthValue ?? '*', yearValue ?? '*');\n      const currentDay = daySeg['aria-valuenow'];\n      const dayValue = !!currentDay && currentDay > dayMax ? dayMax : currentDay;\n      const dayValueStr = dayValue !== undefined ? numberToString(dayValue) : undefined;\n      const updatedDaySeg = {\n        ...daySeg,\n        'aria-valuemax': dayMax,\n        'aria-valuenow': dayValue,\n        'aria-valuetext': dayValueStr,\n        text: dayValueStr\n      };\n      updatedSegments = replaceDateSegment(modifiedSegments, 'day', updatedDaySeg);\n    }\n  }\n\n  // If the updatedSegment is complete, automatically select the next segment.\n  updatedSegments =\n    updatedSegment.isComplete && autoAdvance\n      ? selectNext(updatedSegments, orderedSegments)\n      : updatedSegments;\n\n  return updatedSegments;\n};\n\n// Construct a new DateFieldState from a set of updated segments.\nconst createDateFieldStateFromSegments = (\n  currentState: DateFieldState,\n  updatedSegments: DateSegmentState[]\n) => {\n  return {\n    isCommitting: currentState.isCommitting,\n    currentDate: createCalendarDateFromSegments(updatedSegments),\n    isCompleteDate: isDateComplete(updatedSegments),\n    isDateSelected: currentState.isDateSelected,\n    isPartialDate: isPartialDate(updatedSegments),\n    orderedSegments: getOrderedSegments(currentState),\n    segments: updatedSegments\n  };\n};\n\n// Construct a new DateFieldState given an updated segment, which may affect other segments.\nconst createDateFieldState = (\n  currentState: DateFieldState,\n  updatedSegmentType: EditableDateSegment,\n  updatedSegment: DateSegmentState,\n  autoAdvance = true\n): DateFieldState => {\n  const updatedSegments = createDateSegmentStates(\n    currentState.segments,\n    currentState.orderedSegments,\n    updatedSegmentType,\n    updatedSegment,\n    autoAdvance\n  );\n\n  return createDateFieldStateFromSegments(currentState, updatedSegments);\n};\n\n// Return a new copy of the segment with the value cleared.\nconst clearSegment = (segmentState: DateSegmentState) => {\n  return {\n    ...segmentState,\n    'aria-valuetext': undefined,\n    'aria-valuenow': undefined,\n    text: undefined,\n    isComplete: false\n  };\n};\n\n// Return a new copy of segments with all values cleared and aria-valuemax adjusted.\nconst clearDate = (segments: DateSegmentState[]) => {\n  return segments.map((segmentState) => {\n    const cleared = clearSegment(segmentState);\n    const valueMax =\n      cleared.type === 'year'\n        ? MAX_ISO_YEAR\n        : cleared.type === 'month'\n        ? getMonthsInYear('*')\n        : getDaysInMonth('*', '*');\n    return { ...cleared, 'aria-valuemax': valueMax };\n  });\n};\n\n// Return a new copy of the segment with updated values.\nconst updateSegment = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  action: Extract<DateReducerAction, { actionType: 'updateSegment' }>,\n  segments: DateSegmentState[]\n) => {\n  const actionText = action.data.text;\n  const hasLeadingZero = action.data.hasLeadingZero;\n  const locale = action.data.locale;\n  const minValue = segmentState['aria-valuemin']!;\n  const maxValue = segmentState['aria-valuemax']!;\n  const wasComplete = segmentState.isComplete;\n\n  // If the segment was already complete, replace any existing text with actionText.\n  // Otherwise append actionText onto existing text to get the requested string.\n  // For instance if the existing text is '1' and actionText (i.e. that the user typed)\n  // is '2' then requestedValStr is '12'.\n  const requestedValStr = wasComplete ? actionText : segmentState.text + actionText;\n\n  // If the requested value is out of range, discard the existing text/value and only\n  // keep the new one. Check if the segment is complete.\n  const requestedVal = stringToNumber(requestedValStr);\n  const inRange = withinRange(requestedVal, minValue, maxValue);\n  const newValStr = inRange ? requestedValStr : actionText;\n  const newVal = inRange ? requestedVal : stringToNumber(actionText);\n  const isComplete =\n    isSegmentComplete(newVal, maxValue) || (!!hasLeadingZero && segmentType !== 'year');\n\n  // For month changes, aria-valuetext includes the month name.\n  const ariaValueText =\n    segmentType === 'month'\n      ? getMonthAria(locale, newVal as IsoMonth, getYearValue(segments))\n      : newValStr;\n\n  // Create a new segment state that reflects the updated value.\n  return {\n    ...segmentState,\n    'aria-valuetext': ariaValueText,\n    'aria-valuenow': newVal,\n    text: newValStr,\n    isComplete\n  };\n};\n\n// Return a new DateSegmentState[] where the specified segment is selected, all others cleared.\nconst selectSegment = (segments: DateSegmentState[], segmentType: EditableDateSegment) => {\n  const updatedSegments = checkFeb29EdgeCase(segments);\n  return updatedSegments.map((seg) => {\n    return { ...seg, isSelected: seg.type === segmentType ? true : false };\n  });\n};\n\n// Return a new DateSegmentState[] where the first segment is selected.\nconst selectFirst = (segments: DateSegmentState[], orderedSegments: EditableDateSegment[]) => {\n  return selectSegment(segments, orderedSegments[0]);\n};\n\n// Find the index of the selected segment in the ordered list; return -1 if there is no selection.\nconst getSelectedSegmentIndex = (\n  segments: DateSegmentState[],\n  orderedSegments: EditableDateSegment[]\n) => {\n  const sel = segments.find((seg) => seg.isSelected === true);\n  return sel === undefined ? -1 : orderedSegments.findIndex((type) => type === sel.type);\n};\n\n// Convenience function to mark the selected segment complete.\nconst markSelectedSegmentComplete = (segments: DateSegmentState[]) => {\n  return segments.map((seg) => (seg.isSelected ? { ...seg, isComplete: true } : seg));\n};\n\n// Select the segment following the one that is currently selected.\nconst selectNext = (segments: DateSegmentState[], orderedSegments: EditableDateSegment[]) => {\n  const selectedIndex = getSelectedSegmentIndex(segments, orderedSegments);\n  const max = orderedSegments.length - 1;\n\n  // If we're already at the last position, do nothing. Note if nothing was currently selected\n  // then selectedIndex is -1. The first segment will be selected.\n  return selectedIndex === max\n    ? segments\n    : selectSegment(markSelectedSegmentComplete(segments), orderedSegments[selectedIndex + 1]);\n};\n\n// Select the segment prior to the one that is currently selected.\nconst selectPrevious = (segments: DateSegmentState[], orderedSegments: EditableDateSegment[]) => {\n  const selectedIndex = getSelectedSegmentIndex(segments, orderedSegments);\n  return selectedIndex === 0\n    ? segments\n    : selectedIndex === -1\n    ? selectFirst(segments, orderedSegments)\n    : selectSegment(markSelectedSegmentComplete(segments), orderedSegments[selectedIndex - 1]);\n};\n\n// Return a new DateSegmentState[] where all segments are unselected and any values are\n// marked complete. We want to do this when the user commits the DateField value (on blur).\nconst clearSelectionAndComplete = (segments: DateSegmentState[]) => {\n  return segments.map((seg) => {\n    return { ...seg, isSelected: false, isComplete: !!seg.text };\n  });\n};\n\n// Return a new DateSegmentState[] where all segments are unselected.\nconst clearSelection = (segments: DateSegmentState[]) => {\n  return segments.map((seg) => {\n    return { ...seg, isSelected: false };\n  });\n};\n\n// Return a new DateFieldState where the entire date is selected if the date is complete,\n// or the first segment is selected.\nconst selectDateOrSegment = (currentState: DateFieldState) => {\n  if (currentState.isCompleteDate) {\n    return createDateFieldStateWithSelectedDate(\n      currentState,\n      clearSelection(currentState.segments),\n      true\n    );\n  } else {\n    const updatedSegments = selectFirst(currentState.segments, currentState.orderedSegments);\n    return createDateFieldStateFromSegments(currentState, updatedSegments);\n  }\n};\n\n// Create a new DateFieldState from the updatedSegments and isDateSelected params.\nconst createDateFieldStateWithSelectedDate = (\n  currentState: DateFieldState,\n  updatedSegments: DateSegmentState[],\n  isDateSelected: boolean\n) => {\n  return {\n    isCommitting: currentState.isCommitting,\n    currentDate: createCalendarDateFromSegments(updatedSegments),\n    isCompleteDate: isDateComplete(updatedSegments),\n    isDateSelected,\n    isPartialDate: isPartialDate(updatedSegments),\n    orderedSegments: getOrderedSegments(currentState),\n    segments: updatedSegments\n  };\n};\n\nconst YEAR_HOME_VALUE = 1900;\nconst YEAR_END_VALUE = 2100;\n\n// If a segment is empty, use today's date as a starting point for any step or page action.\nconst getDefaultSegmentValue = (segmentType: EditableDateSegment) => {\n  const { year: yearDefault, month: monthDefault, day: dayDefault } = getTodayAsCalendarDate();\n  const defaults = { year: yearDefault, month: monthDefault, day: dayDefault };\n  return defaults[segmentType];\n};\n\n// Get the minimum value for the segment.\nconst getHomeSegmentValue = (segmentType: EditableDateSegment, segmentState: DateSegmentState) => {\n  return segmentType === 'year' ? YEAR_HOME_VALUE : segmentState['aria-valuemin']!;\n};\n\n// Get the maximum value for the segment (for year, this is YEAR_END_VALUE).\nconst getEndSegmentValue = (segmentType: EditableDateSegment, segmentState: DateSegmentState) => {\n  return segmentType === 'year' ? YEAR_END_VALUE : segmentState['aria-valuemax']!;\n};\n\n// Return the result of stepping currentValue in the requested direction, taking into account min and max.\nconst getSteppedSegmentValue = (\n  currentValue: number,\n  direction: DirectionType,\n  min: number,\n  max: number\n) => {\n  const newValue =\n    direction === 'increase'\n      ? currentValue + 1 > max\n        ? min\n        : currentValue + 1\n      : currentValue - 1 < min\n      ? max\n      : currentValue - 1;\n  return newValue;\n};\n\n// Return the result of paging the value up or down, taking into account min and max.\nconst getPagedSegmentValue = (\n  currentValue: number,\n  direction: DirectionType,\n  min: number,\n  max: number,\n  segmentType: EditableDateSegment\n) => {\n  const step = segmentType === 'month' ? 2 : segmentType === 'year' ? 5 : 7;\n  const newValue =\n    direction === 'increase'\n      ? currentValue + step > max\n        ? (currentValue + step) % max\n        : currentValue + step\n      : currentValue - step < min\n      ? currentValue - step + max\n      : currentValue - step;\n  return newValue;\n};\n\n// Create a new segment with an updated value from a keyboard action such as step, page, Home, or End.\nconst createSegmentFromKeyboardAction = (\n  newVal: number,\n  locale: BCP47Locale,\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[]\n) => {\n  const newValStr = numberToString(newVal);\n  // For month changes, aria-valuetext includes the month name.\n  const ariaValueText =\n    segmentType === 'month'\n      ? getMonthAria(locale, newVal as IsoMonth, getYearValue(segments))\n      : newValStr;\n\n  // Create a new segment state that reflects the updated value.\n  // After any keyboard action, the value is complete so that if the user types anything,\n  // it will replace the stepped value.\n  return {\n    ...segmentState,\n    'aria-valuetext': ariaValueText,\n    'aria-valuenow': newVal,\n    text: newValStr,\n    isComplete: true\n  };\n};\n\n// Set the segment to its minimum value.\nconst goToHome = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[],\n  locale: BCP47Locale\n) => {\n  const newValue = getHomeSegmentValue(segmentType, segmentState);\n  return createSegmentFromKeyboardAction(newValue, locale, segmentType, segmentState, segments);\n};\n\n// Set the segment to its maximum value.\nconst goToEnd = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[],\n  locale: BCP47Locale\n) => {\n  const newValue = getEndSegmentValue(segmentType, segmentState);\n  return createSegmentFromKeyboardAction(newValue, locale, segmentType, segmentState, segments);\n};\n\n// Step or page a segment's value.\nconst doStepOrPage = (\n  segmentType: EditableDateSegment,\n  segmentState: DateSegmentState,\n  segments: DateSegmentState[],\n  type: 'step' | 'page',\n  direction: DirectionType,\n  locale: BCP47Locale\n) => {\n  const valueNow = segmentState['aria-valuenow'];\n  const min = segmentState['aria-valuemin']!;\n  const max = segmentState['aria-valuemax']!;\n  const newValue =\n    valueNow === undefined\n      ? getDefaultSegmentValue(segmentType)\n      : type === 'page'\n      ? getPagedSegmentValue(valueNow, direction, min, max, segmentType)\n      : getSteppedSegmentValue(valueNow, direction, min, max);\n\n  return createSegmentFromKeyboardAction(newValue, locale, segmentType, segmentState, segments);\n};\n\n// This is for an edge case where the month is February, the day is 29, and the year is < 1000, and it is not a leap year.\n// If so, we update the daySegment to 28. This function is called on 'commit'.\n// JET-75124 Leap year date of 02/29 is converted to 28 automatically (as soon as you type the first number in the year)\nconst checkFeb29EdgeCase = (stateSegments: DateSegmentState[]) => {\n  const monthSegment = stateSegments.find((seg) => seg.type === 'month');\n  const daySegment = stateSegments.find((seg) => seg.type === 'day');\n  const yearSegment = stateSegments.find((seg) => seg.type === 'year');\n\n  const year = yearSegment?.['aria-valuenow'];\n\n  if (\n    year !== undefined &&\n    year < 1000 &&\n    !isLeapYear(year) &&\n    monthSegment?.['aria-valuenow'] === 2 &&\n    daySegment?.['aria-valuenow'] === 29\n  ) {\n    const updatedDaySeg = {\n      ...daySegment,\n      'aria-valuemax': 28,\n      'aria-valuenow': 28,\n      'aria-valuetext': '28',\n      text: '28'\n    };\n    return replaceDateSegment(stateSegments, 'day', updatedDaySeg);\n  }\n  return stateSegments;\n};\n\nexport { dateReducer, getMonthAria, numberToString, stringToNumber };\nexport type { DateReducerAction, DirectionType };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ComponentProps, RefObject } from 'preact';\nimport {\n  Dispatch,\n  MutableRef,\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useRef\n} from 'preact/hooks';\nimport { calendarDatesAreDifferent } from '#utils/PRIVATE_dayUtils';\nimport { DateReducerAction } from './dateReducer';\nimport { DateFieldState } from './useDateField';\nimport { CalendarDate, EditableDateSegment } from './types';\nimport { getClientHints } from '#utils/PRIVATE_clientHints';\nimport { isBackspaceOrDelete, isSelectAll } from '#utils/PRIVATE_keyboardUtils';\nimport { InputDateMask } from './InputDateMask';\nimport { useDoubleTap } from '#hooks/UNSAFE_useDoubleTap';\nimport { useTabbableMode } from '#hooks/UNSAFE_useTabbableMode';\n\ntype InputDateMaskProps = ComponentProps<typeof InputDateMask>;\n\ntype Props = {\n  dateResetRef: MutableRef<boolean>;\n  direction: 'ltr' | 'rtl';\n  dispatch: Dispatch<DateReducerAction>;\n  groupRef?: RefObject<HTMLDivElement>;\n  isDisabled?: boolean;\n  isInputFocused?: boolean;\n  onCommit: InputDateMaskProps['onCommit'];\n  onInput: InputDateMaskProps['onInput'];\n  state: DateFieldState;\n  value?: CalendarDate;\n};\n\ntype CommitHandle = {\n  handleCommitOnBlur: () => void;\n};\n\nfunction isMobile() {\n  const deviceType = getClientHints().deviceType;\n  return deviceType === 'phone' || deviceType === 'tablet';\n}\n\n/**\n * A hook that creates various handlers and manages effects for a DateField.\n */\nconst useDateFieldHandlers = ({\n  dateResetRef,\n  direction,\n  dispatch,\n  groupRef,\n  isDisabled,\n  isInputFocused,\n  onCommit,\n  onInput,\n  state,\n  value: currentValue\n}: Props) => {\n  const { tabbableModeProps } = useTabbableMode();\n  const { tabIndex: tabbableModeIndex } = tabbableModeProps;\n  const anySegmentSelected = state.segments.some((segment) => !!segment.isSelected);\n\n  // If any segment is selected, it is contenteditable=true and it has the focus. If you shift-Tab, you will\n  // land on the outer div (DateField) first meaning it takes 2 shift-tab keys to get the previous element.\n  // To prevent this, if any segment is selected the tabindex on the div is set to -1.\n  // We also need to set tabindex to -1 for the disabled case, since we are dealing with a div instead\n  // of an intrinsic input and have to handle it directly.\n  const updatedTabIndex = tabbableModeIndex === -1 || anySegmentSelected || isDisabled ? -1 : 0;\n\n  // Keep track of the last changed and last committed date values.\n  const lastDateRef = useRef<CalendarDate | undefined>(state.currentDate);\n  const lastCommittedDateRef = useRef<CalendarDate | undefined>(state.currentDate);\n  // Keep track whether the date was cleared.\n  const dateClearedRef = useRef<boolean>(false);\n\n  // If the value was programmatically changed (see useDateField.ts), then update the\n  // last changed and last committed date refs to stay in sync.\n  // currentValue is the controlled value passed from the parent.\n  if (dateResetRef.current) {\n    lastDateRef.current = currentValue;\n    lastCommittedDateRef.current = currentValue;\n  }\n\n  // Call onCommit, only if the value is different.\n  const doCommitIfNeeded = useCallback(() => {\n    if (calendarDatesAreDifferent(lastCommittedDateRef.current, state.currentDate)) {\n      onCommit?.({ value: state.currentDate });\n      lastCommittedDateRef.current = state.currentDate;\n    }\n  }, [onCommit, state.currentDate]);\n\n  // This is called when onFocusOut is called on the date field. We dispatch\n  // 'commitOnBlur' to clear any selected segments and mark non-empty segments as\n  // complete. It also puts the state into 'isCommitting' that will trigger\n  // a re-render in which we doCommitIfNeeded based on that state.\n  const handleCommitOnBlur = useCallback(() => {\n    dispatch({ actionType: 'commitOnBlur' }); // sets 'isCommitting' state. This might update the state, so we need to wait before calling onCommit.\n  }, [dispatch]);\n\n  // Handle requested segment changes by calling the reducer dispatch function.\n  const onChange = useCallback(\n    (action: DateReducerAction) => {\n      dispatch(action);\n    },\n    [dispatch]\n  );\n\n  // If the user clicked on a segment, dispatch a request to select it.\n  // If they clicked on the date field itself, select the first segment.\n  const onClick = useCallback(\n    (e: Event) => {\n      const segmentType = (e.target as HTMLElement).getAttribute(\n        'data-segment'\n      ) as EditableDateSegment | null;\n\n      if (segmentType !== null) {\n        dispatch({ actionType: 'selectSegment', data: { type: segmentType } });\n      } else {\n        dispatch({ actionType: 'selectFirst' });\n      }\n    },\n    [dispatch]\n  );\n\n  // If complete, select the date.\n  const selectAll = useCallback(\n    (isGroupFocus = true) => {\n      if (state.isCompleteDate) {\n        dispatch({ actionType: 'selectDateOrSegment' });\n        // Focus can end up in different places depending on if the user selected a segment\n        // first (via click or arrow key), and then did select all. To make shift-tabbing\n        // consistent in all cases, set focus to the group when selecting the date.\n        isGroupFocus && groupRef?.current?.focus();\n      }\n    },\n    [dispatch, groupRef, state.isCompleteDate]\n  );\n\n  const onDoubleClick = useCallback(() => {\n    selectAll();\n  }, [selectAll]);\n\n  const onDoubleTap = useCallback(\n    (e: Event) => {\n      const segmentType = (e.target as HTMLElement).getAttribute(\n        'data-segment'\n      ) as EditableDateSegment;\n\n      // Only do select all if a segment was double tapped, which means the\n      // mobile keyboard will stay up.\n      !!segmentType && selectAll(false);\n    },\n    [selectAll]\n  );\n\n  const doubleTapHandlers = useDoubleTap({ onDoubleTap: onDoubleTap, onSingleTap: onClick });\n\n  // Handle arrow key navigation between segments. If no segment is currently selected, then select the first one.\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (\n        (direction === 'ltr' && event.key === 'ArrowLeft') ||\n        (direction === 'rtl' && event.key === 'ArrowRight')\n      ) {\n        // Select the previous segment when pressing Left arrow (or Right arrow in rtl).\n        dispatch({ actionType: 'selectPrevious' });\n        event.stopPropagation();\n      } else if (\n        (direction === 'ltr' && event.key === 'ArrowRight') ||\n        (direction === 'rtl' && event.key === 'ArrowLeft')\n      ) {\n        // Select the next segment when pressing Right arrow (or Left arrow in rtl).\n        dispatch({ actionType: 'selectNext' });\n        event.stopPropagation();\n      } else if (\n        (isBackspaceOrDelete(event) || event.key === 'Backspace') &&\n        state.isDateSelected\n      ) {\n        // Clear the entire date.\n        dispatch({ actionType: 'clearDate' });\n        dateClearedRef.current = true;\n        // Kill the event to prevent weird issue with placeholders getting deleted on iOS only.\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n      } else if (isSelectAll(event)) {\n        selectAll();\n        event.preventDefault();\n        event.stopPropagation();\n      } else if (event.key === 'Enter') {\n        // Hitting Enter commits any changes.\n        dispatch({ actionType: 'commitOnEnter' });\n        event.preventDefault();\n        event.stopPropagation();\n      }\n    },\n    [direction, dispatch, selectAll, state.isDateSelected]\n  );\n\n  // If you try to call onInput from onChange directly it doesn't work. The value of\n  // state.currentDate is from the current render, not the render *after* the dispatch.\n  // So wait for the state to finish updating.\n  useLayoutEffect(() => {\n    if (\n      calendarDatesAreDifferent(lastDateRef.current, state.currentDate) &&\n      !dateResetRef.current\n    ) {\n      const frozenDate =\n        state.currentDate !== undefined\n          ? Object.freeze({ ...state.currentDate })\n          : state.currentDate;\n      onInput({ value: frozenDate });\n      lastDateRef.current = frozenDate;\n    }\n    dateResetRef.current = false;\n  }, [onInput, state.currentDate, dateResetRef]);\n\n  // Check state.isCommitting which is set when we are done updating the state's value\n  // on Enter or Blur and ready to call onCommit. We do not want to call onCommit during render,\n  // so we use useLayoutEffect. useEffect might trigger this issue - JET-73689 oj-c-input-date-picker onValueChange triggered after button submit function.\n  useLayoutEffect(() => {\n    if (state.isCommitting) {\n      doCommitIfNeeded();\n      // This will update the state.isCommitting to false.\n      dispatch({ actionType: 'committed' });\n    }\n  }, [dispatch, doCommitIfNeeded, state.isCommitting]);\n\n  // The following is a simplified version of how we detect keyboard vs. mouse focus\n  // in the useCollectionFocusRing hook. If the user tabs onto the field, we want to\n  // automatically select the first segment.\n  const recentPointerRef = useRef<boolean>(false);\n  const pointerDownTimerRef = useRef<ReturnType<typeof setTimeout> | undefined>();\n  const onPointerDown = () => {\n    recentPointerRef.current = true;\n    clearTimeout(pointerDownTimerRef.current);\n\n    pointerDownTimerRef.current = setTimeout(() => {\n      recentPointerRef.current = false;\n    }, 200);\n  };\n\n  useEffect(() => {\n    // If we receive focus that is *not* due to the user clicking in the field, i.e. the user\n    // tabbed onto the field, then select the first segment.\n    // Note: we cannot check isFocused because it includes the ? icon in compact UAD, and we don't\n    // want the date selected when the help icon is focused.\n    isInputFocused && !recentPointerRef.current && dispatch({ actionType: 'selectFirst' });\n\n    // If we lose focus due to the keyboard, i.e. shift-tabbing onto the compact UAD help icon,\n    // then 'deselectAndComplete' which will clear any selected segments.\n    !isInputFocused && !recentPointerRef.current && dispatch({ actionType: 'deselectAndComplete' });\n    recentPointerRef.current = false;\n  }, [dispatch, isInputFocused]);\n\n  const handlers = isMobile()\n    ? { ...doubleTapHandlers, onKeyDown }\n    : { onClick, onDoubleClick, onKeyDown, onPointerDown };\n\n  return {\n    dateClearedRef,\n    dateFieldHandlers: isDisabled ? {} : handlers,\n    handleCommitOnBlur,\n    segmentHandlers: isDisabled ? {} : { onChange },\n    tabIndex: updatedTabIndex\n  };\n};\n\nexport { useDateFieldHandlers };\nexport type { CommitHandle };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ComponentProps, Ref, RefObject, JSX } from 'preact';\nimport { forwardRef } from 'preact/compat';\nimport { useImperativeHandle, useRef } from 'preact/hooks';\n\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\nimport { merge } from '@oracle/oraclejet-internal-utilities/stringUtils';\n\nimport { useComponentTheme } from '#hooks/UNSAFE_useComponentTheme';\nimport { useFormFieldContext } from '#hooks/UNSAFE_useFormFieldContext';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport type { BundleType } from '#resources/nls/bundle';\nimport { Flex } from '#UNSAFE_Flex';\nimport { HiddenAccessible } from '#UNSAFE_HiddenAccessible';\nimport { LiveRegion } from '#UNSAFE_LiveRegion';\nimport { TextFieldInputRedwoodTheme } from '#UNSAFE_TextField/themes/redwood/TextFieldInputTheme';\nimport type { TextFieldInputVariantOptions } from '#UNSAFE_TextField/themes/TextFieldInputStyles.css';\nimport { isEmbeddedVariant } from '#utils/PRIVATE_formControlUtils';\nimport { formatFullCalendarDate } from '#utils/UNSAFE_calendarDateUtils';\nimport { classNames } from '#utils/UNSAFE_classNames';\nimport { DateSegment } from './DateSegment';\nimport type { InputDateMask } from './InputDateMask';\nimport { LiteralSegment } from './LiteralSegment';\nimport type { DatePlaceholders, EditableDateSegment } from './types';\nimport { type DateSegmentState, useDateField } from './useDateField';\nimport { type CommitHandle, useDateFieldHandlers } from './useDateFieldHandlers';\n\ntype InputDateMaskProps = ComponentProps<typeof InputDateMask>;\n\ntype AriaProps = Pick<\n  UnpackSignals<JSX.AriaAttributes>,\n  'aria-describedby' | 'aria-invalid' | 'aria-label' | 'aria-labelledby'\n>;\n\ntype HTMLElementProps = Pick<UnpackSignals<JSX.IntrinsicElements['div']>, 'onBlur' | 'onFocus'>;\n\nexport type Props = AriaProps &\n  HTMLElementProps & {\n    /**\n     * A base id prefix.\n     */\n    baseId: string;\n\n    /**\n     * A ref to the element that receives focus when the field's label is clicked,\n     * or when the component is toggled between readonly and enabled. This is the\n     * first segment in the field.\n     */\n    fieldRef?: RefObject<HTMLDivElement>;\n\n    /**\n     * Specifies the smallest date unit that is displayed by the component.\n     * If set to month, only month and year are shown.\n     * If set to day then month, day, and year are shown.\n     */\n    granularity?: InputDateMaskProps['granularity'];\n\n    /**\n     * True if the component has an inside label.\n     */\n    hasInsideLabel?: boolean;\n\n    /**\n     * Specifies for accessibility purposes whether a value is required.\n     */\n    isRequired?: InputDateMaskProps['isRequired'];\n\n    /**\n     * The placeholder masks used by the date field.\n     */\n    masks: DatePlaceholders;\n\n    /**\n     * Specifies how to align text within the field.\n     */\n    textAlign?: InputDateMaskProps['textAlign'];\n\n    /**\n     * The current display value of the component.\n     */\n    value?: InputDateMaskProps['value'];\n\n    /**\n     * The style variant of the component.\n     */\n    variant?: InputDateMaskProps['variant'];\n\n    /**\n     * Callback invoked each time the user changes the value of a segment For example, if the user\n     * types '12' into the month segment, this callback will be called twice to change the month\n     * first to '1' and then '12'.\n     */\n    onInput: InputDateMaskProps['onInput'];\n\n    /**\n     * Callback invoked when the user commits the entered value by blurring or hitting the enter key.\n     */\n    onCommit: InputDateMaskProps['onCommit'];\n  };\n\nconst findSegment = (segments: DateSegmentState[], type: EditableDateSegment): DateSegmentState => {\n  return segments.find((segment) => segment.type === type)!;\n};\n\n/**\n * Container for Segment children that represent different parts of a date with no time.\n */\nconst DateField = forwardRef(\n  (\n    {\n      'aria-describedby': describedBy,\n      'aria-invalid': ariaInvalid,\n      'aria-label': ariaLabel,\n      'aria-labelledby': ariaLabelledBy,\n      baseId,\n      fieldRef,\n      granularity = 'day',\n      hasInsideLabel,\n      isRequired,\n      masks: dateMasks,\n      onBlur,\n      onCommit,\n      onFocus,\n      onInput,\n      textAlign,\n      value,\n      variant = 'default'\n    }: Props,\n    ref?: Ref<CommitHandle>\n  ) => {\n    const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n    const announceDateCleared = translations.inputDateMask_date_cleared();\n    const labels = {\n      month: translations.formControl_month(),\n      day: translations.formControl_day(),\n      year: translations.formControl_year()\n    };\n\n    const { direction, locale } = useUser();\n\n    const { isDisabled, isFocused, isInputFocused } = useFormFieldContext();\n    const hasValue = value !== undefined;\n\n    // DateField is similar to TextFieldInput for styling. The main difference\n    // is TextFieldInput renders a textarea or input and DateField renders a div, so the positioning with\n    // padding is different. DateField and TextFieldInput are both the mainContent\n    // of a TextField component.\n    const { classes } = useComponentTheme<TextFieldInputVariantOptions>(\n      TextFieldInputRedwoodTheme,\n      {\n        type: 'notPassword',\n        styleVariant: isEmbeddedVariant(variant) ? 'embedded' : 'default',\n        textarea: 'notTextArea',\n        input: 'notInput',\n        div: 'isDiv',\n        prefix: 'noPrefix',\n        suffix: 'noSuffix',\n        startContent: 'noStartContent',\n        endContent: 'noEndContent',\n        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',\n        value: hasValue ? 'hasValue' : 'noValue',\n        focused: isFocused ? 'isFocused' : 'notFocused',\n        disabled: isDisabled ? 'isDisabled' : 'notDisabled'\n      }\n    );\n\n    const compClasses = classNames([classes]);\n\n    const { state, dispatch, dateResetRef } = useDateField({\n      ariaLabels: labels,\n      dateMasks,\n      granularity,\n      locale,\n      value\n    });\n    const { isDateSelected, isPartialDate, segments: editableSegments } = state;\n    const yearSegment = findSegment(editableSegments, 'year');\n    const monthSegment = findSegment(editableSegments, 'month');\n    const daySegment = granularity === 'day' ? findSegment(editableSegments, 'day') : undefined;\n    const segmentsMap = {\n      year: yearSegment,\n      month: monthSegment,\n      day: daySegment\n    };\n\n    const groupRef = useRef<HTMLDivElement>(null);\n    const { dateClearedRef, dateFieldHandlers, handleCommitOnBlur, segmentHandlers, tabIndex } =\n      useDateFieldHandlers({\n        dateResetRef,\n        direction,\n        dispatch,\n        groupRef,\n        isDisabled,\n        isInputFocused,\n        onCommit,\n        onInput,\n        state,\n        value\n      });\n\n    useImperativeHandle(\n      ref!,\n      () => {\n        return {\n          handleCommitOnBlur\n        };\n      },\n      [handleCommitOnBlur]\n    );\n\n    // Like other form components, don't show placeholders for inside labels unless focused.\n    // This flag causes the segment placeholders to be hidden.\n    const isHidden = value === undefined && hasInsideLabel && !isFocused;\n\n    // If the date is complete, create a hidden accessible region with the full formatted date.\n    const formattedDateStr = !state.isCompleteDate\n      ? ''\n      : formatFullCalendarDate(locale, state.currentDate!, granularity);\n\n    const formattedDateAriaId = `${baseId}-date`;\n    const formattedDateAria = state.isCompleteDate ? (\n      <HiddenAccessible id={formattedDateAriaId}>{formattedDateStr}</HiddenAccessible>\n    ) : undefined;\n    const ariaDescribedBy = state.isCompleteDate\n      ? merge([describedBy, formattedDateAriaId])\n      : describedBy;\n\n    // Add an announcement to the live region if the date was cleared.\n    // Note: we deliberately do not reset dateClearedRef because there are multiple\n    // rerenders after clearing the date and we want to make sure the announcement\n    // has time to be heard.\n    const announceText = dateClearedRef.current ? announceDateCleared : '';\n\n    // firstSegmentType is 'day', 'month', or 'year' and is used to determine\n    // where to put the fieldRef.\n    const firstSegmentType = state.orderedSegments[0];\n\n    return (\n      <div\n        aria-describedby={ariaDescribedBy}\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        class={compClasses}\n        onFocusIn={onFocus}\n        onFocusOut={onBlur}\n        ref={groupRef}\n        role=\"group\"\n        tabIndex={tabIndex}\n        {...dateFieldHandlers}>\n        <Flex direction=\"row\" wrap=\"nowrap\" justify={textAlign}>\n          {dateMasks.map(({ type, value: placeholder }) => {\n            const segmentProps = type !== 'literal' ? segmentsMap[type] : {};\n            if (type === 'literal') {\n              return (\n                <LiteralSegment\n                  isHidden={isHidden}\n                  isHighlighted={isDateSelected}\n                  isPlaceholder={!isPartialDate}\n                  text={placeholder}></LiteralSegment>\n              );\n            } else {\n              return (\n                <DateSegment\n                  inputRef={type === firstSegmentType ? fieldRef : undefined}\n                  isDisabled={isDisabled}\n                  isInvalid={!!ariaInvalid}\n                  isHidden={isHidden}\n                  isHighlighted={isDateSelected}\n                  isRequired={isRequired}\n                  placeholder={placeholder}\n                  type={type}\n                  {...segmentHandlers}\n                  {...segmentProps}></DateSegment>\n              );\n            }\n          })}\n        </Flex>\n        {formattedDateAria}\n        <LiveRegion>{announceText}</LiveRegion>\n      </div>\n    );\n  }\n);\n\nexport { DateField, findSegment };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentProps } from 'preact';\nimport { useReducer, useRef } from 'preact/hooks';\nimport { BCP47Locale } from '#UNSAFE_IntlDateTime';\nimport { DateField } from './DateField';\nimport { CalendarDate, DateGranularity, DatePlaceholders, EditableDateSegment } from './types';\nimport { DateSegment } from './DateSegment';\nimport { dateReducer, getMonthAria, numberToString } from './dateReducer';\nimport { calendarDatesAreDifferent } from '../utils/PRIVATE_dayUtils';\nimport {\n  getDaysInMonth,\n  getMonthsInYear,\n  MIN_ISO_YEAR,\n  MAX_ISO_YEAR,\n  MIN_ISO_DAY,\n  MIN_ISO_MONTH\n} from '../utils/UNSAFE_calendarDateUtils';\n\ntype DateFieldType = ComponentProps<typeof DateField>;\n\ntype useDateFieldProps = {\n  ariaLabels: Record<EditableDateSegment, string>;\n  dateMasks: DatePlaceholders;\n  granularity: DateGranularity;\n  locale: BCP47Locale;\n  value: DateFieldType['value'];\n};\n\ntype DateSegmentState = Readonly<ComponentProps<typeof DateSegment>>;\n\ntype DateFieldState = {\n  readonly isCommitting: boolean;\n  readonly currentDate: CalendarDate | undefined;\n  readonly isCompleteDate: boolean;\n  readonly isDateSelected: boolean;\n  readonly isPartialDate: boolean;\n  readonly orderedSegments: EditableDateSegment[];\n  readonly segments: DateSegmentState[];\n};\n\n/**\n * Hook that returns a DateFieldState and a dispatch method to request changes to that state.\n */\nconst useDateField = ({\n  ariaLabels,\n  dateMasks,\n  granularity,\n  locale,\n  value: currentValue\n}: useDateFieldProps) => {\n  // Construct an ordered list of the editable segments, i.e. ['month', 'day', 'year'].\n  const fdm = dateMasks.filter(({ type }) => type !== 'literal');\n  const orderedSegments = fdm.map(({ type }) => type) as EditableDateSegment[];\n\n  // Derive some data from currentValue that will become part of our initial state.\n  const yearValue = currentValue?.year;\n  const monthValue = currentValue?.month;\n  const dayValue = currentValue?.day;\n  const monthMax = getMonthsInYear(yearValue ?? '*');\n  const dayMax = getDaysInMonth(monthValue ?? '*', yearValue ?? '*');\n  const isCompleteDate = !!yearValue && !!monthValue && (granularity === 'month' || !!dayValue);\n  const isPartialDate = !!yearValue || !!monthValue || !!dayValue;\n  const yearValueStr = yearValue ? numberToString(yearValue) : undefined;\n  const monthValueStr = monthValue ? numberToString(monthValue) : undefined;\n  const dayValueStr = dayValue ? numberToString(dayValue) : undefined;\n  const monthAria = monthValue ? getMonthAria(locale, monthValue, yearValue) : undefined;\n\n  const daySeg = [\n    {\n      type: 'day' as EditableDateSegment,\n      'aria-label': ariaLabels.day,\n      'aria-valuemin': MIN_ISO_DAY,\n      'aria-valuemax': dayMax,\n      'aria-valuenow': dayValue,\n      'aria-valuetext': dayValueStr,\n      isComplete: !!dayValue,\n      isSelected: false,\n      text: dayValueStr\n    }\n  ];\n\n  // Create state for each editable segment of a date, i.e. year, month, or day.\n  const editableSegments = [\n    {\n      type: 'year' as EditableDateSegment,\n      'aria-label': ariaLabels.year,\n      'aria-valuemin': MIN_ISO_YEAR,\n      'aria-valuemax': MAX_ISO_YEAR,\n      'aria-valuenow': yearValue,\n      'aria-valuetext': yearValueStr,\n      isComplete: !!yearValue,\n      isSelected: false,\n      text: yearValueStr\n    },\n    {\n      type: 'month' as EditableDateSegment,\n      'aria-label': ariaLabels.month,\n      'aria-valuemin': MIN_ISO_MONTH,\n      'aria-valuemax': monthMax,\n      'aria-valuenow': monthValue,\n      'aria-valuetext': monthAria,\n      isComplete: !!monthValue,\n      isSelected: false,\n      text: monthValueStr\n    },\n    ...(granularity === 'day' ? daySeg : [])\n  ];\n\n  // Create the initial state to pass to our reducer.\n  const initialState: DateFieldState = {\n    isCommitting: false,\n    currentDate: currentValue,\n    isCompleteDate,\n    isDateSelected: false,\n    isPartialDate,\n    orderedSegments,\n    segments: editableSegments\n  };\n\n  const [state, dispatch] = useReducer(dateReducer, initialState);\n\n  // currentValue is the controlled value passed from the parent.\n  const lastValueFromParentRef = useRef<CalendarDate | undefined>(currentValue);\n  const dateResetRef = useRef<boolean>(false);\n\n  // If a new value is being pushed from the parent, and that value differs from\n  // the current value of the reducer, then this is a programmatic update\n  // and we need to call 'reset' to update the reducer state. Otherwise, the only\n  // time the reducer state is updated from the value is on mount.\n  if (calendarDatesAreDifferent(lastValueFromParentRef.current, currentValue)) {\n    lastValueFromParentRef.current = currentValue;\n    if (calendarDatesAreDifferent(currentValue, state.currentDate)) {\n      dispatch({ actionType: 'reset', data: initialState });\n      dateResetRef.current = true;\n    }\n  }\n\n  return { dateResetRef, dispatch, state };\n};\n\nexport { useDateField };\nexport type { DateFieldState, DateSegmentState };\n","import { createContext } from 'preact';\nimport { useContext } from 'preact/hooks';\n\ntype InputDateMaskContextProps = {\n  isInputDatePickerParent: boolean;\n  isDropdownOpen: boolean;\n};\n\n/**\n * Context used to indicate when the component is being used in\n * composition within some parent, such as InputDatePicker.\n */\nconst InputDateMaskContext = createContext<InputDateMaskContextProps>({\n  isInputDatePickerParent: false,\n  isDropdownOpen: false\n});\n\nconst useInputDateMaskContext = () => useContext(InputDateMaskContext);\n\nexport { InputDateMaskContext, useInputDateMaskContext };\nexport type { InputDateMaskContextProps };\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { ComponentProps, ContextType, Ref, RefObject, JSX } from 'preact';\nimport { forwardRef } from 'preact/compat';\nimport { useCallback, useImperativeHandle, useMemo, useRef } from 'preact/hooks';\n\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\n\nimport { Label } from '#UNSAFE_Label';\nimport { ReadonlyTextField, ReadonlyTextFieldInput, TextField } from '#UNSAFE_TextField';\nimport { TextFieldContent } from '#UNSAFE_TextField/TextFieldContent';\nimport {\n  CompactUserAssistance,\n  InlineUserAssistance,\n  type UserAssistanceDensityType\n} from '#UNSAFE_UserAssistance';\nimport { type FocusableHandle, useFocusableTextField } from '#hooks/UNSAFE_useFocusableTextField';\nimport { useFormContext } from '#hooks/UNSAFE_useFormContext';\nimport { FormFieldContext } from '#hooks/UNSAFE_useFormFieldContext';\nimport type { FormVariantContext } from '#hooks/UNSAFE_useFormVariantContext';\nimport type { TestIdProps } from '#hooks/UNSAFE_useTestId';\nimport { useTextField } from '#hooks/UNSAFE_useTextField';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { useUser } from '#hooks/UNSAFE_useUser';\nimport type { BundleType } from '#resources/nls/bundle';\nimport { translateCustomMasks } from '#utils/PRIVATE_dayUtils';\nimport { formatShortCalendarDate, getDatePlaceholderMasks } from '#utils/UNSAFE_calendarDateUtils';\nimport type { TextProps } from '#utils/UNSAFE_interpolations/text';\nimport type { Size } from '#utils/UNSAFE_size';\nimport type { LayoutColumnSpan } from '#utils/UNSAFE_styles/Layout';\nimport type { ValueUpdateDetail } from '#utils/UNSAFE_valueUpdateDetail';\nimport type { CommitHandle } from './useDateFieldHandlers';\nimport { DateField } from './DateField';\nimport { useInputDateMaskContext } from './InputDateMaskContext';\nimport type { CalendarDate, DatePlaceholders } from './types';\n\ntype InlineUserAssistanceProps = ComponentProps<typeof InlineUserAssistance>;\n\ntype TextFieldContentProps = ComponentProps<typeof TextFieldContent>;\n\ntype Props = TestIdProps & {\n  /**\n   * The ID of an element (or space separated IDs of multiple elements) that\n   * describes the input.\n   */\n  'aria-describedby'?: UnpackSignals<JSX.AriaAttributes>['aria-describedby'];\n\n  /**\n   * Text to provide guidance to help the user understand what data to enter.\n   */\n  assistiveText?: InlineUserAssistanceProps['assistiveText'];\n\n  /**\n   * Specifies how many columns to span in a FormLayout with direction === 'row'\n   */\n  columnSpan?: LayoutColumnSpan;\n\n  /**\n   * Use this property to provide content for the end slot, such as a calendar icon.\n   */\n  endContent?: TextFieldContentProps['endContent'];\n\n  /**\n   * Specifies the smallest date unit that is displayed by the component.\n   * If set to month, only month and year are shown.\n   * If set to day then month, day, and year are shown.\n   */\n  granularity?: 'month' | 'day';\n\n  /**\n   * Help source URL associated with the component.\n   */\n  helpSourceLink?: InlineUserAssistanceProps['helpSourceLink'];\n\n  /**\n   * Custom text to be rendered for the <code>helpSourceLink</code>.\n   */\n  helpSourceText?: InlineUserAssistanceProps['helpSourceText'];\n\n  /**\n   * Specifies whether the component is disabled.\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Specifies whether the component is readonly.\n   */\n  isReadonly?: boolean;\n\n  /**\n   * Specifies for accessibility purposes whether a value is required.\n   *\n   * Setting this property to <code>false</code> means that a value is not required to be\n   * committed by the user. Setting this property to <code>true</code> means that a value\n   * is required to be committed by the user.\n   */\n  isRequired?: boolean;\n\n  /**\n   * Specifies whether to show an indicator on screen that a value is required, for example\n   * before the user has committed a value.\n   */\n  isRequiredShown?: InlineUserAssistanceProps['isRequiredShown'];\n\n  /**\n   * Specifies the label associated with the field.\n   */\n  label: string;\n\n  /**\n   * Specifies where the label is positioned relative to the field.\n   */\n  labelEdge?: 'inside' | 'start' | 'top' | 'none';\n\n  /**\n   * Specifies the width of the label when <code>labelEdge</code> is <code>\"start\"</code>.\n   */\n  labelStartWidth?: Size;\n\n  /**\n   * A ref to the component field. This can be used when you are composing with InputDateMask\n   * and need to provide an anchor ref to a floating component.\n   */\n  mainFieldRef?: RefObject<HTMLDivElement>;\n\n  /**\n   * If specified, overrides the locale specific order of the individual date segments as\n   * well as the locale specific separator. The value of each placeholder is only used\n   * when the type is 'literal', otherwise it is replaced with a translated placeholder\n   * for month, day, or year. If masks are specified and granularity = day, then the\n   * placeholders must include month, day, and year. If granularity = month, then the\n   * placeholders must include month and year, but not day.\n   */\n  masks?: DatePlaceholders;\n\n  /**\n   * Messages to show on screen that are associated with the component.\n   */\n  messages?: InlineUserAssistanceProps['messages'];\n\n  /**\n   * Specifies how to align text within the field.\n   */\n  textAlign?: TextProps['textAlign'];\n\n  /**\n   * Specifies the density of the user assistance presentation. It can be set to:\n   * <ul>\n   * <li><code>'efficient'</code>: Show inline and reserve space to prevent layout reflow when user\n   * assistance text is displayed.</li>\n   * <li><code>'reflow'</code>: Show inline. Layout will reflow when text is displayed.</li>\n   * <li><code>'compact'</code>: Messages, help, hints, and required will not be shown inline; they will show in a mode that keeps the screen more compact, like a popup for the messages, and a required icon to indicate Required. </li>\n   * </ul>\n   */\n  userAssistanceDensity?: UserAssistanceDensityType;\n\n  /**\n   * The current display value of the component.\n   */\n  value?: CalendarDate;\n\n  /**\n   * The style variant of the component.\n   */\n  variant?: ContextType<typeof FormVariantContext>;\n\n  /**\n   * Callback invoked when the user commits the entered value by blurring or hitting the enter key.\n   */\n  onCommit?: (detail: ValueUpdateDetail<CalendarDate>) => void;\n\n  /**\n   * Callback invoked each time the user changes the value of a segment For example, if the user\n   * types '12' into the month segment, this callback will be called twice to change the month\n   * first to '1' and then '12'.\n   */\n  onInput: (detail: ValueUpdateDetail<CalendarDate>) => void;\n};\n\n/**\n * An InputDateMask allows you to edit the month, day, and year fields of a calendar date.\n */\nexport const InputDateMask = forwardRef(\n  (\n    {\n      'aria-describedby': ariaDescribedBy,\n      assistiveText,\n      columnSpan,\n      endContent,\n      granularity = 'day',\n      helpSourceLink,\n      helpSourceText,\n      isDisabled: propIsDisabled,\n      isReadonly: propIsReadonly,\n      isRequired,\n      isRequiredShown,\n      label,\n      labelEdge: propLabelEdge,\n      labelStartWidth: propLabelStartWidth,\n      mainFieldRef,\n      messages,\n      masks,\n      testId,\n      textAlign: propTextAlign,\n      userAssistanceDensity: propUserAssistanceDensity,\n      value,\n      variant,\n      onCommit,\n      onInput\n    }: Props,\n    ref?: Ref<FocusableHandle>\n  ) => {\n    const {\n      isDisabled: isFormDisabled,\n      isReadonly: isFormReadonly,\n      labelEdge: formLabelEdge,\n      labelStartWidth: formLabelStartWidth,\n      textAlign: formTextAlign,\n      userAssistanceDensity: formUserAssistanceDensity\n    } = useFormContext();\n    // default to FormContext values if component properties are not specified\n    const isDisabled = propIsDisabled ?? isFormDisabled;\n    const isReadonly = propIsReadonly ?? isFormReadonly;\n    const labelEdge = propLabelEdge ?? formLabelEdge;\n    const labelStartWidth = propLabelStartWidth ?? formLabelStartWidth;\n    // JET-72775 - Form control alignment in tables\n    // default to 'start' if no text align is set\n    const textAlign = propTextAlign ?? formTextAlign ?? 'start';\n    const userAssistanceDensity = propUserAssistanceDensity ?? formUserAssistanceDensity;\n    const enabledElementRef = useRef<HTMLDivElement>(null);\n    const readonlyElementRef = useRef<HTMLDivElement>(null);\n\n    const aRef = useRef<HTMLDivElement>(null);\n    const anchorRef = mainFieldRef ?? aRef;\n    const dateFieldRef = useRef<CommitHandle>(null);\n\n    const { isDropdownOpen, isInputDatePickerParent } = useInputDateMaskContext();\n\n    // JET-73689: When we get onFocusOut on the text field that is not due to\n    // interaction with the dropdown, we delegate isCommitting to DateField.\n    const onTextFieldFocusOut = useCallback(() => {\n      (!isInputDatePickerParent || !isDropdownOpen) && dateFieldRef.current?.handleCommitOnBlur();\n    }, [isDropdownOpen, isInputDatePickerParent]);\n\n    const {\n      focusProps,\n      isFocused,\n      methods: focusMethods\n    } = useFocusableTextField<HTMLDivElement, HTMLDivElement>({\n      isDisabled,\n      isReadonly,\n      enabledElementRef,\n      onBlurWithin: onTextFieldFocusOut,\n      readonlyElementRef\n    });\n\n    useImperativeHandle(ref!, () => focusMethods, [focusMethods]);\n\n    const isComponentFocused = isFocused || (isInputDatePickerParent && isDropdownOpen);\n\n    const {\n      baseId,\n      formFieldContext,\n      inputProps,\n      labelProps: origLabelProps,\n      textFieldProps,\n      userAssistanceProps\n    } = useTextField({\n      ariaDescribedBy,\n      helpSourceLink,\n      helpSourceText,\n      isDisabled,\n      isFocused: isComponentFocused,\n      isReadonly,\n      isRequiredShown,\n      labelEdge,\n      messages,\n      styleVariant: variant,\n      userAssistanceDensity,\n      value\n    });\n\n    // When using a div with role=group (i.e. DateField), you need aria-labelledby instead of a\n    // for-id association with a label. Remove forId and id and use aria-labelledby instead.\n    const { forId, ...labelProps } = origLabelProps;\n    const { id, ...dateFieldProps } = inputProps;\n    const ariaLabelledBy = labelProps.id;\n    // Because we don't use for-id, clicking the label does not automatically focus the field.\n    // We have to do it manually.\n    const onClick = useCallback(() => {\n      enabledElementRef.current?.focus();\n    }, [enabledElementRef]);\n\n    const labelComp =\n      labelEdge !== 'none' ? (\n        <Label {...(!isDisabled && !isReadonly ? { onClick } : {})} {...labelProps}>\n          {label}\n        </Label>\n      ) : undefined;\n\n    const fieldLabelProps = {\n      label: labelEdge !== 'none' ? labelComp : undefined,\n      labelEdge: labelEdge !== 'none' ? labelEdge : undefined,\n      labelStartWidth: labelEdge !== 'none' ? labelStartWidth : undefined,\n      labelText: labelEdge === 'inside' && !isDisabled ? label : undefined\n    };\n\n    const ariaLabel = labelEdge === 'none' ? label : undefined;\n    const hasInsideLabel = label !== undefined && labelEdge === 'inside';\n    const isInlineDensity =\n      userAssistanceDensity === 'efficient' || userAssistanceDensity === 'reflow';\n\n    const inlineUserAssistance = isInlineDensity ? (\n      isDisabled ? (\n        // save space for user assistance if density is 'efficient', even though we don't\n        // render user assistance for disabled fields\n        userAssistanceDensity !== 'efficient' ? undefined : (\n          <InlineUserAssistance\n            userAssistanceDensity={userAssistanceDensity}\n            {...userAssistanceProps}\n          />\n        )\n      ) : isReadonly ? (\n        <InlineUserAssistance\n          fieldLabel={label}\n          messages={messages}\n          userAssistanceDensity={userAssistanceDensity}\n          {...userAssistanceProps}\n        />\n      ) : (\n        <InlineUserAssistance\n          assistiveText={assistiveText}\n          fieldLabel={label}\n          helpSourceLink={helpSourceLink}\n          helpSourceText={helpSourceText}\n          messages={messages}\n          isRequiredShown={isRequiredShown}\n          userAssistanceDensity={userAssistanceDensity}\n          {...userAssistanceProps}\n        />\n      )\n    ) : undefined;\n\n    const compactUserAssistance =\n      userAssistanceDensity === 'compact' ? (\n        <CompactUserAssistance\n          anchorRef={anchorRef}\n          messages={messages}\n          assistiveText={assistiveText}\n          {...userAssistanceProps}\n        />\n      ) : undefined;\n\n    const { locale } = useUser();\n\n    const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n    const monthPlaceholder = translations.inputDateMask_monthPlaceholder();\n    const dayPlaceholder = translations.inputDateMask_dayPlaceholder();\n    const yearPlaceholder = translations.inputDateMask_yearPlaceholder();\n\n    // The DatePlaceholders type already ensures the masks contain the right placeholders,\n    // for either full calendar dates or month-year dates. This check ensures the masks,\n    // if provided, match the granularity. E.g. for granularity=month, you should pass\n    // month and year placeholders, and a separator.\n    if (\n      masks &&\n      ((granularity === 'day' && masks.length !== 5) ||\n        (granularity === 'month' && masks.length !== 3))\n    ) {\n      throw new Error('Specified masks must match the granularity');\n    }\n\n    const dateMasks = useMemo(() => {\n      // Determine the locale specific placeholder masks and separators in the correct order\n      // for the locale, unless a custom set of masks was passed in. Each mask represents a\n      // placeholder for a segment of a date (i.e. mm/dd/yyyy). Memoize because we shouldn't\n      // need to recreate this data often.\n      const placeholderMasks = masks\n        ? translateCustomMasks(masks, monthPlaceholder, dayPlaceholder, yearPlaceholder)\n        : getDatePlaceholderMasks(\n            locale,\n            granularity,\n            monthPlaceholder,\n            dayPlaceholder,\n            yearPlaceholder\n          );\n\n      return placeholderMasks;\n    }, [masks, locale, granularity, dayPlaceholder, monthPlaceholder, yearPlaceholder]);\n\n    if (isReadonly) {\n      return (\n        <FormFieldContext.Provider value={formFieldContext}>\n          <ReadonlyTextField\n            role=\"presentation\"\n            columnSpan={columnSpan}\n            compactUserAssistance={compactUserAssistance}\n            inlineUserAssistance={inlineUserAssistance}\n            onBlur={focusProps.onFocusOut}\n            onFocus={focusProps.onFocusIn}\n            ref={anchorRef}\n            testId={testId}\n            mainContent={\n              <ReadonlyTextFieldInput\n                aria-describedby={dateFieldProps['aria-describedby']}\n                aria-label={ariaLabel}\n                aria-labelledby={labelProps.id}\n                as=\"div\"\n                elementRef={readonlyElementRef}\n                textAlign={textAlign}\n                value={\n                  value === undefined ? '' : formatShortCalendarDate(value, granularity, dateMasks)\n                }\n                hasEmptyLabel={label === '' && labelEdge === 'none'}\n                hasInsideLabel={hasInsideLabel}\n                onBlur={inputProps.onBlur}\n                onFocus={inputProps.onFocus}\n              />\n            }\n            {...fieldLabelProps}></ReadonlyTextField>\n        </FormFieldContext.Provider>\n      );\n    }\n\n    // The main content inside TextField is a DateField (not TextFieldInput) in this case.\n    // We reuse the TextField building blocks and hooks, but recompose them.\n    const mainContent = (\n      <DateField\n        aria-label={ariaLabel}\n        aria-labelledby={ariaLabelledBy}\n        baseId={baseId}\n        fieldRef={enabledElementRef}\n        granularity={granularity}\n        hasInsideLabel={labelComp !== undefined && labelEdge === 'inside'}\n        isRequired={isRequired}\n        masks={dateMasks}\n        onCommit={onCommit}\n        onInput={onInput}\n        ref={dateFieldRef}\n        textAlign={textAlign}\n        value={value}\n        {...dateFieldProps}\n      />\n    );\n\n    return (\n      <FormFieldContext.Provider value={formFieldContext}>\n        <TextField\n          columnSpan={columnSpan}\n          compactUserAssistance={compactUserAssistance}\n          endContent={endContent}\n          inlineUserAssistance={inlineUserAssistance}\n          mainContent={mainContent}\n          onBlur={focusProps.onFocusOut}\n          onFocus={focusProps.onFocusIn}\n          mainFieldRef={anchorRef}\n          testId={testId}\n          {...textFieldProps}\n          {...fieldLabelProps}\n        />\n      </FormFieldContext.Provider>\n    );\n  }\n);\n"],"names":["preventDefaultHandler","e","preventDefault","isIos","getClientHints","platform","DateSegment","ariaLabel","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","inputRef","isComplete","isDisabled","isHidden","isHighlighted","isInvalid","isRequired","isSelected","onChange","placeholder","text","type","hasDisplayValue","length","rootClasses","classNames","segmentStyles","base","selected","highlighted","placeholderClasses","hidden","notHidden","emptySegmentValueText","useTranslationBundle","inputDateMask_empty_segment","sRef","useRef","segmentRef","hasLeadingZero","locale","useUser","onKeyDown","useCallback","event","key","isSelectAll","isBackspaceOrDelete","undefined","isNumberOnlyString","actionType","data","current","direction","stopPropagation","useEffect","focus","customDataAttribute","valueText","toString","_jsx","children","_jsxs","ref","role","autocapitalize","autocorrect","class","contentEditable","enterkeyhint","inputMode","onCut","onPaste","spellcheck","tabIndex","LiteralSegment","isPlaceholder","spanClasses","literalBase","jsx","dateReducer","state","action","updatedSegments","selectFirst","clearDate","segments","orderedSegments","createDateFieldStateWithSelectedDate","updatedSegment","clearSegment","findSegment","createDateFieldState","checkFeb29EdgeCase","clearSelectionAndComplete","updatedSegmentsClearedAndComplete","isCommitting","goToEnd","goToHome","doStepOrPage","selectDateOrSegment","selectNext","selectPrevious","selectSegment","updateSegment","Error","stringToNumber","s","numberToString","n","find","segment","isDateComplete","allSegments","every","seg","isPartialDate","some","createCalendarDateFromSegments","iterator","map","values","cd","segValue","getYearValue","getMonthAria","month","year","getMonthName","getOrderedSegments","currentState","replaceDateSegment","existingSegments","updatedSegmentType","createDateSegmentStates","autoAdvance","modifiedSegments","daySeg","monthValue","yearValue","dayMax","getDaysInMonth","currentDay","dayValue","dayValueStr","updatedDaySeg","createDateFieldStateFromSegments","currentDate","isCompleteDate","isDateSelected","segmentState","cleared","valueMax","MAX_ISO_YEAR","getMonthsInYear","segmentType","actionText","minValue","maxValue","requestedValStr","requestedVal","inRange","max","newValStr","newVal","val","isSegmentComplete","getSelectedSegmentIndex","sel","findIndex","markSelectedSegmentComplete","selectedIndex","createSegmentFromKeyboardAction","newValue","getHomeSegmentValue","getEndSegmentValue","valueNow","min","yearDefault","monthDefault","day","dayDefault","getTodayAsCalendarDate","getDefaultSegmentValue","currentValue","step","getPagedSegmentValue","getSteppedSegmentValue","stateSegments","monthSegment","daySegment","yearSegment","isLeapYear","useDateFieldHandlers","dateResetRef","dispatch","groupRef","isInputFocused","onCommit","onInput","value","tabbableModeProps","useTabbableMode","tabbableModeIndex","anySegmentSelected","updatedTabIndex","lastDateRef","lastCommittedDateRef","dateClearedRef","doCommitIfNeeded","calendarDatesAreDifferent","handleCommitOnBlur","onClick","target","getAttribute","selectAll","isGroupFocus","onDoubleClick","onDoubleTap","doubleTapHandlers","useDoubleTap","onSingleTap","stopImmediatePropagation","useLayoutEffect","frozenDate","Object","freeze","recentPointerRef","pointerDownTimerRef","handlers","deviceType","isMobile","onPointerDown","clearTimeout","setTimeout","dateFieldHandlers","segmentHandlers","DateField","forwardRef","describedBy","ariaInvalid","ariaLabelledBy","baseId","fieldRef","granularity","hasInsideLabel","masks","dateMasks","onBlur","onFocus","textAlign","variant","translations","announceDateCleared","inputDateMask_date_cleared","labels","formControl_month","formControl_day","formControl_year","isFocused","useFormFieldContext","hasValue","classes","useComponentTheme","TextFieldInputRedwoodTheme","styleVariant","isEmbeddedVariant","textarea","input","div","prefix","suffix","startContent","endContent","insideLabel","focused","disabled","compClasses","ariaLabels","filter","monthMax","yearValueStr","monthValueStr","monthAria","MIN_ISO_DAY","initialState","MIN_ISO_YEAR","MIN_ISO_MONTH","useReducer","lastValueFromParentRef","useDateField","editableSegments","segmentsMap","useImperativeHandle","formattedDateStr","formatFullCalendarDate","formattedDateAriaId","formattedDateAria","HiddenAccessible","id","ariaDescribedBy","merge","announceText","firstSegmentType","jsxs","onFocusIn","onFocusOut","Flex","wrap","justify","segmentProps","LiveRegion","InputDateMaskContext","createContext","isInputDatePickerParent","isDropdownOpen","useInputDateMaskContext","useContext","InputDateMask","assistiveText","columnSpan","helpSourceLink","helpSourceText","propIsDisabled","isReadonly","propIsReadonly","isRequiredShown","label","labelEdge","propLabelEdge","labelStartWidth","propLabelStartWidth","mainFieldRef","messages","testId","propTextAlign","userAssistanceDensity","propUserAssistanceDensity","isFormDisabled","isFormReadonly","formLabelEdge","formLabelStartWidth","formTextAlign","formUserAssistanceDensity","useFormContext","enabledElementRef","readonlyElementRef","aRef","anchorRef","dateFieldRef","onTextFieldFocusOut","focusProps","methods","focusMethods","useFocusableTextField","onBlurWithin","isComponentFocused","formFieldContext","inputProps","labelProps","origLabelProps","textFieldProps","userAssistanceProps","useTextField","forId","dateFieldProps","labelComp","Label","fieldLabelProps","labelText","inlineUserAssistance","InlineUserAssistance","fieldLabel","compactUserAssistance","CompactUserAssistance","monthPlaceholder","inputDateMask_monthPlaceholder","dayPlaceholder","inputDateMask_dayPlaceholder","yearPlaceholder","inputDateMask_yearPlaceholder","useMemo","translateCustomMasks","getDatePlaceholderMasks","FormFieldContext","Provider","ReadonlyTextField","mainContent","ReadonlyTextFieldInput","as","elementRef","formatShortCalendarDate","hasEmptyLabel","TextField"],"mappings":"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"}