{"version":3,"file":"useMessagesFocusManager-8777bce0.js","sources":["../../src/hooks/PRIVATE_useMessagesFocusManager/useMessagesFocusManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { RefObject, JSX } from 'preact';\nimport { useEffect, useMemo, useRef, useState } from 'preact/hooks';\nimport type { UnpackSignals } from '@oracle/oraclejet-internal-utilities/attributeUtils';\n\nexport type FocusableComponentHandle = {\n  focus: () => boolean;\n  contains: (element: HTMLElement) => boolean;\n};\n\ntype FocusableComponentCallbacks = {\n  onFocus?: () => void;\n  onFocusLeave?: () => void;\n};\n\ntype FocusManagerHandlers = Pick<\n  UnpackSignals<JSX.HTMLAttributes>,\n  'onFocusIn' | 'onFocusOut' | 'onKeyUp'\n>;\n\ntype ComponentOptions = {\n  ref: RefObject<FocusableComponentHandle>;\n  callbacks?: FocusableComponentCallbacks;\n};\n\ntype FocusManagerOptions = {\n  handleEscapeKey?: boolean;\n};\n\nconst componentsMap = new Map<symbol, ComponentOptions>();\nconst componentsOrder = [] as symbol[];\nconst priorFocusCache = new Map<symbol, Node>();\nlet hasDocumentListener = false;\nlet priorFocusedElement: HTMLElement;\nlet currentFocusedMessage: symbol | undefined;\n\n/**\n * Handles KeyDown event in the document element during the capture phase.\n *\n * @param event The keydown event object\n */\nfunction handleDocumentKeyDownCapture(event: KeyboardEvent) {\n  // Do nothing if any of the following is true:\n  // 1. No components are registered\n  // 2. Pressed key is not F6\n  // 3. Event is defaultPrevented\n  if (componentsMap.size === 0 || event.key !== 'F6' || event.defaultPrevented) {\n    return;\n  }\n\n  // Try cycling focus through the messages and if that fails\n  // set the focus to the prior focused element.\n  if (!cycleFocusThroughMessages(event)) {\n    currentFocusedMessage && togglePreviousFocus(currentFocusedMessage, event);\n  }\n}\n\n/**\n * Handles the blur event captured on the document\n * @param event Blur event object\n */\nfunction handleDocumentBlurCapture(event: FocusEvent) {\n  priorFocusedElement = event.target as HTMLElement;\n}\n\n/**\n * Handles the keyup event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The keyup event object\n */\nfunction handleComponentKeyUp(id: symbol, event: KeyboardEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // Additional checks for keyup event and recognized keys\n  if (event.type === 'keyup' && ['Escape'].includes(event.key)) {\n    // toggle focus to the previously focused element\n    togglePreviousFocus(id, event);\n  }\n}\n\n/**\n * Handles the focus event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The focus event object\n */\nfunction handleComponentFocus(id: symbol, event: FocusEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // Store the id of the current focused message\n  currentFocusedMessage = id;\n\n  // Track previous focus if the priorFocused element is not a part of this or any other\n  // registered component\n  const { callbacks } = componentsMap.get(id)!;\n  if (priorFocusedElement && !isPartOfRegisteredMessages(priorFocusedElement)) {\n    priorFocusCache.set(id, priorFocusedElement!);\n\n    // since the focus moved to this component from outside, call the\n    // onFocus callbacks if available\n    callbacks?.onFocus?.();\n  }\n}\n\n/**\n * Handles the blur event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The focus event object\n */\nfunction handleComponentBlur(id: symbol, event: FocusEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // reset the current focus message ID\n  currentFocusedMessage = undefined;\n}\n\n/**\n * Cycles the focus through the registered messages component from the previous message of current focused\n * message to the top of the hierarchy.\n *\n * @param event The event that initiated this action\n * @returns boolean indicating the result of this action\n */\nfunction cycleFocusThroughMessages(event: Event) {\n  // At this point, we need to focus the previous message from the current focused\n  // message\n  const nextPosition =\n    indexOfOrDefaultTo(componentsOrder, currentFocusedMessage, componentsOrder.length) - 1;\n  for (let i = nextPosition; i > -1; i--) {\n    const id = componentsOrder[i];\n    const { ref } = componentsMap.get(id) ?? {};\n    if (ref?.current?.focus?.()) {\n      // prevent default action as the event has transferred focus\n      event.preventDefault();\n      // invoke callback to let the current component know the focus is left\n      if (currentFocusedMessage) {\n        const { callbacks } = componentsMap.get(currentFocusedMessage) ?? {};\n        callbacks?.onFocusLeave?.();\n      }\n      // Focus is set, so break the loop\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Checks if the provided element is a part of any of the registered messages\n *\n * @param element The candidate element\n * @returns true if is inside any of the registered messages\n */\nfunction isPartOfRegisteredMessages(element: HTMLElement) {\n  for (const { ref } of componentsMap.values()) {\n    if (ref.current?.contains(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Finds the index of the item in the array, if it does not exist returns the\n * default value instead\n *\n * @param arr The array to perform the search\n * @param search The item to be searched\n * @param defaultIndex The default value if the item is not found\n * @returns The index of the item or the default value\n */\nfunction indexOfOrDefaultTo<T>(arr: T[], search: T, defaultIndex = -1) {\n  const index = arr.indexOf(search);\n  if (index !== -1) return index;\n  return defaultIndex;\n}\n\n/**\n * Traverses through the priorFocusCache to fetch the last focused\n * element outside of the messages region.\n *\n * @param id The current focused message's ID\n * @returns The closest prior focused element, null if not found\n */\nfunction getClosestPriorFocusedElement(id: symbol) {\n  // F6 navigation cycles through messages in reverse order\n  // so to get the closest prior focused element we need to\n  // traverse in natural order from the current message\n  const index = componentsOrder.indexOf(id);\n  for (let i = index; i < componentsOrder.length; i++) {\n    if (priorFocusCache.has(componentsOrder[i])) {\n      return priorFocusCache.get(componentsOrder[i])!;\n    }\n  }\n\n  // No prior cache found, so return null\n  return null;\n}\n\n/**\n * Adds the component to the internal members.\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param ref A ref handle to the focusable component\n * @param callbacks Optional callbacks\n */\nfunction addComponent(id: symbol, options: ComponentOptions) {\n  componentsMap.set(id, options);\n  componentsOrder.push(id);\n}\n\n/**\n * Removes the component from the internal members\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction removeComponent(id: symbol) {\n  if (!componentsMap.has(id)) {\n    return;\n  }\n\n  componentsMap.delete(id);\n  componentsOrder.splice(componentsOrder.indexOf(id), 1);\n}\n\n/**\n * Clears the priorFocusCache of the specified component\n *\n * @param id The id of the component whose cache is to be cleared\n */\nfunction clearFocusCache(id: symbol) {\n  priorFocusCache.delete(id);\n}\n\n/**\n * Adds event listeners to the document element\n */\nfunction addDocumentListeners() {\n  // Add the events in capture phase, as we do not want this to be stopped by the elements\n  // in the DOM tree.\n  // make sure to use keydown as we need to prevent the default behavior which is moving to\n  // the address bar in some browsers & OS.\n  document.documentElement.addEventListener('keydown', handleDocumentKeyDownCapture, true);\n  document.documentElement.addEventListener('blur', handleDocumentBlurCapture, true);\n  hasDocumentListener = true;\n}\n\n/**\n * Removes event listeners from the document element\n */\nfunction removeDocumentListeners() {\n  document.documentElement.removeEventListener('keydown', handleDocumentKeyDownCapture, true);\n  document.documentElement.removeEventListener('blur', handleDocumentBlurCapture, true);\n  hasDocumentListener = false;\n}\n\n/**\n * Registers a component for its focus to be managed.\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param componentOptions An object containing component options\n * @param focusManagerOptions An object containing focus manager options\n *\n * @returns An object containing focus event listeners\n */\nfunction register(\n  id: symbol,\n  componentOptions: ComponentOptions,\n  focusManagerOptions: FocusManagerOptions = { handleEscapeKey: true }\n) {\n  if (!hasDocumentListener) {\n    addDocumentListeners();\n  }\n\n  addComponent(id, componentOptions);\n  const handlers: FocusManagerHandlers = {\n    onFocusIn: (event: FocusEvent) => handleComponentFocus(id, event),\n    onFocusOut: (event: FocusEvent) => handleComponentBlur(id, event)\n  };\n  if (focusManagerOptions.handleEscapeKey) {\n    handlers['onKeyUp'] = (event: KeyboardEvent) => handleComponentKeyUp(id, event);\n  }\n  return handlers;\n}\n\n/**\n * Focuses the element which was focused prior to the passed component.\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The event that initiated the focus transfer. The event will be default prevented if the focus\n *              is transferred successfully.\n * @returns true, if focus is restored. false otherwise.\n */\nfunction togglePreviousFocus(id: symbol, event?: Event) {\n  const target = getClosestPriorFocusedElement(id);\n  const { callbacks } = componentsMap.get(id) ?? {};\n  if (target && document.body.contains(target)) {\n    (target as HTMLElement).focus();\n    // invoke callback to let the component know the focus is left\n    callbacks?.onFocusLeave?.();\n    // As the prior focus is restored, empty the focus cache\n    priorFocusCache.clear();\n    event?.preventDefault();\n    return true;\n  }\n\n  // Prior focused element does not exist or\n  // Element does not exist in DOM.\n  return false;\n}\n\n/**\n * Unregisters a component from focus management\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction unregister(id: symbol) {\n  removeComponent(id);\n  clearFocusCache(id);\n\n  if (hasDocumentListener && componentsMap.size === 0) {\n    // no component is registered, so remove the document listeners\n    removeDocumentListeners();\n  }\n}\n\n/**\n * Moves the priority of the component with the specified id\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction prioritize(id: symbol) {\n  if (!componentsMap.has(id)) {\n    // Do nothing if the component is not registered\n    return;\n  }\n\n  // Remove and add the component with the same ref\n  // to move it in the priority queue\n  const options = componentsMap.get(id)!;\n  removeComponent(id);\n  addComponent(id, options);\n}\n\n/**\n * The focus manager object\n */\nconst messagesFocusManager = {\n  prioritize,\n  register,\n  togglePreviousFocus,\n  unregister\n};\n\n/**\n * A custom hook that handles focus management for the messages component.\n * @param ref The custom ref handle for the component\n * @param callbacks Optional callbacks\n * @returns The handlers and a controller\n */\nexport function useMessageFocusManager(\n  ref: ComponentOptions['ref'],\n  callbacks?: ComponentOptions['callbacks'],\n  options?: FocusManagerOptions\n) {\n  const id = useRef(Symbol());\n  const focusManager = useRef(messagesFocusManager);\n  const [handlers, setHandlers] = useState<FocusManagerHandlers>({});\n  const controller = useMemo(\n    () => ({\n      prioritize: () => focusManager.current.prioritize(id.current),\n      restorePriorFocus: () => focusManager.current.togglePreviousFocus(id.current)\n    }),\n    []\n  );\n\n  // Register handlers for focus management\n  useEffect(() => {\n    const currentFocusManager = focusManager.current;\n    const currentId = id.current;\n    setHandlers(currentFocusManager.register(currentId, { ref, callbacks }, options));\n    return () => currentFocusManager.unregister(currentId);\n    // eslint-disable-next-line\n  }, []); // we only want this to run on mount\n\n  return {\n    handlers,\n    controller\n  };\n}\n"],"names":["componentsMap","Map","componentsOrder","priorFocusCache","priorFocusedElement","currentFocusedMessage","hasDocumentListener","handleDocumentKeyDownCapture","event","size","key","defaultPrevented","i","arr","search","defaultIndex","index","indexOf","indexOfOrDefaultTo","length","id","ref","get","current","focus","preventDefault","callbacks","onFocusLeave","cycleFocusThroughMessages","togglePreviousFocus","handleDocumentBlurCapture","target","handleComponentFocus","has","element","values","contains","isPartOfRegisteredMessages","set","onFocus","addComponent","options","push","removeComponent","delete","splice","getClosestPriorFocusedElement","document","body","clear","messagesFocusManager","prioritize","register","componentOptions","focusManagerOptions","handleEscapeKey","documentElement","addEventListener","handlers","onFocusIn","onFocusOut","undefined","handleComponentBlur","type","includes","handleComponentKeyUp","unregister","clearFocusCache","removeEventListener","useRef","Symbol","focusManager","setHandlers","useState","controller","useMemo","restorePriorFocus","useEffect","currentFocusManager","currentId"],"mappings":"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"}