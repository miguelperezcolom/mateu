{"version":3,"file":"utils-8ccd1b88.js","sources":["../../src/PRIVATE_Axis/utils/axisUtils.ts","../../src/PRIVATE_Axis/utils/titleUtils.ts","../../src/PRIVATE_Axis/timeAxis/timeAxisInfo.ts","../../src/utils/PRIVATE_chartUtils/dataUtils.ts","../../src/PRIVATE_Axis/dataAxis/dataAxisInfo.ts","../../src/utils/PRIVATE_chartUtils/numberFomatUtils.ts","../../src/PRIVATE_Axis/dataAxis/dataAxisUtils.ts","../../src/UNSAFE_BarChart/utils/barSeriesUtils.ts","../../src/PRIVATE_Axis/groupAxis/hierarchicalUtils.ts","../../src/PRIVATE_Axis/groupAxis/groupAxisInfo.ts","../../src/PRIVATE_Axis/groupAxis/separator.ts","../../src/utils/PRIVATE_chartUtils/layoutUtils.ts","../../src/utils/PRIVATE_chartUtils/utils.ts","../../src/utils/PRIVATE_chartUtils/overviewUtils.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition, DataAxisProps } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { AXIS_DEFAULTS } from './axisDefaults';\nimport { VisTextStyle } from '#utils/UNSAFE_visUtils';\nimport type { Font, GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\n\nconst AXIS_MAX_RATIO = 0.3;\n\n/**\n * Returns resolved axis position.\n */\nexport function getAxesPosition(\n  yAxis: DataAxisProps | undefined,\n  y2Axis: DataAxisProps | undefined,\n  isHoriz: boolean,\n  isRtl: boolean\n): {\n  xAxisPosition: AxisPosition;\n  yAxisPosition: AxisPosition;\n  y2AxisPosition: AxisPosition;\n} {\n  let xAxisPosition, yAxisPosition: AxisPosition, y2AxisPosition: AxisPosition;\n\n  if (isHoriz) {\n    yAxisPosition = yAxis?.position === 'top' ? 'top' : 'bottom';\n    y2AxisPosition = y2Axis?.position === 'bottom' ? 'bottom' : 'top';\n    xAxisPosition = (isRtl ? 'right' : 'left') as AxisPosition;\n  } else {\n    xAxisPosition = 'bottom' as AxisPosition;\n    const isYEnd = yAxis?.position === 'end';\n    const isY2End = y2Axis?.position === 'end';\n    yAxisPosition = isYEnd ? (isRtl ? 'left' : 'right') : isRtl ? 'right' : 'left';\n    y2AxisPosition = isY2End ? (isRtl ? 'right' : 'left') : isRtl ? 'left' : 'right';\n  }\n  return { xAxisPosition, yAxisPosition, y2AxisPosition };\n}\n\n/**\n * Returns the tick label anchor position for axis.\n * @param position\n * @param isRtl\n */\nexport function getTickLabelAnchor(position: AxisPosition, isRtl: boolean, isGroupAxis?: boolean) {\n  if (!isRtl) {\n    return position === 'left' ? 'end' : position === 'right' ? 'start' : 'middle';\n  }\n  return position === 'left' || (isGroupAxis && position === 'right')\n    ? 'start'\n    : position === 'right'\n    ? 'end'\n    : 'middle';\n}\n\n/**\n * Returns the scale for the axis.\n * @param availSpace\n * @param axisViewportMin\n * @param axisViewportMax\n * @param position\n * @returns\n */\nexport function getAxisRange(\n  availSpace: Dimension,\n  position: AxisPosition,\n  isRtl: boolean,\n  isTimeAxis?: boolean\n) {\n  const { x, y, width, height } = availSpace;\n  const y2 = y + height;\n  const x2 = x + width;\n\n  let rangeStart: number;\n  let rangeEnd: number;\n\n  if (position === 'left' || position === 'right') {\n    rangeStart = isTimeAxis ? y : y2;\n    rangeEnd = isTimeAxis ? y2 : y;\n  } else {\n    rangeStart = isRtl ? x2 : x;\n    rangeEnd = isRtl ? x : x2;\n  }\n\n  return [rangeStart, rangeEnd];\n}\n\n/**\n * Returns the maximum possible size of the axis.\n * @param availSpace The available space.\n * @param isHoriz If the axis is horizontal.\n * @param axisSize The ratio of axis to the chart.\n * @returns\n */\nexport function getAxisMaxSize(availSpace: Dimension, isHoriz: boolean, axisSize?: number) {\n  const size = Math.max(0, Math.min(1, axisSize != undefined ? axisSize : AXIS_MAX_RATIO));\n  return (isHoriz ? availSpace.height : availSpace.width) * size;\n}\n\n/**\n * Returns the width of a group for given availableSpace, axisposition and axis extents.\n * @param availSpace The available space to render the axis\n * @param position The position of the axis\n * @param min The minimum value of axis coord\n * @param max The maximum value of axis coord\n * @returns\n */\nexport function getGroupWidth(\n  availSpace: Dimension,\n  position: AxisPosition,\n  min: number,\n  max: number\n) {\n  const isHoriz = position === 'top' || position === 'bottom';\n  if (isHoriz) {\n    return availSpace.width / (max - min);\n  } else {\n    return availSpace.height / (max - min);\n  }\n}\n\n/**\n * Returns the num of labels to skip safely.\n * @param axisStepWidth\n * @param tickLabelStyle\n * @param getTextDimensions\n * @returns\n */\nexport function getSafeSkips(\n  axisStepWidth: number,\n  tickLabelStyle: VisTextStyle,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  if (!getTextDimensions) {\n    return 0;\n  }\n  const textDims = getTextDimensions('MW', tickLabelStyle as Font);\n  const gaps = AXIS_DEFAULTS.labelGap;\n  return Math.floor((0.5 * textDims.width + gaps) / (2 * axisStepWidth));\n}\n\nexport function getGroupWidthRatios(barWidths: number[], barGapRatio: number, numGroups: number) {\n  let barWidthSum, gapWidthSum: number, groupWidths;\n  if (barWidths.length === 0) {\n    barWidthSum = numGroups;\n\n    gapWidthSum = (barWidthSum * barGapRatio) / (1 - barGapRatio);\n\n    // no need for group widths if z is constant\n    groupWidths = null;\n  } else {\n    barWidthSum = barWidths?.reduce((prev, cur) => prev + cur, 0);\n\n    // The gap size is the same for all groups, regardless of the bar width.\n    gapWidthSum = (barWidthSum * barGapRatio) / (1 - barGapRatio);\n    groupWidths = barWidths.map((_barWidth) => {\n      // divide the gaps evenly\n      return _barWidth + gapWidthSum / numGroups;\n    });\n  }\n\n  const averageGroupZ = (barWidthSum + gapWidthSum) / numGroups;\n\n  return { groupWidths, averageGroupZ };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport type { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { getSectionDims } from '#utils/PRIVATE_visLayoutUtils';\nimport { getTextInfo, positionMultilineText } from '#PRIVATE_VisSVGText/utils/utils';\nimport { TextProps } from '#PRIVATE_VisSVGText/text.types';\nimport { AxisPosition } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\n\nconst defaultTitleProps = {\n  text: '',\n  lines: [],\n  lineProps: [],\n  titleDim: 0,\n  dims: {\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  },\n  isTruncated: false,\n  isRotated: false\n};\n\n/**\n * Returns the title props.\n * @returns\n */\nexport function getTitleProps(\n  title: string | undefined,\n  titleStyle: Record<string, any>,\n  maxHeight: number,\n  availSpace: Dimension,\n  position: AxisPosition,\n  isRtl: boolean,\n  getTextDimensions?: GetTextDimensionsType\n): TextProps & { titleDim: number } {\n  if (!title || !getTextDimensions) {\n    return defaultTitleProps;\n  }\n\n  const isHoriz = position === 'top' || position === 'bottom';\n\n  const maxWidth = isHoriz ? availSpace.width : availSpace.height;\n\n  const { lines, height, width, dims, lineHeight, isTruncated } = getTextInfo(\n    title,\n    titleStyle,\n    maxWidth,\n    maxHeight,\n    true,\n    1,\n    getTextDimensions\n  );\n\n  if (height > maxHeight || width === 0 || height === 0) {\n    // title does not fit or not rendered\n    return defaultTitleProps;\n  }\n  const isRotated = position === 'left' || position === 'right';\n  const lineProps = positionMultilineText(lines, dims, lineHeight, position, availSpace, isRtl);\n  const textDim = getSectionDims(availSpace, position, width, height);\n  return {\n    text: title,\n    dims: textDim,\n    titleDim: height,\n    isTruncated,\n    lines: position === 'left' || position === 'top' ? lines : lines.reverse(),\n    lineProps,\n    isRotated\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition, Group, TimeAxisProps, ChartSeriesData } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport { getLocale } from '#utils/UNSAFE_getLocale';\nimport { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { merge } from '@oracle/oraclejet-internal-utilities/stringUtils';\nimport { getAxisMaxSize, getAxisRange, getSafeSkips } from '#PRIVATE_Axis/utils/axisUtils';\nimport { getTitleProps } from '#PRIVATE_Axis/utils/titleUtils';\nimport { AXIS_DEFAULTS } from '#PRIVATE_Axis/utils/axisDefaults';\nimport {\n  getGroupAxisLabelsInfo,\n  getTickLabelInfo,\n  skipLabelsGreedy,\n  updateLabelsDims\n} from '#PRIVATE_Axis/utils/labelUtils';\n\nconst TIME_SECOND = 1000;\nconst TIME_MINUTE = 60 * TIME_SECOND;\nconst TIME_HOUR = 60 * TIME_MINUTE;\nconst TIME_DAY = 24 * TIME_HOUR;\nconst TIME_MONTH_MIN = 28 * TIME_DAY;\nconst TIME_MONTH_MAX = 31 * TIME_DAY;\nconst TIME_YEAR_MIN = 365 * TIME_DAY;\nconst TIME_YEAR_MAX = 366 * TIME_DAY;\n\nexport function getTimeAxisProps(\n  groups: Group[],\n  position: AxisPosition,\n  availSpace: Dimension,\n  viewportMin: number,\n  viewportMax: number,\n  averageInterval: number,\n  isRtl: boolean,\n  xAxis?: TimeAxisProps,\n  axisFontSize?: string,\n  getTextDimensions?: GetTextDimensionsType,\n  isTimeAxis?: boolean\n) {\n  const isHoriz = position === 'top' || position === 'bottom';\n  const axisMaxDim = getAxisMaxSize(availSpace, isHoriz, xAxis?.size);\n  const titleStyle = { fontSize: axisFontSize, ...xAxis?.titleStyle };\n  const timeAxisType = xAxis?.timeAxisType || 'regular';\n  const { titleDim, ...titleProps } = getTitleProps(\n    xAxis?.title,\n    titleStyle,\n    axisMaxDim,\n    availSpace,\n    position,\n    isRtl,\n    getTextDimensions\n  );\n  const { width: titleWidth, height: titleHeight } = titleProps.dims!;\n  const isTitleRendered = titleWidth > 0 && titleHeight > 0;\n  let axisDim = isTitleRendered ? titleDim + AXIS_DEFAULTS.titleGap : 0;\n  const isRotated = position === 'left' || position === 'right';\n\n  if (isTitleRendered) {\n    if (isRotated) {\n      availSpace.width -= axisDim;\n      availSpace.x += position === 'left' ? axisDim : 0;\n    } else {\n      availSpace.height -= axisDim;\n      availSpace.y += position === 'top' ? axisDim : 0;\n    }\n  }\n  const [start, end] = getAxisRange(availSpace, position, isRtl, isTimeAxis);\n\n  const tickLabelStyle = {\n    fontSize: axisFontSize,\n    fill: xAxis?.tickLabel?.style?.color,\n    ...xAxis?.tickLabel?.style,\n    textAnchor: 'middle'\n  };\n\n  const valueToCoord = (value: number) => {\n    return getCoordFromValue(\n      value,\n      viewportMin,\n      viewportMax,\n      start,\n      end,\n      averageInterval,\n      groups,\n      xAxis?.timeAxisType!\n    );\n  };\n\n  const scale = {\n    transform: valueToCoord,\n    range: () => {\n      return [start, end];\n    },\n    domain: () => {\n      return [viewportMin, viewportMax];\n    },\n    invert: (coord: number) => {\n      return getValueFromCoord(\n        coord,\n        start,\n        end,\n        viewportMin,\n        viewportMax,\n        averageInterval,\n        groups,\n        xAxis?.timeAxisType || 'enabled'\n      );\n    }\n  };\n\n  const locale = getLocale();\n  let axisStep = xAxis?.step;\n  const gap = AXIS_DEFAULTS.labelGap;\n\n  let times: number[] = [];\n  if (axisStep != null) {\n    times = getLabelPos(viewportMin, viewportMax, axisStep);\n  } else if (timeAxisType === 'mixedFrequency') {\n    axisStep = getMixedFrequencyStep(viewportMax - viewportMin);\n    times = getLabelPos(viewportMin, viewportMax, axisStep);\n  } else {\n    for (let i = 0; i < groups.length; i++) {\n      const date = new Date(groups[i].id).getTime();\n      if (date >= viewportMin && date <= viewportMax) times.push(date);\n    }\n    axisStep = averageInterval;\n  }\n\n  const level1Formatter = Array.isArray(xAxis?.tickLabel?.format)\n    ? xAxis?.tickLabel?.format[0]\n    : xAxis?.tickLabel?.format;\n  const level2Formatter = Array.isArray(xAxis?.tickLabel?.format)\n    ? xAxis?.tickLabel?.format[1]\n    : undefined;\n\n  if (timeAxisType != 'skipGaps') {\n    const granularity = calculateGranularity(axisStep, viewportMax - viewportMin);\n    times = treatMissingValues(times, granularity);\n\n    if (times.length > 1) {\n      // Since the contents of the times array might have been updated, the step value should\n      // be updated.\n      // The step value is approximated to the estimated average of the intervals in the updated\n      // times array.\n      // It is safe to do so even when there were no missing values as it should not have any side-effects\n      // on rendering the axis.\n      // If there are less than 2 values in the times array, proceed with the existing step value.\n      axisStep = (times[times.length - 1] - times[0]) / (times.length - 1);\n    }\n    const label = formatAxisLabel(\n      new Date(times[0] || viewportMin),\n      undefined,\n      !isHoriz,\n      false,\n      locale,\n      granularity,\n      level1Formatter,\n      level2Formatter\n    )[0];\n    const labelDims = getTextDimensions?.(label!, tickLabelStyle);\n    if (labelDims) {\n      const labelDim = isHoriz ? labelDims.width : labelDims.height;\n      const totalWidth =\n        (labelDim + getTickLabelGap(labelDims.height, isHoriz)) * (times.length - 1);\n      if (totalWidth > Math.abs(end - start)) {\n        axisStep = getMixedFrequencyStep(viewportMax - viewportMin);\n        times = getLabelPos(viewportMin, viewportMax, axisStep);\n      }\n    }\n  }\n\n  if (times.length === 0) {\n    times = [viewportMin];\n  }\n\n  const granularity = calculateGranularity(axisStep!, viewportMax - viewportMin);\n\n  const isLabelRendered = xAxis?.tickLabel?.isRendered != false;\n  let isLabel1Rendered = isLabelRendered;\n  let isLabel2Rendered = isLabelRendered;\n\n  let tickLabels: any[] = [];\n  const axisStepWidth = Math.abs(end - start) / times.length;\n\n  if (xAxis?.isRendered === false) {\n    return {\n      defaultLabelFormatter: undefined,\n      title: undefined,\n      titleProps: undefined,\n      titleStyle: {},\n      axisDim: 0,\n      scale,\n      tickLabels: [],\n      axisStepWidth,\n      averageGroupZ: 0,\n      tickLabelStyle: {},\n      separators: [],\n      isGroupLabelRendered: () => false\n    };\n  }\n\n  if (isLabelRendered) {\n    const { labelInfos1, labelInfos2 } = generateLabels(\n      times,\n      granularity,\n      valueToCoord,\n      level1Formatter,\n      level2Formatter\n    );\n\n    const numOfSafeSkips = getSafeSkips(axisStepWidth, tickLabelStyle, getTextDimensions);\n\n    const getLabel1Dims = (label: string | undefined, index: number) => {\n      const rangeValue = labelInfos1[index].coord;\n      if (!rangeValue || !label) {\n        return {\n          indexAtLevel: index,\n          text: '',\n          dims: { width: 0, height: 0, x: 0, y: 0 },\n          lines: [],\n          isTruncated: false,\n          didNotFit: false,\n          lineProps: []\n        };\n      }\n      return getTickLabelInfo(\n        rangeValue,\n        label,\n        index,\n        tickLabelStyle,\n        isHoriz,\n        false,\n        false,\n        false,\n        Infinity,\n        Infinity,\n        availSpace,\n        getTextDimensions\n      );\n    };\n\n    const getLabel2Dims = (label: string | undefined, index: number) => {\n      const rangeValue = labelInfos2[index]?.coord;\n      if (!rangeValue || !label) {\n        return {\n          indexAtLevel: index,\n          text: '',\n          dims: { width: 0, height: 0, x: 0, y: 0 },\n          lines: [],\n          lineProps: [],\n          didNotFit: false,\n          isTruncated: false\n        };\n      }\n\n      return getTickLabelInfo(\n        rangeValue,\n        label,\n        index,\n        tickLabelStyle,\n        isHoriz,\n        false,\n        false,\n        false,\n        Infinity,\n        Infinity,\n        availSpace,\n        getTextDimensions\n      );\n    };\n\n    const {\n      maxWidth: label1MaxWidth,\n      maxHeight: label1MaxHeight,\n      tickLabels: tickLabels1\n    } = getGroupAxisLabelsInfo(\n      labelInfos1.map((i) => i.text),\n      getLabel1Dims,\n      isHoriz,\n      false,\n      false,\n      numOfSafeSkips\n    );\n\n    axisDim = isHoriz ? label1MaxHeight + gap : label1MaxWidth + gap;\n\n    isLabel1Rendered =\n      isTitleRendered && isHoriz\n        ? axisDim < axisMaxDim - titleHeight\n        : axisDim < axisMaxDim - titleHeight;\n\n    const {\n      maxWidth: label2MaxWidth,\n      maxHeight: label2MaxHeight,\n      tickLabels: tickLabels2\n    } = skipLabelsGreedy(\n      labelInfos2.map((i) => i.label2),\n      getLabel2Dims,\n      isHoriz\n    );\n\n    const level2AxisDim = isHoriz\n      ? axisDim + label2MaxHeight + gap\n      : axisDim + label2MaxWidth + gap;\n\n    isLabel2Rendered = isHoriz\n      ? level2AxisDim < axisMaxDim - titleHeight\n      : level2AxisDim < axisMaxDim - titleHeight;\n\n    if (isLabel1Rendered) {\n      const getAxisPos = (index: number) => {\n        return labelInfos1[index].coord;\n      };\n      updateLabelsDims(\n        label1MaxWidth,\n        label1MaxHeight,\n        tickLabels1,\n        getAxisPos,\n        availSpace,\n        position\n      );\n      tickLabels = tickLabels.concat(tickLabels1);\n      axisDim = axisDim + titleHeight;\n    }\n\n    if (isLabel2Rendered) {\n      const getAxisPos = (index: number) => {\n        return labelInfos2[index].coord;\n      };\n      updateLabelsDims(\n        label2MaxWidth,\n        label2MaxHeight,\n        tickLabels2,\n        getAxisPos,\n        availSpace,\n        position\n      );\n      tickLabels.forEach((value) => {\n        if (value.lineProps[0]) {\n          value.lineProps[0].y -= value.lineProps[0].height;\n        }\n      });\n      tickLabels = tickLabels.concat(tickLabels2);\n      axisDim = level2AxisDim + titleHeight;\n    }\n  }\n\n  const defaultLabelFormatter = (axisValue: number) => {\n    const date = new Date(axisValue);\n    const twoLabels = formatAxisLabel(\n      date,\n      undefined,\n      false,\n      false,\n      locale,\n      granularity,\n      level1Formatter,\n      level2Formatter\n    );\n    return merge(twoLabels as string[]) as string;\n  };\n\n  return {\n    defaultLabelFormatter,\n    title: isTitleRendered ? xAxis?.title : undefined,\n    titleProps: isTitleRendered ? titleProps : undefined,\n    titleStyle,\n    axisDim,\n    scale,\n    tickLabels,\n    axisStepWidth,\n    averageGroupZ: 0,\n    tickLabelStyle,\n    separators: [],\n    isGroupLabelRendered: () => false\n  };\n}\n\n/**\n * Calculates the granularity of the time axis.\n * @param step The step of the axis.\n * @param timeRange The time range of the axis.\n * @returns\n */\nexport function calculateGranularity(step: number, timeRange: number) {\n  if (step >= TIME_YEAR_MIN || timeRange >= 6 * TIME_YEAR_MIN) return TIME_YEAR_MIN;\n\n  if (step >= TIME_MONTH_MIN || timeRange >= 6 * TIME_MONTH_MIN) return TIME_MONTH_MIN;\n\n  if (step >= TIME_DAY || timeRange >= 6 * TIME_DAY) return TIME_DAY;\n\n  if (step >= TIME_HOUR || timeRange >= 6 * TIME_HOUR) return TIME_HOUR;\n\n  if (step >= TIME_MINUTE || timeRange >= 6 * TIME_MINUTE) return TIME_MINUTE;\n\n  return TIME_SECOND;\n}\n\n/**\n * Returns the step for mixed frequency time range.\n * @param timeRange\n * @returns\n */\nexport function getMixedFrequencyStep(timeRange: number) {\n  if (timeRange >= 6 * TIME_YEAR_MIN) return TIME_YEAR_MIN;\n  if (timeRange >= 6 * TIME_MONTH_MIN) return TIME_MONTH_MIN;\n  if (timeRange >= 6 * TIME_DAY) return TIME_DAY;\n  if (timeRange >= TIME_DAY) return 3 * TIME_HOUR;\n  if (timeRange >= 6 * TIME_HOUR) return TIME_HOUR;\n  if (timeRange >= TIME_HOUR) return 15 * TIME_MINUTE;\n  if (timeRange >= 30 * TIME_MINUTE) return 5 * TIME_MINUTE;\n  if (timeRange >= 6 * TIME_MINUTE) return TIME_MINUTE;\n  if (timeRange >= TIME_MINUTE) return 15 * TIME_SECOND;\n  if (timeRange >= 30 * TIME_SECOND) return 5 * TIME_SECOND;\n  return TIME_SECOND;\n}\n\nexport function formatLabelWithFormatter(\n  date: Date,\n  prevDate: Date | undefined,\n  formatter?: (date: number) => string\n) {\n  if (!formatter) {\n    return '';\n  }\n\n  const label = formatter(date.getTime());\n  const prevLabel = prevDate ? formatter?.(prevDate.getTime()) : undefined;\n\n  if (prevLabel !== label || label == null) {\n    return label;\n  }\n  // TODO: JET-65541. This is not as straightforward for format function. See old jet logic formatLabelWithConverter.\n  // do not skip label when it is same as prevLabel checking for granularity\n  // for eg. if June and July both convert to 'J' and granularity is TIME_MONTH_MIN, we want to keep both 'J's\n  // for eg. if Saturday and Sunday both convert to 'S' and granularity is TIME_MONTH_DAY, we want to keep both 'S's\n\n  return '';\n}\n\nexport function formatAxisLabel(\n  date: Date,\n  prevDate: Date | undefined,\n  bOneLabel: boolean,\n  isVert: boolean,\n  locale: string,\n  granularity: number,\n  label1Formatter?: (date: number) => string,\n  label2Formatter?: (date: number) => string\n) {\n  let label1 = null; // level 1 label\n  let label2 = null; // level 2 label\n\n  // If dateTimeFormatter is used, use it\n  if (label1Formatter || label2Formatter) {\n    if (label1Formatter) label1 = formatLabelWithFormatter(date, prevDate, label1Formatter);\n    if (label2Formatter) label2 = formatLabelWithFormatter(date, prevDate, label2Formatter);\n\n    return [label1, label2];\n  }\n\n  if (granularity === TIME_YEAR_MIN) {\n    label1 = formatDate(date, locale, false, false, true); // Year\n  } else if (granularity === TIME_MONTH_MIN) {\n    if (prevDate == null || prevDate.getMonth() != date.getMonth())\n      label1 = formatDate(date, locale, false, true, false); // Month\n\n    if (prevDate == null || prevDate.getFullYear() != date.getFullYear())\n      label2 = formatDate(date, locale, false, false, true); // Year\n  } else if (granularity === TIME_DAY) {\n    if (bOneLabel) {\n      label1 = formatDate(date, locale, true, true, true); // Day, Month, Year\n    } else {\n      if (prevDate == null || prevDate.getDate() != date.getDate())\n        label1 = formatDate(date, locale, true, false, false); // Day\n\n      if (prevDate == null || prevDate.getFullYear() != date.getFullYear())\n        label2 = formatDate(date, locale, false, true, true); // Year, Month\n      else if (prevDate.getMonth() != date.getMonth())\n        label2 = formatDate(date, locale, false, true, false); // Month\n    }\n  } else {\n    if (granularity === TIME_HOUR) {\n      if (prevDate == null || prevDate.getHours() != date.getHours())\n        label1 = formatTime(date, locale, false, false); // HH AM/PM or HH:MM\n    } else if (granularity === TIME_MINUTE) {\n      if (prevDate == null || prevDate.getMinutes() != date.getMinutes())\n        label1 = formatTime(date, locale, true, false); // HH:MM\n    } else {\n      if (prevDate == null || prevDate.getSeconds() != date.getSeconds())\n        label1 = formatTime(date, locale, true, true); // HH:MM:SS\n    }\n\n    if (isVert) {\n      if (prevDate == null || prevDate.getDate() != date.getDate())\n        label2 = formatDate(date, locale, true, true, false); // Month, Day\n    } else {\n      if (prevDate == null || prevDate.getFullYear() != date.getFullYear())\n        label2 = formatDate(date, locale, true, true, true); // Year, Month, Day\n      else if (prevDate.getMonth() != date.getMonth())\n        label2 = formatDate(date, locale, true, true, false); // Month, Day\n      else if (prevDate.getDate() != date.getDate())\n        label2 = formatDate(date, locale, true, false, false); // Day\n    }\n  }\n\n  return [label1, label2];\n}\n\n/**\n * Returns the formatted date string.\n * @param date\n * @param locale\n * @param showDay\n * @param showMonth\n * @param showYear\n * @returns\n */\nexport function formatDate(\n  date: Date,\n  locale: string,\n  showDay: boolean,\n  showMonth: boolean,\n  showYear: boolean\n) {\n  // this function is equivalent to _formatDate present in DvtTimeAxisInfo\n  // replacing the impl to use toLocaleDateString\n\n  const options = {\n    year: showYear ? ('numeric' as const) : undefined,\n    month: showMonth ? ('short' as const) : undefined,\n    day: showDay ? ('numeric' as const) : undefined\n  };\n\n  return date.toLocaleDateString(locale, options);\n}\n\n/**\n * Returns the formatted time string.\n * @param date\n * @param locale\n * @param showMinute\n * @param showSecond\n * @returns\n */\nexport function formatTime(date: Date, locale: string, showMinute: boolean, showSecond: boolean) {\n  // this function is equivalent to _formatDate present in DvtTimeAxisInfo\n  // replacing the impl to use toLocaleDateString\n\n  const options = {\n    hour: '2-digit' as const,\n    minute: showMinute ? ('2-digit' as const) : undefined,\n    second: showSecond ? ('2-digit' as const) : undefined\n  };\n\n  return date.toLocaleTimeString(locale, options);\n}\n\nexport function getLabelPos(start: number, end: number, step: number) {\n  // The time positions has to be at even intervals from the beginning of a year (January 1, 12:00:00 AM), otherwise\n  // we may have labels such as [2013, 2014, 2015, ...] that are drawn at [June 8 2013, June 8 2014, June 8 2015, ...],\n  // which is data misrepresentation.\n  const anchor = new Date(start);\n  const initialTimezoneOffset = anchor.getTimezoneOffset();\n  anchor.setMonth(0, 1); // January 1\n  anchor.setHours(0, 0, 0, 0); // 00:00:00\n  let time = anchor.getTime();\n\n  const times = [];\n  if (step >= TIME_YEAR_MIN && step <= TIME_YEAR_MAX) {\n    // Assume that the step is one year, which can mean different # of days depending on the year\n    while (time < start) time = addOneYear(time);\n    while (time <= end) {\n      times.push(time);\n      time = addOneYear(time);\n    }\n  } else if (step >= TIME_MONTH_MIN && step <= TIME_MONTH_MAX) {\n    // Assume that the step is one month, which can mean different # of days depending on the month\n    while (time < start) time = addOneMonth(time);\n    while (time <= end) {\n      times.push(time);\n      time = addOneMonth(time);\n    }\n  } else {\n    // Bug 26396791. Correction is needed due to daylight savings.\n    // Only apply daylight correction when step is less than a month. Daylight savings does not impact any step higher than month.\n    // JET-52348 - Ideally we should be using Date api to add and substract date offsets to calculate labels since\n    // Date will automatically handle daylight savings. This approach should solve issues for steps greater than month but we could encounter\n    // offsets in axis labels when dataset values are in different daylight savings and chart step is low (eg day or hour);\n    const timezoneCorrection = (initialTimezoneOffset - anchor.getTimezoneOffset()) * 60 * 1000;\n    const correction = step < TIME_MONTH_MIN ? timezoneCorrection : 0;\n    time += Math.ceil((start - time - correction) / step) * step + correction;\n    while (time <= end) {\n      times.push(time);\n      time += step;\n    }\n  }\n  return times;\n}\n\nexport function generateLabels(\n  times: number[],\n  granularity: number,\n  getCoordFromValue: (time: number) => number,\n  label1Formatter?: (time: number) => string,\n  label2Formatter?: (time: number) => string\n) {\n  const locale = getLocale();\n\n  const labelInfos1 = [];\n  const coords1 = [];\n\n  const labelInfos2 = [];\n  const coords2 = [];\n  let isOneLevel = true;\n  let prevDate = undefined;\n  for (let i = 0; i < times.length; i++) {\n    const time = times[i];\n    const coord = getCoordFromValue(time);\n    const date = new Date(time);\n    const [label1, label2] = formatAxisLabel(\n      date,\n      prevDate,\n      false,\n      false,\n      locale,\n      granularity,\n      label1Formatter,\n      label2Formatter\n    );\n    if (label1 != null) {\n      labelInfos1.push({ text: label1, coord });\n      coords1.push(coord);\n    }\n\n    if (label2 != null) {\n      labelInfos2.push({ label2, coord });\n      coords2.push(coord);\n      isOneLevel = false;\n    }\n\n    prevDate = date;\n  }\n  return {\n    labelInfos1,\n    labelInfos2,\n    coords1,\n    coords2,\n    isOneLevel\n  };\n}\n/**\n * Adds the time by one year, e.g. 2014 January 15 -> 2015 January 15 -> ...\n */\nexport function addOneYear(time: number) {\n  const date = new Date(time);\n  date.setFullYear(date.getFullYear() + 1);\n  return date.getTime();\n}\n\n/**\n * Adds the time by one month, e.g. January 15 -> February 15 -> March 15 -> ...\n */\nexport function addOneMonth(time: number) {\n  const date = new Date(time);\n  date.setMonth(date.getMonth() + 1);\n  return date.getTime();\n}\n\n/**\n * Returns the corresponding index for the given time in time axis.\n * @param time The time stamp.\n * @param averageInterval The average interval of the time axis.\n * @param groups The groups array.\n * @returns\n */\nexport function timeToIndex(time: number, averageInterval: number, groups: Group[]) {\n  let endIndex = groups.length;\n  // TODO: can do binary search to make this fast\n  for (let i = 0; i < groups.length; i++) {\n    if (time <= new Date(groups[i].id).getTime()) {\n      endIndex = i;\n      break;\n    }\n  }\n  const startIndex = endIndex - 1;\n\n  const startTime =\n    groups[startIndex] !== undefined\n      ? new Date(groups[startIndex].id).getTime()\n      : new Date(groups[0].id).getTime() - averageInterval;\n  const endTime =\n    groups[endIndex] !== undefined\n      ? new Date(groups[endIndex].id).getTime()\n      : new Date(groups[groups.length - 1].id).getTime() + averageInterval;\n\n  return startIndex + (time - startTime) / (endTime - startTime);\n}\n\n/**\n * Returns the time stamp for given index.\n * @param index The index.\n * @param averageInterval The average interval of the axis.\n * @param groups The groups array.\n * @returns\n */\nexport function indexToTime(index: number, averageInterval: number, groups: Group[]) {\n  const endIndex = Math.min(Math.max(Math.ceil(index), 0), groups.length);\n  const startIndex = endIndex - 1;\n  const startTime =\n    groups[startIndex] !== undefined\n      ? getTime(groups[startIndex].id)\n      : getTime(groups[0].id) - averageInterval;\n  const endTime =\n    groups[endIndex] !== undefined\n      ? getTime(groups[endIndex].id)\n      : getTime(groups[groups.length - 1].id) + averageInterval;\n\n  return startTime + (index - startIndex) * (endTime - startTime);\n}\n\nexport function getTime(uxTime: string | number) {\n  return new Date(uxTime).getTime();\n}\n\nexport function getCoordFromValue(\n  value: number,\n  minValue: number,\n  maxValue: number,\n  startCoord: number,\n  endCoord: number,\n  averageInterval: number,\n  groups: Group[],\n  timeAxisType: 'skipGaps' | 'mixedFrequency' | 'enabled'\n) {\n  let ratio;\n  if (timeAxisType === 'skipGaps') {\n    if (groups.length < 1) {\n      return startCoord;\n    }\n    const minVal = timeToIndex(minValue, averageInterval, groups);\n    const maxVal = timeToIndex(maxValue, averageInterval, groups);\n    const val = timeToIndex(value, averageInterval, groups);\n    ratio = (val - minVal) / (maxVal - minVal);\n  } else {\n    ratio = (value - minValue) / (maxValue - minValue);\n  }\n\n  return startCoord + ratio * (endCoord - startCoord);\n}\n\nexport function getValueFromCoord(\n  coord: number,\n  startCoord: number,\n  endCoord: number,\n  minValue: number,\n  maxValue: number,\n  averageInterval: number,\n  groups: Group[],\n  timeAxisType: 'skipGaps' | 'enabled' | 'mixedFrequency'\n) {\n  const ratio = (coord - startCoord) / (endCoord - startCoord);\n\n  if (timeAxisType === 'skipGaps') {\n    const minVal = timeToIndex(minValue, averageInterval, groups);\n    const maxVal = timeToIndex(maxValue, averageInterval, groups);\n    return indexToTime(minVal + ratio * (maxVal - minVal), averageInterval, groups);\n  } else return minValue + ratio * (maxValue - minValue);\n}\n\nexport function isoToNumber(dateString?: string) {\n  if (!dateString) {\n    return;\n  }\n  return new Date(dateString).getTime();\n}\n\n/**\n * Returns the average interval for the time axis.\n * @param groups The number of groups.\n * @param start The earliest time among all data points.\n * @param end The latest time among all data points.\n * @returns\n */\nexport function getAverageInterval(groups: Group[], start: number, end: number) {\n  if (end != start && groups.length > 1) {\n    return (end - start) / (groups.length - 1);\n  } else if (end - start > 0) {\n    return end - start;\n  }\n\n  return 6 * TIME_MINUTE;\n}\n\n/**\n * Returns the time axis info.\n * @param groups The groups array.\n * @param xAxis The xAxis props.\n * @param offset The start and end offset for the axis.\n * @param timeAxisRange The start and end of the time range.\n * @returns\n */\nexport function getTimeAxisInfo(\n  groups: Group[],\n  xAxis: TimeAxisProps = {},\n  startOffset: number,\n  endOffset: number,\n  timeAxisRange: { start?: number; end?: number }\n) {\n  let { start, end } = timeAxisRange;\n  const { viewportMin, viewportMax, viewportEndGroup, viewportStartGroup } = xAxis;\n\n  let minValue = isoToNumber((viewportMin || viewportStartGroup) as string);\n  let maxValue = isoToNumber((viewportMax || viewportEndGroup) as string);\n\n  const axisType = xAxis.timeAxisType!;\n  // if start or end are undefined, use the application set viewport settings\n  if (start == undefined) {\n    start = minValue;\n  }\n\n  if (end == undefined) {\n    end = maxValue;\n  }\n\n  const averageInterval = getAverageInterval(groups, start!, end!);\n\n  const globalMin = start! + startOffset * averageInterval;\n  const globalMax = end! + endOffset * averageInterval;\n\n  minValue = minValue || globalMin;\n  maxValue = maxValue || globalMax;\n\n  let startIndex = 0;\n  let endIndex = Math.max(0, groups.length - 1);\n\n  // TODO: since groups is expected to be sorted, can binary search here\n  groups.forEach((group: Group, index: number) => {\n    const timeStamp = new Date(group.id).getTime();\n\n    if (timeStamp < minValue!) {\n      startIndex = index;\n    }\n\n    if (timeStamp < maxValue!) {\n      endIndex = index;\n    }\n  });\n\n  const minAxisExtent = getMinTimeAxisExtent(axisType, globalMin, globalMax, averageInterval);\n\n  return {\n    viewportMin: minValue,\n    viewportMax: maxValue,\n    viewportStartGroup,\n    viewportEndGroup,\n    startIndex,\n    endIndex,\n    min: globalMin,\n    max: globalMax,\n    step: averageInterval,\n    ticks: [],\n    minorTicks: [],\n    minAxisExtent\n  };\n}\n\nfunction getMinTimeAxisExtent(\n  axisType: 'skipGaps' | 'mixedFrequency' | 'enabled',\n  globalMin: number,\n  globalMax: number,\n  averageInterval: number\n) {\n  if (axisType === 'skipGaps') {\n    return 1;\n  } else if (axisType === 'mixedFrequency') {\n    return Math.min((globalMax - globalMin) / 8, averageInterval);\n  } else {\n    return averageInterval;\n  }\n}\n\n/**\n * Returns the maximum of time stamps for the given dataset\n * and time axis type.\n * @param groups The array of groups.\n * @param series The array of series.\n * @param getDataItem The function that returns item for given seriesIndex and groupIndex.\n * @param timeAxisType The time axis type.\n * @returns\n */\nexport function getStartAndEndTime<K extends string | number, D extends { x?: number | string }>(\n  groups: Group[],\n  series: ChartSeriesData<K, D>[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  timeAxis: TimeAxisProps\n) {\n  const range: { start?: number; end?: number } = {\n    start: Number.MAX_VALUE,\n    end: -Number.MAX_VALUE\n  };\n  const numGroups = groups.length;\n  const timeAxisType = timeAxis.timeAxisType;\n\n  if (timeAxisType != 'mixedFrequency' && numGroups > 0) {\n    range.start = isoToNumber(groups[0].id) as number;\n    range.end = isoToNumber(groups[numGroups - 1].id) as number;\n  } else {\n    // TODO: this is inefficient. We should precompute all the repeated necessary\n    // infomation and reuse whereever needed.\n    series.forEach((_: ChartSeriesData<K, D>, seriesIndex: number) => {\n      groups.forEach((_: Group, groupIndex) => {\n        const itemX = getDataItem(seriesIndex, groupIndex)?.x;\n        if (typeof itemX == 'number') return;\n        const num = isoToNumber(itemX);\n        if (num) {\n          range.start = Math.min(range.start!, num);\n          range.end = Math.max(range.end!, num);\n        }\n      });\n    });\n  }\n  // if we can't determine valid range, let the application set viewportMin and viewportMax\n  // or viewportStartGroup, viewportEndGroup to determine the axis range.\n  if (range.start === Number.MAX_VALUE && range.end === -Number.MAX_VALUE) {\n    range.start = undefined;\n    range.end = undefined;\n  }\n  return range;\n}\n\n/**\n * Treat missing values when there are large gaps in time axis.\n * @param times\n * @param granularity\n * @returns\n */\nfunction treatMissingValues(times: number[], granularity: number) {\n  let initialInterval;\n  const intervals: Set<number> = new Set();\n  let hasMissingValues = false;\n  let ret = times; // If there are no missing values, the original array will be returned.\n  const intervalsCache = [];\n\n  const timeLength = times.length;\n  let previousDate = new Date(times[0]);\n  for (let i = 1; i < timeLength; i++) {\n    // Calculate the current interval.\n    const currentDate = new Date(times[i]);\n    const currentInterval = calculateGranularInterval(previousDate, currentDate, granularity);\n    previousDate = currentDate;\n\n    // Cache the result so as to not calculate again while filling the missing values\n    // Since the cache is only used for filling in the missing values, and the operation\n    // is performed in the same order as this one, having the cache key in the format\n    // '1546318800000-1514782800000' should be fine.\n    intervalsCache.push(currentInterval);\n\n    // Proceed only if the current interval is greater than the current\n    // granularity level.\n    if (currentInterval <= 0) {\n      continue;\n    }\n\n    // Add the current interval to the set.\n    // The GCD of all the intervals will be used to fill in the missing the\n    // values.\n    intervals.add(currentInterval);\n\n    // During the initial iteration, we will not have any information on intervals,\n    // so, store the current interval and continue.\n    if (!initialInterval) {\n      initialInterval = currentInterval;\n      continue;\n    }\n\n    // Check if the current interval is regular.\n    if (currentInterval !== initialInterval) {\n      hasMissingValues = true;\n    }\n  }\n\n  // If missing values are present, treat them.\n  if (hasMissingValues) {\n    // Get the GCD of intervals and it will be the minimum interval in the new set of times\n    const minimumInterval = getGCDInterval([...intervals]);\n    ret = [];\n    ret.push(times[0]);\n    for (let i = 1; i < timeLength; i++) {\n      const currentValue = times[i];\n      let previousValue = times[i - 1];\n\n      // Retrieve the interval from cache.\n      // As we are looping through the same array the cache will have the interval value\n      // and will never be undefined.\n      const currentInterval = intervalsCache[i - 1];\n\n      // If no values are missing in this interval,\n      // add current value to the return array and continue.\n      // Note: Values are considered missing only when the interval is greater than the current granularity level (minimumInterval).\n      // Example: Jan 1, Jan 15, Feb 1, Mar 1, May 1, Jun 1\n      // Granularity = Month; Minimum Interval = 1 (1 month)\n      // Mar 1, May 1 => has one missing value: Apr\n      // Jan 1, Jan 15 => has no missing value\n      if (currentInterval <= minimumInterval) {\n        ret.push(currentValue);\n        continue;\n      }\n\n      // Calculate the interval at which the values are to be filled\n      const ratioOfCurrentIntervalToMinimumInterval = currentInterval / minimumInterval; // Should be a round number as minimumInterval is a divisor of currentInterval\n      const numMissingValues = ratioOfCurrentIntervalToMinimumInterval - 1;\n      const fillIntervalInMilliseconds = Math.round(\n        (currentValue - previousValue) / ratioOfCurrentIntervalToMinimumInterval\n      );\n\n      // Fill in the missing values\n      for (let j = 1; j <= numMissingValues; j++) {\n        previousValue += fillIntervalInMilliseconds;\n        ret.push(previousValue);\n      }\n      ret.push(currentValue); // Finally, add the current value\n      previousValue = currentValue; // Update the previous value\n    }\n  }\n  return ret;\n}\n\n/**\n * Calculates the granual interval.\n * @param previousDate\n * @param currentDate\n * @param granularity\n * @returns\n */\nfunction calculateGranularInterval(previousDate: Date, currentDate: Date, granularity: number) {\n  // Treat times for the day light savings.\n  const prevTimezoneOffset = previousDate.getTimezoneOffset();\n  const currentTimezoneOffset = currentDate.getTimezoneOffset();\n  const currentTime = currentDate.getTime();\n  const currentTimezoneOffsetCorrection = (prevTimezoneOffset - currentTimezoneOffset) * 1000 * 60;\n  if (currentTimezoneOffsetCorrection > 0) {\n    currentDate.setTime(currentTime + currentTimezoneOffsetCorrection);\n  }\n\n  let granularInterval;\n  if (granularity === TIME_YEAR_MIN)\n    granularInterval = currentDate.getFullYear() - previousDate.getFullYear();\n  else if (granularity === TIME_MONTH_MIN)\n    granularInterval =\n      12 * (currentDate.getFullYear() - previousDate.getFullYear()) +\n      (currentDate.getMonth() - previousDate.getMonth());\n  else\n    granularInterval = Math.round((currentDate.getTime() - previousDate.getTime()) / granularity);\n\n  if (currentTimezoneOffsetCorrection > 0) {\n    currentDate.setTime(currentTime); // reset to original value\n  }\n\n  return granularInterval;\n}\n\n/**\n * Returns the greatest common denominator.\n * @param interval1\n * @param interval2\n * @returns\n */\nfunction gcd(interval1: number, interval2: number): number {\n  if (interval1 === 0) return interval2;\n  return gcd(interval2 % interval1, interval1);\n}\n\n/**\n * Returns the gcd of the intervals.\n * @param intervals\n * @returns\n */\nfunction getGCDInterval(intervals: number[]) {\n  let result = intervals[0];\n  for (let i = 1; i < intervals.length; i++) {\n    result = gcd(result, intervals[i]);\n    if (result === 1) return 1;\n  }\n  return result;\n}\n\n/**\n * Retuns the tick label gap.\n * @param labelHeight The height of the label.\n * @param isHoriz Whether the axis is horizontal.\n * @returns\n */\nfunction getTickLabelGap(labelHeight: number, isHoriz: boolean) {\n  // legacy numbers.\n  return isHoriz ? labelHeight * 0.79 : labelHeight * 0.28;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ChartSeriesData, DataAxisProps, Group } from '../UNSAFE_visTypes/chart';\nimport { getTime } from '#PRIVATE_Axis/timeAxis/timeAxisInfo';\nimport { BarSeriesData } from '#UNSAFE_BarChart/barChart.types';\n\n/**\n * Returns the min and max value among the items rendered in the viewport.\n * @param series The array of chart series.\n * @param viewportMin The current viewport min.\n * @param viewportMax The current viewport max.\n * @returns\n */\nexport function getDataMinMax<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; widthWeight?: number; value?: number; id: K }\n>(\n  series: ChartSeriesData<K, D>[],\n  groups: Group[],\n  xStartIndex: number,\n  xEndIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isStacked: boolean,\n  isLog: boolean,\n  hiddenSet: Set<K>,\n  hideAndShowBehavior: 'none' | 'withRescale' | 'withoutRescale'\n) {\n  let yDataMin = Number.MAX_VALUE;\n  let yDataMax = -Number.MAX_VALUE;\n  let xMin = Number.MAX_VALUE;\n  let xMax = -Number.MAX_VALUE;\n  let yMin = Number.MAX_VALUE;\n  let yMax = -Number.MAX_VALUE;\n  let y2DataMin = Number.MAX_VALUE;\n  let y2DataMax = -Number.MAX_VALUE;\n  let y2Min = Number.MAX_VALUE;\n  let y2Max = -Number.MAX_VALUE;\n  let isY2AxisRendered = false;\n  let isYAxisRendered = false;\n  let hasWidthWeightValue = false;\n  const barWidths: number[] = [];\n  const idToDataMap = new Map<K, D>();\n  for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {\n    let posCumulValue = 0;\n    let negCumulValue = 0;\n\n    series.forEach((chartSeries: BarSeriesData<K, D>, seriesIndex: number) => {\n      const isAssociatedToY2 = chartSeries?.associatedYAxis === 'y2';\n\n      isY2AxisRendered = isY2AxisRendered || !!isAssociatedToY2;\n      isYAxisRendered = isYAxisRendered || !isAssociatedToY2;\n\n      const item = getDataItem(seriesIndex, groupIndex);\n      const itemHasWidthWeightValue = item && 'widthWeight' in item;\n      hasWidthWeightValue = hasWidthWeightValue || itemHasWidthWeightValue!;\n      if (itemHasWidthWeightValue) {\n        barWidths.push(Math.max(0, item?.widthWeight!));\n      }\n      const itemHasValue = item && 'value' in item;\n      if (\n        !item ||\n        (itemHasValue && item.value == null && item.x == null && 'y' in item && item.y == null)\n      ) {\n        return;\n      }\n      idToDataMap.set(item.id, item);\n      if (groupIndex >= xStartIndex && groupIndex <= xEndIndex) {\n        const skipData =\n          item?.id != null && hiddenSet.has(item.id) && hideAndShowBehavior === 'withRescale';\n        if (skipData || (itemHasValue && item.value !== undefined && item.value <= 0 && isLog)) {\n          return;\n        }\n        if (isStacked) {\n          if (itemHasValue && item.value !== undefined) {\n            posCumulValue += item.value > 0 ? item.value : 0;\n            negCumulValue += item.value < 0 ? item.value : 0;\n          }\n          if (isAssociatedToY2) {\n            y2DataMin = Math.min(isLog ? posCumulValue : negCumulValue, y2DataMin);\n            y2DataMax = Math.max(posCumulValue, y2DataMax);\n          } else {\n            yDataMin = Math.min(isLog ? posCumulValue : negCumulValue, yDataMin);\n            yDataMax = Math.max(posCumulValue, yDataMax);\n          }\n        } else {\n          if (itemHasValue && item.value !== undefined) {\n            if (isAssociatedToY2) {\n              y2DataMin = Math.min(y2DataMin, item.value);\n              y2DataMax = Math.max(y2DataMax, item.value);\n            } else {\n              yDataMin = Math.min(yDataMin, item.value);\n              yDataMax = Math.max(yDataMax, item.value);\n            }\n          }\n          if ('x' in item && item.x !== undefined && 'y' in item && item.y !== undefined) {\n            xMin = Math.min(xMin, item.x as number);\n            xMax = Math.max(xMax, item.x as number);\n\n            if (isAssociatedToY2) {\n              y2Min = Math.min(y2Min, item.y);\n              y2Max = Math.max(y2Max, item.y);\n            } else {\n              yMin = Math.min(yMin, item.y);\n              yMax = Math.max(yMax, item.y);\n            }\n          }\n        }\n      }\n    });\n  }\n  return {\n    yDataMin,\n    y2DataMin,\n    yDataMax,\n    y2DataMax,\n    xMin,\n    xMax,\n    yMin,\n    y2Min,\n    yMax,\n    y2Max,\n    idToDataMap,\n    isY2AxisRendered,\n    isYAxisRendered,\n    hasWidthWeightValue,\n    barWidths\n  };\n}\n\n/**\n * Returns the dataMin and dataMax, used for axis extend calculations, from the chart data.\n * @param series\n * @param hiddenIds\n * @param xStartIndex\n * @param xEndIndex\n * @param yAxis\n * @returns\n */\nexport function getDataExtent<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; widthWeight?: number; value?: number; id: K }\n>(\n  series: BarSeriesData<K, D>[],\n  groups: Group[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  xStartIndex: number,\n  xEndIndex: number,\n  isStacked: boolean,\n  hiddenSet: Set<K>,\n  hideAndShowBehavior: 'none' | 'withRescale' | 'withoutRescale',\n  yAxis?: DataAxisProps,\n  y2Axis?: DataAxisProps\n) {\n  let yDataMin = yAxis?.dataMin;\n  let yDataMax = yAxis?.dataMax;\n  let y2DataMin = y2Axis?.dataMin;\n  let y2DataMax = y2Axis?.dataMax;\n  //TODO: For performance optimization we can return early if we do not need idToDataMap i.e when selectionMode is off.\n  // if (dataMin != null && dataMax != null) {\n  //   return { dataMin, dataMax };\n  // }\n  const data = getDataMinMax<K, D>(\n    series,\n    groups,\n    xStartIndex,\n    xEndIndex,\n    getDataItem,\n    isStacked,\n    yAxis?.scale === 'log',\n    hiddenSet,\n    hideAndShowBehavior\n  );\n\n  if (yDataMin == null) {\n    yDataMin = data.yDataMin;\n  }\n  if (yDataMax == null) {\n    yDataMax = data.yDataMax;\n  }\n\n  if (y2DataMin == null) {\n    y2DataMin = data.y2DataMin;\n  }\n\n  if (y2DataMax == null) {\n    y2DataMax = data.y2DataMax;\n  }\n  return {\n    yDataMax,\n    yDataMin,\n    y2DataMax,\n    y2DataMin,\n    xMin: data.xMin,\n    xMax: data.xMax,\n    yMin: data.yMin,\n    yMax: data.yMax,\n    y2Min: data.y2Min,\n    y2Max: data.y2Max,\n    idToDataMap: data.idToDataMap,\n    isY2AxisRendered: data.isY2AxisRendered,\n    isYAxisRendered: data.isYAxisRendered,\n    hasWidthWeightValue: data.hasWidthWeightValue,\n    barWidths: data.barWidths\n  };\n}\n\n/**\n * For a given groupIndex gIndex, and seriesIndex sIndex, returns the next groupIndex that has not null data.\n * @param gIndex The groupIndex.\n * @param sIndex The seriesIndex.\n * @param groups The groups arrray.\n * @param getDataItem The function that returns data item for given seriesIndex and groupIndex.\n * @returns\n */\nfunction findNextGroupWithData<D>(\n  gIndex: number,\n  sIndex: number,\n  groups: Group[],\n  getDataItem: (sIndex: number, gIndex: number) => D | undefined\n) {\n  let right = gIndex;\n  while (right < groups.length) {\n    const hasData = !!getDataItem(sIndex, right);\n    if (hasData) {\n      return right;\n    }\n    right += 1;\n  }\n  return -1;\n}\n\n/**\n * For a given groupIndex gIndex, and seriesIndex sIndex, returns the prev groupIndex that has not null data.\n * @param gIndex The groupIndex.\n * @param sIndex The seriesIndex.\n * @param groups The groups arrray.\n * @param getDataItem The function that returns data item for given seriesIndex and groupIndex.\n * @returns\n */\nfunction findPreviousGroupWithData<D>(\n  gIndex: number,\n  sIndex: number,\n  getDataItem: (sIndex: number, gIndex: number) => D | undefined\n) {\n  let left = gIndex;\n  while (left >= 0) {\n    const hasData = !!getDataItem(sIndex, left);\n    if (hasData) {\n      return left;\n    }\n    left -= 1;\n  }\n  return -1;\n}\n\n/**\n * Finds the nearest data group/item for the given x axis coordinate.\n * @param x The x coordinate.\n * @param groups The groups array.\n * @param series The series array.\n * @param getDataItem The function that returns data item for given seriesIndex and groupIndex.\n * @returns\n */\nexport function findNearestRegularAxisIndex<K, D>(\n  x: number,\n  groups: Group[],\n  series: ChartSeriesData<K, D>[],\n  getDataItem: (sIndex: number, gIndex: number) => D | undefined\n) {\n  const keyFunc = (index: number) => getTime(groups[index].id);\n\n  if (groups.length < 2) {\n    return 0;\n  }\n\n  if (keyFunc(0) > x) {\n    return Math.min(\n      ...series.map((_, sIndex) => findNextGroupWithData<D>(0, sIndex, groups, getDataItem))\n    );\n  }\n\n  if (keyFunc(groups.length - 1) < x) {\n    return Math.max(\n      ...series.map((_, sIndex) =>\n        findPreviousGroupWithData(groups.length - 1, sIndex, getDataItem)\n      )\n    );\n  }\n\n  const groupIndex = findGroup(0, groups.length - 1, x, keyFunc);\n\n  const prevIndex = Math.max(\n    ...series.map((_, sIndex) => findPreviousGroupWithData(groupIndex, sIndex, getDataItem))\n  );\n\n  if (prevIndex === groupIndex) return prevIndex;\n\n  const nextIndex = Math.min(\n    ...series.map((_, sIndex) => findNextGroupWithData<D>(groupIndex, sIndex, groups, getDataItem))\n  );\n\n  if (keyFunc(nextIndex) - x < x - keyFunc(prevIndex)) {\n    return nextIndex;\n  }\n  return prevIndex;\n}\n\n/**\n * Finds the nearest data group/item for the given x axis coordinate in mixed frequency time axis chart.\n * @param x The x axis coordinate\n * @param groups The chart groups.\n * @param series The chart series.\n * @param getDataItem The function that returns data item for each series and groups.\n */\nexport function getNearestMixedFrequencyDataItem<K, D extends { x?: number | string }>(\n  target: number,\n  series: ChartSeriesData<K, D>[],\n  groups: Group[],\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined\n) {\n  /**\n   * first find the data items in each series closest to the given value and\n   * then find the closest among them.\n   * TODO: make this O(log(n))\n   */\n  return series.map((_, seriesIndex) => {\n    let min = Number.MAX_VALUE;\n    let minIndex = 0;\n    for (let groupIndex = 0; groupIndex < groups.length; groupIndex++) {\n      const x = getDataItem(seriesIndex, groupIndex)?.x;\n      if (!x) {\n        continue;\n      }\n      const time = getTime(x);\n      const dist = Math.abs(target - time);\n      if (dist < min) {\n        min = dist;\n        minIndex = groupIndex;\n      }\n    }\n    return { seriesIndex, groupIndex: minIndex };\n  });\n}\n\n/**\n * For a given target value, binary searches the index between min and max. The keyFunc returns the\n * value for each given index.\n * @param min The minimum index to search.\n * @param max The maximum index to search.\n * @param target The target value to find the neareast index to.\n * @param keyFunc The function that returns the target value for each given index.\n * @returns\n */\nfunction findGroup(min: number, max: number, target: number, keyFunc: (index: number) => number) {\n  let left = min;\n  let right = max;\n\n  const foundIndex = (ll: number, rr: number) => {\n    return rr - ll === 1 && keyFunc(ll) <= target && target <= keyFunc(rr);\n  };\n\n  let moveRight = 0;\n  let step = Math.floor((right - left) / 2);\n  while (!foundIndex(left, right)) {\n    const newIndex = moveRight ? Math.floor(left + step) : Math.ceil(right - step);\n    const diff = target - keyFunc(newIndex);\n    if (0 <= diff) {\n      left = newIndex;\n      moveRight = moveRight ? 0 : 1;\n    } else {\n      right = newIndex;\n    }\n    step = Math.floor((right - left) / 2);\n  }\n  return target - keyFunc(left) < keyFunc(right) - target ? left : right;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ScaleLog, ScaleLinear } from '#utils/PRIVATE_chartUtils';\nimport { DataAxisInfoProps } from '#utils/UNSAFE_visTypes/chart';\n\nconst MAX_NUMBER_OF_GRIDS_AUTO = 10;\nconst MINOR_TICK_COUNT = 2;\nconst MAJOR_TICK_INCREMENT_BUFFER = 0.0000000001;\nconst MAX_ZOOM = 64;\n\nexport class DataAxisInfo {\n  numGroups!: number;\n  dataMin!: number;\n  dataMax!: number;\n  viewportMin?: number;\n  viewportMax?: number;\n  min?: number;\n  max?: number;\n  isLog: boolean;\n  majorTickCount!: number;\n  minorTickCount!: number;\n  majorIncrement?: number;\n  minorIncrement?: number;\n  minMajorIncrement?: number;\n  isZeroBaseline: boolean;\n\n  constructor({\n    scale = 'linear',\n    baselineScaling = 'zero',\n    dataMax,\n    dataMin,\n    min,\n    max,\n    viewportMin,\n    viewportMax,\n    numGroups,\n    ...options\n  }: DataAxisInfoProps & { numGroups: number, majorTickCount?: number }) {\n    this.numGroups = numGroups;\n    this.isLog = scale === 'log';\n    this.isZeroBaseline = !this.isLog && baselineScaling === 'zero';\n\n    this.setDataRange(dataMin!, dataMax!);\n    this.setViewportRange(viewportMin, viewportMax, min, max);\n\n    this.majorIncrement = this.actualToLinear(options.step);\n    this.minorIncrement = this.actualToLinear(options.minorStep);\n    this.minMajorIncrement = this.actualToLinear(options.minStep);\n    this.majorTickCount = options.majorTickCount!;\n\n    this.calcAxisExtents();\n  }\n\n  getInfo() {\n    return {\n      min: this.min!,\n      max: this.max!,\n      viewportMin: this.viewportMin!,\n      viewportMax: this.viewportMax!,\n      viewportStartGroup: undefined,\n      viewportEndGroup: undefined,\n      startIndex: 0,\n      endIndex: this.numGroups - 1,\n      ticks: this.getTicks(),\n      minorTicks: this.getMinorTicks(),\n      minAxisExtent: this.getMinExtent(),\n      getScale: this.getScale.bind(this),\n      step: this.majorIncrement!\n    };\n  }\n\n  /**\n   * Set the dataMin and dataMax.\n   * @param dataMin The minimum of the data.\n   * @param dataMax The maximum of the data.\n   */\n  setDataRange(dataMin: number, dataMax: number) {\n    this.dataMin = this.actualToLinear(dataMin)!;\n    this.dataMax = this.actualToLinear(dataMax)!;\n\n    if (this.isZeroBaseline) {\n      this.dataMin = Math.min(0, this.dataMin);\n      this.dataMax = Math.max(0, this.dataMax!);\n    }\n  }\n\n  setViewportRange(viewportMin?: number, viewportMax?: number, min?: number, max?: number) {\n    this.min = this.actualToLinear(min);\n    this.max = this.actualToLinear(max);\n    this.viewportMin = viewportMin == null ? this.min : this.actualToLinear(viewportMin);\n    this.viewportMax = viewportMax == null ? this.max : this.actualToLinear(viewportMax);\n  }\n\n  setDefaultMin(scaleUnit: number) {\n    // if already set in setViewportRange\n    if (this.min != null) {\n      return;\n    }\n\n    if (this.isZeroBaseline && this.dataMin >= 0) {\n      this.min = 0;\n    } else if (!this.isZeroBaseline && this.max != null) {\n      this.min = this.max - scaleUnit * (Math.floor((this.max - this.dataMin) / scaleUnit) + 1);\n    } else {\n      this.min = (Math.ceil(this.dataMin / scaleUnit) - 1) * scaleUnit;\n    }\n\n    // If all data points are positive, the axis min shouldn't be less than zero\n    if (this.dataMin >= 0 && !this.isLog) {\n      this.min = Math.max(this.min, 0);\n    }\n  }\n\n  setDefaultMax(scaleUnit: number, minValue: number, maxValue: number) {\n    if (this.max != null) {\n      return;\n    }\n    if (this.majorTickCount) {\n      this.max = this.min! + this.majorTickCount * scaleUnit;\n\n      if (this.max < this.dataMax) {\n        const axisStep = this.calcAxisStep(minValue, maxValue + scaleUnit);\n        scaleUnit = this.minMajorIncrement ? Math.max(axisStep, this.minMajorIncrement) : axisStep;\n        this.max = this.min! + this.majorTickCount * scaleUnit;\n      }\n    } else if (this.isZeroBaseline && this.dataMax <= 0) {\n      this.max = 0;\n    } else if (!this.isZeroBaseline && this.min != null) {\n      this.max = this.min + scaleUnit * (Math.floor((this.dataMax - this.min) / scaleUnit) + 1);\n    } else {\n      this.max = (Math.floor(this.dataMax / scaleUnit) + 1) * scaleUnit;\n    }\n    // If all data points are negative, the axis max shouldn't be more that zero\n    if (this.dataMax <= 0) {\n      this.max = Math.min(this.max, 0);\n    }\n  }\n\n  calcAxisExtents() {\n    // Include 0 in the axis if we're scaling from the baseline\n    if (this.isZeroBaseline) {\n      this.dataMin = Math.min(0, this.dataMin);\n      this.dataMax = Math.max(0, this.dataMax);\n    }\n\n    const maxValue = this.max != null ? this.max : this.dataMax;\n    const minValue = this.min != null ? this.min : this.dataMin;\n    const axisStep = this.calcAxisStep(minValue, maxValue);\n    let scaleUnit = this.minMajorIncrement ? Math.max(axisStep, this.minMajorIncrement) : axisStep;\n\n    // If there's only a single value on the axis, we need to adjust the\n    // this.dataMin and this.dataMax to produce a nice looking axis with around 6 ticks.\n    if (this.dataMin === this.dataMax) {\n      if (this.dataMin === 0) {\n        this.dataMax += 5 * scaleUnit;\n      } else {\n        this.dataMin -= 2 * scaleUnit;\n        this.dataMax += 2 * scaleUnit;\n      }\n    }\n\n    this.setDefaultMin(scaleUnit);\n\n    this.setDefaultMax(scaleUnit, minValue, maxValue);\n\n    if (this.max === this.min) {\n      // happens if this.dataMin === this.dataMax === 0\n      this.max = 100;\n      this.min = 0;\n      scaleUnit = (this.max - this.min) / MAX_NUMBER_OF_GRIDS_AUTO;\n    }\n\n    if (\n      (this.viewportMin !== this.min || this.viewportMax !== this.max) &&\n      this.viewportMax != null &&\n      this.viewportMin != null\n    ) {\n      scaleUnit = this.calcAxisStep(this.viewportMin, this.viewportMax);\n    }\n\n    if (this.viewportMin == null) {\n      this.viewportMin = this.min;\n    }\n\n    if (this.viewportMax == null) {\n      this.viewportMax = this.max;\n    }\n\n    this.calcMajorMinorSteps(scaleUnit);\n  }\n\n  /**\n   * Determines the number of major and minor tick counts and increments for the axis if values were not given.\n   * The default minor tick count is 2.\n   * @param {number} scaleUnit The scale unit of the axis.\n   * @private\n   */\n\n  calcMajorMinorSteps(scaleUnit: number) {\n    if (this.max == null || this.min == null) {\n      return;\n    }\n    if (!this.majorIncrement) {\n      if (this.majorTickCount) {\n        this.majorIncrement = (this.viewportMax! - this.viewportMin!) / this.majorTickCount;\n      } else {\n        this.majorIncrement = this.minMajorIncrement\n          ? Math.max(scaleUnit, this.minMajorIncrement!)\n          : scaleUnit;\n      }\n    }\n\n    if (!this.majorTickCount) {\n      this.majorTickCount = (this.viewportMax! - this.viewportMin!) / this.majorIncrement;\n\n      // Check if we have a floating point inaccuracy that causes the tick count to be undercalculated\n      // within the allowable buffer. If so, tick count is supposed to be the rounded up integer.\n      if (Math.ceil(this.majorTickCount) - this.majorTickCount < MAJOR_TICK_INCREMENT_BUFFER) {\n        this.majorTickCount = Math.ceil(this.majorTickCount);\n      }\n    }\n\n    if (!this.minorTickCount) {\n      if (this.minorIncrement) {\n        this.minorTickCount = this.majorIncrement / this.minorIncrement;\n      } else if (this.isLog) {\n        this.minorTickCount = this.majorIncrement;\n      } else {\n        this.minorTickCount = MINOR_TICK_COUNT;\n      }\n    }\n\n    if (!this.minorIncrement) {\n      this.minorIncrement = this.majorIncrement / this.minorTickCount;\n    }\n  }\n\n  calcAxisStep(minValue: number, maxValue: number) {\n    if (this.majorIncrement) {\n      return this.majorIncrement;\n    }\n\n    const spread = maxValue - minValue;\n\n    if (spread === 0) {\n      if (minValue === 0) {\n        return 10;\n      }\n      return Math.pow(10, Math.floor(Math.log10(minValue)) - 1);\n    }\n\n    if (this.isLog) {\n      return Math.floor(spread / 8) + 1;\n    }\n\n    if (this.majorTickCount) {\n      const increment = spread / this.majorTickCount;\n      const testVal = Math.pow(10, Math.ceil(Math.log10(increment) - 1));\n      let firstDigit = increment / testVal;\n      if (firstDigit > 1 && firstDigit <= 1.5) {\n        firstDigit = 1.5;\n      } else if (firstDigit > 5) {\n        firstDigit = 10;\n      } else {\n        firstDigit = Math.ceil(firstDigit);\n      }\n      return firstDigit * testVal;\n    }\n    return this.getDefaultAxisStep(spread);\n  }\n\n  /**\n   * Aesthetically choose a step depending of the spread value.\n   * @param spread The spread of the data values.\n   * @returns The step for the axis.\n   */\n  getDefaultAxisStep(spread: number): number {\n    const t = Math.log10(spread);\n    const testVal = Math.pow(10, Math.ceil(t) - 2);\n    const first2Digits = Math.round(spread / testVal);\n\n    let scaleFactor = 1;\n    if (first2Digits >= 10 && first2Digits <= 14) {\n      scaleFactor = 2;\n    } else if (first2Digits >= 15 && first2Digits <= 19) {\n      scaleFactor = 3;\n    } else if (first2Digits >= 20 && first2Digits <= 24) {\n      scaleFactor = 4;\n    } else if (first2Digits >= 25 && first2Digits <= 45) {\n      scaleFactor = 5;\n    } else if (first2Digits >= 46 && first2Digits <= 80) {\n      scaleFactor = 10;\n    } else {\n      scaleFactor = 20;\n    }\n    return scaleFactor * testVal;\n  }\n\n  linearToActual(value: number) {\n    return this.isLog ? Math.pow(10, value) : value;\n  }\n\n  actualToLinear(value?: number) {\n    if (value == null) {\n      return;\n    }\n\n    if (this.isLog) {\n      return Math.log10(value);\n    }\n    return value;\n  }\n\n  getScale(range: [number, number]) {\n    const { viewportMin, viewportMax } = this.getAxisViewport();\n    const domain: [number, number] = [\n      this.linearToActual(viewportMin),\n      this.linearToActual(viewportMax)\n    ];\n    if (this.isLog) {\n      return new ScaleLog(domain, range);\n    }\n    return new ScaleLinear(domain, range);\n  }\n\n  getFirstTick() {\n    if (this.isZeroBaseline) {\n      return Math.ceil(this.viewportMin! / this.majorIncrement!) * this.majorIncrement!;\n    }\n    return (\n      this.min! +\n      Math.ceil((this.viewportMin! - this.min!) / this.majorIncrement!) * this.majorIncrement!\n    );\n  }\n\n  getAxisViewport() {\n    return {\n      viewportMin: this.viewportMin!,\n      viewportMax: this.viewportMax!\n    };\n  }\n\n  /**\n   * Returns the min and max extent of the axis.\n   */\n  getAxisExtent() {\n    return {\n      min: this.min!,\n      max: this.max!\n    };\n  }\n  /**\n   * Returns the major ticks.\n   */\n  getTicks() {\n    let firstTick = this.getFirstTick();\n    const ticks = [];\n\n    while (firstTick <= this.viewportMax!) {\n      ticks.push(this.linearToActual(firstTick));\n      firstTick += this.majorIncrement!;\n    }\n    return ticks;\n  }\n\n  getMinorTicks() {\n    const coords = [];\n    for (let i = -1; i <= this.majorTickCount; i++) {\n      const value = i * this.majorIncrement! + this.getFirstTick();\n      if (this.isLog && this.majorIncrement == 1 && this.minorIncrement == 1) {\n        // draw linear ticks from 2 to 9\n        for (let j = 2; j <= 9; j++) {\n          const linearValue = value + Math.log10(j);\n          if (linearValue > this.max!) break;\n          if (linearValue < this.min!) continue;\n          coords.push(this.linearToActual(linearValue));\n        }\n      } else {\n        for (let j = 1; j < this.minorTickCount; j++) {\n          const minorValue = value + j * this.minorIncrement!;\n          if (minorValue > this.max!) break;\n          if (minorValue < this.min!) continue;\n\n          coords.push(minorValue);\n        }\n      }\n    }\n    return coords;\n  }\n\n  getStep() {\n    return this.majorIncrement!;\n  }\n\n  getMinExtent() {\n    return (this.max! - this.min!) / MAX_ZOOM;\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nconst SCALING_FACTOR_DIFFERENCE = 3;\n\nconst scales = ['none', 'thousand', 'million', 'billion', 'trillion', 'quadrillion'] as const;\n\nconst scalesOrder = scales.map((_, i) => ({ scaleFactor: i * SCALING_FACTOR_DIFFERENCE }));\n\nexport type Scale = (typeof scales)[number];\n\nexport function getLinearAxisValueFormatter(\n  minValue: number,\n  maxValue: number,\n  tickStep: number,\n  locale: string\n) {\n  const scaleFactor = getScaleFactor(minValue, maxValue);\n  const decimalPlaces = getDecimalPlaces(minValue, maxValue, tickStep, scaleFactor);\n\n  const scale = Math.pow(10, scaleFactor);\n  const scaleConverterOptions = {\n    style: 'decimal' as const,\n    notation: 'compact' as const,\n    numberingSystem: 'latn' as const,\n    useGrouping: false\n  };\n  let defaultConverter = new Intl.NumberFormat(locale, scaleConverterOptions);\n\n  // Formatting for scale\n  const _SCALE_REGEXP = /(\\d+)(.*$)/;\n  const formattedScale = defaultConverter.format(scale);\n  const formattedScaleParts = _SCALE_REGEXP.exec(formattedScale);\n\n  const numberConverterOptions = {\n    style: 'decimal' as const,\n    minimumFractionDigits: decimalPlaces,\n    maximumFractionDigits: decimalPlaces\n  };\n  defaultConverter = new Intl.NumberFormat(locale, numberConverterOptions);\n\n  return (value: number) => {\n    if (!formattedScaleParts) {\n      return '';\n    }\n    const suffix = formattedScaleParts[2]; // Reset the suffix\n    const fsn = (Number(formattedScaleParts[1]) / scale) * value;\n    let formattedScaledNumber = fsn.toString();\n    formattedScaledNumber = defaultConverter.format(fsn);\n\n    // Add the scale factor suffix, unless value is zero\n    if (typeof suffix === 'string' && value !== 0) {\n      formattedScaledNumber += suffix;\n    }\n    return formattedScaledNumber;\n  };\n}\n\n/**\n * Returns the number of decimal places to use for given minValue, maxValue, tickStep, scaleFactor.\n * @param minValue The minValue of the axis.\n * @param maxValue The maxValue of the axis.\n * @param tickStep The step of the axis.\n * @param scaleFactor The scale factor of the scaling of the axis.\n * @returns\n */\nfunction getDecimalPlaces(\n  minValue: number,\n  maxValue: number,\n  tickStep: number,\n  scaleFactor: number\n) {\n  let decimalPlaces;\n  if (tickStep === 0 && minValue === maxValue) {\n    const valuePowerOfTen = getPowerOfTen(maxValue);\n    const scaleFactorDiff = scaleFactor - valuePowerOfTen;\n    if (scaleFactorDiff <= 0) {\n      // Value is same or larger than the scale factor, ensure 4 significant digits.\n      // Make sure that the number of decimal places is at least zero. Bug 18677330\n      decimalPlaces = Math.max(scaleFactorDiff + 3, 0);\n    } else {\n      // Value is smaller, ensure enough decimals to show 1 significant digit\n      decimalPlaces = Math.max(scaleFactorDiff, 4);\n    }\n  } else {\n    // get the number of decimal places in the number by subtracting\n    // the order of magnitude of the tick step from the order of magnitude\n    // of the scale factor\n    // (e.g.: scale to K, tick step of 50 -> 3 - 1 = 2 decimal places)\n    const tickStepPowerOfTen = getPowerOfTen(tickStep);\n    decimalPlaces = Math.max(scaleFactor - tickStepPowerOfTen, 0);\n  }\n\n  return decimalPlaces;\n}\n\n/**\n * Returns scale factor of scale given by scale name.\n * @param {string} scaleName\n * @return {number} scale factor of scale given by scale name\n */\nfunction getScaleFactor(minValue: number, maxValue: number) {\n  const absMax = Math.max(Math.abs(minValue), Math.abs(maxValue));\n  const power = getPowerOfTen(absMax);\n  return findNearestLEScaleFactor(power);\n}\n\n/**\n * Returns the log base 10 for a given value.\n * @param {number} value\n * @returns\n */\nfunction getPowerOfTen(value: number) {\n  // more comprehensive and easier than working with\n  // value returned by Math.log(value)/Math.log(10)\n  let val = value >= 0 ? value : -value;\n  let power = 0;\n\n  // Check for degenerate and zero values\n  if (val < 1e-15) {\n    return 0;\n  } else if (val === Infinity) {\n    return Number.MAX_VALUE;\n  }\n\n  if (val >= 10) {\n    // e.g. for 1000 the power should be 3\n    while (val >= 10) {\n      power += 1;\n      val /= 10;\n    }\n  } else if (val < 1) {\n    while (val < 1) {\n      power -= 1;\n      val *= 10;\n    }\n  }\n  return power;\n}\n\n/**\n * Finds a scale factor 'x' such that x <= value (e.g. if value equals 4 then returned scale factor equals 3)\n * @param {number} value value representing an order of magnitude\n * @return {number} a scale factor 'x' such that x <= value\n */\nfunction findNearestLEScaleFactor(value: number) {\n  let scaleFactor = 0;\n\n  if (value <= scalesOrder[0].scaleFactor) {\n    // if the number is less than 10, don't scale\n    scaleFactor = scalesOrder[0].scaleFactor;\n  } else if (value >= scalesOrder[scalesOrder.length - 1].scaleFactor) {\n    // if the data is greater than or equal to 10 quadrillion, scale to quadrillions\n    scaleFactor = scalesOrder[scalesOrder.length - 1].scaleFactor;\n  } else {\n    // else find the nearest scaleFactor such that scaleFactor <= value\n    const end = scalesOrder.length - 1;\n    for (let i = end; i >= 0; i--) {\n      if (scalesOrder[i].scaleFactor <= value) {\n        scaleFactor = scalesOrder[i].scaleFactor;\n        break;\n      }\n    }\n  }\n  return scaleFactor;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { AxisPosition, DataAxisProps } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\nimport type { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { getLinearAxisValueFormatter } from '#utils/PRIVATE_chartUtils/numberFomatUtils';\nimport { ScaleLinear, ScaleLog } from '#utils/PRIVATE_chartUtils';\nimport { getAxisMaxSize, getAxisRange, getTickLabelAnchor } from '#PRIVATE_Axis/utils/axisUtils';\nimport { getTitleProps } from '#PRIVATE_Axis/utils/titleUtils';\nimport { AXIS_DEFAULTS } from '#PRIVATE_Axis/utils/axisDefaults';\nimport {\n  getDataAxisLabelsInfo,\n  getTickLabelInfo,\n  updateLabelsDims\n} from '#PRIVATE_Axis/utils/labelUtils';\nimport { AxisInfo } from '#PRIVATE_Axis/axis.types';\n\n/**\n * Returns the maximum available height for the tick label, which is the\n * distance between two ticks.\n * @param ticks\n * @param scale\n * @returns\n */\nexport function getMaxAvailHeight(ticks: number[], scale: ScaleLinear | ScaleLog) {\n  const range = scale.range();\n  return Math.abs(range[1] - range[0]) / ticks.length;\n}\n\n/**\n * The function that returns the y axis properties.\n * @param dataAxisInfo The DataAxisInfo.\n * @param dataAxis The dataAxis props.\n * @param groups The chart groups.\n * @param position The position of axis in the given space.\n * @param availSpace The available space.\n * @param isRtl Whether the reading direction is right to left.\n * @param getTextDimensions Function for text measurement.\n * @returns\n */\nexport function getDataAxisProps(\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean,\n  locale: string,\n  dataAxisInfo: AxisInfo,\n  dataAxis?: DataAxisProps,\n  axisFontSize?: string,\n  getTextDimensions?: GetTextDimensionsType,\n  isAxisRendered?: boolean\n) {\n  const [start, end] = getAxisRange(availSpace, position, isRtl);\n  const scale = dataAxisInfo.getScale!([start, end]);\n\n  if (dataAxis?.isRendered === false || isAxisRendered === false) {\n    // if isRendered is undefined we render the axis.\n    return {\n      title: undefined,\n      titleStyle: {},\n      titleProps: undefined,\n      axisDim: 0,\n      tickLabels: [],\n      tickLabelStyle: undefined,\n      scale,\n      formatYValue: undefined,\n      groupWidth: 0,\n      formatAxisLabel: undefined // TODO : JET-69997 - groupAxis support formatLabel\n    };\n  }\n\n  const isHoriz = position === 'top' || position === 'bottom';\n  const axisMaxDim = getAxisMaxSize(availSpace, isHoriz, dataAxis?.size);\n  const titleStyle = { fontSize: axisFontSize, ...dataAxis?.titleStyle };\n  const { titleDim, ...titleProps } = getTitleProps(\n    dataAxis?.title,\n    titleStyle,\n    axisMaxDim,\n    availSpace,\n    position,\n    isRtl,\n    getTextDimensions\n  );\n  const { width: titleWidth, height: titleHeight } = titleProps.dims!;\n  const isTitleRendered = titleWidth > 0 && titleHeight > 0;\n  const axisDim = isTitleRendered ? titleDim + AXIS_DEFAULTS.titleGap : 0;\n  const isRotated = position === 'left' || position === 'right';\n\n  if (isTitleRendered) {\n    if (isRotated) {\n      availSpace.width -= axisDim;\n      availSpace.x += position === 'left' ? axisDim : 0;\n    } else {\n      availSpace.height -= axisDim;\n      availSpace.y += position === 'top' ? axisDim : 0;\n    }\n  }\n\n  const tickLabelStyle = {\n    fontSize: axisFontSize,\n    fill: dataAxis?.tickLabel?.style?.color,\n    ...dataAxis?.tickLabel?.style,\n    textAnchor: getTickLabelAnchor(position, isRtl)\n  };\n  const ticks = dataAxisInfo.ticks;\n\n  const linearFormatter = getLinearAxisValueFormatter(\n    ticks[0],\n    ticks[ticks.length - 1],\n    dataAxisInfo.step,\n    locale\n  );\n\n  let isLabelRendered = dataAxis?.tickLabel?.isRendered != false;\n\n  const labels = isLabelRendered\n    ? ticks.map((i) => {\n        if (dataAxis?.tickLabel?.format) {\n          return dataAxis.tickLabel.format(i);\n        }\n\n        if (dataAxis?.scale === 'log') {\n          const formatter = getLinearAxisValueFormatter(i, i, i, locale);\n          return formatter(i);\n        }\n        return linearFormatter(i);\n      })\n    : [];\n\n  const maxLabelHeight = axisMaxDim - axisDim - AXIS_DEFAULTS.labelGap;\n\n  const getLabelInfo = (tick: string | undefined, index: number, _: boolean) => {\n    const coord = scale.transform(ticks[index]);\n    return getTickLabelInfo(\n      coord,\n      tick,\n      index,\n      tickLabelStyle,\n      isHoriz,\n      false,\n      false,\n      false,\n      isHoriz ? maxLabelHeight : axisMaxDim - axisDim,\n      isHoriz ? axisMaxDim - axisDim : maxLabelHeight,\n      availSpace,\n      getTextDimensions\n    );\n  };\n\n  const { maxWidth, maxHeight, tickLabels } = getDataAxisLabelsInfo(labels, getLabelInfo, isHoriz);\n\n  isLabelRendered =\n    isLabelRendered && isHoriz\n      ? maxHeight + AXIS_DEFAULTS.labelGap < axisMaxDim - axisDim\n      : maxWidth + AXIS_DEFAULTS.labelGap < axisMaxDim - axisDim;\n\n  const getAxisPos = (index: number) => {\n    return scale.transform(ticks[index]);\n  };\n\n  let labelDims = 0;\n  if (isLabelRendered) {\n    updateLabelsDims(maxWidth, maxHeight, tickLabels, getAxisPos, availSpace, position);\n    labelDims = isHoriz ? maxHeight + AXIS_DEFAULTS.labelGap : maxWidth + AXIS_DEFAULTS.labelGap;\n  }\n\n  const defaultLabelFormatter = (value: number) => {\n    if (dataAxis?.scale === 'log') {\n      const formatter = getLinearAxisValueFormatter(value, value, value, locale);\n      return formatter(value);\n    }\n    return linearFormatter(value);\n  };\n\n  return {\n    title: isTitleRendered ? dataAxis?.title : undefined,\n    titleStyle,\n    titleProps: isTitleRendered ? titleProps : undefined,\n    axisDim: isTitleRendered ? labelDims + axisDim : labelDims,\n    tickLabels: isLabelRendered ? tickLabels : [],\n    tickLabelStyle,\n    scale,\n    defaultLabelFormatter,\n    axisStepWidth: 0,\n    averageGroupZ: 0,\n    separators: [],\n    isGroupLabelRendered: () => false\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { BarItemData } from '#UNSAFE_BarChart/barChart.types';\nimport { ChartSeriesData } from '#utils/UNSAFE_visTypes/chart';\n\nconst IDEAL_DATA_ITEM_GAP = 2;\nconst DEFAULT_BAR_GAP_RATIO = 0.25;\n\n/**\n * The function that calculates the barWidth and offset from group center for each series.\n * @param axisStepWidth The width of the group.\n * @param noOfSeries The number of series present in the chart.\n * @param barGapRatio The ratio of gap to axisStepWidth.\n * @param dataItemGaps The ratio that determines the gap between the bars.\n */\nexport function getBarGapsInfo<K extends string | number, D extends BarItemData<K>>(\n  seriesIndex: number,\n  groupIndex: number,\n  series: ChartSeriesData<string | number, any>,\n  axisStepWidth: number,\n  averageGroupZ: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  barGapRatio: number,\n  numSeriesY: number,\n  numSeriesY2: number,\n  dataItemGaps: number,\n  isStacked: boolean,\n  isRtl: boolean,\n  isHoriz: boolean\n) {\n  const isY2 = series.associatedYAxis === 'y2';\n  const numSeries = isStacked ? 1 : isY2 ? numSeriesY2 : numSeriesY;\n  const itemsGaps = IDEAL_DATA_ITEM_GAP * dataItemGaps;\n  const item = getDataItem(seriesIndex, groupIndex);\n  const isVariableBarWidth = item?.widthWeight !== undefined;\n  const barWidth = isVariableBarWidth\n    ? getBarWidth(seriesIndex, groupIndex, axisStepWidth, averageGroupZ, getDataItem)\n    : (axisStepWidth * (1 - barGapRatio) - (numSeries - 1) * itemsGaps) / numSeries;\n  if (isStacked) {\n    return { barWidth, offset: (-1 * barWidth) / 2, itemsGaps };\n  }\n  const center = axisStepWidth / 2;\n  const seriesStart =\n    axisStepWidth * (barGapRatio / 2) +\n    seriesIndex * (barWidth + IDEAL_DATA_ITEM_GAP * dataItemGaps);\n  const offset = getOffset(\n    seriesIndex,\n    groupIndex,\n    getDataItem,\n    averageGroupZ,\n    axisStepWidth,\n    barWidth,\n    numSeries,\n    seriesStart,\n    center,\n    isRtl,\n    isHoriz,\n    isVariableBarWidth\n  );\n\n  return { barWidth, offset, itemsGaps };\n}\n\n/**\n * Returns the bar gap ratio.\n * @param isStacked Whether the chart is a stacked bar chart.\n * @param startIndex The viewport start index.\n * @param endIndex The viewport end index.\n */\nexport function getBarGapRatio(isStacked: boolean, startIndex: number, endIndex: number) {\n  const noOfGroups = endIndex - startIndex + 1;\n  // logic from legacy\n  return isStacked ? 0.37 + 0.26 / noOfGroups : DEFAULT_BAR_GAP_RATIO;\n}\n\nexport function getBarWidth<K extends string | number, D extends BarItemData<K>>(\n  seriesIndex: number,\n  groupIndex: number,\n  axisStepWidth: number,\n  averageGroupZ: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined\n) {\n  const widthWeightValue = getWidthWeightVal(getDataItem, seriesIndex, groupIndex, 1);\n  const ratio = widthWeightValue / averageGroupZ;\n  return ratio * axisStepWidth;\n}\n\nexport function getOffset<K extends string | number, D extends BarItemData<K>>(\n  seriesIndex: number,\n  groupIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  averageGroupZ: number,\n  axisStepWidth: number,\n  barWidth: number,\n  numSeries: number,\n  seriesStart: number,\n  center: number,\n  isRtl: boolean,\n  isHoriz: boolean,\n  isVariableBarWidth: boolean\n) {\n  let yTotalWidth = 0;\n  const offset = [];\n  if (isVariableBarWidth) {\n    for (let s = 0; s < numSeries; s++) {\n      offset[s] = yTotalWidth;\n      yTotalWidth += getBarWidth(s, groupIndex, axisStepWidth, averageGroupZ, getDataItem);\n    }\n    for (const s in offset) {\n      offset[s] -= yTotalWidth / 2;\n    }\n    return offset[seriesIndex];\n  } else {\n    return isRtl && !isHoriz ? center - seriesStart - barWidth : seriesStart - center;\n  }\n}\n\nexport function getWidthWeightVal<K extends string | number, D extends BarItemData<K>>(\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  seriesIndex: number,\n  groupIndex: number,\n  defaultVal: number\n) {\n  const dataItem = getDataItem(seriesIndex, groupIndex);\n  if (dataItem == null || typeof dataItem != 'object') return defaultVal;\n  if (dataItem['widthWeight'] != null)\n    // Object with value property\n    return Math.max(0, dataItem['widthWeight']); // override any negative widthWeight values as 0\n  return defaultVal;\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { TextProps } from '#PRIVATE_VisSVGText/text.types';\nimport { Group, Scale } from '#utils/UNSAFE_visTypes/chart';\n\ntype LevelInfo = {\n  maxWidth: number;\n  maxHeight: number;\n  isRotated: boolean;\n  numOfSkips: number;\n  tickLabels: (TextProps & {\n    index: number;\n  })[];\n};\n\nexport type LevelsInfo = Map<number, LevelInfo>;\n\nexport const SEPARATOR_GAP = 6;\n\nexport type GroupLevelItem = {\n  item: Group;\n  start: number;\n  end: number;\n  position: number;\n  path: number[];\n};\n\nexport function getTicks(startIndex: number, endIndex: number) {\n  const ticks = [];\n  for (let i = startIndex; i <= endIndex; i++) {\n    ticks.push(i);\n  }\n  return ticks;\n}\n\nexport function getLevelStartingGroup(\n  levelsArray: GroupLevelItem[][],\n  levelIndex: number,\n  viewportMin: number,\n  min: number,\n  max: number,\n  xScale: Scale,\n  isRtl: boolean,\n  isHoriz: boolean\n) {\n  const noOfGroups = levelsArray[levelIndex].length;\n  const minCoord = xScale.transform(viewportMin);\n  for (let i = 0; i < noOfGroups; i++) {\n    const labelCoord = getLabelCoord(levelIndex, i, min, max, levelsArray, xScale);\n    if (((!isRtl || !isHoriz) && labelCoord >= minCoord) || (isRtl && labelCoord <= minCoord)) {\n      return i;\n    }\n  }\n  return noOfGroups;\n}\n\nexport function getLevelEndingGroup(\n  levelsArray: GroupLevelItem[][],\n  levelIndex: number,\n  viewportMax: number,\n  min: number,\n  max: number,\n  xScale: Scale,\n  isRtl: boolean,\n  isHoriz: boolean\n) {\n  const noOfGroups = levelsArray[levelIndex].length;\n  const maxCoord = xScale.transform(viewportMax);\n  for (let i = noOfGroups - 1; i >= 0; i--) {\n    const labelCoord = getLabelCoord(levelIndex, i, min, max, levelsArray, xScale);\n    if (((!isRtl || !isHoriz) && labelCoord <= maxCoord) || (isRtl && labelCoord >= maxCoord)) {\n      return i;\n    }\n  }\n  return 0;\n}\n\n/**\n * Returns the index of starting leaf group.\n * @param levelsArray The levelsArray\n * @param groupIndex The index of the group in that level.\n * @param levelIndex The index of the level.\n * @returns { number } The index of the starting leaf group.\n */\nexport function getLeafStartIndex(\n  levelsArray: GroupLevelItem[][],\n  groupIndex: number,\n  levelIndex?: number\n) {\n  if (levelIndex == null) {\n    levelIndex = levelsArray.length - 1;\n  }\n  return levelsArray[levelIndex][groupIndex]['start'];\n}\n\n/**\n * Returns the index of last leaf group.\n * @param levelsArray The levelsArray\n * @param groupIndex The index of the group in that level.\n * @param levelIndex The index of the level.\n * @returns { number } The index of the last leaf group.\n */\nexport function getLeafEndIndex(\n  levelsArray: GroupLevelItem[][],\n  groupIndex: number,\n  levelIndex?: number\n) {\n  if (levelIndex == null) {\n    levelIndex = levelsArray.length - 1;\n  }\n  return levelsArray[levelIndex][groupIndex]['end'];\n}\n\nexport function getLabelCoord(\n  level: number,\n  index: number,\n  minValue: number,\n  maxValue: number,\n  levelsArray: GroupLevelItem[][],\n  xScale: Scale\n) {\n  let startValue = getLeafStartIndex(levelsArray, index, level);\n  let endValue = getLeafEndIndex(levelsArray, index, level);\n  if (startValue < minValue && endValue > minValue) startValue = minValue;\n  if (endValue > maxValue && startValue < maxValue) endValue = maxValue;\n  const center = endValue ? startValue + (endValue - startValue) / 2 : startValue;\n  return xScale.transform(center);\n}\n\nexport function getLabelAt(\n  index: number,\n  level: number | undefined,\n  levelsArray: GroupLevelItem[][]\n) {\n  const numLevels = levelsArray.length;\n  if (level == null) level = numLevels - 1;\n\n  index = Math.round(index);\n  if (index < 0) return '';\n\n  const labelGroup =\n    levelsArray[level] && levelsArray[level][index] ? levelsArray[level][index]['item'] : null;\n\n  let label = '';\n  if (labelGroup) {\n    if (labelGroup['name']) label = labelGroup['name'];\n    else if (labelGroup['id'] != null)\n      // Empty or null group name allowed if id is specified\n      label = '';\n  }\n  return label;\n}\n\nexport const getPosition = (index: number, level: number, levelsArray: GroupLevelItem[][]) => {\n  if (level == null) level = levelsArray.length - 1;\n  return levelsArray[level][index]['position'];\n};\n\nfunction generateLevelsRecursive(\n  groupsArray: Group[],\n  level: number,\n  levelsArray: GroupLevelItem[][],\n  groupIndex: number,\n  path: number[]\n) {\n  for (let i = 0; i < groupsArray.length; i++) {\n    // Add new array if at first group in a new level\n    if (!levelsArray[level]) levelsArray[level] = [];\n\n    const p = path.slice();\n    p.push(i);\n\n    // Store object for group\n    levelsArray[level].push({\n      item: groupsArray[i],\n      start: groupIndex,\n      end: groupIndex,\n      position: i,\n      path: p\n    });\n\n    if (!groupsArray[i] || !groupsArray[i]['groups']) {\n      groupIndex++;\n      continue;\n    }\n\n    const lastIndex = levelsArray[level].length - 1;\n\n    // Find the index of the last innermost group nested within this group item\n    const currentLeafIndex = generateLevelsRecursive(\n      groupsArray[i]['groups']!,\n      level + 1,\n      levelsArray,\n      levelsArray[level][lastIndex]['start'],\n      p\n    );\n\n    if (groupIndex != currentLeafIndex) {\n      levelsArray[level][lastIndex]['end'] = currentLeafIndex - 1; // start and end index used for centering group labels\n      groupIndex = currentLeafIndex;\n    } else {\n      groupIndex++;\n    }\n  }\n  return groupIndex;\n}\n\nexport function generateLevels(groups: Group[]) {\n  const levelsArray: GroupLevelItem[][] = [];\n  const groupCount = generateLevelsRecursive(groups, 0, levelsArray, 0, []);\n\n  const getGroupFromPath = (path: number[]) => {\n    let root: Group[] | undefined = groups;\n    const ids: string[] = [];\n    path.forEach((value) => {\n      if (!root) {\n        return;\n      }\n      const g = root[value];\n      root = g.groups;\n      ids.push(g.name || g.id);\n    });\n    return ids;\n  };\n\n  return {\n    getGroupFromPath,\n    groupCount,\n    levelsArray\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { GetTextDimensionsType } from '#hooks/PRIVATE_useTextDimensions';\nimport { AXIS_DEFAULTS } from '#PRIVATE_Axis/utils/axisDefaults';\nimport {\n  getAxisMaxSize,\n  getAxisRange,\n  getGroupWidthRatios,\n  getSafeSkips,\n  getTickLabelAnchor\n} from '#PRIVATE_Axis/utils/axisUtils';\nimport {\n  getGroupAxisLabelsInfo,\n  getTickLabelInfo,\n  updateLabelsDims\n} from '#PRIVATE_Axis/utils/labelUtils';\nimport { getTitleProps } from '#PRIVATE_Axis/utils/titleUtils';\nimport { TextProps } from '#PRIVATE_VisSVGText/text.types';\nimport { getBarGapRatio } from '#UNSAFE_BarChart/utils/barSeriesUtils';\nimport { ScaleLinear } from '#utils/PRIVATE_chartUtils';\nimport { VariableWidthScale } from '#utils/PRIVATE_chartUtils/scale';\nimport { AxisPosition, Group, GroupAxisProps } from '#utils/UNSAFE_visTypes/chart';\nimport { Dimension } from '#utils/UNSAFE_visTypes/common';\n\nimport {\n  getLabelCoord,\n  getLevelEndingGroup,\n  getLevelStartingGroup,\n  getTicks,\n  GroupLevelItem,\n  LevelsInfo\n} from './hierarchicalUtils';\nimport { getSeparatorPaths, getSeparatorStartLevel } from './separator';\n\n/**\n * Retuns the info about group axis.\n * @param groups The groups array.\n * @param xAxis The xAxis props.\n * @param offset The start and end offset for the chart.\n * @returns\n */\nexport function getGroupAxisInfo(\n  leafGroups: Group[],\n  xAxis: GroupAxisProps = {},\n  startOffset: number,\n  endOffset: number\n) {\n  let { viewportMin, viewportMax, viewportEndGroup, viewportStartGroup } = xAxis;\n  const groupCount = leafGroups.length;\n\n  if (viewportMin != null) {\n    const groupIndex = Math.max(0, Math.ceil(viewportMin));\n    viewportStartGroup = leafGroups[isNaN(groupIndex) ? 0 : groupIndex].id;\n  }\n\n  if (viewportStartGroup != null && viewportMin == null) {\n    viewportMin = leafGroups.findIndex((value: Group) => value.id === viewportStartGroup);\n  }\n\n  if (viewportMin == null) {\n    viewportMin = startOffset;\n    viewportStartGroup = leafGroups[0]?.id;\n  }\n\n  if (viewportMax != null) {\n    const groupIndex = Math.min(groupCount, Math.floor(viewportMax));\n    viewportEndGroup = leafGroups[groupIndex < 0 ? 0 : groupIndex].id;\n  }\n\n  if (viewportEndGroup != null && viewportMax == null) {\n    viewportMax = leafGroups.findIndex((value: Group) => value.id === viewportEndGroup);\n  }\n\n  if (viewportMax == null) {\n    viewportMax = groupCount - 1 + endOffset;\n    viewportEndGroup = leafGroups[Math.floor(viewportMax)]?.id;\n  }\n\n  const ticks = getTicks(0, leafGroups.length - 1);\n\n  return {\n    min: startOffset,\n    max: leafGroups.length - 1 + endOffset,\n    viewportMin,\n    viewportMax,\n    viewportStartGroup,\n    viewportEndGroup,\n    startIndex: Math.max(0, Math.ceil(viewportMin!)),\n    endIndex: Math.min(Math.floor(viewportMax), viewportMax!),\n    ticks,\n    minorTicks: [],\n    step: 1,\n    minAxisExtent: 1\n  };\n}\n\n/**\n * The function that returns the x axis properties.\n * @param groupAxisIno The GroupAxisInfo.\n * @param groupAxis The groupAxis props.\n * @param groups The chart groups.\n * @param position The position of axis in the given space.\n * @param availSpace The available space.\n * @param isRtl Whether the reading direction is right to left.\n * @param getTextDimensions Function for text measurement.\n * @returns\n */\nexport function getGroupAxisProps(\n  position: AxisPosition,\n  availSpace: Dimension,\n  isRtl: boolean,\n  viewportMin: number,\n  viewportMax: number,\n  min: number,\n  max: number,\n  startIndex: number,\n  endIndex: number,\n  isDomainFlipped: boolean,\n  levelsArray: GroupLevelItem[][],\n  endOffset: number,\n  barWidths: number[],\n  isStacked: boolean,\n  groupAxis?: GroupAxisProps,\n  axisFontSize?: string,\n  getTextDimensions?: GetTextDimensionsType,\n  isTestEnv?: boolean,\n  groupCount?: number,\n  hasWidthWeightValue?: boolean\n) {\n  const [start, end] = getAxisRange(availSpace, position, isRtl);\n  const domain: [number, number] = isDomainFlipped\n    ? [viewportMax, viewportMin]\n    : [viewportMin, viewportMax];\n  const gapRatio = getBarGapRatio(isStacked, startIndex, endIndex);\n  const { groupWidths, averageGroupZ } = getGroupWidthRatios(barWidths, gapRatio, groupCount!);\n  const scale = hasWidthWeightValue\n    ? new VariableWidthScale(domain, [start, end], groupWidths, groupCount!)\n    : new ScaleLinear(domain, [start, end]);\n\n  const axisStepWidth = Math.abs(end - start) / (viewportMax - viewportMin);\n\n  if (groupAxis?.isRendered === false) {\n    return {\n      title: undefined,\n      titleProps: undefined,\n      titleStyle: {},\n      tickLabels: [],\n      tickLabelStyle: {},\n      axisDim: 0,\n      scale,\n      defaultLabelFormatter: undefined,\n      separators: [],\n      isGroupLabelRendered: () => false,\n      axisStepWidth,\n      averageGroupZ\n    };\n  }\n\n  const groupSeparators = groupAxis?.groupSeparators;\n  const isHoriz = position === 'top' || position === 'bottom';\n  const axisMaxDim = getAxisMaxSize(availSpace, isHoriz, groupAxis?.size);\n  const titleStyle = { fontSize: axisFontSize, ...groupAxis?.titleStyle };\n\n  const { titleDim, ...titleProps } = getTitleProps(\n    groupAxis?.title,\n    titleStyle,\n    axisMaxDim,\n    availSpace,\n    position,\n    isRtl,\n    getTextDimensions\n  );\n\n  const { width: titleWidth, height: titleHeight } = titleProps.dims!;\n  const isTitleRendered = titleWidth > 0 && titleHeight > 0;\n  const axisDim = isTitleRendered ? titleDim + AXIS_DEFAULTS.titleGap : 0;\n  const isRotated = position === 'left' || position === 'right';\n\n  if (isTitleRendered) {\n    if (isRotated) {\n      availSpace.width -= axisDim;\n      availSpace.x += position === 'left' ? axisDim : 0;\n    } else {\n      availSpace.height -= axisDim;\n      availSpace.y += position === 'top' ? axisDim : 0;\n    }\n  }\n\n  const tickLabelStyle = {\n    fontSize: axisFontSize,\n    fill: groupAxis?.tickLabel?.style?.color,\n    ...groupAxis?.tickLabel?.style,\n    textAnchor: getTickLabelAnchor(position, isRtl, true)\n  };\n\n  const isLabelRendered = groupAxis?.tickLabel?.isRendered != false;\n\n  const groupLabels: (TextProps & {\n    index: number;\n  })[] = [];\n  let labelDims = 0;\n\n  let lastRenderedLevel: number | undefined;\n\n  const levelsInfo: LevelsInfo = new Map();\n\n  for (let level = 0; level < levelsArray.length; level++) {\n    const sIndex = getLevelStartingGroup(\n      levelsArray,\n      level,\n      viewportMin,\n      min,\n      max,\n      scale,\n      isRtl,\n      isHoriz\n    );\n    const eIndex = getLevelEndingGroup(\n      levelsArray,\n      level,\n      viewportMax,\n      min,\n      max,\n      scale,\n      isRtl,\n      isHoriz\n    );\n\n    const labelsInView = levelsArray[level]\n      .slice(sIndex, eIndex + 1)\n      .map(({ item }) => item.name || item.id);\n\n    const numOfSafeSkips = getSafeSkips(axisStepWidth, tickLabelStyle, getTextDimensions);\n\n    const maxLabelDim = axisMaxDim - axisDim - AXIS_DEFAULTS.labelGap;\n\n    const isWrapAllowed = tickLabelStyle.whiteSpace != 'nowrap';\n\n    const getLabelInfo = (\n      label: string | undefined,\n      index: number,\n      isRotated: boolean,\n      allowTruncate: boolean,\n      isWrapAllowed: boolean\n    ) => {\n      const rangeValue = getLabelCoord(\n        level,\n        index + sIndex,\n        startIndex,\n        endIndex,\n        levelsArray,\n        scale\n      );\n      return getTickLabelInfo(\n        rangeValue,\n        label,\n        index + sIndex,\n        tickLabelStyle,\n        isHoriz,\n        isRotated,\n        isWrapAllowed,\n        allowTruncate,\n        isHoriz ? axisStepWidth : maxLabelDim,\n        isHoriz ? maxLabelDim : axisStepWidth,\n        availSpace,\n        getTextDimensions\n      );\n    };\n\n    const autoRotate = groupAxis?.tickLabel?.autoRotate != false;\n    const levelInfo = getGroupAxisLabelsInfo(\n      labelsInView,\n      getLabelInfo,\n      isHoriz,\n      autoRotate,\n      isWrapAllowed,\n      numOfSafeSkips\n    );\n\n    levelsInfo.set(level, levelInfo);\n\n    const { maxWidth, maxHeight, tickLabels } = levelInfo;\n\n    const isLevelRendered = isHoriz\n      ? maxHeight + AXIS_DEFAULTS.labelGap < axisMaxDim - axisDim\n      : maxWidth + AXIS_DEFAULTS.labelGap < axisMaxDim - axisDim;\n\n    if (isLevelRendered) lastRenderedLevel = level;\n\n    const getAxisPos = (index: number) => {\n      return getLabelCoord(level, index, min, max, levelsArray, scale)!;\n    };\n\n    if (isLabelRendered && isLevelRendered) {\n      updateLabelsDims(maxWidth, maxHeight, tickLabels, getAxisPos, availSpace, position);\n      const levelDims = isHoriz\n        ? maxHeight + AXIS_DEFAULTS.labelGap\n        : maxWidth + AXIS_DEFAULTS.labelGap;\n      labelDims += levelDims;\n      tickLabels.forEach((label) => {\n        label['dataProps'] = {\n          'data-oj-private-object': 'group',\n          'data-oj-private-level-index': level.toString(),\n          'data-oj-private-group-index': label.index.toString(),\n          'data-oj-private-text': label.isTruncated ? label.text : undefined,\n          'data-oj-private-group-id': isTestEnv\n            ? levelsArray[level][label.index].item.id\n            : undefined\n        };\n      });\n      if (position === 'left') {\n        availSpace.x += levelDims;\n        availSpace.width -= levelDims;\n      } else if (position === 'right') {\n        availSpace.width -= levelDims;\n      }\n      availSpace.height -= levelDims;\n    }\n    groupLabels.push(...tickLabels);\n  }\n\n  const axisDimensions = isTitleRendered ? labelDims + axisDim : labelDims;\n  if (position === 'right' && lastRenderedLevel != undefined) {\n    let width = 0;\n    for (let i = 0; i < lastRenderedLevel + 1; i += 1) {\n      const { maxWidth, tickLabels } = levelsInfo.get(i)!;\n      const getAxisPos = (index: number) => {\n        return getLabelCoord(i, index, startIndex, endIndex, levelsArray, scale)!;\n      };\n      tickLabels.forEach((l) => {\n        l.lines.forEach((_: any, index: number) => {\n          const dim = l.lineProps[index];\n          const x = availSpace.x + availSpace.width + labelDims - width;\n          const y = getAxisPos(l.index);\n          dim.x = x;\n          dim.y = y;\n        });\n        const textDim = l.dims!;\n        const x = availSpace.x + availSpace.width + labelDims - width;\n        const y = getAxisPos(l.index);\n        textDim.x = x;\n        textDim.y = y;\n      });\n      width += maxWidth + AXIS_DEFAULTS.labelGap;\n    }\n  }\n\n  let separators: [number, number, number, number][] = [];\n  if (groupSeparators?.isRendered != false) {\n    const separatorStartLevel = getSeparatorStartLevel(lastRenderedLevel, levelsInfo);\n    separators = getSeparatorPaths(\n      levelsArray,\n      separatorStartLevel,\n      levelsInfo,\n      isHoriz,\n      scale,\n      endOffset,\n      isRtl\n    );\n  }\n\n  const isGroupLabelRendered = (levelIndex: number, groupIndex: number) => {\n    const dims = levelsInfo.get(levelIndex)?.tickLabels[groupIndex]?.dims;\n    const text = levelsInfo.get(levelIndex)?.tickLabels[groupIndex]?.text;\n    return !!(dims?.width != 0 && dims?.height != 0 && text);\n  };\n\n  return {\n    title: isTitleRendered ? groupAxis?.title : undefined,\n    titleProps: isTitleRendered ? titleProps : undefined,\n    titleStyle,\n    tickLabels: isLabelRendered ? groupLabels.filter(Boolean) : [],\n    tickLabelStyle,\n    axisDim: axisDimensions,\n    scale,\n    defaultLabelFormatter: undefined,\n    separators,\n    isGroupLabelRendered,\n    axisStepWidth,\n    averageGroupZ\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { getGroupAxisLabelsInfo } from '#PRIVATE_Axis/utils/labelUtils';\nimport { TextProps } from '#PRIVATE_VisSVGText/text.types';\nimport { Scale } from '#utils/UNSAFE_visTypes/chart/chart.types';\nimport {\n  getLabelAt,\n  getLeafEndIndex,\n  getLeafStartIndex,\n  GroupLevelItem,\n  LevelsInfo,\n  SEPARATOR_GAP\n} from './hierarchicalUtils';\n\nexport function getSeparatorStartLevel(\n  lastRenderedLevel: number | undefined,\n  levelsInfo: Map<number, ReturnType<typeof getGroupAxisLabelsInfo>>\n) {\n  if (!lastRenderedLevel) {\n    return 0;\n  }\n\n  let startLevel = lastRenderedLevel;\n\n  // The start level of the separators may itself have skipped labels, but all levels after must not skip labels\n  // We reset the startLevel when we find a level that skips labels\n  for (let i = lastRenderedLevel - 1; i >= 0; i--) {\n    const info = levelsInfo.get(i);\n    if (info && info.numOfSkips > 0) {\n      startLevel = i;\n    }\n  }\n\n  return startLevel;\n}\n\nexport function getSeparatorPaths(\n  levelsArray: GroupLevelItem[][],\n  separatorStartLevel: number,\n  levelsInfo: LevelsInfo,\n  isHoriz: boolean,\n  scale: Scale,\n  endOffset: number,\n  isRtl: boolean\n) {\n  let previousLevelSize = 0;\n  let x1, y1, x2, y2, x3, x4;\n  const paths: [number, number, number, number][] = [];\n  const offset = 0.5;\n\n  /*\n   * orientation = 'vertical'                     if rotated:\n   * (x1, y1)                        (x2, y1)     (x1, y1)                 (x2, y1)\n   *    |                               |            |     rotated label      |\n   *    ------------- label -------------            --------------------------\n   * (x1, y2)    (x3, y2)(x4, y2)    (x2, y2)     (x1, y2)                 (x2, y2)\n   *\n   *\n   * orientation = 'horizontal'\n   * (x1, y1) _______ (x2, y1)\n   *         |\n   *         |\n   *         | label\n   *         |\n   *         |\n   * (x1, y2) _______ (x2, y2)\n   */\n\n  for (let level = separatorStartLevel; level >= 0; level--) {\n    const levelInfo = levelsInfo.get(level);\n\n    if (!levelInfo) {\n      continue;\n    }\n\n    const { maxWidth, maxHeight, tickLabels, isRotated } = levelInfo!;\n\n    const levelSize = isHoriz ? maxHeight : maxWidth;\n    if (levelSize == 0) {\n      previousLevelSize = levelSize;\n      continue;\n    }\n\n    // variables to keep track of whether certain edge cases apply\n    // previous label exists, does not have blank name, and is within the viewport\n    let prevLabelRendered = false;\n\n    // previous label exists, but has a blank name (uneven heirarchy)\n    let prevLabelEmpty = null;\n\n    // Start drawing separators from second innermost level rendered.\n    if (level < separatorStartLevel) {\n      for (let i = 0; i < tickLabels.length; i++) {\n        const label = tickLabels[i];\n        if (label == null) continue;\n\n        const index = label.index;\n\n        // label exists, but has a blank name (uneven heirarchy)\n        const isEmptyLabel = getLabelAt(index, level, levelsArray).length === 0;\n\n        if (isEmptyLabel) continue;\n\n        let isFirstLabel = label && tickLabels[index - 1] == null;\n        const isLastLabel = label && tickLabels[index + 1] == null;\n\n        const start = getLeafStartIndex(levelsArray, index, level);\n        const end = getLeafEndIndex(levelsArray, index, level);\n\n        if (isHoriz) {\n          const yCoord = label.dims!.y;\n\n          x1 = scale.transform(start - (isFirstLabel ? endOffset : offset));\n          y1 = yCoord - levelSize / 2 - previousLevelSize * 0.5 - SEPARATOR_GAP;\n\n          x2 = scale.transform(end + (isLastLabel ? endOffset : offset));\n          y2 = !isRotated ? yCoord : yCoord + levelSize / 2;\n\n          if (prevLabelRendered == false && x1 != null) {\n            paths.push([x1, y2, x1, y1]);\n          }\n\n          if (x2 != null) {\n            paths.push([x2, y2, x2, y1]);\n          }\n\n          // draw horizontal lines, when necessary, around non-empty labels\n\n          let labelWidth = 0;\n          if (label) labelWidth = (isRotated ? label.dims?.height : label.dims?.width)!;\n\n          x1 = scale.transform(start - (isFirstLabel ? endOffset : offset));\n          x2 = scale.transform(end + (isLastLabel ? endOffset : offset));\n\n          x3 = label\n            ? isRtl\n              ? label.dims!.x + labelWidth * 0.5\n              : label.dims!.x - labelWidth * 0.5\n            : scale.transform(end + offset);\n          x4 = label\n            ? isRtl\n              ? label.dims!.x - labelWidth * 0.5\n              : label.dims!.x + labelWidth * 0.5\n            : scale.transform(start - offset);\n\n          if (isRotated)\n            // draw horizontal line beneath rotated label\n            paths.push([x1, y2!, x2, y2!]);\n          else {\n            // draw horizontal lines on either size of rendered label\n            const spacing = isRtl ? -label.dims!.height * 0.5 : label.dims!.height * 0.5; // small space between end of horizontal lines and label\n            const drawRightLine = isRtl ? x1 > x3 - spacing : x1 < x3 - spacing;\n            const drawLeftLine = isRtl ? x4 + spacing > x2 : x4 + spacing < x2;\n\n            if (drawRightLine) paths.push([x1, y2!, x3 - spacing, y2!]);\n\n            if (drawLeftLine) paths.push([x4 + spacing, y2!, x2, y2!]);\n          }\n        } else {\n          x1 = !isRtl\n            ? label.dims!.x + SEPARATOR_GAP * 0.5\n            : label.dims!.x - levelSize - SEPARATOR_GAP * 0.5;\n          y1 = scale.transform(start - (isFirstLabel ? endOffset : offset));\n          x2 = !isRtl\n            ? label.dims!.x - levelSize - SEPARATOR_GAP * 0.5\n            : label.dims!.x + SEPARATOR_GAP * 0.5;\n          y2 = scale.transform(end + (isLastLabel ? endOffset : offset));\n\n          if (\n            ((!isEmptyLabel && prevLabelRendered == false) ||\n              (index == 0 && isEmptyLabel && level != 0)) &&\n            y1 != null\n          ) {\n            paths.push([x1, y1, x2, y1]);\n          }\n\n          if (y2 != null) {\n            paths.push([x2, y2, x1, y2]);\n          }\n\n          // draw vertical lines, when necessary, around non-empty labels\n\n          y1 =\n            isFirstLabel && prevLabelEmpty == false\n              ? 0\n              : scale.transform(start - (isFirstLabel ? endOffset : offset));\n          if (isFirstLabel) isFirstLabel = false;\n          y2 = scale.transform(end + (isLastLabel ? endOffset : offset));\n\n          paths.push([x2!, y1, x2!, y2]);\n        }\n        // information about previous label\n        prevLabelRendered = !isEmptyLabel && label != null;\n        prevLabelEmpty = label != null || (label == null && isEmptyLabel);\n      }\n    }\n    previousLevelSize = levelSize; // save height or width of previous level\n  }\n\n  return paths;\n}\n\nexport function getHorizontalSeparatorCoord(\n  label: TextProps & {\n    index: number;\n  },\n  scale: Scale,\n  start: number,\n  end: number,\n  offset: number,\n  levelSize: number,\n  previousLevelSize: number,\n  isRtl: boolean,\n  isRotated: boolean,\n  paths: [number, number, number, number][],\n  prevLabelRendered: boolean | null\n) {\n  const yCoord = label.dims!.y;\n\n  let x1 = scale.transform(start - offset);\n  const y1 = !isRotated\n    ? yCoord - levelSize / 2 - previousLevelSize * 0.5 - SEPARATOR_GAP\n    : yCoord + previousLevelSize * 0.5;\n  let x2 = scale.transform(end + offset);\n  const y2 = !isRotated ? yCoord : yCoord + levelSize + previousLevelSize + 2 * SEPARATOR_GAP;\n\n  if (prevLabelRendered == false && x1 != null) {\n    paths.push([x1, y2, x1, y1]);\n  }\n\n  if (x2 != null) {\n    paths.push([x2, y2, x2, y1]);\n  }\n\n  // draw horizontal lines, when necessary, around non-empty labels\n\n  let labelWidth = 0;\n  if (label) labelWidth = (isRotated ? label.dims?.height : label.dims?.width)!;\n\n  x1 = scale.transform(start - offset);\n  x2 = scale.transform(end + offset);\n\n  const x3 = label\n    ? isRtl\n      ? label.dims!.x + labelWidth * 0.5\n      : label.dims!.x - labelWidth * 0.5\n    : scale.transform(end + offset);\n  const x4 = label\n    ? isRtl\n      ? label.dims!.x - labelWidth * 0.5\n      : label.dims!.x + labelWidth * 0.5\n    : scale.transform(start - offset);\n\n  if (isRotated)\n    // draw horizontal line beneath rotated label\n    paths.push([x1, y2!, x2, y2!]);\n  else {\n    // draw horizontal lines on either size of rendered label\n    const spacing = isRtl ? -label.dims!.height * 0.5 : label.dims!.height * 0.5; // small space between end of horizontal lines and label\n    const drawRightLine = isRtl ? x1 > x3 - spacing : x1 < x3 - spacing;\n    const drawLeftLine = isRtl ? x4 + spacing > x2 : x4 + spacing < x2;\n\n    if (drawRightLine) paths.push([x1, y2!, x3 - spacing, y2!]);\n\n    if (drawLeftLine) paths.push([x4 + spacing, y2!, x2, y2!]);\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  DataAxisProps,\n  Group,\n  GroupAxisProps,\n  TimeAxisProps,\n  AxisPosition,\n  ChartSeriesData,\n  Scale\n} from '../UNSAFE_visTypes/chart';\nimport { Dimension } from '../UNSAFE_visTypes/common';\nimport { BarItemData, BarSeriesData } from '../../UNSAFE_BarChart/barChart.types';\nimport {\n  findNearestRegularAxisIndex,\n  getDataExtent,\n  getNearestMixedFrequencyDataItem\n} from './dataUtils';\nimport { getAxesPosition } from '../../PRIVATE_Axis/utils/axisUtils';\nimport type { GetTextDimensionsType } from '../../hooks/PRIVATE_useTextDimensions';\nimport { cloneDimension } from '../../utils/PRIVATE_visLayoutUtils';\nimport { LineAreaItem } from '#UNSAFE_LineAreaChart/lineAreaChart.types';\nimport { ScatterItem } from '#UNSAFE_ScatterChart/scatterChart.types';\nimport { ChartOverviewConfig } from '#utils/UNSAFE_visTypes/chart/chart.types';\nimport {\n  getOverviewHeight,\n  OVERVIEW_PANE_SIZE,\n  TIME_AXIS_OVERVIEW_PANE_SIZE\n} from './overviewUtils';\nimport { DataAxisInfo } from '#PRIVATE_Axis/dataAxis/dataAxisInfo';\nimport { getDataAxisProps } from '#PRIVATE_Axis/dataAxis/dataAxisUtils';\nimport {\n  getStartAndEndTime,\n  getTime,\n  getTimeAxisInfo,\n  getTimeAxisProps\n} from '#PRIVATE_Axis/timeAxis/timeAxisInfo';\nimport { getGroupAxisInfo, getGroupAxisProps } from '#PRIVATE_Axis/groupAxis/groupAxisInfo';\nimport { generateLevels } from '#PRIVATE_Axis/groupAxis/hierarchicalUtils';\nconst OUTER_GAP_WIDTH = 10;\nconst OUTER_GAP_HEIGHT = 8;\nconst MIN_SCROLL_SIZE = 12;\nconst SCROLL_GAP = 6;\n\n/**\n * Returns the chart layout info.\n * @returns\n */\nexport function getLayoutInfo<\n  K extends string | number,\n  D extends LineAreaItem<K> | ScatterItem<K> | BarItemData<K>\n>(\n  series: BarSeriesData<K, D>[],\n  groups: Group[],\n  getDataItem: (seriesIndex: number, groupIndex: number, groupPath: number[]) => D | undefined,\n  xAxis: GroupAxisProps | TimeAxisProps | DataAxisProps | undefined,\n  yAxis: DataAxisProps | undefined,\n  y2Axis: DataAxisProps | undefined,\n  availSpace: Dimension,\n  hiddenSet: Set<K>,\n  hideAndShowBehavior: 'none' | 'withRescale' | 'withoutRescale',\n  isHoriz: boolean,\n  isRtl: boolean,\n  isStacked: boolean,\n  axisFontSize: string,\n  getStartAndEndAxesOffset: (groupCount: number) => { startOffset: number; endOffset: number },\n  locale: string,\n  splitDualY: boolean,\n  splitterPositin: number,\n  getTextDimensions?: GetTextDimensionsType,\n  isTestEnv?: boolean,\n  hasXDataAxis?: boolean\n) {\n  const isTimeAxis = (xAxis as TimeAxisProps)?.timeAxisType != null;\n  const { xAxisPosition, yAxisPosition, y2AxisPosition } = getAxesPosition(\n    yAxis,\n    y2Axis,\n    isHoriz,\n    isRtl\n  );\n  let xAxisInfo;\n  let dataInfo;\n\n  const hasY2Axis = series.some((s) => s.associatedYAxis === 'y2');\n\n  addAxisGaps(\n    availSpace,\n    isHoriz,\n    isRtl,\n    hasY2Axis,\n    axisFontSize,\n    yAxis,\n    y2Axis,\n    xAxis,\n    getTextDimensions\n  );\n\n  const { levelsArray, getGroupFromPath, groupCount } = generateLevels(groups);\n  const leafGroups =\n    levelsArray.length > 0 ? levelsArray[levelsArray.length - 1].map((i) => i.item) : [];\n\n  const { startOffset, endOffset } = getStartAndEndAxesOffset(groupCount);\n\n  const getDataItemWithGroupPath = (seriesIndex: number, groupIndex: number) => {\n    return getDataItem(\n      seriesIndex,\n      groupIndex,\n      levelsArray[levelsArray.length - 1]?.[groupIndex]?.path\n    );\n  };\n\n  if (hasXDataAxis) {\n    dataInfo = getDataExtent<K, D>(\n      series,\n      leafGroups,\n      getDataItemWithGroupPath,\n      0,\n      leafGroups.length - 1,\n      isStacked,\n      hiddenSet,\n      hideAndShowBehavior,\n      xAxis as DataAxisProps\n    );\n    xAxisInfo = new DataAxisInfo({\n      ...(xAxis as DataAxisProps),\n      dataMin: dataInfo.xMin,\n      dataMax: dataInfo.xMax,\n      numGroups: leafGroups.length\n    }).getInfo();\n  } else {\n    if (isTimeAxis) {\n      const timeAxisRange = getStartAndEndTime(\n        leafGroups,\n        series,\n        getDataItemWithGroupPath,\n        xAxis as TimeAxisProps\n      );\n      xAxisInfo = getTimeAxisInfo(\n        leafGroups,\n        xAxis as TimeAxisProps,\n        startOffset,\n        endOffset,\n        timeAxisRange\n      );\n    } else {\n      xAxisInfo = getGroupAxisInfo(leafGroups, xAxis as GroupAxisProps, startOffset, endOffset);\n    }\n\n    dataInfo = getDataExtent<K, D>(\n      series,\n      leafGroups,\n      getDataItemWithGroupPath,\n      xAxisInfo.startIndex,\n      xAxisInfo.endIndex,\n      isStacked,\n      hiddenSet,\n      hideAndShowBehavior,\n      yAxis,\n      y2Axis\n    );\n  }\n  const {\n    yDataMax,\n    yDataMin,\n    y2DataMax,\n    y2DataMin,\n    yMin,\n    yMax,\n    y2Min,\n    y2Max,\n    idToDataMap,\n    isY2AxisRendered,\n    isYAxisRendered,\n    hasWidthWeightValue,\n    barWidths\n  } = dataInfo;\n\n  let yAxisInfo, y2AxisInfo;\n  if (y2DataMin < yDataMin || y2DataMax > yDataMax) {\n    y2AxisInfo = new DataAxisInfo({\n      ...y2Axis,\n      dataMax: hasXDataAxis ? y2Max : y2DataMax,\n      dataMin: hasXDataAxis ? y2Min : y2DataMin,\n      numGroups: leafGroups.length\n    }).getInfo();\n\n    yAxisInfo = new DataAxisInfo({\n      ...yAxis,\n      dataMax: hasXDataAxis ? yMax : yDataMax,\n      dataMin: hasXDataAxis ? yMin : yDataMin,\n      majorTickCount: y2AxisInfo.ticks.length - 1,\n      numGroups: leafGroups.length\n    }).getInfo();\n  } else {\n    yAxisInfo = new DataAxisInfo({\n      ...yAxis,\n      dataMax: hasXDataAxis ? yMax : yDataMax,\n      dataMin: hasXDataAxis ? yMin : yDataMin,\n      numGroups: leafGroups.length\n    }).getInfo();\n    y2AxisInfo = new DataAxisInfo({\n      ...y2Axis,\n      dataMax: hasXDataAxis ? y2Max : y2DataMax,\n      dataMin: hasXDataAxis ? y2Min : y2DataMin,\n      majorTickCount: yAxisInfo.ticks.length - 1,\n      numGroups: leafGroups.length\n    }).getInfo();\n  }\n\n  const { axisDim: yDim } = getDataAxisProps(\n    yAxisPosition,\n    cloneDimension(availSpace),\n    isRtl,\n    locale,\n    yAxisInfo,\n    yAxis,\n    axisFontSize,\n    getTextDimensions,\n    isYAxisRendered\n  );\n\n  const { axisDim: y2Dim } = getDataAxisProps(\n    y2AxisPosition,\n    cloneDimension(availSpace),\n    isRtl,\n    locale,\n    y2AxisInfo,\n    y2Axis,\n    axisFontSize,\n    getTextDimensions,\n    isY2AxisRendered\n  );\n\n  const isXAxisHoriz = xAxisPosition === 'bottom';\n\n  // get updated available space for x axis.\n  const { xSpace: xAvailSpace } = getSpaces(\n    availSpace,\n    xAxisPosition,\n    yAxisPosition,\n    y2AxisPosition,\n    isXAxisHoriz ? availSpace.height : availSpace.width,\n    yDim,\n    y2Dim\n  );\n\n  const axisProps = isTimeAxis\n    ? getTimeAxisProps(\n        leafGroups,\n        xAxisPosition,\n        xAvailSpace,\n        xAxisInfo.viewportMin!,\n        xAxisInfo.viewportMax!,\n        xAxisInfo.step,\n        isRtl,\n        xAxis as TimeAxisProps,\n        axisFontSize,\n        getTextDimensions,\n        isTimeAxis\n      )\n    : hasXDataAxis\n    ? getDataAxisProps(\n        xAxisPosition,\n        xAvailSpace,\n        isRtl,\n        locale,\n        xAxisInfo,\n        xAxis as DataAxisProps,\n        axisFontSize,\n        getTextDimensions\n      )\n    : getGroupAxisProps(\n        xAxisPosition,\n        xAvailSpace,\n        isRtl,\n        xAxisInfo.viewportMin,\n        xAxisInfo.viewportMax,\n        xAxisInfo.min,\n        xAxisInfo.max,\n        xAxisInfo.startIndex!,\n        xAxisInfo.endIndex!,\n        isHoriz,\n        levelsArray,\n        endOffset,\n        barWidths,\n        isStacked,\n        xAxis as GroupAxisProps,\n        axisFontSize,\n        getTextDimensions,\n        isTestEnv,\n        groupCount,\n        hasWidthWeightValue\n      );\n\n  const { axisDim: xMaxDim, scale: xScale, ...xProps } = axisProps;\n\n  // recalculate y axis props after the x axis.\n  const { ySpace: newYSpace } = getSpaces(\n    availSpace,\n    xAxisPosition,\n    yAxisPosition,\n    y2AxisPosition,\n    xMaxDim!,\n    isXAxisHoriz ? availSpace.width : availSpace.height,\n    y2Dim\n  );\n\n  const { ySpace: newySpace, y2Space: newY2Space } = getYY2(\n    splitDualY,\n    splitterPositin,\n    newYSpace,\n    isHoriz,\n    isRtl\n  );\n\n  const newYProps = getDataAxisProps(\n    yAxisPosition,\n    newySpace,\n    isRtl,\n    locale,\n    yAxisInfo,\n    yAxis,\n    axisFontSize,\n    getTextDimensions,\n    isYAxisRendered\n  );\n  const newY2Props = getDataAxisProps(\n    y2AxisPosition,\n    newY2Space,\n    isRtl,\n    locale,\n    y2AxisInfo,\n    y2Axis,\n    axisFontSize,\n    getTextDimensions,\n    isY2AxisRendered\n  );\n\n  const { axisDim: yMaxDim, scale: yScale, ...yProps } = newYProps;\n  const { axisDim: y2MaxDim, scale: y2Scale, ...y2Props } = newY2Props;\n\n  const { plotAreaSpace, xSpace, ySpace, y2Space } = getSpaces(\n    availSpace,\n    xAxisPosition,\n    yAxisPosition,\n    y2AxisPosition,\n    xMaxDim!,\n    yMaxDim,\n    y2MaxDim\n  );\n\n  return {\n    getGroupFromPath,\n    leafGroups,\n    levelsArray,\n    xAxisInfo,\n    xProps,\n    xScale,\n    xAxisPosition,\n    yProps,\n    y2Props,\n    yScale,\n    y2Scale,\n    yMaxDim,\n    y2MaxDim,\n    yAxisPosition,\n    y2AxisPosition,\n    y2AxisInfo,\n    yAxisInfo,\n    plotAreaSpace,\n    xSpace,\n    ySpace,\n    y2Space,\n    idToDataMap\n  };\n}\n\n/**\n * Returns the available space for x axis and y axis.\n * @param availSpace The available space of the chart.\n * @param xAxisPosition The position of x axis.\n * @param yAxisPosition The position of y axis.\n * @param xMaxDim The max dimension of x axis.\n * @param yMaxDim The max dimension of y axis.\n * @returns\n */\nexport function getSpaces(\n  availSpace: Dimension,\n  xAxisPosition: AxisPosition,\n  yAxisPosition: AxisPosition,\n  y2AxisPosition: AxisPosition,\n  xMaxDim: number,\n  yMaxDim: number,\n  y2MaxDim: number\n) {\n  const isXHoriz = xAxisPosition === 'bottom' || xAxisPosition === 'top';\n  const isYLeft = yAxisPosition === 'left';\n  const isY2Left = y2AxisPosition === 'left';\n\n  const isYBottom = yAxisPosition === 'bottom';\n  const isY2Bottom = y2AxisPosition === 'bottom';\n\n  let xSpace: Dimension;\n  let ySpace: Dimension;\n  let y2Space: Dimension;\n  let plotAreaSpace: Dimension;\n\n  if (isXHoriz) {\n    xSpace = getHorizSpace(\n      availSpace,\n      xAxisPosition,\n      isYLeft ? yMaxDim : isY2Left ? y2MaxDim : 0,\n      isY2Left && !isYLeft ? yMaxDim : isYLeft && !isY2Left ? y2MaxDim : 0,\n      xMaxDim\n    );\n    ySpace = getVertSpace(\n      availSpace,\n      yAxisPosition as 'left' | 'right',\n      xAxisPosition === 'bottom' ? xMaxDim : 0,\n      xAxisPosition === 'top' ? xMaxDim : 0,\n      yMaxDim\n    );\n    y2Space = getVertSpace(\n      availSpace,\n      y2AxisPosition as 'left' | 'right',\n      xAxisPosition === 'bottom' ? xMaxDim : 0,\n      xAxisPosition === 'top' ? xMaxDim : 0,\n      y2MaxDim\n    );\n    plotAreaSpace = {\n      x: xSpace.x,\n      y: ySpace.y,\n      width: xSpace.width,\n      height: ySpace.height\n    };\n  } else {\n    xSpace = getVertSpace(\n      availSpace,\n      xAxisPosition,\n      isYBottom ? yMaxDim : isY2Bottom ? y2MaxDim : 0,\n      isY2Bottom && !isYBottom ? yMaxDim : isYBottom && !isY2Bottom ? y2MaxDim : 0,\n      xMaxDim\n    );\n    ySpace = getHorizSpace(\n      availSpace,\n      yAxisPosition as 'top' | 'bottom',\n      xAxisPosition === 'left' ? xMaxDim : 0,\n      xAxisPosition === 'left' ? 0 : xMaxDim,\n      yMaxDim\n    );\n    y2Space = getHorizSpace(\n      availSpace,\n      y2AxisPosition as 'top' | 'bottom',\n      xAxisPosition === 'left' ? xMaxDim : 0,\n      xAxisPosition === 'left' ? 0 : xMaxDim,\n      y2MaxDim\n    );\n\n    plotAreaSpace = {\n      x: ySpace.x,\n      y: xSpace.y,\n      width: ySpace.width,\n      height: xSpace.height\n    };\n  }\n\n  return { xSpace, ySpace, y2Space, plotAreaSpace };\n}\n\n/**\n * Returns the vertical sub section of given available space.\n * @param availSpace The available space.\n * @param position The position of the vertical section.\n * @param bottomOffset The bottom offset of the vertical section.\n * @param topOffset The top offset of the vertical section.\n * @param width The width of the section.\n * @returns\n */\nexport function getVertSpace(\n  availSpace: Dimension,\n  position: 'left' | 'right',\n  bottomOffset: number,\n  topOffset: number,\n  width: number\n) {\n  return {\n    x: position === 'left' ? availSpace.x : availSpace.x + availSpace.width - width,\n    width: width,\n    y: availSpace.y + topOffset,\n    height: availSpace.height - bottomOffset - topOffset\n  };\n}\n\n/**\n * Returns the horizontal sub section of given available space.\n * @param availSpace The available space.\n * @param position The position of the horizontal section.\n * @param leftOffset The left offset of the horizontal section.\n * @param rightOffset The right offset of the horizontal section.\n * @param height The height of the section.\n * @returns\n */\nexport function getHorizSpace(\n  availSpace: Dimension,\n  position: 'top' | 'bottom',\n  leftOffset: number,\n  rightOffset: number,\n  height: number\n) {\n  return {\n    x: availSpace.x + leftOffset,\n    width: availSpace.width - leftOffset - rightOffset,\n    y: position === 'top' ? availSpace.y : availSpace.y + availSpace.height - height,\n    height: height\n  };\n}\n\n/**\n * Returns the outer spacing for the chart.\n * @param width The height of the chart.\n * @param height The width of the chart.\n * @returns\n */\nexport function getOuterGaps(width: number, height: number) {\n  const widthRatio = Math.min(width / 400, 1);\n  const heightRatio = Math.min(height / 300, 1);\n  return {\n    width: widthRatio * OUTER_GAP_WIDTH,\n    height: heightRatio * OUTER_GAP_HEIGHT\n  };\n}\n\n/**\n * Returns the default available space for chart.\n * @param width The width of the chart.\n * @param height The height of the chart.\n * @returns\n */\nexport function getAvailSpace(width: number, height: number, needsOuterGap = true) {\n  const gaps = getOuterGaps(width, height);\n  if (!needsOuterGap) {\n    gaps.width = Math.min(1, gaps.width);\n    gaps.height = Math.min(1, gaps.height);\n  }\n  return {\n    width: width - 2 * gaps.width,\n    height: height - 2 * gaps.height,\n    x: gaps.width,\n    y: gaps.height\n  };\n}\n\n/**\n * Retuns the available space for the scrollbar.\n * @param availSpace\n * @param zoomAndScroll\n * @param xAxisPosition\n * @returns\n */\nexport function getScrollBarSpace(\n  isTimeAxis: boolean,\n  availSpace: Dimension,\n  zoomAndScroll: 'live' | 'off',\n  xAxisPosition: AxisPosition,\n  overview?: 'on' | 'off' | ChartOverviewConfig\n) {\n  const dims = { x: 0, y: 0, height: 0, width: 0 };\n  const noOverviewOrScroll = zoomAndScroll === 'off' && overview === 'off';\n  // for preact can still show overview without zoomAndScroll\n  // small scroll bar present if overview is off, but zoomAndScroll is on.\n  if (noOverviewOrScroll) {\n    return { scrollDims: dims, availSpace };\n  }\n  const avSpace = cloneDimension(availSpace);\n\n  let scrollSize = MIN_SCROLL_SIZE;\n  const overviewSize = isTimeAxis ? TIME_AXIS_OVERVIEW_PANE_SIZE : OVERVIEW_PANE_SIZE;\n\n  if (overview === 'on' && xAxisPosition === 'bottom') {\n    scrollSize = availSpace.height * overviewSize;\n  } else if (overview !== undefined) {\n    scrollSize = getOverviewHeight(isTimeAxis, availSpace.height, overview);\n  }\n\n  if (xAxisPosition === 'left') {\n    dims.x = availSpace.x;\n    dims.y = availSpace.y;\n    dims.width = scrollSize;\n    dims.height = availSpace.height;\n\n    avSpace.x += dims.width + SCROLL_GAP;\n    avSpace.width -= dims.width + SCROLL_GAP;\n  } else if (xAxisPosition === 'right') {\n    dims.x = availSpace.x + availSpace.width - scrollSize;\n    dims.width = scrollSize;\n    dims.height = availSpace.height;\n    dims.y = availSpace.y;\n\n    avSpace.width -= dims.width + SCROLL_GAP;\n  } else {\n    dims.x = availSpace.x;\n    dims.y = availSpace.y + availSpace.height - scrollSize;\n    dims.height = scrollSize;\n    dims.width = availSpace.width;\n\n    avSpace.height -= dims.height + SCROLL_GAP;\n  }\n  return { scrollDims: dims, availSpace: avSpace };\n}\n\n/**\n * Updates the scrollbar space\n * @param availSpace\n * @param isHoriz\n * @param yMaxDim\n */\nexport function updateScrollBarSpace(\n  availSpace: Dimension,\n  isHoriz: boolean,\n  isRtl: boolean,\n  yMaxDim: number\n) {\n  const newDims = cloneDimension(availSpace);\n  if (isHoriz) {\n    newDims.width -= yMaxDim;\n    newDims.x += isRtl ? 0 : yMaxDim;\n  } else {\n    newDims.height -= yMaxDim;\n  }\n  return newDims;\n}\n\nexport function findNearestDataPoint<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; value?: number; id: K }\n>(\n  series: ChartSeriesData<K, D>[],\n  groups: Group[],\n  xScale: Scale,\n  yScale: Scale,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  isStacked: boolean,\n  getSeriesDataInfo: (\n    seriesIndex: number,\n    groupIndex: number\n  ) => { offset: number; dataWidth: number },\n  getYCoord: (\n    value: number,\n    yScale: Scale,\n    isStacked: boolean,\n    isLog: boolean,\n    dataItemGaps: number,\n    negCummValue: number,\n    posCummValue: number\n  ) => number,\n  isLog: boolean,\n  dataItemGaps: number,\n  hiddenIds?: Set<number | string>,\n  timeAxisType?: 'enabled' | 'mixedFrequency' | 'skipGaps',\n  y2Scale?: Scale\n) {\n  return (x: number, y?: number, y2?: number) => {\n    let candidates: { seriesIndex: number; groupIndex: number }[] = [];\n    let neareastGroupIndex = Math.round(x);\n    let groupCenter = xScale.transform(neareastGroupIndex);\n    const isMixedFrequency = timeAxisType === 'mixedFrequency';\n\n    if (timeAxisType === 'enabled' || timeAxisType === 'skipGaps') {\n      neareastGroupIndex = findNearestRegularAxisIndex<K, D>(x, groups, series, getDataItem);\n      groupCenter = xScale.transform(getTime(groups[neareastGroupIndex].id));\n    }\n    candidates = series.map((_, sIndex) => ({\n      groupIndex: neareastGroupIndex,\n      seriesIndex: sIndex\n    }));\n\n    if (isMixedFrequency) {\n      candidates = getNearestMixedFrequencyDataItem<K, D>(x, series, groups, getDataItem);\n    }\n\n    let yPosCummValue = 0;\n    let yNegCummValue = 0;\n\n    let y2PosCummValue = 0;\n    let y2NegCummValue = 0;\n\n    let minDistance = Number.MAX_VALUE;\n    let minDistanceDims2 = Number.MAX_VALUE;\n    let minSeriesIndex = 0;\n    let minSeriesCenter = groupCenter;\n\n    let yCoord;\n\n    // Currently this logic is aware of various chart settings. Another approach is\n    // purely geometric (save dims of each chart item and sort by some distance measure).\n    // Not sure which one is faster but can consider for performance evaluation.\n    candidates.forEach(({ seriesIndex, groupIndex }) => {\n      const isAssociatedToY2 = series[seriesIndex].associatedYAxis === 'y2';\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (!item || hiddenIds?.has(item.id!) || item.value == null || (isLog && item.value <= 0)) {\n        return;\n      }\n\n      let dist = 0;\n      let dist2 = 0;\n\n      if (isMixedFrequency) {\n        dist = Math.abs(xScale.transform(getTime(item?.x!)) - xScale.transform(x));\n        dist2 = isAssociatedToY2\n          ? Math.abs(y2Scale!.transform(item.value) - y2Scale!.transform(y2!))\n          : Math.abs(yScale.transform(item.value) - yScale.transform(y!));\n      } else if (!isStacked) {\n        const { offset, dataWidth } = getSeriesDataInfo(seriesIndex, groupIndex);\n        const seriesCenter = offset + groupCenter + dataWidth / 2;\n        if (dataWidth === 0) {\n          dist = isAssociatedToY2\n            ? Math.abs(y2Scale!.transform(item.value) - y2Scale!.transform(y2!))\n            : Math.abs(yScale.transform(item.value) - yScale.transform(y!));\n        } else {\n          dist = Math.abs(xScale.transform(x) - seriesCenter);\n          if (dist < minDistance) {\n            minSeriesCenter = seriesCenter;\n          }\n        }\n      } else {\n        const itemY = isAssociatedToY2\n          ? (item.value < 0 ? y2NegCummValue : y2PosCummValue) + item.value / 2\n          : (item.value < 0 ? yNegCummValue : yPosCummValue) + item.value / 2;\n        dist = isAssociatedToY2\n          ? Math.abs(y2Scale!.transform(y2!) - y2Scale!.transform(itemY))\n          : Math.abs(yScale.transform(y!) - yScale.transform(itemY));\n      }\n\n      if (dist < minDistance) {\n        minDistance = dist;\n        minSeriesIndex = seriesIndex;\n        neareastGroupIndex = groupIndex;\n        yCoord = getYCoord(\n          item.value,\n          isAssociatedToY2 ? y2Scale! : yScale,\n          isStacked,\n          isLog,\n          dataItemGaps,\n          isAssociatedToY2 ? y2NegCummValue : yNegCummValue,\n          isAssociatedToY2 ? y2PosCummValue : yPosCummValue\n        );\n        if (isMixedFrequency) {\n          minDistanceDims2 = dist2;\n        }\n      } else if (dist === minDistance) {\n        if (isMixedFrequency && dist2 < minDistanceDims2) {\n          minDistance = dist;\n          minSeriesIndex = seriesIndex;\n          neareastGroupIndex = groupIndex;\n          minDistanceDims2 = dist2;\n          yCoord = getYCoord(\n            item.value,\n            isAssociatedToY2 ? y2Scale! : yScale,\n            isStacked,\n            isLog,\n            dataItemGaps,\n            isAssociatedToY2 ? y2NegCummValue : yNegCummValue,\n            isAssociatedToY2 ? y2PosCummValue : yPosCummValue\n          );\n        }\n      }\n\n      if (isStacked) {\n        if (isAssociatedToY2) {\n          y2PosCummValue += item.value > 0 ? item.value : 0;\n          y2NegCummValue += item.value < 0 ? item.value : 0;\n        } else {\n          yPosCummValue += item.value > 0 ? item.value : 0;\n          yNegCummValue += item.value < 0 ? item.value : 0;\n        }\n      }\n    });\n\n    const neareastItemId = getDataItem(minSeriesIndex, neareastGroupIndex)?.id;\n\n    // the initial guess can also be hidden.\n    if (neareastItemId == null || hiddenIds?.has(neareastItemId)) {\n      return;\n    }\n\n    const isSeriesAssociatedToY2 = series[minSeriesIndex].associatedYAxis === 'y2';\n    return {\n      seriesIndex: minSeriesIndex,\n      groupIndex: neareastGroupIndex,\n      y: isSeriesAssociatedToY2 ? undefined : yCoord,\n      y2: isSeriesAssociatedToY2 ? yCoord : undefined,\n      x: isMixedFrequency\n        ? xScale.transform(getTime(getDataItem(minSeriesIndex, neareastGroupIndex)?.x!))\n        : isStacked\n        ? groupCenter\n        : minSeriesCenter\n    };\n  };\n}\n\nexport function getGroupCenterCoord<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; value?: number; id: K }\n>(\n  group: Group,\n  groupIndex: number,\n  xScale: Scale,\n  item: D,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency'\n) {\n  if (!timeAxisType) {\n    return xScale.transform(groupIndex);\n  } else if (timeAxisType === 'mixedFrequency') {\n    return xScale.transform(new Date(item.x!).getTime());\n  } else {\n    return xScale.transform(new Date(group.id).getTime());\n  }\n}\n\nexport function getMixedFreqGroupCenter<\n  K extends string | number,\n  D extends { x?: string; y?: number; value?: number; id: K }\n>(xScale: Scale, item: D) {\n  return xScale.transform(new Date(item.x!).getTime());\n}\n\nfunction getYY2(\n  splitDualY: boolean,\n  splitPosition: number,\n  availSpace: Dimension,\n  isHoriz: boolean,\n  isRtl: boolean\n) {\n  if (!splitDualY) {\n    return {\n      ySpace: availSpace,\n      y2Space: availSpace\n    };\n  }\n\n  const { x, y, width, height } = availSpace;\n\n  const y2Width = isHoriz ? width * splitPosition : width;\n  const y2Height = isHoriz ? height : splitPosition * height;\n  const yWidth = isHoriz ? width - y2Width : width;\n  const yHeight = isHoriz ? height : height - y2Height;\n\n  const y2x = isHoriz ? (isRtl ? x : x + yWidth) : x;\n  const y2y = isHoriz ? y : y + yHeight;\n\n  const yx = isHoriz ? (isRtl ? x + y2Width : x) : x;\n  const yy = y;\n\n  return {\n    ySpace: {\n      x: yx,\n      y: yy,\n      width: yWidth,\n      height: yHeight\n    },\n    y2Space: {\n      x: y2x,\n      y: y2y,\n      width: y2Width,\n      height: y2Height\n    }\n  };\n}\n\nexport function getYY2Ticks(\n  yTicks: number[],\n  y2Ticks: number[],\n  isHoriz: boolean,\n  isSplitDual: boolean\n) {\n  if (!isSplitDual) {\n    return { yTicks, y2Ticks };\n  }\n  let _yTicks: number[] = [];\n  let _y2Ticks: number[] = [];\n  if (!isHoriz) {\n    _yTicks = yTicks;\n    _y2Ticks = y2Ticks.slice(0, -1);\n  } else {\n    _yTicks = yTicks.slice(0, -1);\n    _y2Ticks = y2Ticks;\n  }\n\n  return { yTicks: _yTicks, y2Ticks: _y2Ticks };\n}\n\nexport function addAxisGaps(\n  availSpace: Dimension,\n  isHoriz: boolean,\n  isRtl: boolean,\n  hasY2Axis: boolean,\n  axisFontSize: string,\n  yAxis?: DataAxisProps,\n  y2Axis?: DataAxisProps,\n  xAxis?: GroupAxisProps | TimeAxisProps | DataAxisProps,\n  getTextDimensions?: GetTextDimensionsType\n) {\n  const { yAxisPosition, y2AxisPosition } = getAxesPosition(yAxis, y2Axis, isHoriz, isRtl);\n  const isXRendered = !!(xAxis?.isRendered != false);\n  const isYRendered = !!(yAxis?.isRendered != false);\n  const isY2Rendered = hasY2Axis && !!(y2Axis?.isRendered != false);\n\n  let axisGap = 6;\n\n  const xAxisFontStyle = { fontSize: axisFontSize, ...xAxis?.tickLabel?.style };\n  const yAxisFontStyle = { fontSize: axisFontSize, ...yAxis?.tickLabel?.style };\n  const y2AxisFontStyle = { fontSize: axisFontSize, ...y2Axis?.tickLabel?.style };\n\n  if (isHoriz) {\n    axisGap *= (getTextDimensions?.('MW', xAxisFontStyle)?.height || 0) / 14; // adjust for font size\n  } else {\n    axisGap *=\n      Math.max(\n        getTextDimensions?.('MW', yAxisFontStyle)?.height || 0,\n        getTextDimensions?.('MW', y2AxisFontStyle)?.height || 0\n      ) / 14; // adjust for font size\n  }\n  axisGap = Math.ceil(axisGap); // prevent rounding errors\n\n  // top gap if necessary\n  if (\n    (isHoriz &&\n      !(yAxisPosition == 'top' && isYRendered) &&\n      !(y2AxisPosition == 'top' && isY2Rendered)) ||\n    !isHoriz\n  ) {\n    availSpace.y += axisGap;\n    availSpace.height -= axisGap;\n  }\n\n  // bottom gap if necessary\n  if (\n    (isHoriz &&\n      !(yAxisPosition == 'bottom' && isYRendered) &&\n      !(y2AxisPosition == 'bottom' && isY2Rendered)) ||\n    (!isHoriz && !isXRendered)\n  ) {\n    availSpace.height -= axisGap;\n  }\n\n  if (\n    isHoriz &&\n    (((yAxisPosition === 'bottom' || yAxisPosition === 'top') && isYRendered) ||\n      ((y2AxisPosition === 'bottom' || y2AxisPosition === 'top') && isY2Rendered))\n  ) {\n    availSpace.width -= axisGap;\n  }\n}\n\n/**\n * @param hasCenterdSeries Wheter the chart has centered series.\n * @param hasNonCenteredSeries Whether the chart has non centered series.\n * @param isHoriz Whether the chart is horizontal.\n * @param groupCount The group count of the chart.\n * @param hasBar Whether the chart contains bar series.\n * @returns\n */\nexport function getStartAndEndAxesOffset(\n  hasCenterdSeries: boolean,\n  hasUncenteredSeries: boolean,\n  isHoriz: boolean,\n  groupCount: number,\n  hasBar?: boolean\n) {\n  // identical logic for offset the legacy chart impl for BLAC chart\n  let offset = 0;\n  if (hasBar || hasCenterdSeries) {\n    offset = 0.5;\n  } else {\n    const maxOffset = isHoriz ? 0.2 : 0.5;\n    offset = maxOffset - maxOffset / Math.sqrt(groupCount);\n  }\n\n  return hasUncenteredSeries\n    ? { startOffset: -1 * offset, endOffset: offset + 1 }\n    : { startOffset: -1 * offset, endOffset: offset };\n}\n","/**\n * @license\n * Copyright (c) 2008 %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { Dimension, MarkerShapes } from '../UNSAFE_visTypes/common';\nimport { Point } from '../PRIVATE_visSVGUtils';\nimport { Scale, Group, ChartSeriesData, ChartItemData } from '../UNSAFE_visTypes/chart';\nimport { ColorProps } from '../UNSAFE_interpolations/colors';\nimport { colorSchemeVars } from '@oracle/oraclejet-internal-theme-contract/themeContract.css';\nimport { rgb, rgba } from '../../UNSAFE_Theme';\nimport { getGroupCenterCoord } from '../../utils/PRIVATE_chartUtils/layoutUtils';\nimport { CommonLineType } from '#utils/UNSAFE_visTypes/common/common.types';\nimport { GroupLevelItem } from '#PRIVATE_Axis/groupAxis/hierarchicalUtils';\n\nconst LABEL_OFFSET = 15;\n\n/**\n * Returns the cumulative series for stacked chart.\n */\nexport function getCumulativeSeries<K extends string | number, D extends { value: number; id: K }>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: (number | undefined)[][] = Array(numSeries)\n    .fill(numGroups)\n    .map(() => {\n      return new Array(numGroups);\n    });\n  for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n    let prevValidTotal = undefined;\n    for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (\n        !item ||\n        hiddenIds?.has(item.id) ||\n        (isLog && item.value !== undefined && item.value <= 0)\n      ) {\n        series[seriesIndex][groupIndex] = undefined;\n        continue;\n      }\n\n      if (seriesIndex > 0 && prevValidTotal != null) {\n        const prev = series[seriesIndex - 1][groupIndex];\n        if (prev != null) {\n          series[seriesIndex][groupIndex] = prev + item.value;\n        } else {\n          series[seriesIndex][groupIndex] = prevValidTotal + item.value;\n        }\n      } else {\n        series[seriesIndex][groupIndex] = item.value;\n        prevValidTotal = item.value;\n      }\n    }\n  }\n  return series;\n}\n\n/**\n * Returns the series data.\n */\nexport function getSeriesData<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; value?: number; id: K }\n>(\n  numSeries: number,\n  numGroups: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  hiddenIds: Set<number | string>,\n  isLog: boolean\n) {\n  const series: (number[] | { x: number; y: number }[])[] = [];\n  for (let seriesIndex = 0; seriesIndex < numSeries; seriesIndex += 1) {\n    const currentSeries: number[] | { x: number; y: number }[] = [];\n    for (let groupIndex = 0; groupIndex < numGroups; groupIndex += 1) {\n      const item = getDataItem(seriesIndex, groupIndex);\n      if (\n        !item ||\n        hiddenIds?.has(item.id) ||\n        (isLog && item.value !== undefined && item.value <= 0)\n      ) {\n        continue;\n      }\n      currentSeries[groupIndex] =\n        item.value !== undefined ? item.value : { x: item.x! as number, y: item.y! }; // TODO : Need fix for x as number\n    }\n    series.push(currentSeries);\n  }\n  return series;\n}\n\n/**\n * Returns the markertype order.\n */\nexport function getMarkers(): MarkerShapes[] {\n  return ['square', 'circle', 'diamond', 'plus', 'triangleDown', 'triangleUp'];\n}\n\n/**\n * Returns the marker fill and stroke depending on the state.\n */\nexport function getMarkerFillAndStroke( // TODO : JET-62244 - Replace getMarkerFillAndStroke function with classes.\n  isMarkerDisplayed: boolean,\n  isSelectionEnabled: boolean,\n  isHovered: boolean,\n  isFocused: boolean,\n  isSelected: boolean,\n  seriesColor: ColorProps['color'],\n  itemColor?: ColorProps['color']\n) {\n  let fill;\n  let stroke;\n  let outerStroke;\n\n  if (isSelectionEnabled) {\n    if (isSelected) {\n      fill = itemColor || seriesColor;\n      outerStroke = rgb(colorSchemeVars.palette.neutral[130]);\n      stroke = rgb(colorSchemeVars.palette.neutral[0]);\n    } else if (isHovered || isFocused) {\n      stroke = itemColor || seriesColor;\n      fill = rgb(colorSchemeVars.palette.neutral[0]);\n    } else {\n      if (isMarkerDisplayed) {\n        fill = itemColor || seriesColor;\n        stroke = rgb(colorSchemeVars.palette.neutral[0]);\n      } else {\n        fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n        stroke = rgba(colorSchemeVars.palette.neutral[0], 0);\n      }\n    }\n  } else if (isMarkerDisplayed) {\n    fill = itemColor || seriesColor;\n    stroke = rgb(colorSchemeVars.palette.neutral[0]);\n  } else {\n    stroke = isFocused ? itemColor || seriesColor : rgba(colorSchemeVars.palette.neutral[0], 0);\n    fill = rgba(colorSchemeVars.palette.neutral[0], 0);\n  }\n  return { fill, stroke, outerStroke };\n}\n\n/**\n * Returns the coordinates of line or area based on orientation and size of the chart.\n */\nexport function getLineAreaSegments<\n  K extends string | number,\n  D extends { x?: number | string; y?: number; value?: number; id: K }\n>(\n  yScale: Scale,\n  xScale: Scale,\n  data: (number | undefined)[] | { x: number; y: number }[],\n  startIndex: number,\n  endIndex: number,\n  isLog: boolean,\n  groups: Group[],\n  seriesIndex: number,\n  getDataItem: (seriesIndex: number, groupIndex: number) => D | undefined,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency',\n  hasXYValues?: boolean\n): Point[][] {\n  const segments: Point[][] = [];\n  let currentPath: Point[] = [];\n\n  for (let groupIndex = startIndex; groupIndex < endIndex + 1; groupIndex += 1) {\n    let item, value, valueX, valueY;\n    if (hasXYValues) {\n      item = data[groupIndex] as { x: number; y: number };\n      valueX = item?.x;\n      valueY = item?.y;\n    } else {\n      item = data[groupIndex] as number;\n      value = item;\n    }\n    if (item == null || (isLog && value! <= 0 && valueX! <= 0 && valueY! <= 0)) {\n      segments.push(currentPath);\n      currentPath = [];\n      continue;\n    }\n    let x, y;\n\n    if (hasXYValues) {\n      x = xScale.transform(valueX!);\n      y = yScale.transform(valueY!);\n    } else {\n      x = getGroupCenterCoord<K, D>(\n        groups[groupIndex],\n        groupIndex,\n        xScale,\n        getDataItem(seriesIndex, groupIndex)!,\n        timeAxisType\n      );\n      y = yScale.transform(value!);\n    }\n    currentPath.push([x, y]);\n    if (groupIndex === endIndex) {\n      segments.push(currentPath);\n    }\n  }\n  return segments;\n}\n\n/**\n * Returns the markertype order.\n */\nexport function getLabelPosition(\n  labelPosition: 'belowMarker' | 'aboveMarker' | 'beforeMarker' | 'afterMarker' | 'center',\n  tx?: number,\n  ty?: number,\n  labelDims?: Dimension\n) {\n  if (labelPosition === 'aboveMarker') {\n    ty = ty! - LABEL_OFFSET;\n  } else if (labelPosition === 'belowMarker') {\n    ty = ty! + LABEL_OFFSET;\n  } else if (labelPosition === 'afterMarker') {\n    tx = tx! + labelDims?.width! / 2 + LABEL_OFFSET;\n  } else if (labelPosition === 'beforeMarker') {\n    tx = tx! - labelDims?.width! / 2 - LABEL_OFFSET;\n  }\n\n  return { x: tx, y: ty };\n}\n\n// JET-71237 optimize this function\nexport const findSeriesGroupIndexFromId = <K, D>(\n  series: ChartSeriesData<K, D>[],\n  id: K,\n  levelsArray: GroupLevelItem[][],\n  getDataItem?: (seriesIndex: number, groupIndex: number, groupPath: number[]) => D | undefined\n) => {\n  const leafGroups = levelsArray[levelsArray.length - 1];\n  for (let i = 0; i < series.length; i++) {\n    for (let j = 0; j < leafGroups.length; j++) {\n      const item = getDataItem && getDataItem(i, j, leafGroups[j].path);\n      if (item && (item as unknown as ChartItemData<K>).id === id) {\n        return {\n          seriesIndex: i,\n          groupIndex: j\n        };\n      }\n    }\n  }\n  return {\n    seriesIndex: 0,\n    groupIndex: 0\n  };\n};\nexport function getCmdPoints(\n  lineSegmentCoords: Point[],\n  lineType: string,\n  isHoriz: boolean,\n  isRtl?: boolean,\n  groupWidth?: number,\n  timeAxisType?: 'enabled' | 'skipGaps' | 'mixedFrequency',\n  isArea?: boolean\n) {\n  const pointsArrays = [];\n  let points: number[] = [];\n  pointsArrays.push(points);\n  const isCentered = lineType == 'centeredStepped' || lineType == 'centeredSegmented';\n  const isParallel = isCentered || lineType == 'stepped' || lineType == 'segmented';\n  const dir = isRtl && !isHoriz ? -1 : 1;\n  let coord, xCoord, yCoord, lastCoord, finalXCoord;\n  for (let i = 0; i < lineSegmentCoords.length; i++) {\n    if (lineSegmentCoords[i] == null) {\n      if (timeAxisType !== 'mixedFrequency') {\n        // Draw the last step\n        if (isParallel && lastCoord) {\n          finalXCoord = isCentered\n            ? lastCoord[0] + 0.5 * groupWidth! * dir\n            : lastCoord[0] + groupWidth! * dir;\n          pushCoords(points, finalXCoord, lastCoord[1], isHoriz);\n        }\n      }\n      // Start a new list of points, except in ADF and MAF mixed freq where we want to connect points across nulls.\n      points = [];\n      pointsArrays.push(points);\n      lastCoord = null;\n      continue;\n    }\n    coord = lineSegmentCoords[i];\n    xCoord = isCentered ? coord[0] - (groupWidth! / 2) * dir : coord[0];\n    yCoord = coord[1];\n\n    if (lastCoord && isParallel) {\n      pushCoords(points, xCoord, lastCoord[1], isHoriz); // draw the step\n    }\n    if (!isArea && (lineType === 'segmented' || lineType === 'centeredSegmented')) {\n      points = [];\n      pointsArrays.push(points);\n    }\n\n    pushCoords(points, xCoord, yCoord, isHoriz);\n    lastCoord = coord;\n  }\n  if (isParallel && lastCoord) {\n    finalXCoord = isCentered\n      ? lastCoord[0] + 0.5 * groupWidth! * dir\n      : lastCoord[0] + groupWidth! * dir;\n    pushCoords(points, finalXCoord, lastCoord[1], isHoriz);\n  }\n  return pointsArrays.join(' ');\n}\n\nexport function isNonCurvedLine(\n  lineType: CommonLineType | 'centeredStepped' | 'centeredSegmented'\n) {\n  return ['straight', 'stepped', 'segmented', 'centeredStepped', 'centeredSegmented'].includes(\n    lineType\n  );\n}\nexport function pushCoords(points: number[], x: number, y: number, isHoriz: boolean) {\n  if (isHoriz) {\n    points.push(Math.round(y * 10) / 10, Math.round(x * 10) / 10);\n  } else {\n    points.push(Math.round(x * 10) / 10, Math.round(y * 10) / 10);\n  }\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport {\n  ChartOverviewConfig,\n  Scale,\n  ViewportDetail\n} from '#utils/UNSAFE_visTypes/chart/chart.types';\n\nexport const TIME_AXIS_OVERVIEW_PANE_SIZE = 0.25;\nexport const OVERVIEW_PANE_SIZE = 0.2;\n\nexport function getOverviewHeight(\n  isTimeAxis: boolean,\n  chartHeight: number,\n  overview: ChartOverviewConfig | 'on' | 'off'\n) {\n  if (overview === 'off') {\n    return 0;\n  }\n\n  if (overview === 'on') {\n    return chartHeight * (isTimeAxis ? TIME_AXIS_OVERVIEW_PANE_SIZE : OVERVIEW_PANE_SIZE);\n  }\n  const isPercent = overview.height.includes('%');\n  const ratio = parseFloat(overview.height);\n  return isPercent ? (ratio / 100) * chartHeight : ratio;\n}\n\nexport function updateViewportFromOverview(\n  xAxisExtent: { min: number; max: number },\n  isRtl: boolean,\n  windowX: number,\n  windowWidth: number,\n  deltaX: number,\n  deltaWidth: number,\n  xScale: Scale,\n  onViewportChange?: (detail: ViewportDetail) => void\n) {\n  const start = windowX + deltaX;\n  const end = windowX + deltaX + windowWidth + deltaWidth;\n  const xMin = Math.max(xAxisExtent.min, xScale.invert(isRtl ? end : start));\n  const xMax = Math.min(xAxisExtent.max, xScale.invert(isRtl ? start : end));\n  onViewportChange?.({\n    xMin,\n    xMax\n  });\n}\n"],"names":["getAxesPosition","yAxis","y2Axis","isHoriz","isRtl","xAxisPosition","yAxisPosition","y2AxisPosition","position","getTickLabelAnchor","isGroupAxis","getAxisRange","availSpace","isTimeAxis","x","y","width","height","y2","x2","rangeStart","rangeEnd","getAxisMaxSize","axisSize","size","Math","max","min","undefined","getSafeSkips","axisStepWidth","tickLabelStyle","getTextDimensions","textDims","gaps","AXIS_DEFAULTS","labelGap","floor","defaultTitleProps","text","lines","lineProps","titleDim","dims","isTruncated","isRotated","getTitleProps","title","titleStyle","maxHeight","maxWidth","lineHeight","getTextInfo","positionMultilineText","getSectionDims","reverse","TIME_SECOND","TIME_MINUTE","TIME_HOUR","TIME_DAY","TIME_MONTH_MIN","TIME_YEAR_MIN","getTimeAxisProps","groups","viewportMin","viewportMax","averageInterval","xAxis","axisFontSize","axisMaxDim","fontSize","timeAxisType","titleProps","titleWidth","titleHeight","isTitleRendered","axisDim","titleGap","start","end","fill","tickLabel","style","color","textAnchor","valueToCoord","value","minValue","maxValue","startCoord","endCoord","ratio","length","minVal","timeToIndex","maxVal","getCoordFromValue","scale","transform","range","domain","invert","coord","index","endIndex","ceil","startIndex","startTime","getTime","id","endTime","indexToTime","getValueFromCoord","locale","getLocale","axisStep","step","gap","times","getLabelPos","getMixedFrequencyStep","i","date","Date","push","level1Formatter","Array","isArray","format","level2Formatter","granularity","calculateGranularity","initialInterval","intervals","Set","hasMissingValues","ret","intervalsCache","timeLength","previousDate","currentDate","currentInterval","calculateGranularInterval","add","minimumInterval","result","gcd","getGCDInterval","currentValue","previousValue","ratioOfCurrentIntervalToMinimumInterval","numMissingValues","fillIntervalInMilliseconds","round","j","treatMissingValues","label","formatAxisLabel","labelDims","totalWidth","labelHeight","getTickLabelGap","abs","isLabelRendered","isRendered","isLabel1Rendered","isLabel2Rendered","tickLabels","defaultLabelFormatter","averageGroupZ","separators","isGroupLabelRendered","labelInfos1","labelInfos2","label1Formatter","label2Formatter","coords1","coords2","prevDate","isOneLevel","time","label1","label2","generateLabels","numOfSafeSkips","getLabel1Dims","rangeValue","getTickLabelInfo","Infinity","indexAtLevel","didNotFit","getLabel2Dims","label1MaxWidth","label1MaxHeight","tickLabels1","getGroupAxisLabelsInfo","map","label2MaxWidth","label2MaxHeight","tickLabels2","skipLabelsGreedy","level2AxisDim","getAxisPos","updateLabelsDims","concat","forEach","axisValue","twoLabels","merge","timeRange","formatLabelWithFormatter","formatter","bOneLabel","isVert","formatDate","getMonth","getFullYear","getDate","getHours","formatTime","getMinutes","getSeconds","showDay","showMonth","showYear","options","year","month","day","toLocaleDateString","showMinute","showSecond","hour","minute","second","toLocaleTimeString","anchor","initialTimezoneOffset","getTimezoneOffset","setMonth","setHours","addOneYear","addOneMonth","timezoneCorrection","correction","setFullYear","uxTime","isoToNumber","dateString","getTimeAxisInfo","startOffset","endOffset","timeAxisRange","viewportEndGroup","viewportStartGroup","axisType","getAverageInterval","globalMin","globalMax","group","timeStamp","minAxisExtent","getMinTimeAxisExtent","ticks","minorTicks","prevTimezoneOffset","currentTimezoneOffset","currentTime","currentTimezoneOffsetCorrection","granularInterval","setTime","interval1","interval2","getDataExtent","series","getDataItem","xStartIndex","xEndIndex","isStacked","hiddenSet","hideAndShowBehavior","yDataMin","dataMin","yDataMax","dataMax","y2DataMin","y2DataMax","data","isLog","Number","MAX_VALUE","xMin","xMax","yMin","yMax","y2Min","y2Max","isY2AxisRendered","isYAxisRendered","hasWidthWeightValue","barWidths","idToDataMap","Map","groupIndex","posCumulValue","negCumulValue","chartSeries","seriesIndex","isAssociatedToY2","associatedYAxis","item","itemHasWidthWeightValue","widthWeight","itemHasValue","set","has","getDataMinMax","findNextGroupWithData","gIndex","sIndex","right","findPreviousGroupWithData","left","findNearestRegularAxisIndex","keyFunc","_","target","foundIndex","ll","rr","moveRight","newIndex","findGroup","prevIndex","nextIndex","DataAxisInfo","constructor","baselineScaling","numGroups","this","isZeroBaseline","setDataRange","setViewportRange","majorIncrement","actualToLinear","minorIncrement","minorStep","minMajorIncrement","minStep","majorTickCount","calcAxisExtents","getInfo","getTicks","getMinorTicks","getMinExtent","getScale","bind","setDefaultMin","scaleUnit","setDefaultMax","calcAxisStep","calcMajorMinorSteps","minorTickCount","spread","pow","log10","increment","testVal","firstDigit","getDefaultAxisStep","t","first2Digits","scaleFactor","linearToActual","getAxisViewport","ScaleLog","ScaleLinear","getFirstTick","getAxisExtent","firstTick","coords","linearValue","minorValue","getStep","scalesOrder","getLinearAxisValueFormatter","tickStep","absMax","findNearestLEScaleFactor","getPowerOfTen","getScaleFactor","decimalPlaces","scaleFactorDiff","tickStepPowerOfTen","getDecimalPlaces","defaultConverter","Intl","NumberFormat","notation","numberingSystem","useGrouping","formattedScale","formattedScaleParts","exec","numberConverterOptions","minimumFractionDigits","maximumFractionDigits","suffix","fsn","formattedScaledNumber","toString","val","power","getDataAxisProps","dataAxisInfo","dataAxis","isAxisRendered","formatYValue","groupWidth","linearFormatter","labels","maxLabelHeight","getDataAxisLabelsInfo","tick","getBarGapRatio","getBarWidth","widthWeightValue","defaultVal","dataItem","getWidthWeightVal","getLevelStartingGroup","levelsArray","levelIndex","xScale","noOfGroups","minCoord","labelCoord","getLabelCoord","getLevelEndingGroup","maxCoord","getLeafStartIndex","getLeafEndIndex","level","startValue","endValue","center","getLabelAt","numLevels","labelGroup","generateLevelsRecursive","groupsArray","path","p","slice","lastIndex","currentLeafIndex","generateLevels","getGroupFromPath","root","ids","g","name","groupCount","getGroupAxisProps","isDomainFlipped","groupAxis","isTestEnv","gapRatio","groupWidths","barGapRatio","barWidthSum","gapWidthSum","reduce","prev","cur","_barWidth","getGroupWidthRatios","VariableWidthScale","groupSeparators","groupLabels","lastRenderedLevel","levelsInfo","eIndex","labelsInView","maxLabelDim","isWrapAllowed","whiteSpace","getLabelInfo","allowTruncate","autoRotate","levelInfo","isLevelRendered","levelDims","axisDimensions","get","l","dim","textDim","separatorStartLevel","startLevel","info","numOfSkips","getSeparatorStartLevel","x1","y1","x3","x4","previousLevelSize","paths","offset","levelSize","prevLabelRendered","prevLabelEmpty","isEmptyLabel","isFirstLabel","isLastLabel","yCoord","labelWidth","spacing","drawLeftLine","SEPARATOR_GAP","getSeparatorPaths","filter","Boolean","getSpaces","xMaxDim","yMaxDim","y2MaxDim","isYLeft","isY2Left","isYBottom","isY2Bottom","xSpace","ySpace","y2Space","plotAreaSpace","getHorizSpace","getVertSpace","bottomOffset","topOffset","leftOffset","rightOffset","getOuterGaps","getGroupCenterCoord","pushCoords","points","yScale","getSeriesDataInfo","getYCoord","dataItemGaps","hiddenIds","y2Scale","candidates","neareastGroupIndex","groupCenter","isMixedFrequency","minIndex","dist","getNearestMixedFrequencyDataItem","yPosCummValue","yNegCummValue","y2PosCummValue","y2NegCummValue","minDistance","minDistanceDims2","minSeriesIndex","minSeriesCenter","dist2","itemY","dataWidth","seriesCenter","neareastItemId","isSeriesAssociatedToY2","leafGroups","needsOuterGap","numSeriesY","numSeriesY2","isY2","numSeries","itemsGaps","isVariableBarWidth","barWidth","seriesStart","yTotalWidth","s","getOffset","lineSegmentCoords","lineType","isArea","pointsArrays","isCentered","isParallel","dir","xCoord","lastCoord","finalXCoord","join","prevValidTotal","labelPosition","tx","ty","getStartAndEndAxesOffset","splitDualY","splitterPositin","hasXDataAxis","xAxisInfo","dataInfo","hasY2Axis","isXRendered","isYRendered","isY2Rendered","axisGap","xAxisFontStyle","yAxisFontStyle","y2AxisFontStyle","addAxisGaps","some","getDataItemWithGroupPath","timeAxis","itemX","num","getStartAndEndTime","isNaN","findIndex","getGroupAxisInfo","yAxisInfo","y2AxisInfo","yDim","cloneDimension","y2Dim","isXAxisHoriz","xAvailSpace","axisProps","xProps","newYSpace","newySpace","newY2Space","splitPosition","y2Width","y2Height","yWidth","yHeight","y2x","y2y","yx","getYY2","newYProps","newY2Props","yProps","y2Props","hasXYValues","segments","currentPath","valueX","valueY","isMarkerDisplayed","isSelectionEnabled","isHovered","isFocused","isSelected","seriesColor","itemColor","stroke","outerStroke","rgb","colorSchemeVars","palette","neutral","rgba","zoomAndScroll","overview","scrollDims","avSpace","scrollSize","overviewSize","chartHeight","isPercent","includes","parseFloat","getOverviewHeight","currentSeries","hasCenterdSeries","hasUncenteredSeries","hasBar","maxOffset","sqrt","newDims","xAxisExtent","windowX","windowWidth","deltaX","deltaWidth","onViewportChange"],"mappings":"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"}