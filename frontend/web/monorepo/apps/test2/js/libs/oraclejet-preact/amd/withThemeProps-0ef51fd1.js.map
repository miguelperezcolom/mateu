{"version":3,"file":"withThemeProps-0ef51fd1.js","sources":["../../src/hoc/UNSAFE_withThemeProps/withThemeProps.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { createRef, ComponentType, type RefObject } from 'preact';\nimport { useEffect, forwardRef } from 'preact/compat';\nimport { EnvironmentProvider } from '#UNSAFE_Environment';\nimport {\n  ThemeModifiers as Props,\n  DARK_CLASS,\n  INVERT_CLASS,\n  LIGHT_CLASS,\n  COLORSCHEME_DEPENDENT_CLASS,\n  SCALE_SM_CLASS,\n  SCALE_MD_CLASS,\n  SCALE_LG_CLASS,\n  SCALE_DEPENDENT_CLASS,\n  DENSITY_COMPACT_CLASS,\n  DENSITY_STANDARD_CLASS,\n  DENSITY_DEPENDENT_CLASS\n} from '#UNSAFE_Theme';\n\n/**\n * Higher Order Component that allows you to wrap an existing component with an EnvironmentProvider\n * containing the desired colorScheme, scale, and density context. The returned component contains all the props\n * of the wrapped component with the addition of the `colorScheme`, `scale`, and `density` props.\n *\n * This should be used when nesting an alternate colorScheme (ie dark palette sub-form within a global light\n * palette). You can use this HOC instead of manually applying colorScheme classnames to DOM elements. This also\n * eliminates the need to add additional DOM wrapper elements.\n */\nconst withThemeProps = <T extends object>(WrappedComponent: ComponentType<T>) => {\n  const displayName =\n    WrappedComponent.displayName || WrappedComponent.name || 'ComponentWithProvider';\n\n  const ComponentWithProvider = forwardRef(\n    ({ colorScheme, scale, density, ...props }: T & Partial<Props>, ref) => {\n      // if no ref is supplied, create one\n      const wrapRef = (ref || createRef()) as RefObject<unknown>;\n\n      useEffect(() => {\n        if (wrapRef.current) {\n          const { classList } = wrapRef.current as HTMLElement;\n          if (!classList) return;\n\n          // dynamically apply the appropriate colorscheme classname to ref element\n          if (colorScheme) {\n            const schemes = [\n              LIGHT_CLASS,\n              DARK_CLASS,\n              INVERT_CLASS,\n              COLORSCHEME_DEPENDENT_CLASS\n            ] as const;\n            schemes.map((current) => classList.remove(current));\n\n            if (colorScheme === 'dark') {\n              classList.add(DARK_CLASS);\n              classList.add(INVERT_CLASS);\n            } else {\n              classList.add(LIGHT_CLASS);\n            }\n            classList.add(COLORSCHEME_DEPENDENT_CLASS);\n          }\n\n          // dynamically apply the appropriate scale classname to ref element\n          if (scale) {\n            const scales = [SCALE_SM_CLASS, SCALE_MD_CLASS, SCALE_LG_CLASS, SCALE_DEPENDENT_CLASS];\n            scales.map((current) => classList.remove(current));\n            classList.add(\n              `${\n                scale === 'sm' ? SCALE_SM_CLASS : scale === 'md' ? SCALE_MD_CLASS : SCALE_LG_CLASS\n              }`\n            );\n            classList.add(SCALE_DEPENDENT_CLASS);\n          }\n\n          // dynamically apply the appropriate density classname to ref element\n          if (density) {\n            const densities = [\n              DENSITY_COMPACT_CLASS,\n              DENSITY_STANDARD_CLASS,\n              DENSITY_DEPENDENT_CLASS\n            ];\n            densities.map((current) => classList.remove(current));\n            classList.add(\n              `${density === 'compact' ? DENSITY_COMPACT_CLASS : DENSITY_STANDARD_CLASS}`\n            );\n            classList.add(DENSITY_DEPENDENT_CLASS);\n          }\n        }\n      }, [wrapRef, colorScheme, scale, density]);\n\n      // wrap component with new colorscheme context\n      return (\n        <EnvironmentProvider environment={{ colorScheme, scale, density }}>\n          <WrappedComponent {...(props as T)} ref={wrapRef} />\n        </EnvironmentProvider>\n      );\n    }\n  );\n\n  ComponentWithProvider.displayName = `withThemeProps(${displayName})`;\n\n  return ComponentWithProvider;\n};\n\nexport default withThemeProps;\n"],"names":["WrappedComponent","displayName","name","ComponentWithProvider","forwardRef","colorScheme","scale","density","props","ref","wrapRef","createRef","useEffect","current","classList","LIGHT_CLASS","DARK_CLASS","INVERT_CLASS","COLORSCHEME_DEPENDENT_CLASS","map","remove","add","SCALE_SM_CLASS","SCALE_MD_CLASS","SCALE_LG_CLASS","SCALE_DEPENDENT_CLASS","DENSITY_COMPACT_CLASS","DENSITY_STANDARD_CLASS","DENSITY_DEPENDENT_CLASS","_jsx","EnvironmentProvider","environment","children","jsx"],"mappings":"mMAmC0CA,IACxC,MAAMC,EACJD,EAAiBC,aAAeD,EAAiBE,MAAQ,wBAErDC,EAAwBC,cAC5B,EAAGC,cAAaC,QAAOC,aAAYC,GAA6BC,KAE9D,MAAMC,EAAWD,GAAOE,EAASA,YAuDjC,OArDAC,EAAAA,WAAU,KACR,GAAIF,EAAQG,QAAS,CACnB,MAAMC,UAAEA,GAAcJ,EAAQG,QAC9B,IAAKC,EAAW,OAGhB,GAAIT,EAAa,CACC,CACdU,EAAWA,YACXC,EAAUA,WACVC,EAAYA,aACZC,EAA2BA,6BAErBC,KAAKN,GAAYC,EAAUM,OAAOP,KAEtB,SAAhBR,GACFS,EAAUO,IAAIL,EAAAA,YACdF,EAAUO,IAAIJ,EAAAA,eAEdH,EAAUO,IAAIN,EAAAA,aAEhBD,EAAUO,IAAIH,EAAAA,4BACf,CAGD,GAAIZ,EAAO,CACM,CAACgB,EAAcA,eAAEC,EAAcA,eAAEC,EAAcA,eAAEC,EAAqBA,uBAC9EN,KAAKN,GAAYC,EAAUM,OAAOP,KACzCC,EAAUO,IACR,GACY,OAAVf,EAAiBgB,EAAAA,eAA2B,OAAVhB,EAAiBiB,EAAAA,eAAiBC,EACtEA,kBAEFV,EAAUO,IAAII,EAAAA,sBACf,CAGD,GAAIlB,EAAS,CACO,CAChBmB,EAAqBA,sBACrBC,EAAsBA,uBACtBC,EAAuBA,yBAEfT,KAAKN,GAAYC,EAAUM,OAAOP,KAC5CC,EAAUO,IACR,GAAe,YAAZd,EAAwBmB,wBAAwBC,EAAAA,0BAErDb,EAAUO,IAAIO,EAAAA,wBACf,CACF,IACA,CAAClB,EAASL,EAAaC,EAAOC,IAI/BsB,EAAAA,IAACC,EAAAA,oBAAoB,CAAAC,YAAa,CAAE1B,cAAaC,QAAOC,WACtDyB,SAAAH,EAAAI,IAACjC,EAAgB,IAAMQ,EAAaC,IAAKC,KAE3C,IAMN,OAFAP,EAAsBF,YAAc,kBAAkBA,KAE/CE,CAAqB"}