{"version":3,"file":"useLengthFilter-c05fd679.js","sources":["../../src/hooks/UNSAFE_useLengthFilter/useLengthFilter.ts"],"sourcesContent":["import { ComponentProps } from 'preact';\nimport { useCallback, useEffect, useState } from 'preact/hooks';\nimport { TextFieldInput } from '../../UNSAFE_TextField';\nimport { calcLength, CountUnit as _CountUnit, filter } from '../../utils/UNSAFE_lengthFilter';\n\nexport type CountUnit = _CountUnit;\n\ntype PickedPropsFromTextFieldInput = Pick<\n  ComponentProps<typeof TextFieldInput>,\n  'onCommit' | 'onInput' | 'value'\n>;\ntype UseLengthFilterProps = PickedPropsFromTextFieldInput & {\n  maxLength?: number;\n  maxLengthUnit?: CountUnit;\n};\n\n/**\n * A custom hook that applies the length filter to text field input\n * @param param0 The props for the useLengthFilter hook\n * @returns The filtered event handlers\n */\nexport function useLengthFilter({\n  maxLength,\n  maxLengthUnit,\n  onCommit,\n  onInput,\n  value\n}: UseLengthFilterProps) {\n  const hasNoValue = value === undefined;\n  const [isMaxLengthExceeded, setMaxLengthExceeded] = useState(false);\n  const parse = useCallback(\n    (value: string) => filter(value, maxLength, maxLengthUnit),\n    [maxLength, maxLengthUnit]\n  );\n  // Reapply maxLength filter when the value is changed\n  useEffect(() => {\n    if (hasNoValue) {\n      return;\n    }\n\n    const filteredValue = parse(value);\n    if (filteredValue !== value) {\n      onInput?.({ previousValue: value, value: filteredValue });\n      onCommit?.({ previousValue: value, value: filteredValue });\n\n      // Value is filtered, means that the max length is exceeded\n      setMaxLengthExceeded(true);\n    } else {\n      // Value is not filtered, means that the max length is not exceeded\n      setMaxLengthExceeded(false);\n    }\n  }, [value, onCommit, onInput, parse, hasNoValue]);\n\n  const onFilteredInput = useCallback(\n    (...args: Parameters<Exclude<typeof onInput, undefined>>) => {\n      const { previousValue, value } = args[0];\n      const filteredValue = parse(value ?? '');\n\n      // Call the onInput event only when the value is changed\n      if (previousValue !== filteredValue) {\n        onInput?.({ ...args[0], value: filteredValue });\n        // value is not filtered, so the max length is not exceeded\n        setMaxLengthExceeded(false);\n      } else {\n        // value is changed but then filtered to previous value\n        // meaning that the max length was exceeded\n        setMaxLengthExceeded(true);\n      }\n    },\n    [onInput, parse]\n  );\n\n  const valueLength = hasNoValue ? undefined : calcLength(value, maxLengthUnit);\n  // this is set to true when the parsed value length is exactly the maxlength\n  const isMaxLengthReached = hasNoValue ? undefined : maxLength === valueLength;\n\n  return {\n    valueLength,\n    isMaxLengthReached,\n    isMaxLengthExceeded,\n    onFilteredInput\n  };\n}\n"],"names":["maxLength","maxLengthUnit","onCommit","onInput","value","hasNoValue","undefined","isMaxLengthExceeded","setMaxLengthExceeded","useState","parse","useCallback","filter","useEffect","filteredValue","previousValue","onFilteredInput","args","valueLength","calcLength","isMaxLengthReached"],"mappings":"4GAqBgB,UAAgBA,UAC9BA,EAASC,cACTA,EAAaC,SACbA,EAAQC,QACRA,EAAOC,MACPA,IAEA,MAAMC,OAAuBC,IAAVF,GACZG,EAAqBC,GAAwBC,EAAQA,UAAC,GACvDC,EAAQC,EAAAA,aACXP,GAAkBQ,EAAAA,OAAOR,EAAOJ,EAAWC,IAC5C,CAACD,EAAWC,IAGdY,EAAAA,WAAU,KACR,GAAIR,EACF,OAGF,MAAMS,EAAgBJ,EAAMN,GACxBU,IAAkBV,GACpBD,IAAU,CAAEY,cAAeX,EAAOA,MAAOU,IACzCZ,IAAW,CAAEa,cAAeX,EAAOA,MAAOU,IAG1CN,GAAqB,IAGrBA,GAAqB,EACtB,GACA,CAACJ,EAAOF,EAAUC,EAASO,EAAOL,IAErC,MAAMW,EAAkBL,EAAAA,aACtB,IAAIM,KACF,MAAMF,cAAEA,EAAaX,MAAEA,GAAUa,EAAK,GAChCH,EAAgBJ,EAAMN,GAAS,IAGjCW,IAAkBD,GACpBX,IAAU,IAAKc,EAAK,GAAIb,MAAOU,IAE/BN,GAAqB,IAIrBA,GAAqB,EACtB,GAEH,CAACL,EAASO,IAGNQ,EAAcb,OAAaC,EAAYa,EAAAA,WAAWf,EAAOH,GAI/D,MAAO,CACLiB,cACAE,mBAJyBf,OAAaC,EAAYN,IAAckB,EAKhEX,sBACAS,kBAEJ"}