{"version":3,"file":"useAnimationStatus-4b135f52.js","sources":["../../src/hooks/PRIVATE_useAnimationStatus/useAnimationStatus.ts"],"sourcesContent":["import { useRef, useCallback, useState, useEffect } from 'preact/hooks';\nimport { useAnimation, UseAnimationConfig } from '../UNSAFE_useAnimation';\nimport type { RefObject } from 'preact';\n\ntype AnimationCallback = UseAnimationConfig<AnimationStatus, HTMLElement>['onAnimationEnd'];\nexport type AnimationStates = UseAnimationConfig<AnimationStatus, HTMLElement>['animationStates'];\n\n/**\n * Animation Status\n * 'unmounted' indicates the element is unmounted from the screen. No transitions should be applied.\n * 'initial' indicates the element is mounted, but stays hidden and is in the initial state\n * 'opening' indicates the element is in the opening state, visible and begins transitioning in.\n * 'closing' indicates the element is in the closing state, visible and begins transitioning out\n * The animation state lifecycle is as follows: 'unmounted' => 'initial' => 'opening' => 'closing' => 'unmounted'\n */\nexport type AnimationStatus = 'unmounted' | 'initial' | 'opening' | 'closing';\n\n/**\n * The AnimationStatus hook properties\n */\nexport type AnimationStatusProps = {\n  /**\n   * isOpen property indicates that animation should change to status opening\n   */\n  isOpen: boolean;\n  /**\n   * If isAnimatedOnMount true, the animation should start on mount\n   */\n  isAnimatedOnMount: boolean;\n  /**\n   * animationStates is the configuration of the animations, how the element should be animated\n   */\n  animationStates: AnimationStates;\n  /**\n   * The callback called after animation is finished\n   * @returns\n   */\n  onTransitionEnd?: (isOpen: boolean) => void;\n};\n\nexport function useAnimationStatus<E extends HTMLElement>({\n  isOpen,\n  isAnimatedOnMount,\n  animationStates,\n  onTransitionEnd\n}: AnimationStatusProps): {\n  /**\n   * status is the animation status\n   */\n  status: AnimationStatus;\n  /**\n   * animationElementRef is the reference of the element that is animated\n   */\n  animationElementRef: RefObject<E | null>;\n  /**\n   * setAnimationElementRef is a callback that should be used to set up element for the animation\n   * @param node an element that animation should be applied to\n   * @returns\n   */\n  setAnimationElementRef: (node: E | null) => void;\n} {\n  const [status, _setStatus] = useState<AnimationStatus>(isOpen ? 'initial' : 'unmounted');\n  const _status = useRef<AnimationStatus>(isOpen ? 'initial' : 'unmounted');\n  const setStatus = (s: AnimationStatus) => {\n    _status.current = s;\n    _setStatus(s);\n  };\n  const animationElementRef = useRef<E | null>(null);\n  const [animationElement, _setAnimationElement] = useState<E | null>(null);\n\n  const { nodeRef } = useAnimation<AnimationStatus, HTMLElement>(status, {\n    animationStates,\n    isAnimatedOnMount: isAnimatedOnMount,\n    onAnimationEnd: useCallback<NonNullable<AnimationCallback>>(() => {\n      if (status === 'opening') {\n        onTransitionEnd?.(true);\n      } else if (!isOpen) {\n        Object.assign(animationElement!.style, {\n          visibility: null\n        });\n        setStatus('unmounted');\n        onTransitionEnd?.(false);\n      }\n    }, [status, isOpen, onTransitionEnd, animationElement])\n  });\n\n  // We need setRef callback in order to set up visibility and node for the animation\n  // before it gets rendered in the next render cycle, i.e. when status === 'initial' the component is rendered,\n  // after component is rendered but is not yet painted references are applied, here we have the chance to set visibility to hidden\n  // and set up animation node.\n  const setAnimationRef = useCallback(\n    (node: E | null) => {\n      if (animationElementRef.current !== node) {\n        animationElementRef.current = node;\n        // Component will be visually hidden when status is 'initial' to avoid flickering.\n        // Flickering happens because it gets rendered before animation happens\n        // in next render cycle\n        if (node != null && status == 'initial') {\n          Object.assign(node.style, {\n            visibility: 'hidden'\n          });\n        }\n        nodeRef(node);\n        _setAnimationElement(node);\n      }\n    },\n    [status, nodeRef]\n  );\n\n  useEffect(() => {\n    // 1. Ignore status update on initial render\n    if (status === 'unmounted' && !isOpen) {\n      return;\n    }\n    // 2. Mount visually hidden component\n    // Component gets mounted\n    if (status === 'unmounted' && isOpen) {\n      setStatus('initial');\n      return;\n    }\n\n    // 3. Setup animation\n    // Component has been mounted.\n    // We will kick out animation as node is already present in DOM.\n    if (status === 'initial' && isOpen) {\n      setStatus('opening');\n      if (!animationStates.opening) {\n        onTransitionEnd?.(true);\n      }\n      return;\n    }\n\n    // 4. Unhide component.\n    if (status === 'opening' && isOpen) {\n      if (animationElement) {\n        Object.assign(animationElement.style, {\n          visibility: 'visible'\n        });\n      }\n      return;\n    }\n\n    // 5. Closing\n    if (!isOpen) {\n      if (!animationStates.closing) {\n        if (animationElement) {\n          Object.assign(animationElement.style, {\n            visibility: null\n          });\n        }\n        setStatus('unmounted');\n        onTransitionEnd?.(false);\n      } else {\n        if (_status.current !== 'unmounted') {\n          setStatus('closing');\n        }\n      }\n    }\n  }, [\n    isOpen,\n    animationElement,\n    status,\n    animationStates.opening,\n    animationStates.closing,\n    onTransitionEnd\n  ]);\n\n  return {\n    status,\n    animationElementRef,\n    setAnimationElementRef: setAnimationRef\n  };\n}\n"],"names":["isOpen","isAnimatedOnMount","animationStates","onTransitionEnd","status","_setStatus","useState","_status","useRef","setStatus","s","current","animationElementRef","animationElement","_setAnimationElement","nodeRef","useAnimation","onAnimationEnd","useCallback","Object","assign","style","visibility","setAnimationRef","node","useEffect","opening","closing","setAnimationElementRef"],"mappings":"+GAwCM,UAAoDA,OACxDA,EAAMC,kBACNA,EAAiBC,gBACjBA,EAAeC,gBACfA,IAiBA,MAAOC,EAAQC,GAAcC,EAAQA,SAAkBN,EAAS,UAAY,aACtEO,EAAUC,EAAMA,OAAkBR,EAAS,UAAY,aACvDS,EAAaC,IACjBH,EAAQI,QAAUD,EAClBL,EAAWK,EAAE,EAETE,EAAsBJ,SAAiB,OACtCK,EAAkBC,GAAwBR,EAAQA,SAAW,OAE9DS,QAAEA,GAAYC,EAAYA,aAA+BZ,EAAQ,CACrEF,kBACAD,kBAAmBA,EACnBgB,eAAgBC,EAAWA,aAAiC,KAC3C,YAAXd,EACFD,KAAkB,GACRH,IACVmB,OAAOC,OAAOP,EAAkBQ,MAAO,CACrCC,WAAY,OAEdb,EAAU,aACVN,KAAkB,GACnB,GACA,CAACC,EAAQJ,EAAQG,EAAiBU,MAOjCU,EAAkBL,eACrBM,IACKZ,EAAoBD,UAAYa,IAClCZ,EAAoBD,QAAUa,EAIlB,MAARA,GAA0B,WAAVpB,GAClBe,OAAOC,OAAOI,EAAKH,MAAO,CACxBC,WAAY,WAGhBP,EAAQS,GACRV,EAAqBU,GACtB,GAEH,CAACpB,EAAQW,IA6DX,OA1DAU,EAAAA,WAAU,KAER,GAAe,cAAXrB,GAA2BJ,EAA/B,CAKA,GAAe,cAAXI,IAA0BJ,EAQ9B,MAAe,YAAXI,GAAwBJ,GAC1BS,EAAU,gBACLP,EAAgBwB,SACnBvB,KAAkB,UAMP,YAAXC,GAAwBJ,EACtBa,GACFM,OAAOC,OAAOP,EAAiBQ,MAAO,CACpCC,WAAY,YAObtB,IACEE,EAAgByB,QASK,cAApBpB,EAAQI,SACVF,EAAU,YATRI,GACFM,OAAOC,OAAOP,EAAiBQ,MAAO,CACpCC,WAAY,OAGhBb,EAAU,aACVN,KAAkB,MAlCpBM,EAAU,UAJX,CA4CA,GACA,CACDT,EACAa,EACAT,EACAF,EAAgBwB,QAChBxB,EAAgByB,QAChBxB,IAGK,CACLC,SACAQ,sBACAgB,uBAAwBL,EAE5B"}