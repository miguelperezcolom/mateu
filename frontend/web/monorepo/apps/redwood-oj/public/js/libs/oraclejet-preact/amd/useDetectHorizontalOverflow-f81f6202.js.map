{"version":3,"file":"useDetectHorizontalOverflow-f81f6202.js","sources":["../../src/hooks/PRIVATE_useDetectHorizontalOverflow/useDetectHorizontalOverflow.ts"],"sourcesContent":["import { RefObject } from 'preact';\nimport { useState, useLayoutEffect, useRef, StateUpdater, useCallback } from 'preact/hooks';\nimport { useResizeObserver } from '../../hooks/UNSAFE_useResizeObserver';\nimport { Size } from '../../utils/UNSAFE_size';\nimport { getTabWidths } from '../../utils/PRIVATE_tabBarUtils';\nimport type { TrailingContentInfo } from '../../utils/PRIVATE_tabBarUtils';\n\ntype TabDimensions<K extends string | number> = {\n  key: K;\n  maxWidth: number;\n  nonTextWidth?: number;\n  needsTruncation?: boolean;\n  cumulativeWidth?: number;\n};\n\n//The minimum width of the overflowtabbaritem, it can be rendered with width greater than this based on available width\nconst MORE_ITEM_WIDTH = 48;\nconst LABEL_MIN_WIDTH = 96;\nconst TAB_BORDER = 6;\n//This is the minWidth a tab will have if it has only a label.\nconst TAB_MIN_WIDTH = LABEL_MIN_WIDTH + TAB_BORDER;\n\nexport type useDetectOverflowProps<K extends string | number> = {\n  rootRef: RefObject<HTMLDivElement>;\n  keysArray: (K | undefined)[];\n  isTruncationDisabled?: boolean;\n};\n\n/**\n * Implements overflow detection and calculation\n */\nexport function useDetectHorizontalOverflow<K extends string | number>({\n  rootRef,\n  keysArray,\n  isTruncationDisabled = true\n}: useDetectOverflowProps<K>) {\n  const [visibleItemKeys, setVisibleItemKeys] = useState<(K | undefined)[]>();\n  const [overflowItemKeys, setOverflowingItemKeys] = useState<(K | undefined)[]>();\n  const trailingContentWidths = useRef(new Map<K, TrailingContentInfo>());\n  const [tabMaxWidth, setTabMaxWidth] = useState<Map<K, Size>>();\n  // This state var is to only re-trigger the layout effect. Using it locally will not give the latest updated value hence we use current suffix vars\n  const [tabBarWidth, setTabBarWidth] = useState<number>(0);\n  const isAllItemsTruncatedMax = useRef<boolean>(false);\n  const isAllItemsTruncatedFinal = useRef<boolean>(false);\n  const tabDimensions = useRef<TabDimensions<K>[]>();\n\n  useLayoutEffect(() => {\n    // Store locally to avoid calling rootRef everytime within layouteffect\n    const tabBarWidthCurrent = rootRef?.current?.clientWidth;\n    const tabBarScrollWidthCurrent = rootRef?.current?.scrollWidth;\n    if (\n      rootRef.current &&\n      keysArray &&\n      keysArray.length > 0 &&\n      tabBarWidthCurrent &&\n      tabBarWidthCurrent > 0\n    ) {\n      //Set tabBarWidth if not the current value\n      if (tabBarWidth !== tabBarWidthCurrent) {\n        setTabBarWidth(tabBarWidthCurrent);\n      }\n\n      if (tabMaxWidth === undefined) {\n        const isOverflow = tabBarWidthCurrent > 0 && tabBarWidthCurrent < tabBarScrollWidthCurrent!;\n\n        //If there is no overflow maxWidth should be its prevState, prevState may also be undefined if truncation is disabled.\n        if (!isOverflow) {\n          setTabMaxWidth((prevState) => {\n            return prevState;\n          });\n        } else {\n          //We need to calculate maxWidth only if truncation threshold limit is not reached\n          if (!isAllItemsTruncatedMax.current) {\n            const tabWidths = getTabWidths(\n              rootRef.current,\n              trailingContentWidths,\n              isTruncationDisabled,\n              tabBarWidthCurrent,\n              isAllItemsTruncatedMax?.current,\n              keysArray as K[]\n            );\n            //If all items have reached max treshold of truncation then we set it to true\n            if (tabWidths.every((item) => item.hasReachedLimit)) {\n              isAllItemsTruncatedMax.current = true;\n            }\n            tabDimensions.current = tabWidths as any;\n          }\n          //If all items have reached max treshold of truncation then we do not have update tabDimensions are maxWidth cannot go lesser than 96px.\n          else {\n            tabDimensions.current = tabDimensions.current?.map((item) => ({\n              ...item\n            }));\n          }\n        }\n\n        //Set calculated maxWidths\n        if (!isTruncationDisabled) {\n          const tabMaxWidthMap = new Map(\n            tabDimensions.current?.map((tab) => [tab.key, (tab.maxWidth + 'px') as Size])\n          );\n          setTabMaxWidth(tabMaxWidthMap);\n        }\n        //Overflow calculation\n        if (tabBarWidthCurrent < tabBarScrollWidthCurrent!) {\n          const arr = tabDimensions.current?.map((item) => item.cumulativeWidth) as number[];\n          const lastIndex = arr.length - 1;\n          //In addition to scrollWidth we check if the cumulative width of last item is greater than rootRef clientwidth\n          if (arr && tabBarWidthCurrent < arr[lastIndex]) {\n            const { closestEntry, closestIndex } = searchClosest(arr, tabBarWidthCurrent);\n            // Check for not null, because even for '0' value of closestIndex we want to slice in such cases only overflow item will be rendered\n            if (closestEntry && closestIndex != null) {\n              // Closest index refers to the index of the last item that would be visible.\n              // While splicing we need to include it however if we check for closestIndex < lastIndex alone then closestIndex + 1 will be greater than the last item index so we check for one less.\n              const lastVisibleItemIndex =\n                closestIndex < lastIndex - 1 ? closestIndex + 1 : closestIndex;\n              setVisibleItemKeys(keysArray.slice(0, lastVisibleItemIndex));\n              setOverflowingItemKeys(keysArray?.slice(lastVisibleItemIndex));\n              //Once OverflowTabBarItem is rendered, i.e overflowItemKeys move into overflow menu then space is available, which can be re-dsitributed to truncated visible items. We also check if these visible items have already gone through this calculation otherwise we skip it to avoid infinite loop.\n              if (closestIndex > 0 && !isAllItemsTruncatedFinal.current && !isTruncationDisabled) {\n                const tabWidthsAfterOverflow = getTabWidths(\n                  rootRef.current,\n                  trailingContentWidths,\n                  isTruncationDisabled,\n                  tabBarWidthCurrent,\n                  isAllItemsTruncatedMax?.current\n                );\n                const tabMaxWidthMapAfterOverflow = new Map(\n                  tabWidthsAfterOverflow.map((tab) => [tab.key, (tab.maxWidth + 'px') as Size])\n                );\n                //Flag to indicate that final truncation calculation has occured\n                isAllItemsTruncatedFinal.current = true;\n                setTabMaxWidth(tabMaxWidthMapAfterOverflow);\n              }\n            }\n          }\n        }\n      }\n    }\n  }, [keysArray, rootRef, tabBarWidth, tabMaxWidth, isTruncationDisabled]);\n\n  const updateTabBarWidth = useCallback(\n    (entry: { contentRect: { width: StateUpdater<number> } }) => {\n      const rectWidth = Math.ceil(entry.contentRect.width as number);\n      // Sometimes entry.contentRect.width maybe a decimal value so we need to get absolute value\n      if (Math.abs(tabBarWidth - (entry.contentRect.width as number)) > 1) {\n        setTabBarWidth(entry.contentRect.width);\n        if (tabMaxWidth !== undefined && !isAllItemsTruncatedMax.current) {\n          setTabMaxWidth(undefined);\n        }\n        //Once there is change in the container width and there is no overflow we render all items as visible.\n        if (rectWidth >= rootRef.current?.scrollWidth!) {\n          setVisibleItemKeys(keysArray);\n          setOverflowingItemKeys([]);\n        }\n        isAllItemsTruncatedFinal.current = false;\n      }\n    },\n    [tabBarWidth, tabMaxWidth, rootRef, keysArray]\n  );\n\n  useResizeObserver(rootRef, updateTabBarWidth);\n\n  return shouldRenderAllTabs(visibleItemKeys, overflowItemKeys, keysArray)\n    ? {\n        visibleItemKeys: keysArray,\n        overflowItemKeys,\n        maxWidths: tabMaxWidth\n      }\n    : {\n        visibleItemKeys,\n        overflowItemKeys,\n        maxWidths: tabMaxWidth\n      };\n}\n\n//If the overflow + visible keys or their quantity are not the same as keysArray then we first render all the keys as visible\nconst shouldRenderAllTabs = <K extends string | number>(\n  visibleItemKeys: (K | undefined)[] | undefined,\n  overflowItemKeys: (K | undefined)[] | undefined,\n  keysArray: (K | undefined)[]\n) => {\n  if (visibleItemKeys == null) return true;\n  else if (visibleItemKeys && overflowItemKeys && keysArray) {\n    const combinedArray = [...visibleItemKeys, ...overflowItemKeys];\n    const isNotEqual =\n      combinedArray.length !== keysArray.length ||\n      JSON.stringify(keysArray) !== JSON.stringify(combinedArray);\n    return isNotEqual;\n  } else return false;\n};\n\n//Searches for a value closest and smaller than search value from the cumulative array\nconst searchClosest = (\n  arr: number[] | undefined,\n  searchValue: number | undefined | null\n): { closestEntry: number | null; closestIndex: number | null } => {\n  {\n    if (arr != null && searchValue != null) {\n      let left = 0;\n      let right = arr.length - 1;\n      let closestEntry: number | null = null;\n      let closestIndex: number | null = null;\n      while (left <= right && left < arr.length && right > -1) {\n        const mid = Math.floor((left + right) / 2);\n        const midEntry = arr[mid];\n        if (midEntry === searchValue) {\n          return { closestEntry: midEntry!, closestIndex: mid! };\n        } else if (midEntry < searchValue) {\n          closestEntry = midEntry;\n          closestIndex = mid;\n          left = mid + 1;\n        } else {\n          right = mid - 1;\n        }\n        //If the searchValue is greater than closest entry and their difference is greater more item width then we have space to fit more item. Otherwise we return the index with the closest and small value when compared to searchvalue\n        if (closestEntry && searchValue > closestEntry) {\n          //NOTE: Do not update closestEntry to midEntry here because value from const midEntry = arr[mid], midEntry maybe greater than searchValue and below it may end up updating closestIndex to mid +1 due to abs check\n          //Sometimes closest entry may be much smaller than searchvalue so in such cases we maybe able to accomodate more items. The difference between searchValue and closestEntry should be greater than the minWidth needed for any item so that it can be rendered. If the difference is lesser than item min width we then check if space is available to render overflowitem alone else we reduce the closestIndex.\n          closestIndex =\n            Math.abs(searchValue - closestEntry) > TAB_MIN_WIDTH && mid + 1 <= arr.length - 2\n              ? mid + 1\n              : Math.abs(searchValue - closestEntry) > MORE_ITEM_WIDTH\n              ? mid\n              : mid - 1 >= 0\n              ? mid - 1\n              : 0;\n        }\n        //If the searchValue is lesser than closestEntry we return a value lesser than mid, this happens when all the values in the array are lesser than searchValue, i.e screensize is extremely small\n        else {\n          closestIndex = mid - 1 >= 0 ? mid - 1 : 0;\n        }\n      }\n      return { closestEntry: closestEntry!, closestIndex: closestIndex! };\n    } else return { closestEntry: null, closestIndex: null };\n  }\n};\n"],"names":["shouldRenderAllTabs","visibleItemKeys","overflowItemKeys","keysArray","combinedArray","length","JSON","stringify","searchClosest","arr","searchValue","left","right","closestEntry","closestIndex","mid","Math","floor","midEntry","abs","LABEL_MIN_WIDTH","rootRef","isTruncationDisabled","setVisibleItemKeys","useState","setOverflowingItemKeys","trailingContentWidths","useRef","Map","tabMaxWidth","setTabMaxWidth","tabBarWidth","setTabBarWidth","isAllItemsTruncatedMax","isAllItemsTruncatedFinal","tabDimensions","useLayoutEffect","tabBarWidthCurrent","current","clientWidth","tabBarScrollWidthCurrent","scrollWidth","undefined","map","item","tabWidths","getTabWidths","every","hasReachedLimit","prevState","tabMaxWidthMap","tab","key","maxWidth","cumulativeWidth","lastIndex","lastVisibleItemIndex","slice","tabWidthsAfterOverflow","tabMaxWidthMapAfterOverflow","updateTabBarWidth","useCallback","entry","rectWidth","ceil","contentRect","width","useResizeObserver","maxWidths"],"mappings":"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"}