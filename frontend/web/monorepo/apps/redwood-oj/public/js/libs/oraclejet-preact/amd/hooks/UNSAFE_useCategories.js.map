{"version":3,"file":"UNSAFE_useCategories.js","sources":["../../../src/hooks/UNSAFE_useCategories/useCategories.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useMemo, useRef } from 'preact/hooks';\nimport { isEqual } from '../../utils/UNSAFE_visUtils/eventsUtils';\n\nexport type CategoriesProps<K extends number | string> = {\n  items: { item: { id: K } }[];\n  getCategoriesFromItem: (item: { id: K }) => string[];\n  initialCategories?: string[];\n  matchCriteria?: 'any' | 'all';\n  replace?: boolean;\n  onCategoriesChange?: (categories: string[]) => void;\n};\n\n/**\n * Toggles the existing categories/id with updated categories/id.\n * @param original The set of original ids/categories\n * @param updated The set of updated ids/categories\n * @returns\n */\nconst toggle = <T>(original: Set<T>, updated: Set<T>) => {\n  const matches = new Set(original);\n  updated.forEach((item) => {\n    if (!original.has(item)) {\n      matches.add(item);\n    } else {\n      matches.delete(item);\n    }\n  });\n  return matches;\n};\n\n/**\n * Creates initial map of category and data items.\n * @param items Data item objects. If 'categories' field is not present, id will be assumed to be default category.\n */\nfunction getCategoryMap<K extends number | string>(\n  items: { item: { id: K } }[],\n  getCategory: (item: { id: K }) => string[]\n) {\n  const categoryToItem: Map<string, Set<K>> = new Map();\n  const itemToCategory: Map<K, Set<string>> = new Map();\n  items.forEach((item: any) => {\n    const id: K = item.id;\n    const categories: string[] = getCategory(item);\n    itemToCategory.set(id, new Set(categories));\n    categories.forEach((category) => {\n      if (categoryToItem.has(category)) {\n        categoryToItem.get(category)?.add(id);\n      } else {\n        categoryToItem.set(category, new Set([id]));\n      }\n    });\n  });\n  return { categoryToItem, itemToCategory };\n}\n\n/**\n * Returns the items for a given categories.\n * @param categoryToItemMap Map of categories to Item.\n * @param matchCriteria Whether to match any or all categories.\n * @param categories categories\n * @returns\n */\nfunction getItemsFromCategories<K>(\n  categoryToItemMap: Map<string, Set<K>>,\n  matchCriteria: 'any' | 'all' = 'any',\n  categories: Set<string>\n) {\n  return [...categories].reduce((acc: Set<K>, cur: string, index: number) => {\n    const curItems = categoryToItemMap.get(cur)!;\n    if (matchCriteria === 'any') {\n      return curItems ? new Set([...acc, ...curItems]) : acc;\n    }\n\n    if (!index) return curItems;\n    return new Set([...acc].filter((item) => curItems.has(item)));\n  }, new Set<K>());\n}\n\n/**\n * A hook that helps to manage getting ids that match specific categories or criterias in a set of data. It also handles partial versus exact matching.\n *\n * @param items The array of items.\n * @param getCategoriesFromItem The function that returns the categories array for given item.\n * @param initialCategories The initial categories.\n * @param matchCriteria  The matching condition for the categories.\n * By default, matchCriteria is 'all' and only items whose categories match all of the values specified in the categories array will be matched.\n * If matchCriteria is 'any', then items that match at least one of the categories values will be matched.\n * @param replace Whether the new categories should completely replace the old categories (for highlighting) or just toggle previous categories (for hideAndShow)\n * @param onCategoriesChange The callback to invoke when categories change.\n * @returns ids An array of item ids (K[]) that match the current selected categories, according to the 'matchCriteria'. This is the result of filtering items based on the categories that have been selected.\n * @returns updateCategories The function to update the selected categories/items. It modifies the current set of categories either by toggling (replace: false) or replacing (replace: true), and updates the items that match the new categories.\n */\nexport const useCategories = <K extends string | number>({\n  items,\n  getCategoriesFromItem,\n  initialCategories = [],\n  matchCriteria = 'all',\n  replace = true,\n  onCategoriesChange\n}: CategoriesProps<K>) => {\n  const categoryMap = useMemo(\n    () => getCategoryMap<K>(items, getCategoriesFromItem),\n    [items, getCategoriesFromItem]\n  );\n\n  const initialCategoriesSet = new Set(initialCategories);\n  const newIds = getItemsFromCategories(\n    categoryMap.categoryToItem,\n    matchCriteria,\n    initialCategoriesSet\n  );\n\n  const categoriesRef = useRef(initialCategoriesSet);\n  const idsRef = useRef(newIds);\n\n  if (!isEqual(newIds, idsRef.current)) {\n    idsRef.current = newIds;\n  }\n\n  if (!isEqual(categoriesRef.current, initialCategoriesSet)) {\n    categoriesRef.current = initialCategoriesSet;\n    onCategoriesChange?.([...initialCategoriesSet]);\n  }\n\n  const updateCategories = (id: K | undefined) => {\n    let updatedCategories = id != null ? categoryMap.itemToCategory.get(id)! : new Set([]);\n    let updatedItems = getItemsFromCategories(\n      categoryMap.categoryToItem,\n      matchCriteria,\n      updatedCategories\n    );\n\n    if (!replace) {\n      updatedItems = toggle(idsRef.current, updatedItems);\n      updatedCategories = toggle(categoriesRef.current, updatedCategories);\n    }\n\n    if (!isEqual(updatedItems, idsRef.current)) {\n      idsRef.current = updatedItems;\n    }\n\n    if (updatedCategories && !isEqual(updatedCategories, categoriesRef.current)) {\n      categoriesRef.current = updatedCategories;\n      onCategoriesChange?.([...updatedCategories]);\n    }\n  };\n\n  return {\n    ids: [...idsRef.current],\n    updateCategories\n  };\n};\n"],"names":["toggle","original","updated","matches","Set","forEach","item","has","delete","add","getItemsFromCategories","categoryToItemMap","matchCriteria","categories","reduce","acc","cur","index","curItems","get","filter","items","getCategoriesFromItem","initialCategories","replace","onCategoriesChange","categoryMap","useMemo","getCategory","categoryToItem","Map","itemToCategory","id","set","category","getCategoryMap","initialCategoriesSet","newIds","categoriesRef","useRef","idsRef","isEqual","current","ids","updateCategories","updatedCategories","updatedItems"],"mappings":"0FA0BA,MAAMA,EAAS,CAAIC,EAAkBC,KACnC,MAAMC,EAAU,IAAIC,IAAIH,GAQxB,OAPAC,EAAQG,SAASC,IACVL,EAASM,IAAID,GAGhBH,EAAQK,OAAOF,GAFfH,EAAQM,IAAIH,EAGb,IAEIH,CAAO,EAmChB,SAASO,EACPC,EACAC,EAA+B,MAC/BC,GAEA,MAAO,IAAIA,GAAYC,QAAO,CAACC,EAAaC,EAAaC,KACvD,MAAMC,EAAWP,EAAkBQ,IAAIH,GACvC,MAAsB,QAAlBJ,EACKM,EAAW,IAAId,IAAI,IAAIW,KAAQG,IAAaH,EAGhDE,EACE,IAAIb,IAAI,IAAIW,GAAKK,QAAQd,GAASY,EAASX,IAAID,MADnCY,CAC0C,GAC5D,IAAId,IACT,iBAgB6B,EAC3BiB,QACAC,wBACAC,oBAAoB,GACpBX,gBAAgB,MAChBY,WAAU,EACVC,yBAEA,MAAMC,EAAcC,WAClB,IAnEJ,SACEN,EACAO,GAEA,MAAMC,EAAsC,IAAIC,IAC1CC,EAAsC,IAAID,IAahD,OAZAT,EAAMhB,SAASC,IACb,MAAM0B,EAAQ1B,EAAK0B,GACbnB,EAAuBe,EAAYtB,GACzCyB,EAAeE,IAAID,EAAI,IAAI5B,IAAIS,IAC/BA,EAAWR,SAAS6B,IACdL,EAAetB,IAAI2B,GACrBL,EAAeV,IAAIe,IAAWzB,IAAIuB,GAElCH,EAAeI,IAAIC,EAAU,IAAI9B,IAAI,CAAC4B,IACvC,GACD,IAEG,CAAEH,iBAAgBE,iBAC3B,CAgDUI,CAAkBd,EAAOC,IAC/B,CAACD,EAAOC,IAGJc,EAAuB,IAAIhC,IAAImB,GAC/Bc,EAAS3B,EACbgB,EAAYG,eACZjB,EACAwB,GAGIE,EAAgBC,SAAOH,GACvBI,EAASD,SAAOF,GAEjBI,EAAAA,QAAQJ,EAAQG,EAAOE,WAC1BF,EAAOE,QAAUL,GAGdI,EAAAA,QAAQH,EAAcI,QAASN,KAClCE,EAAcI,QAAUN,EACxBX,IAAqB,IAAIW,KA0B3B,MAAO,CACLO,IAAK,IAAIH,EAAOE,SAChBE,iBAzBwBZ,IACxB,IAAIa,EAA0B,MAANb,EAAaN,EAAYK,eAAeZ,IAAIa,GAAO,IAAI5B,IAAI,IAC/E0C,EAAepC,EACjBgB,EAAYG,eACZjB,EACAiC,GAGGrB,IACHsB,EAAe9C,EAAOwC,EAAOE,QAASI,GACtCD,EAAoB7C,EAAOsC,EAAcI,QAASG,IAG/CJ,EAAAA,QAAQK,EAAcN,EAAOE,WAChCF,EAAOE,QAAUI,GAGfD,IAAsBJ,EAAOA,QAACI,EAAmBP,EAAcI,WACjEJ,EAAcI,QAAUG,EACxBpB,IAAqB,IAAIoB,IAC1B,EAMF"}