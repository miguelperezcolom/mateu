{"version":3,"file":"Sheet-fdd314ac.js","sources":["../../src/UNSAFE_Sheet/useSheetSwipe.ts","../../src/UNSAFE_Sheet/Sheet.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useRef, useCallback } from 'preact/hooks';\n\n/*\n  threshold: Minimal threshold required before recognizing\n  tolerance: A tolerance value which allows the user to move their finger about a length measured in pixels.\n  This allows the swipe gesture to be triggered more easily since a User might not move their finger\n  in a straight line.\n*/\ntype SwipeOptions = {\n  threshold?: number;\n  maximumTime?: number;\n  tolerance?: number;\n  isDisabled?: boolean;\n};\n\ntype SwipeInfo = {\n  direction: 'down';\n};\n\ntype SwipeState = {\n  pointerDownId: number | null;\n  startTime: number | null;\n  prevpageX: number;\n  prevpageY: number;\n  elementScrollTop: number;\n};\n/*This \"private\" hook will live until we end up stating a final decision on useSwipe hook.\nFor that hook to work, element that use it has to set touch-action:none;, since pointer events\nare canceled once a touch action is going to be handled by the browser. This works for most\nof the components that don't scroll. But if the component scroll, there is a need for the browser to \nhandle scroll which is imposible with a hook just using pointer events.\n\nUpdate 11/6/23:\nNishad's team is going to confirm if other comps that will use useSwipe need mouse interactions. If they need it,\nwe can either have a flag to use pointer or touch events or two separated hooks. If they don't need mouse interactions,\nwe could start using useSwipe with touch events instead.\n*/\nexport function useSheetSwipe(\n  onSwipe: (e: SwipeInfo) => void,\n  { threshold = 10, maximumTime = 300, tolerance = 50, isDisabled = false }: SwipeOptions = {\n    threshold: 10,\n    maximumTime: 300,\n    tolerance: 50,\n    isDisabled: false\n  }\n): { swipeProps: Record<string, any> } {\n  const ref = useRef<SwipeState>({\n    pointerDownId: 0,\n    startTime: null,\n    prevpageX: 0,\n    prevpageY: 0,\n    elementScrollTop: 0\n  });\n\n  const clearSwipe = useCallback(() => {\n    ref.current = {\n      pointerDownId: null,\n      startTime: 0,\n      prevpageX: 0,\n      prevpageY: 0,\n      elementScrollTop: 0\n    };\n  }, []);\n\n  const onTouchStart = useCallback(\n    (e: TouchEvent) => {\n      const touchobj = e.changedTouches[0];\n      if (!ref.current.pointerDownId) {\n        ref.current = {\n          pointerDownId: touchobj.identifier,\n          startTime: e.timeStamp,\n          prevpageX: touchobj.pageX,\n          prevpageY: touchobj.pageY,\n          elementScrollTop: (e.currentTarget as HTMLElement).scrollTop\n        };\n      } else {\n        clearSwipe();\n      }\n    },\n    [clearSwipe]\n  );\n\n  const onTouchEnd = useCallback(\n    (ev: TouchEvent) => {\n      const touchobj = ev.changedTouches[0];\n      if (touchobj.identifier === ref.current.pointerDownId) {\n        if (ref.current.startTime && ev.timeStamp - ref.current.startTime < maximumTime) {\n          if (\n            touchobj.pageY - ref.current.prevpageY > threshold &&\n            Math.abs(touchobj.pageX - ref.current.prevpageX) <= tolerance &&\n            ref.current.elementScrollTop === 0\n          ) {\n            onSwipe?.({ direction: 'down' });\n          }\n        }\n      }\n      // state would be reset to its original state whether swipe is completed or cancelled\n      clearSwipe();\n    },\n    [threshold, onSwipe, clearSwipe, maximumTime, tolerance]\n  );\n\n  const swipeProps = isDisabled\n    ? {}\n    : {\n        /** event handlers to spread on the target element. */\n        onTouchStart,\n        onTouchEnd,\n        ontouchcancel: clearSwipe\n      };\n\n  return {\n    swipeProps\n  };\n}\n","import { JSX } from 'preact';\nimport { useCallback, useEffect, useMemo, useRef } from 'preact/hooks';\n\nimport { Modal } from '../UNSAFE_Modal';\nimport { WindowOverlay } from '../UNSAFE_WindowOverlay';\n//Temporal import.\nimport { useSheetSwipe } from './useSheetSwipe';\nimport { focusWithin } from '../utils/PRIVATE_tabbableUtils';\n\nimport { sheetStyles } from './themes/SheetStyles.css';\nimport { mergeRefs } from '#utils/PRIVATE_refUtils';\nimport { AnimationStates, useAnimationStatus } from '#hooks/PRIVATE_useAnimationStatus';\nimport { SLIDE_DOWN_XLARGE, SLIDE_UP_XLARGE, DURATION_LARGE } from '#utils/PRIVATE_animationUtils';\nimport { useTranslationBundle } from '#hooks/UNSAFE_useTranslationBundle';\nimport { BundleType } from '#resources/nls/bundle';\n\n/*\n  pointerDismissed: Swipedown and tapScrim\n  keyboardDismissed: \"Escape\" | \"Tab\"\n*/\nexport type CloseDetail = { reason: 'pointerDismissed' | 'keyboardDismissed' };\n\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\n\ntype SheetProps = IntrinsicProps & {\n  onClose?: (detail: CloseDetail) => void;\n  isOpen?: boolean;\n  initialFocus?: 'none' | 'firstFocusable';\n};\n\nconst animationStates: AnimationStates = {\n  opening: {\n    ...SLIDE_UP_XLARGE,\n    options: {\n      duration: DURATION_LARGE\n    }\n  },\n  closing: {\n    ...SLIDE_DOWN_XLARGE,\n    options: {\n      duration: DURATION_LARGE\n    }\n  }\n};\n\nexport const Sheet = ({ children, onClose, isOpen = false, initialFocus = 'none' }: SheetProps) => {\n  const sheetRef = useRef<HTMLDivElement>(null);\n\n  // Initial focus going to be set after animation once opening animation is added\n  useEffect(() => {\n    if (isOpen && initialFocus === 'firstFocusable') {\n      const sheetElement = sheetRef.current;\n      if (sheetElement) {\n        focusWithin(sheetElement);\n      }\n    }\n  }, [isOpen, initialFocus]);\n  const handlePointerDismissed = useCallback(() => {\n    onClose?.({ reason: 'pointerDismissed' });\n  }, [onClose]);\n\n  // TODO: Use useSwipe when it works on components that could scroll. Important to notice all components that have a\n  // sheet will use this comp and this comp is going to use useSwipe. So comps that have their own impl (menu right now),\n  // will stop having its own implementation\n  const { swipeProps } = useSheetSwipe(handlePointerDismissed);\n\n  const handleKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      switch (event.code) {\n        case 'Tab':\n        case 'Escape':\n          onClose?.({ reason: 'keyboardDismissed' });\n        default:\n          break;\n      }\n    },\n    [onClose]\n  );\n  const { setAnimationElementRef, status } = useAnimationStatus<HTMLElement>({\n    isOpen,\n    isAnimatedOnMount: false,\n    animationStates\n  });\n\n  useEffect(() => {\n    if (status === 'opening') {\n      if (initialFocus === 'firstFocusable') {\n        const dropdownElement = sheetRef.current;\n        if (dropdownElement) {\n          focusWithin(dropdownElement);\n        }\n      }\n    }\n  }, [status, initialFocus]);\n\n  const stableRef = useMemo(\n    () => mergeRefs(setAnimationElementRef, sheetRef),\n    [setAnimationElementRef]\n  );\n\n  const isMounted = status !== 'unmounted';\n\n  const translations = useTranslationBundle<BundleType>('@oracle/oraclejet-preact');\n\n  return (\n    <>\n      {isMounted ? (\n        <Modal isOpen={isMounted} onBackdropClick={handlePointerDismissed}>\n          <WindowOverlay placement=\"bottom\">\n            <div\n              {...swipeProps}\n              ref={stableRef}\n              class={sheetStyles.sheetContainerWrapper}\n              style={{ maxHeight: `calc(100vh - ${TOP_OFFSET}px)` }}\n              onKeyDown={handleKeyDown}>\n              <a\n                onClick={handlePointerDismissed}\n                role=\"button\"\n                aria-label={translations.sheet_close()}\n                tabIndex={-1}\n                class={sheetStyles.sheetHiddenLink}></a>\n              {children}\n            </div>\n          </WindowOverlay>\n        </Modal>\n      ) : null}\n    </>\n  );\n};\n\nconst TOP_OFFSET = 96;\n"],"names":["useSheetSwipe","onSwipe","threshold","maximumTime","tolerance","isDisabled","ref","useRef","pointerDownId","startTime","prevpageX","prevpageY","elementScrollTop","clearSwipe","useCallback","current","onTouchStart","e","touchobj","changedTouches","identifier","timeStamp","pageX","pageY","currentTarget","scrollTop","onTouchEnd","ev","Math","abs","direction","swipeProps","ontouchcancel","animationStates","opening","SLIDE_UP_XLARGE","options","duration","DURATION_LARGE","closing","SLIDE_DOWN_XLARGE","TOP_OFFSET","children","onClose","isOpen","initialFocus","sheetRef","useEffect","sheetElement","focusWithin","handlePointerDismissed","reason","handleKeyDown","event","defaultPrevented","code","setAnimationElementRef","status","useAnimationStatus","isAnimatedOnMount","dropdownElement","stableRef","useMemo","mergeRefs","isMounted","translations","useTranslationBundle","_jsx","jsx","_Fragment","Fragment","Modal","onBackdropClick","WindowOverlay","placement","_jsxs","jsxs","class","sheetStyles","sheetContainerWrapper","style","maxHeight","onKeyDown","onClick","role","sheet_close","tabIndex","sheetHiddenLink"],"mappings":"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"}