{"version":3,"file":"useContextMenuGesture-69b54d61.js","sources":["../../src/hooks/UNSAFE_useContextMenuGesture/useContextMenuGesture.ts"],"sourcesContent":["import { useCallback, useEffect, useRef } from 'preact/hooks';\n\nimport { Coords } from '../../UNSAFE_Floating';\n\nimport { getClientHints } from '../../utils/PRIVATE_clientHints';\nimport { getIsSelectionPending as getIsSelectionPendingUtils } from '#utils/PRIVATE_textSelectionUtils';\n\ntype ContextMenuEventDetail = (\n  | { gesture: 'mouse' | 'touch'; anchor: Coords }\n  | { gesture: 'keyboard'; anchor: Element }\n) & { currentTarget: Element; target: Element };\n\ntype ContextMenuHandler = (detail: ContextMenuEventDetail) => void;\n\ntype ContextMenuOptions = {\n  isTouchHoldReleaseGesture?: boolean;\n  isDisabled?: boolean;\n};\n\n/**\n * `useContextMenuGesture` hook to handle contextMenuGesture. Pure onContextMenu event is not enough to handle this since:\n   1.- onContextMenu event is not supported on mobile safari.\n   2.- onContextMenu can't be triggered using keyboard natively on Mac\n\n   What event is running depends on the gesture:\n   -> Mouse\n      We use native onContextMenu event to support it. Nothing fancy about it, prevent default event to suppress the default browser context menu.\n   -> Keyboard\n      We rely on onKeyDown event, since mac doesn't run onContextMenu when pressing Shift-F10. We preventDefault\n      if Shift-F10 is pressed so onContextMenu native event is not run in platforms that support it.\n   -> Touching \n      - For non-visualization components, the default touch gesture is used:\n          This is platform specific.\n          On machines that supports onContextMenu event and also touching (android, hybrid laptops) the native context menu \n          is used.\n          On platforms where onContextMenu doesn't exist(IOS), the steps are the next:\n          1.- We check if only one finger was used and also if the platform is IOS.\n          2.- If there is a touch move we clear the timeout.   \n          3.- If user doesn't move its finger and user holds enough we trigger contextMenu handler.\n          4.- We clearTimeout on touchEnd.\n      - For visualization components:\n          The gesture to launch context menu is touch + hold + release. The 'isTouchHoldReleaseGesture' option should be set to 'true' when using this hook.\n * \n */\nexport const useContextMenuGesture = (\n  onContextMenuHandler: ContextMenuHandler,\n  contextMenuOptions: ContextMenuOptions = {\n    isTouchHoldReleaseGesture: false,\n    isDisabled: false\n  }\n): { triggerProps: Record<string, any> } => {\n  const touchGestureType = !contextMenuOptions.isTouchHoldReleaseGesture\n    ? getClientHints().platform === 'ios'\n      ? 'touchHold'\n      : 'native'\n    : 'touchHoldRelease';\n\n  const pressHoldTime =\n    touchGestureType === 'touchHold' ? PRESS_HOLD_TIME : PRESS_HOLD_RELEASE_TIME;\n\n  /*Use this ref to avoid triggering contextMenuHandler twice. This could happen due to Shift-F10 combination of keys.\n   On firefox preventDefault inside keyDown event does not prevent contextMenu native event to be triggered. That's why \n   we use this ref instead. */\n  const ignoreNativeContextMenuEvent = useRef(false);\n\n  //Info that we need to track when handling touch hold portion of the gesture\n  const touchHoldGestureInfo = useRef<{\n    timeNeededForSelection?: number;\n    startTime?: number;\n    touchPageCoords?: { x: number; y: number };\n    bodyUserSelectValue?: string;\n    webkitBodyUserSelectValue?: string;\n    isMenuOpened?: boolean;\n    scheduleAndHandleTouchHold?: (delay: number) => void;\n    launchContextMenu?: () => void;\n    isTouchHoldComplete: boolean;\n  }>({ isTouchHoldComplete: false });\n\n  // We track if there is any selection pending so we don't trigger the context menu if that's the case\n  const isSelectionPending = useRef(false);\n\n  // TODO: We need to confirm if this type is correct or has to be changed. JET-59244\n  const timerId = useRef<ReturnType<typeof setTimeout>>();\n\n  const getIsSelectionPending = useCallback(() => {\n    if (isSelectionPending.current) {\n      return true;\n    }\n    return getIsSelectionPendingUtils();\n  }, []);\n\n  const resetUserSelect = useCallback(() => {\n    document.body.style.userSelect = touchHoldGestureInfo.current.bodyUserSelectValue as string;\n    // Implemented with the vendor prefix: -webkit- on safari\n    document.body.style.webkitUserSelect = touchHoldGestureInfo.current\n      .webkitBodyUserSelectValue as string;\n    touchHoldGestureInfo.current.isMenuOpened = false;\n  }, []);\n\n  useEffect(() => {\n    const onSelectionChange = () => {\n      const { timeNeededForSelection, startTime } = touchHoldGestureInfo.current;\n      if (startTime && !timeNeededForSelection && document.getSelection()?.type === 'Range') {\n        clearTimeout(timerId.current);\n        touchHoldGestureInfo.current.timeNeededForSelection = Date.now() - startTime;\n        touchHoldGestureInfo.current.scheduleAndHandleTouchHold?.(pressHoldTime);\n      }\n    };\n\n    const onSelectStart = (event: Event) => {\n      if ((event?.target as HTMLElement).nodeName === '#text') {\n        isSelectionPending.current = true;\n        // we want to reset isSelectionPending if we don't get a contextmenu event. 10ms seems to be enough time tweak as needed.\n        setTimeout(() => {\n          isSelectionPending.current = false;\n        }, 10);\n      } else {\n        isSelectionPending.current = false;\n      }\n    };\n    if (touchGestureType === 'touchHold' || touchGestureType === 'touchHoldRelease') {\n      document.addEventListener('selectionchange', onSelectionChange, true);\n    } else {\n      document.addEventListener('selectstart', onSelectStart, true);\n    }\n\n    return () => {\n      document.removeEventListener('selectionchange', onSelectionChange, true);\n      document.removeEventListener('selectstart', onSelectStart, true);\n    };\n  }, [touchGestureType, pressHoldTime]);\n\n  const onContextMenu = useCallback(\n    (event: PointerEvent) => {\n      if (event.pointerType === 'touch' && touchGestureType === 'touchHoldRelease') {\n        event.preventDefault();\n        return;\n      }\n\n      if (!getIsSelectionPending()) {\n        //Prevent default so we don't open browser context menu\n        event.preventDefault();\n\n        if (ignoreNativeContextMenuEvent.current) {\n          ignoreNativeContextMenuEvent.current = false;\n        } else {\n          onContextMenuHandler({\n            /*Pointer type can be touch/pen/mouse if its touch we passed touch if any other value we consider it a mouse \n            gesture */\n            gesture: event.pointerType === 'touch' ? 'touch' : 'mouse',\n            anchor: {\n              x: event.clientX,\n              y: event.clientY,\n              contextElement: event.currentTarget as Element\n            },\n            currentTarget: event.currentTarget as Element,\n            target: event.target as Element\n          });\n        }\n      }\n    },\n    [onContextMenuHandler, getIsSelectionPending, touchGestureType]\n  );\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (!getIsSelectionPending()) {\n        if (event.key === 'F10' && event.shiftKey) {\n          ignoreNativeContextMenuEvent.current = true;\n\n          const currentTarget = event.currentTarget as Element;\n          onContextMenuHandler({\n            gesture: 'keyboard',\n            anchor: currentTarget,\n            currentTarget,\n            target: event.target as Element\n          });\n        }\n      }\n    },\n    [onContextMenuHandler, getIsSelectionPending]\n  );\n\n  const onTouchStart = useCallback(\n    (event: TouchEvent) => {\n      //We check if the touch was using a single finger\n      if (event.touches.length === 1) {\n        const timeNeededForSelection = touchHoldGestureInfo.current.timeNeededForSelection;\n\n        let delay =\n          touchGestureType === 'touchHold'\n            ? pressHoldTime * 2 // By default delay to launch context menu is 1500 ms\n            : pressHoldTime;\n        if (timeNeededForSelection === undefined) {\n          // We get start time to get timeNeeded for selection inside selection change event\n          touchHoldGestureInfo.current.startTime = Date.now();\n        } else {\n          // If timeNeededForSelection was already obtained we use that time + press hold time\n          delay = timeNeededForSelection + pressHoldTime;\n        }\n        const touchobj = event.touches[0];\n        touchHoldGestureInfo.current.touchPageCoords = { x: touchobj.pageX, y: touchobj.pageY };\n        //According to mozilla docs: \"The value of event.currentTarget is only available while the event is being handled\"\n        //Due to this we need to save this element on a const\n        const currentTarget = event.currentTarget as Element;\n\n        const launchContextMenu = () => {\n          touchHoldGestureInfo.current.bodyUserSelectValue = document.body.style.userSelect;\n          touchHoldGestureInfo.current.webkitBodyUserSelectValue =\n            document.body.style.webkitUserSelect;\n          //We have to clean selections and don't permit any until a touchEnd/touchCancel\n          document.body.style.userSelect = 'none';\n          document.body.style.webkitUserSelect = 'none';\n          document.getSelection()?.empty();\n          touchHoldGestureInfo.current.isMenuOpened = true;\n          onContextMenuHandler({\n            gesture: 'touch',\n            anchor: { x: touchobj.clientX, y: touchobj.clientY, contextElement: currentTarget },\n            currentTarget: currentTarget,\n            target: event.target as Element\n          });\n        };\n\n        const scheduleAndHandleTouchHold = (delay: number) => {\n          touchHoldGestureInfo.current.isTouchHoldComplete = false;\n          timerId.current = setTimeout(() => {\n            if (touchGestureType === 'touchHold') {\n              launchContextMenu();\n            }\n            touchHoldGestureInfo.current.isTouchHoldComplete = true;\n          }, delay);\n        };\n\n        touchHoldGestureInfo.current.launchContextMenu = launchContextMenu;\n        touchHoldGestureInfo.current.scheduleAndHandleTouchHold = scheduleAndHandleTouchHold;\n\n        scheduleAndHandleTouchHold(delay);\n      }\n    },\n    [onContextMenuHandler, touchGestureType, pressHoldTime]\n  );\n\n  const onTouchMove = useCallback((e: TouchEvent) => {\n    const firstTouch = e.touches[0];\n    if (\n      Math.abs((touchHoldGestureInfo.current.touchPageCoords?.x as number) - firstTouch.pageX) >\n        MAX_ALLOWED_MOVEMENT ||\n      Math.abs((touchHoldGestureInfo.current.touchPageCoords?.y as number) - firstTouch.pageY) >\n        MAX_ALLOWED_MOVEMENT\n    ) {\n      clearTimeout(timerId.current);\n    }\n  }, []);\n\n  const onTouchEnd = useCallback(\n    (e: TouchEvent) => {\n      clearTimeout(timerId.current);\n\n      if (\n        touchGestureType === 'touchHoldRelease' &&\n        touchHoldGestureInfo.current.isTouchHoldComplete\n      ) {\n        touchHoldGestureInfo.current.launchContextMenu?.();\n      }\n\n      if (touchHoldGestureInfo.current.isMenuOpened) {\n        //Prevent default so we don't open browser context menu\n        e.preventDefault();\n        // 500 comes from testing behavior on real devices, seems like enough time to allow user to lift finger. UX approved.\n        setTimeout(() => {\n          resetUserSelect();\n        }, 500);\n      }\n\n      touchHoldGestureInfo.current.isTouchHoldComplete = false;\n    },\n    [resetUserSelect, touchGestureType]\n  );\n\n  const onTouchCancel = useCallback(() => {\n    clearTimeout(timerId.current);\n    if (touchHoldGestureInfo.current.isMenuOpened) {\n      resetUserSelect();\n    }\n  }, [resetUserSelect]);\n\n  const triggerProps = contextMenuOptions.isDisabled\n    ? {}\n    : {\n        onContextMenu,\n        onKeyDown,\n        ...((touchGestureType === 'touchHold' || touchGestureType === 'touchHoldRelease') && {\n          onTouchStart,\n          onTouchMove,\n          onTouchEnd,\n          onTouchCancel\n        })\n      };\n\n  return { triggerProps };\n};\n\n//Time needed to hold touch to be considered context menu triggering\nconst PRESS_HOLD_TIME = 750;\nconst PRESS_HOLD_RELEASE_TIME = 200; // Same value used in DvtTouchManager._touchHoldTimer\nconst MAX_ALLOWED_MOVEMENT = 5;\n"],"names":["PRESS_HOLD_TIME","PRESS_HOLD_RELEASE_TIME","MAX_ALLOWED_MOVEMENT","onContextMenuHandler","contextMenuOptions","isTouchHoldReleaseGesture","isDisabled","touchGestureType","getClientHints","platform","pressHoldTime","ignoreNativeContextMenuEvent","useRef","touchHoldGestureInfo","isTouchHoldComplete","isSelectionPending","timerId","getIsSelectionPending","useCallback","current","getIsSelectionPendingUtils","resetUserSelect","document","body","style","userSelect","bodyUserSelectValue","webkitUserSelect","webkitBodyUserSelectValue","isMenuOpened","useEffect","onSelectionChange","timeNeededForSelection","startTime","getSelection","type","clearTimeout","Date","now","scheduleAndHandleTouchHold","onSelectStart","event","target","nodeName","setTimeout","addEventListener","removeEventListener","onContextMenu","pointerType","preventDefault","gesture","anchor","x","clientX","y","clientY","contextElement","currentTarget","onKeyDown","key","shiftKey","onTouchStart","touches","length","delay","undefined","touchobj","touchPageCoords","pageX","pageY","launchContextMenu","empty","onTouchMove","e","firstTouch","Math","abs","onTouchEnd","onTouchCancel","triggerProps"],"mappings":"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"}